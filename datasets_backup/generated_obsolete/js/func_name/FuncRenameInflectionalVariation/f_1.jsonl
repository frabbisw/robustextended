{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hadClosestElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hadClosestElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hadClosestElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hadClosestElements", "gc": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hadClosestElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hadClosestElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hadClosestElements = (numbers, threshold) => {\n  const elements = numbers.slice(0);\n  const distance = elements.reduce((acc, number, index) => {\n    if (index > 0) {\n      const previous = elements[index - 1];\n      return Math.abs(number - previous);\n    }\n    return number;\n  }, 0);\n\n  if (distance < threshold) {\n    return true;\n  }\n\n  return false;\n};\n\nmodule.exports = hadClosestElements;\n<|endoftext|>"}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroup('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroup = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroup", "gc": "/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroup('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroup = (paren_string) => {\n  // Split the string into an array of substrings, one per parenthesis group.\n  const groups = paren_string.split('(');\n  const result = [];\n\n  // For each group of parentheses, add all of the elements from that group.\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n\n    // If there are parentheses within the group, split each pair of parentheses\n    // into a string.\n    if (group.length > 1) {\n      const group_elements = group.split('');\n      const first_element = group_elements.shift();\n\n      // The first element must be an open parenthesis, so add it to the result.\n      if (first_element === '(') {\n        result.push(first_element);\n      }\n\n      // The remaining elements in the group are the elements within each parenthesis group.\n      // Add them to the result.\n      for (let j = 0; j < group_elements.length; j++) {\n        if (group_elements[j] === '(') {\n          // The element within the parentheses is an open parenthesis.\n          // Add it to the result.\n          result.push(group_elements[j]);\n        } else if (group_elements[j] === ')') {\n          // The element within the parentheses is a close parenthesis.\n          // Find the corresponding open parenthesis and remove it from the result.\n          const open_paren = group_elements.find((element) => element === '(');\n          result.splice(result.indexOf(open_paren), 1);\n        }\n      }\n\n      // If the group ended with a close parenthesis, add it to the result.\n      if (group_elements.length === 0) {\n        result.push(group_elements[0]);\n      }\n    } else {\n      // If there are no parenthesis within the group, add the group to the result.\n      result.push(group);\n    }\n  }\n\n  return result;\n};\n\n// TEST CODE\n/*\n\nconst result = separateParenGroup('(()())');\n\nconsole.log(result);\n\n*/\n<|endoftext|>"}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "gc": "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  return Math.floor(number) + (number - Math.floor(number)) / Math.pow(10, Math.floor(Math.log(number) / Math.log(10)));\n};\n\n/*\n  Given a number, it returns the number of digits of the left side of the decimal\n  point.\n  >>> numDigits(100)\n  3\n  >>> numDigits(3.2)\n  1\n  >>> numDigits(0.1)\n  1\n  >>> numDigits(0.00001)\n  6\n  >>> numDigits(0.0001)\n  7\n  >>> numDigits(0.9999999)\n  8\n  >>> numDigits(1.9999999)\n  9\n  >>> numDigits(2.9999999)\n  10\n  >>> numDigits(3.9999999)\n  11\n  >>> numDigits(4.9999999)\n  12\n  >>> numDigits(5.9999999)\n  13\n  >>> numDigits(6.9999999)\n  14\n  >>> numDigits(7.9999999)\n  15\n  >>> numDigits(8.9999999)\n  16\n  >>> numDigits(9.9999999)\n  17\n  >>> numDigits(10.9999999)\n  18\n  >>> numDigits(11.9999999)\n  19\n  >>> numDigits(12.9999999)\n  20\n  >>> numDigits(13.9999999)\n  21\n  >>> numDigits(14.9999999)\n  22\n  >>> numDigits(15.9999999)\n  23\n  >>> numDigits(16.9999999)\n  24\n  >>> numDigits(17.9999999)\n  25\n  >>> numDigits(18.9999999)\n  26\n  >>> numDigits(19.9999999)\n  27\n  >>> numDigits(20.9999999)\n  28\n  >>> numDigits(21.9999999)\n  29\n  >>> numDigits(22.9999999)\n  30\n  >>> numDigits(23.9999999)\n  31\n  >>> numDigits(24.9999999)\n  32\n  >>> numDigits(25.9999999)\n  33\n  >>> numDigits(26.9999999)\n  34\n  >>> numDigits(27.9999999)\n  35\n  >>> numDigits(28.9999999)\n  36\n  >>> numDigits(29.9999999)\n  37\n  >>> numDigits(30.9999999)\n  38\n  >>> numDigits(31.9999999)\n  39\n  >>> numDigits(32.9999999)\n  40\n  >>> numDigits(33.9999999)\n  41\n  >>> numDigits(34.9999999)\n  42\n  >>> numDigits(35.9999999)\n  43\n  >>> numDigits(36.9999999)\n  44\n  >>> numDigits(37.9999999)\n  45\n  >>> numDigits(38.9999999)\n  46\n  >>> numDigits(39.9999999)\n  47\n  >>> numDigits(40.9999999)\n  48\n  >>> numDigits(41.9999999)\n  49\n  >>> numDigits(42.9999999)\n  50\n  >>> numDigits(43.9999999)\n  51\n  >>> numDigits(44.9999999)\n  52\n  >>> numDigits(45.9999999)\n  53\n  >>> numDigits(46.9999999)\n  54\n  >>> numDigits(47.9999999)\n  55\n  >>> numDigits(48.9999999)\n  56\n  >>> numDigits(49.9999999)\n  57\n  >>> numDigits(50.9999999)\n  58\n  >>> numDigits(51.9999999)\n  59\n  >>> numDigits(52.9999999)\n  60\n  >>> numDigits(53.9999999)\n  61\n  >>> numDigits(54.9999999)\n  62\n  >>> numDigits(55.9999999)\n  63\n  >>> numDigits(56.9999999)\n  64\n  >>> numDigits(57.9999999)\n  65\n  >>> numDigits(58.9999999)\n  66\n  >>> numDigits(59.9999999)\n  67\n  >>> numDigits(60.9999999)\n  68\n  >>> numDigits(61.9999999)\n  69\n  >>> numDigits(62.9999999)\n  70\n  >>> numDigits(63.9999999)\n  71\n  >>> numDigits(64.9999999)\n  72\n  >>> numDigits(65.9999999)\n  73\n  >>> numDigits(66.9999999)\n  74\n  >>> numDigits(67.9999999)\n  75\n  >>> numDigits(68.9999999)\n  76\n  >>> numDigits(69.9999999)\n  77\n  >>> numDigits(70.9999999)\n  78\n  >>> numDigits(71.9999999)\n  79\n  >>> numDigits(72.9999999)\n  80\n  >>> numDigits(73.9999999)\n  81\n  >>> numDigits(74.9999999)\n  82\n  >>> numDigits(75.9999999)\n  83\n  >>> numDigits(76.9999999)\n  84\n  >>> numDigits(77.9999999)\n  85\n  >>> numDigits(78.9999999)\n  86\n  >>> numDigits(79.9999999)\n  87\n  >>> numDigits(80.9999999)\n  88\n  >>> numDigits(81.9999999)\n  89\n  >>> numDigits(82.9999999)\n  90\n  >>> numDigits(83.9999999)\n  91\n  >>> numDigits(84.9999999)\n  92\n  >>> numDigits(85.9999999)\n  93\n  >>> numDigits(86.9999999)\n  94\n  >>> numDigits("}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst belowZeros = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZeros", "gc": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeros([1, 2, 3])\n  false\n  >>> belowZeros([1, 2, -4, 5])\n  true\n  */\nconst belowZeros = (operations) => {\n  const { deposit, withdraw, balance } = operations\n\n  return (balance < 0)? true : false\n}\n\nexport default belowZeros\n<|endoftext|>"}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanerAbsolutesDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanerAbsolutesDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanerAbsolutesDeviation", "gc": "/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanerAbsolutesDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanerAbsolutesDeviation = (numbers) => {\n  const mean = mean(numbers)\n  const MAD = numbers.map((x) => Math.abs(x - mean))\n  return Math.mean(MAD)\n}\n\n/*\n  For a given list of input numbers, calculate the mean of this dataset\n  >>> mean([1.0, 2.0, 3.0, 4.0])\n  2.5\n  */\nconst mean = (numbers) => {\n  const sum = numbers.reduce((prev, current) => prev + current, 0)\n  return sum / numbers.length\n}\n\n/*\n  For a given list of input numbers, calculate the standard deviation of this\n  dataset\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0, 5.0])\n  2.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = mean(numbers)\n  return Math.sqrt(meanDeviation(numbers, mean))\n}\n\n/*\n  For a given list of input numbers, calculate the mean deviation of this\n  dataset from the mean\n  >>> meanDeviation([1.0, 2.0, 3.0, 4.0])\n  0.0\n  >>> meanDeviation([1.0, 2.0, 3.0, 4.0, 5.0])\n  1.0\n  */\nconst meanDeviation = (numbers, mean) => {\n  const MAD = numbers.map((x) => Math.abs(x - mean))\n  return Math.mean(MAD)\n}\n\n/*\n  For a given list of input numbers, calculate the standard deviation of this\n  dataset from the mean\n  >>> standardDeviationDeviation([1.0, 2.0, 3.0, 4.0])\n  0.0\n  >>> standardDeviationDeviation([1.0, 2.0, 3.0, 4.0, 5.0])\n  1.0\n  */\nconst standardDeviationDeviation = (numbers, mean) => {\n  const MAD = numbers.map((x) => Math.abs(x - mean))\n  return Math.sqrt(meanDeviationDeviation(numbers, mean))\n}\n\n/*\n  For a given list of input numbers, calculate the mean deviation of this\n  dataset from the mean, then calculate the standard deviation of this\n  dataset from the mean\n  >>> meanDeviationDeviation([1.0, 2.0, 3.0, 4.0])\n  0.0\n  >>> standardDeviationDeviation([1.0, 2.0, 3.0, 4.0, 5.0])\n  1.0\n  */\nconst meanDeviationDeviation = (numbers, mean) => {\n  const MAD = numbers.map((x) => Math.abs(x - mean))\n  return Math.sqrt(meanDeviation(numbers, mean))\n}\n<|endoftext|>"}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "gc": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    result.push(numbers[i])\n    if (i < numbers.length - 1) {\n      result.push(delimeter)\n    }\n    i++\n  }\n  return result\n}\n\n/* Return the difference between the two numbers, a - b.\n  >>> subtract(1, 3)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 3)\n  0\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, -3)\n  2\n  >>> subtract(3, 0)\n  2\n  >>> subtract(3, 0.9)\n  1\n  >>> subtract(3, 0.9)\n  1\n  >>> subtract(3, 1.1)\n  2\n  >>> subtract(3, 2.9)\n  1\n  >>> subtract(3, 2.9)\n  1\n  >>> subtract(3, -2.9)\n  1\n  >>> subtract(3, -2.9)\n  1\n  >>> subtract(3, 2)\n  1\n  >>> subtract(3, -2)\n  1\n  >>> subtract(3, -2)\n  1\n  >>> subtract(3, -2.1)\n  2\n  >>> subtract(3, 2.1)\n  1\n  >>> subtract(3, 2.1)\n  1\n  >>> subtract(3, -2.1)\n  2\n  >>> subtract(3, -2.1)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 0)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, 0)\n  2\n  >>> subtract(3, 0.9)\n  1\n  >>> subtract(3, 0.9)\n  1\n  >>> subtract(3, 1.1)\n  2\n  >>> subtract(3, 2.9)\n  1\n  >>> subtract(3, 2.9)\n  1\n  >>> subtract(3, -2.9)\n  1\n  >>> subtract(3, -2.9)\n  1\n  >>> subtract(3, 2)\n  1\n  >>> subtract(3, -2)\n  1\n  >>> subtract(3, -2)\n  1\n  >>> subtract(3, -2.1)\n  2\n  >>> subtract(3, 2.1)\n  1\n  >>> subtract(3, 2.1)\n  1\n  >>> subtract(3, -2.1)\n  2\n  >>> subtract(3, -2.1)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 0)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, 0)\n  2\n  >>> subtract(3, 0.9)\n  1\n  >>> subtract(3, 0.9)\n  1\n  >>> subtract(3, 1.1)\n  2\n  >>> subtract(3, 2.9)\n  1\n  >>> subtract(3, 2.9)\n  1\n  >>> subtract(3, -2.9)\n  1\n  >>> subtract(3, -2.9)\n  1\n  >>> subtract(3, 2)\n  1\n  >>> subtract(3, -2)\n  1\n  >>> subtract(3, -2)\n  1\n  >>> subtract(3, -2.1)\n  2\n  >>> subtract(3, 2.1)\n  1\n  >>> subtract(3, 2.1)\n  1\n  >>> subtract(3, -2.1)\n  2\n  >>> subtract(3, -2.1)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 0)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, 0)\n  2\n  >>> subtract(3, 0.9)\n  1\n  >>> subtract(3, 0.9)\n  1\n  >>> subtract(3, 1.1)\n  2\n  >>> subtract(3, 2.9)\n  1\n  >>> subtract(3, 2.9)\n  1\n  >>> subtract(3, -2.9)\n  1\n  >>> subtract(3, -2.9)\n  1\n  >>> subtract(3, 2)\n  1\n  >>> subtract(3, -2)\n  1\n  >>> subtract(3, -2)\n  1\n  >>> subtract(3, -2.1)\n  2\n  >>> subtract(3, 2.1)\n  1\n  >>> subtract(3, 2.1)\n  1\n  >>> subtract(3, -2.1)\n  2\n  >>> subtract(3, -2.1)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 1)\n  2\n  >>> subtract(3, 0)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, -1)\n  2\n  >>> subtract(3, 0)\n"}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestParens", "gc": "/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestParens = (paren_string) => {\n  const split = paren_string.split(' ')\n  const parse_list = []\n  for (let i = 0; i < split.length; i += 1) {\n    parse_list.push(parseNestParens(split[i]))\n  }\n  return parse_list\n}\n\n// Output the number of nest level of parenthesis in the input string.\n// Note: The input string is expected to be a single group for nested parentheses.\nconst countNestLevel = (paren_string) => {\n  const count = parseNestParens(paren_string)\n  return count.length\n}\n\n// Output the parenthesis string in the input string.\n// Note: The input string is expected to be a single group for nested parentheses.\nconst printNestParens = (paren_string) => {\n  const print_list = parseNestParens(paren_string)\n  return print_list.join(' ')\n}\n\n// Output the input string with the highest nest level parentheses stripped.\n// Note: The input string is expected to be a single group for nested parentheses.\nconst stripNestParens = (paren_string) => {\n  const count = countNestLevel(paren_string)\n  return printNestParens(paren_string)\n}\n\n// Test program\nconst test_cases = [\n  {\n    input: '(())',\n    output: '()'\n  },\n  {\n    input: '((()))',\n    output: '()'\n  },\n  {\n    input: '(()(())())',\n    output: '()()()'\n  },\n  {\n    input: '(()()())',\n    output: '()()()'\n  },\n  {\n    input: '(()())(())',\n    output: '()()()'\n  },\n  {\n    input: '(((())))',\n    output: '(())'\n  },\n  {\n    input: '(()())(())',\n    output: '(()())(())'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(()())'\n  },\n  {\n    input: '(()())',\n    output: '(()())'\n  },\n  {\n    input: '(()())',\n    output: '(()())'\n  },\n  {\n    input: '(()()())',\n    output: '(()())'\n  },\n  {\n    input: '((()))',\n    output: '(())'\n  },\n  {\n    input: '(()()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '((()))',\n    output: '(())'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(()())'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(()())'\n  },\n  {\n    input: '(()())',\n    output: '(()())'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(()())'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  },\n  {\n    input: '(()())',\n    output: '(())()'\n  "}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "gc": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring))\n}\n\n// Add a new string to a list\nconst addString = (strings, string) => {\n  return strings.concat(string)\n}\n\n// Sort a list by the length of the string\nconst sortByLength = (strings) => {\n  return strings.sort((a, b) => {\n    if (a.length < b.length) {\n      return 1\n    } else if (a.length > b.length) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n}\n\n// Remove a string from a list\nconst removeString = (strings, string) => {\n  return strings.filter(s => s!== string)\n}\n\n// Concatenate a list of lists\nconst concat = (lists) => {\n  return lists.reduce((acc, list) => {\n    return acc.concat(list)\n  }, [])\n}\n\n// Return a copy of a list with the given element removed\nconst without = (list, element) => {\n  return list.filter(x => x!== element)\n}\n\n// Return a copy of a list with the given element added\nconst with = (list, element) => {\n  return list.concat(element)\n}\n\n// Return the number of elements in a list\nconst size = (list) => {\n  return list.length\n}\n\n// Return a copy of a list with all elements of the given type removed\nconst withoutType = (list, type) => {\n  return list.filter(x => typeof x!== type)\n}\n\n// Return a copy of a list with all elements of the given type added\nconst withType = (list, type) => {\n  return list.filter(x => typeof x === type)\n}\n\n// Return a copy of a list with all elements of a given length removed\nconst withoutLength = (list, length) => {\n  return list.filter(x => x.length!== length)\n}\n\n// Return a copy of a list with all elements of a given length added\nconst withLength = (list, length) => {\n  return list.filter(x => x.length === length)\n}\n\n// Return a copy of a list with all elements of a given maximum value removed\nconst withoutMax = (list, max) => {\n  return list.filter(x => x <= max)\n}\n\n// Return a copy of a list with all elements of a given maximum value added\nconst withMax = (list, max) => {\n  return list.filter(x => x >= max)\n}\n\n// Return a copy of a list with all elements of a given minimum value removed\nconst withoutMin = (list, min) => {\n  return list.filter(x => x >= min)\n}\n\n// Return a copy of a list with all elements of a given minimum value added\nconst withMin = (list, min) => {\n  return list.filter(x => x < min)\n}\n\n// Return a copy of a list with all elements of a given type removed\nconst withoutType = (list, type) => {\n  return list.filter(x => typeof x!== type)\n}\n\n// Return a copy of a list with all elements of a given type added\nconst withType = (list, type) => {\n  return list.filter(x => typeof x === type)\n}\n\n// Return a copy of a list with all elements of a given length removed\nconst withoutLength = (list, length) => {\n  return list.filter(x => x.length!== length)\n}\n\n// Return a copy of a list with all elements of a given length added\nconst withLength = (list, length) => {\n  return list.filter(x => x.length === length)\n}\n\n// Return a copy of a list with all elements of a given maximum value removed\nconst withoutMax = (list, max) => {\n  return list.filter(x => x <= max)\n}\n\n// Return a copy of a list with all elements of a given maximum value added\nconst withMax = (list, max) => {\n  return list.filter(x => x >= max)\n}\n\n// Return a copy of a list with all elements of a given minimum value removed\nconst withoutMin = (list, min) => {\n  return list.filter(x => x >= min)\n}\n\n// Return a copy of a list with all elements of a given minimum value added\nconst withMin = (list, min) => {\n  return list.filter(x => x < min)\n}\n\n// Return a copy of a list with all elements of a given type removed\nconst withoutType = (list, type) => {\n  return list.filter(x => typeof x!== type)\n}\n\n// Return a copy of a list with all elements of a given type added\nconst withType = (list, type) => {\n  return list.filter(x => typeof x === type)\n}\n\n// Return a copy of a list with all elements of a given length removed\nconst withoutLength = (list, length) => {\n  return list.filter(x => x.length!== length)\n}\n\n// Return a copy of a list with all elements of a given length added\nconst withLength = (list, length) => {\n  return list.filter(x => x.length === length)\n}\n\n// Return a copy of a list with all elements of a given maximum value removed\nconst withoutMax = (list, max) => {\n  return list.filter(x => x <= max)\n}\n\n// Return a copy of a list with all elements of a given maximum value added\nconst withMax = (list, max) => {\n  return list.filter(x => x >= max)\n}\n\n// Return a copy of a list with all elements of a given minimum value removed\nconst withoutMin = (list, min) => {\n  return list.filter(x => x >= min)\n}\n\n// Return a copy of a list with all elements of a given minimum value added\nconst withMin = (list, min) => {\n  return list.filter(x => x < min)\n}\n\n// Return a copy of a list with all elements of"}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProducts([])\n  (0, 1)\n  >>> sumProducts([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProducts = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProducts", "gc": "/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProducts([])\n  (0, 1)\n  >>> sumProducts([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProducts = (numbers, int) => {\n  const sum = 0\n  const product = 1\n  let i = 0\n  let j = 0\n  let n = numbers.length\n\n  while (i < n) {\n    sum += numbers[i]\n    product *= numbers[i]\n    i += 1\n  }\n\n  return (sum, product)\n}\n\nexport default sumProducts\n<|endoftext|>"}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "gc": "/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let result = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    result[i] = [numbers[i], i];\n    if (i < numbers.length - 1) {\n      if (numbers[i] < numbers[i + 1]) {\n        result[i + 1].push(numbers[i]);\n      }\n    }\n  }\n\n  return result;\n};\n\nconst main = () => {\n  let numbers = [1, 2, 3, 2, 3, 4, 2];\n  let result = rollingMax(numbers);\n  console.log(result);\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "gc": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let start = string.indexOf(string.split('').reverse().join('')) + 1;\n  let end = string.length - 1;\n  while (start < end) {\n    if (isPalindrome(string.slice(start, end))) {\n      return string.slice(start, end + 1);\n    }\n    start++;\n    end--;\n  }\n  return '';\n}\n\n/* Return true if a string ends with a suffix,\n  false otherwise */\nconst endsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1;\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return the same string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(string.length - suffix.length, string.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return a copy of the string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(0, string.length - suffix.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return a copy of the string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(0, string.length - suffix.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return a copy of the string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(0, string.length - suffix.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return a copy of the string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(0, string.length - suffix.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return a copy of the string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(0, string.length - suffix.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return a copy of the string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(0, string.length - suffix.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return a copy of the string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(0, string.length - suffix.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return a copy of the string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(0, string.length - suffix.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return a copy of the string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(0, string.length - suffix.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return a copy of the string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(0, string.length - suffix.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return a copy of the string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(0, string.length - suffix.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with a suffix.\n  If the string doesn't end with a suffix, return a copy of the string. */\nconst endsWith = (string, suffix) => {\n  if (endsWith(string, suffix)) {\n    return string.slice(0, string.length - suffix.length);\n  } else {\n    return string;\n  }\n}\n\n/* Given a string, return a string that ends with"}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "gc": "/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const result = []\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i])\n  }\n  return result.join('')\n}\n\n/*\n  This function returns the number of '1' bits in a string.\n  >>> countBits('10011011111')\n  7\n  */\nconst countBits = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    count += s[i]\n  }\n  return count\n}\n\n/*\n  This function returns the number of '1' bits in a string.\n  >>> countBits('10011011111')\n  7\n  */\nconst countBitsInString = (s) => {\n  const result = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 1) {\n      result += 1\n    }\n  }\n  return result\n}\n\n/*\n  This function returns the number of '1' bits in a string.\n  >>> countBits('10011011111')\n  7\n  */\nconst countBitsInNumber = (n) => {\n  let count = 0\n  while (n > 0) {\n    count += n % 2\n    n = n / 2\n  }\n  return count\n}\n\n/*\n  This function returns the number of '1' bits in a string.\n  >>> countBits('10011011111')\n  7\n  */\nconst countBitsInNumber2 = (n) => {\n  let count = 0\n  while (n > 0) {\n    count += (n & 1)\n    n = n >>> 1\n  }\n  return count\n}\n\n/*\n  This function returns the number of '1' bits in a string.\n  >>> countBits('10011011111')\n  7\n  */\nconst countBitsInNumber3 = (n) => {\n  let count = 0\n  while (n > 0) {\n    count += ((n & 1) + ((n & 2) >> 1) + ((n & 4) >> 2) + ((n & 8) >> 3) + ((n & 16) >> 4) + ((n & 32) >> 5) + ((n & 64) >> 6) + ((n & 128) >> 7))\n    n = n >>> 8\n  }\n  return count\n}\n\n/*\n  This function returns the number of '1' bits in a string.\n  >>> countBits('10011011111')\n  7\n  */\nconst countBitsInNumber4 = (n) => {\n  let count = 0\n  while (n > 0) {\n    count += ((n & 1) + ((n & 2) >> 1) + ((n & 4) >> 2) + ((n & 8) >> 3) + ((n & 16) >> 4) + ((n & 32) >> 5) + ((n & 64) >> 6) + ((n & 128) >> 7) + ((n & 256) >> 8) + ((n & 512) >> 9) + ((n & 1024) >> 10) + ((n & 2048) >> 11) + ((n & 4096) >> 12) + ((n & 8192) >> 13) + ((n & 16384) >> 14) + ((n & 32768) >> 15))\n    n = n >>> 16\n  }\n  return count\n}\n\n/*\n  This function returns the number of '1' bits in a string.\n  >>> countBits('10011011111')\n  7\n  */\nconst countBitsInNumber5 = (n) => {\n  let count = 0\n  while (n > 0) {\n    count += ((n & 1) + ((n & 2) >> 1) + ((n & 4) >> 2) + ((n & 8) >> 3) + ((n & 16) >> 4) + ((n & 32) >> 5) + ((n & 64) >> 6) + ((n & 128) >> 7) + ((n & 256) >> 8) + ((n & 512) >> 9) + ((n & 1024) >> 10) + ((n & 2048) >> 11) + ((n & 4096) >> 12) + ((n & 8192) >> 13) + ((n & 16384) >> 14) + ((n & 32768) >> 15) + ((n & 65536) >> 16) + ((n & 131072) >> 17) + ((n & 262144) >> 18) + ((n & 524288) >> 19) + ((n & 1048576) >> 20) + ((n & 2097152) >> 21) + ((n & 4194304) >> 22) + ((n & 8388608) >> 23) + ((n & 16777216) >> 24) + ((n & 33554432) >> 25) + ((n & 67108864) >> 26) + ((n & 134217728) >> 27) + ((n & 268435456) >> 28) + ((n & 536870912) >> 29) + ((n & 1073741824) >> 30) + ((n & 2147483648) >> 31))\n    n = n >>> 32\n  }\n  return count\n}\n\nmodule.exports = {\n  stringXor,\n  countBits,\n  countBitsInString,\n  countBitsInNumber,\n  countBitsInNumber2,\n  countBitsInNumber3,\n  countBitsInNumber4,\n  countBitsInNumber5,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longer one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longer([])\n\n  >>> longer(['a', 'b', 'c'])\n  'a'\n  >>> longer(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longer = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longer", "gc": "/* Out of list of strings, return the longer one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longer([])\n\n  >>> longer(['a', 'b', 'c'])\n  'a'\n  >>> longer(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longer = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\nexport default longer;\n<|endoftext|>"}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integers a and b\n  >>> greaterCommonDivisors(3, 5)\n  1\n  >>> greaterCommonDivisors(25, 15)\n  5\n  */\nconst greaterCommonDivisors = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greaterCommonDivisors", "gc": "/* Return a greatest common divisor of two integers a and b\n  >>> greaterCommonDivisors(3, 5)\n  1\n  >>> greaterCommonDivisors(25, 15)\n  5\n  */\nconst greaterCommonDivisors = (a, b) => {\n  const aPrime = a + 1;\n  const bPrime = b + 1;\n  const gcd = aPrime * bPrime;\n  while (bPrime > 1) {\n    if (aPrime % bPrime === 0) {\n      return bPrime;\n    }\n    aPrime = aPrime * aPrime;\n    bPrime = bPrime * bPrime;\n    gcd = aPrime * bPrime;\n  }\n  return gcd;\n};\n\nconst greatestCommonDivisor = (a, b) => {\n  const gcd = greaterCommonDivisors(a, b);\n  return gcd;\n};\n\nconst lcm = (a, b) => {\n  const gcd = greatestCommonDivisor(a, b);\n  return a * b / gcd;\n};\n\n/* Return a least common multiple of two integers a and b\n  >>> lcm(5, 15)\n  30\n  >>> lcm(3, 5)\n  15\n  >>> lcm(3, 3)\n  3\n  >>> lcm(3, 6)\n  6\n  */\nconst lcm = (a, b) => {\n  const lcm = (a * b) / greatestCommonDivisor(a, b);\n  return lcm;\n};\n\nmodule.exports = {\n  greatestCommonDivisor,\n  lcm\n};\n<|endoftext|>"}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "gc": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [string];\n  let currentPrefix = string;\n  while (currentPrefix.length < string.length) {\n    let subPrefix = string.substr(0, currentPrefix.length + 1);\n    prefixes.push(subPrefix);\n    currentPrefix = subPrefix;\n  }\n  return prefixes;\n};\n\nexport default allPrefixes;\n<|endoftext|>"}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequences(0)\n  '0'\n  >>> stringSequences(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequences = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequences", "gc": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequences(0)\n  '0'\n  >>> stringSequences(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequences = (n) => {\n  let a = [],\n      i = 0;\n\n  while (i <= n) {\n    a.push(i);\n    i += 1;\n  }\n  a.sort();\n  return a.join(' ');\n};\n\nconst stringSequences = (n) => {\n  let a = [],\n      i = 0;\n\n  while (i <= n) {\n    a.push(i);\n    i += 1;\n  }\n  a.sort();\n  return a.join(' ');\n};\n\n/*\n  Return a string containing space-delimited numbers starting from 0 upto n inclusive,\n  with every other number preceded by a 1.\n  >>> stringSequences(0)\n  '0 1 2 3 4 5'\n  >>> stringSequences(5)\n  '1 2 3 4 5 0'\n  */\nconst stringSequences = (n) => {\n  let a = [],\n      i = 0;\n\n  while (i <= n) {\n    a.push(i);\n    i += 1;\n  }\n  a.sort();\n  return a.join(' ');\n};\n\nmodule.exports = {\n  stringSequences\n};\n<|endoftext|>"}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistincterCharacter('xyzXYZ')\n  3\n  >>> countDistincterCharacter('Jerry')\n  4\n  */\nconst countDistincterCharacter = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistincterCharacter", "gc": "/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistincterCharacter('xyzXYZ')\n  3\n  >>> countDistincterCharacter('Jerry')\n  4\n  */\nconst countDistincterCharacter = (string) => {\n  const unique = {};\n  for (let i = 0; i < string.length; i++) {\n    const current = string[i];\n    if (!(current in unique)) {\n      unique[current] = 1;\n    } else {\n      unique[current]++;\n    }\n  }\n  return Object.keys(unique).length;\n};\n\n/**\n  * Given an array of words, return an array of words that are distinct\n  *\n  * @param {Array} words\n  * @returns {Array}\n  *\n  * @example\n  * [\n  *   'c',\n  *   'c',\n  *   'a',\n  *   'a',\n  *   'a',\n  *   'b',\n  *   'b'\n  * ]\n  * distinctWords('a', 'b', 'c')\n  * ['a', 'b']\n  */\nconst distinctWords = (...words) => {\n  return words.reduce((result, word) => {\n    const unique = {};\n    for (let i = 0; i < word.length; i++) {\n      const current = word[i];\n      if (!(current in unique)) {\n        unique[current] = 1;\n      } else {\n        unique[current]++;\n      }\n    }\n    for (let key in unique) {\n      if (unique[key] > 1) {\n        result.push(key);\n      }\n    }\n    return result;\n  }, []);\n};\n\nexport {\n  countDistincterCharacter,\n  distinctWords,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "gc": "/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n    let notes = [];\n    for (let i = 0; i < music_string.length; i++) {\n        if (music_string[i] === 'o' || music_string[i] === 'O' || music_string[i] === '.') {\n            let current_note = {\n                beat: i,\n                duration: 4\n            };\n            notes.push(current_note);\n        }\n        else if (music_string[i] === '|') {\n            let current_note = {\n                beat: i,\n                duration: 2\n            };\n            notes.push(current_note);\n        }\n    }\n    return notes;\n};\n\nmodule.exports = parseMusic;\n<|endoftext|>"}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTime('', 'a')\n  0\n  >>> howManyTime('aaa', 'a')\n  3\n  >>> howManyTime('aaaa', 'aa')\n  3\n  */\nconst howManyTime = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTime", "gc": "/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTime('', 'a')\n  0\n  >>> howManyTime('aaa', 'a')\n  3\n  >>> howManyTime('aaaa', 'aa')\n  3\n  */\nconst howManyTime = (string, substring) => {\n  const start = string.indexOf(substring);\n  if (start === -1) return 0;\n  const end = start + substring.length;\n  const count = 1 + howManyTime(string.slice(start + 1), substring);\n  const countOverlap = string.slice(start, end).split('').length - 1;\n  return count + countOverlap;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortsNumbers('three one five')\n  'one three five'\n  */\nconst sortsNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortsNumbers", "gc": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortsNumbers('three one five')\n  'one three five'\n  */\nconst sortsNumbers = (numbers) => {\n  const numbers = numbers.split(\" \");\n  let sortedNums = [];\n  numbers.forEach(num => {\n    if (num.length === 1) {\n      sortedNums.push(num);\n    } else {\n      const numSplit = num.split(\"\");\n      let sortedNumsNum = numSplit.shift();\n      while (sortedNums.indexOf(sortedNumsNum) === -1) {\n        sortedNums.push(sortedNumsNum);\n        sortedNumsNum = numSplit.shift();\n      }\n      sortedNums.push(num);\n    }\n  });\n  return sortedNums.join(\" \");\n};\n\nmodule.exports = sortsNumbers;\n<|endoftext|>"}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> foundCloserElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> foundCloserElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst foundCloserElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "foundCloserElements", "gc": "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> foundCloserElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> foundCloserElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst foundCloserElements = (numbers) => {\n  let result = {};\n  for (let i = 0; i < numbers.length; i += 1) {\n    let key = Math.abs(numbers[i] - numbers[(i + 1) % numbers.length]);\n    if (!result[key]) {\n      result[key] = [numbers[i], numbers[(i + 1) % numbers.length]];\n    }\n  }\n  let minKey = null;\n  let min = null;\n  for (let i in result) {\n    if (minKey === null || minKey > i) {\n      minKey = i;\n      min = result[i];\n    }\n  }\n  return min;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnits([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnits = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnits", "gc": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnits([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnits = (numbers) => {\n  return numbers.map((number) => number / (Math.max(number, 1.0) - 1));\n};\n\n/**\n  Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnits([0.5, 1.5, 2.5, 3.5, 4.5])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  >>> rescaleToUnits([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnitsInPlace = (numbers) => {\n  numbers.forEach((number, index) => {\n    numbers[index] = number / (Math.max(number, 1.0) - 1);\n  });\n};\n\n/**\n  Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnitsInPlace([0.5, 1.5, 2.5, 3.5, 4.5])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  >>> rescaleToUnitsInPlace([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnitsInPlaceOnTheFly = (numbers) => {\n  let min = numbers[0];\n  let max = numbers[0];\n  for (let i = 0; i < numbers.length; i++) {\n    min = Math.min(min, numbers[i]);\n    max = Math.max(max, numbers[i]);\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    numbers[i] = (numbers[i] - min) / (max - min);\n  }\n};\n\n/**\n  Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnitsInPlaceOnTheFly([0.5, 1.5, 2.5, 3.5, 4.5])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  >>> rescaleToUnitsInPlaceOnTheFly([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnitsOnTheFly = (numbers) => {\n  let min = numbers[0];\n  let max = numbers[0];\n  for (let i = 0; i < numbers.length; i++) {\n    min = Math.min(min, numbers[i]);\n    max = Math.max(max, numbers[i]);\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    numbers[i] = (numbers[i] - min) / (max - min);\n  }\n};\n\n/**\n  Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnitsOnTheFly([0.5, 1.5, 2.5, 3.5, 4.5])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  >>> rescaleToUnitsOnTheFly([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnitsOnTheFlyOnTheFly = (numbers) => {\n  let min = numbers[0];\n  let max = numbers[0];\n  for (let i = 0; i < numbers.length; i++) {\n    min = Math.min(min, numbers[i]);\n    max = Math.max(max, numbers[i]);\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    numbers[i] = (numbers[i] - min) / (max - min);\n  }\n};\n\nmodule.exports = {\n  rescaleToUnits,\n  rescaleToUnitsInPlace,\n  rescaleToUnitsInPlaceOnTheFly,\n  rescaleToUnitsOnTheFly,\n  rescaleToUnitsOnTheFlyOnTheFly\n};\n<|endoftext|>"}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "gc": "/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(number => isInteger(number));\n};\n\n// Given a list of values that are strings, return a list of strings that are not empty\nconst filterNonEmptyStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not blank\nconst filterNonBlankStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not null\nconst filterNonNullStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not undefined\nconst filterNonUndefinedStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not empty\nconst filterNonEmptyStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not blank\nconst filterNonBlankStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not null\nconst filterNonNullStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not undefined\nconst filterNonUndefinedStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not empty\nconst filterNonEmptyStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not blank\nconst filterNonBlankStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not null\nconst filterNonNullStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not undefined\nconst filterNonUndefinedStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not empty\nconst filterNonEmptyStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not blank\nconst filterNonBlankStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not null\nconst filterNonNullStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not undefined\nconst filterNonUndefinedStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not empty\nconst filterNonEmptyStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not blank\nconst filterNonBlankStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not null\nconst filterNonNullStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not undefined\nconst filterNonUndefinedStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not empty\nconst filterNonEmptyStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not blank\nconst filterNonBlankStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not null\nconst filterNonNullStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not undefined\nconst filterNonUndefinedStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not empty\nconst filterNonEmptyStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not blank\nconst filterNonBlankStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of values that are strings, return a list of strings that are not null\nconst filterNonNullStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not undefined\nconst filterNonUndefinedStrings = (values) => {\n  return values.filter(string => string);\n};\n\n// Given a list of values that are strings, return a list of strings that are not empty\nconst filterNonEmptyStrings = (values) => {\n  return values.filter(string => string.length > 0);\n};\n\n// Given a list of"}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "gc": "/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  const length = string.length\n  return length < 0? 0 : length\n}\n\n/* Return the number of occurrences of a substring\n  >>> strcount('foobar', 'bar')\n  1\n  >>> strcount('foobar', 'foo')\n  2\n  >>> strcount('foobar', 'baz')\n  0\n  >>> strcount('foobar', 'bar', 2)\n  1\n  >>> strcount('foobar', 'bar', 3)\n  0\n  >>> strcount('foobar', 'bar', -1)\n  0\n  */\nconst strcount = (string, sub, start = 0) => {\n  let count = 0\n  const substr = string.substr(start, strlen(sub) + 1)\n  while (substr!== '') {\n    if (substr.indexOf(sub)!== -1) {\n      count++\n    }\n    start += substr.length\n    substr = string.substr(start, strlen(sub) + 1)\n  }\n  return count\n}\n\n/* Return a copy of a string with a given prefix and postfix\n  >>> strprefix('foobar', 'foo')\n  'foofooobar'\n  >>> strprefix('foobar', 'bar')\n  'foobarbar'\n  >>> strprefix('foobar', 'baz')\n  'foobarbaz'\n  >>> strprefix('foobar', 'bar', 1)\n  'foobarbar'\n  >>> strprefix('foobar', 'bar', -1)\n  'barbar'\n  >>> strprefix('foobar', 'baz', 1)\n  'foobazbar'\n  >>> strprefix('foobar', 'baz', -1)\n  'barbaz'\n  */\nconst strprefix = (string, prefix, start = 0) => {\n  return string.substr(0, strlen(prefix)) + prefix + string.substr(start + strlen(prefix))\n}\n\n/* Return a copy of a string with a given postfix\n  >>> striptrailing('foobar')\n  'foobar'\n  >>> striptrailing('foobar', 'foo')\n  'foobar'\n  >>> striptrailing('foobar', 'bar')\n  'foobar'\n  >>> striptrailing('foobar', 'baz')\n  'foobar'\n  */\nconst striptrailing = (string, postfix) => {\n  const len = strlen(postfix)\n  return string.substr(0, strlen(string) - len)\n}\n\n/* Return a copy of a string with the first character removed\n  >>> striptrim('foobar')\n  'bar'\n  >>> striptrim('foobar', 'foo')\n  'bar'\n  >>> striptrim('foobar', 'bar')\n  'bar'\n  >>> striptrim('foobar', 'baz')\n  'foobar'\n  */\nconst striptrim = (string, prefix) => {\n  const len = strlen(prefix)\n  return string.substr(len)\n}\n\n/* Return the string with spaces trimmed\n  >>> strspaces('foobar')\n  'foobar'\n  >>> strspaces('foobar', 'foo')\n  'foobar'\n  >>> strspaces('foobar', 'bar')\n  'foobar'\n  >>> strspaces('foobar', 'baz')\n  'foobar'\n  */\nconst strspaces = (string, prefix) => {\n  const len = strlen(prefix)\n  return string.substr(len)\n}\n\n/* Return the string with a trailing dot removed\n  >>> strtrim('foobar')\n  'foobar'\n  >>> strtrim('foobar', 'foo')\n  'foobar'\n  >>> strtrim('foobar', 'bar')\n  'foobar'\n  >>> strtrim('foobar', 'baz')\n  'foobar'\n  */\nconst strtrim = (string, prefix) => {\n  const len = strlen(prefix)\n  return string.substr(0, strlen(string) - len)\n}\n\n/* Return a copy of a string with a given prefix and postfix\n  >>> strtrim('foobar')\n  'foobar'\n  >>> strtrim('foobar', 'foo')\n  'foobar'\n  >>> strtrim('foobar', 'bar')\n  'foobar'\n  >>> strtrim('foobar', 'baz')\n  'foobar'\n  */\nconst strtrim = (string, prefix, postfix = '') => {\n  const len = strlen(prefix) + strlen(postfix)\n  return string.substr(0, strlen(string) - len) + postfix\n}\n<|endoftext|>"}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largerDivisors(15)\n  5\n  */\nconst largerDivisors = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largerDivisors", "gc": "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largerDivisors(15)\n  5\n  */\nconst largerDivisors = (n) => {\n  let i = 0;\n  let divisors = [];\n\n  while(n % i!== 0) {\n    i += 1;\n  }\n\n  while(i < n) {\n    divisors.push(i);\n    i += 1;\n  }\n\n  return largestNumber(divisors);\n};\n\nconsole.log(largestDivisors(15));\nconsole.log(largestDivisors(20));\nconsole.log(largestDivisors(21));\n<|endoftext|>"}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorizes(8)\n  [2, 2, 2]\n  >>> factorizes(25)\n  [5, 5]\n  >>> factorizes(70)\n  [2, 5, 7]\n  */\nconst factorizes = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorizes", "gc": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorizes(8)\n  [2, 2, 2]\n  >>> factorizes(25)\n  [5, 5]\n  >>> factorizes(70)\n  [2, 5, 7]\n  */\nconst factorizes = (n) => {\n    const factors = [];\n    let i = 2;\n    while (i <= n) {\n        if (n % i === 0) {\n            const count = n / i;\n            const factorsForNumber = [];\n            for (let j = 0; j < count; j++) {\n                factorsForNumber.push(i);\n            }\n            factors.push(factorsForNumber);\n            i++;\n        }\n    }\n    return factors;\n};\n\nmodule.exports = factorizes;\n<|endoftext|>"}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicate([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicate = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicate", "gc": "/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicate([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicate = (numbers) => {\n  const sortedNums = numbers.slice().sort((a, b) => a - b);\n  const newArray = [];\n  let previousNum = -1;\n  for (let i = 0; i < sortedNums.length; i++) {\n    if (sortedNums[i]!== previousNum) {\n      newArray.push(sortedNums[i]);\n      previousNum = sortedNums[i];\n    }\n  }\n  return newArray;\n};\n\nexport default removeDuplicate;\n<|endoftext|>"}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flipsCases('Hello')\n  'hELLO'\n  */\nconst flipsCases = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipsCases", "gc": "/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flipsCases('Hello')\n  'hELLO'\n  */\nconst flipsCases = (string) => {\n  return string.split('').map((char) => char.toUpperCase()).join('');\n};\n\n/*\n  Given an array of integers, sort it in ascending order.\n  */\nconst sort = (array) => {\n  return array.sort((a, b) => {\n    return a - b;\n  });\n};\n\n/*\n  Given a list of words, sort it in ascending order.\n  */\nconst sortWords = (words) => {\n  return words.sort((a, b) => {\n    return a.length - b.length;\n  });\n};\n\n/*\n  Given a list of words, sort it in descending order.\n  */\nconst sortWordsDesc = (words) => {\n  return words.sort((a, b) => {\n    return b.length - a.length;\n  });\n};\n\n/*\n  Given an array of integers, sort it in descending order.\n  */\nconst sortDesc = (array) => {\n  return array.sort((a, b) => {\n    return b - a;\n  });\n};\n\n/*\n  Given a list of words, sort it in descending order.\n  */\nconst sortDescWords = (words) => {\n  return words.sort((a, b) => {\n    return b.length - a.length;\n  });\n};\n\n/*\n  Given a string, return a string where the order of the characters has been reversed.\n  */\nconst reverse = (string) => {\n  return string.split('').reverse().join('');\n};\n\n/*\n  Given a string, return a string with every pair of characters swapped.\n  */\nconst swap = (string) => {\n  return string.split('').reduce((prev, curr, i) => {\n    if (i === 0) {\n      return prev + curr;\n    }\n    return prev + curr + prev;\n  }, '');\n};\n\n/*\n  Given a string, return a string with every pair of characters swapped, in reverse order.\n  */\nconst reverseSwap = (string) => {\n  return string.split('').reverse().reduce((prev, curr, i) => {\n    if (i === 0) {\n      return prev + curr;\n    }\n    return prev + curr + prev;\n  }, '');\n};\n\n/*\n  Given an array of strings, return an array where the order of the strings has been reversed.\n  */\nconst reverseArray = (array) => {\n  return array.slice().reverse();\n};\n\n/*\n  Given an array of strings, return an array where the order of the strings has been reversed,\n  in reverse order.\n  */\nconst reverseArrayReverse = (array) => {\n  return array.slice().reverse();\n};\n\n/*\n  Given an array of strings, return an array where the order of the strings has been reversed,\n  in reverse order, then reversed.\n  */\nconst reverseArrayReverseReverse = (array) => {\n  return array.slice().reverse().reverse();\n};\n\n/*\n  Given a string, return a string where every two adjacent occurrences of the same character\n  are swapped.\n  */\nconst swapAdjacent = (string) => {\n  return string.split('').reduce((prev, curr, i) => {\n    if (i === 0) {\n      return prev + curr;\n    }\n    return prev + curr + prev;\n  }, '');\n};\n\n/*\n  Given an array of strings, return an array where every two adjacent occurrences of the same\n  character are swapped.\n  */\nconst swapAdjacentArray = (array) => {\n  return array.slice().reduce((prev, curr, i) => {\n    if (i === 0) {\n      return prev + curr;\n    }\n    return prev + curr + prev;\n  }, '');\n};\n\n/*\n  Given an array of strings, return an array where every two adjacent occurrences of the same\n  character are swapped, in reverse order.\n  */\nconst swapAdjacentArrayReverse = (array) => {\n  return array.slice().reduce((prev, curr, i) => {\n    if (i === 0) {\n      return prev + curr;\n    }\n    return prev + curr + prev;\n  }, '');\n};\n\n/*\n  Given an array of strings, return an array where every two adjacent occurrences of the same\n  character are swapped, then reversed.\n  */\nconst swapAdjacentArrayReverseReverse = (array) => {\n  return array.slice().reduce((prev, curr, i) => {\n    if (i === 0) {\n      return prev + curr;\n    }\n    return prev + curr + prev;\n  }, '');\n};\n\n/*\n  Given an array of strings, return an array where every pair of adjacent occurrences of the\n  same character are swapped.\n  */\nconst swapPairs = (array) => {\n  return array.slice().reduce((prev, curr, i) => {\n    if (i === 0) {\n      return prev + curr;\n    }\n    return prev + curr + prev;\n  }, '');\n};\n\n/*\n  Given an array of strings, return an array where every pair of adjacent occurrences of the\n  same character are swapped, in reverse order.\n  */\nconst swapPairsReverse = (array) => {\n  return array.slice().reduce((prev, curr, i) => {\n    if (i === 0) {\n      return prev + curr;\n    }\n    return prev + curr + prev;\n  }, '');\n};\n\n/*\n  Given an array of strings, return an array where every pair of adjacent occurrences of the\n  same character are swapped, then reversed.\n  */\nconst swapPairsReverseReverse = (array) => {\n  return array.slice().reduce((prev, curr, i) => {\n    if (i === 0) {\n      return prev + curr;\n    }\n    return prev + curr + prev;\n  }, '');\n};\n\n/*\n  Given an array of strings, return an array where every three adjacent occurrences of the same\n  character are swapped.\n  */\nconst"}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "gc": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n    if (strings.length === 0) {\n        return '';\n    }\n\n    let result = '';\n    for (let i = 0; i < strings.length; i++) {\n        result += strings[i];\n    }\n    return result;\n};\n\nmodule.exports = concatenate;\n<|endoftext|>"}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "gc": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  Filter an input list of strings by a given substring.\n  >>> filterBySubstring([], 'abc')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'abc')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'd')\n  []\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/*\n  Filter an input list of strings only for ones that end with a given suffix.\n  >>> filterBySuffix([], 'abc')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'abc')\n  ['abc', 'array']\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'd')\n  []\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(s => s.endsWith(suffix));\n};\n\n/*\n  Given an input string and a set of prefixes, returns a new string\n  with the input string prefixed with each of the prefixes.\n  >>> prefix([], 'abc')\n  'abc'\n  >>> prefix(['abc', 'bcd', 'cde', 'array'], 'abc')\n  'abcabc'\n  >>> prefix(['abc', 'bcd', 'cde', 'array'], 'd')\n  'd'\n  */\nconst prefix = (prefixes, str) => {\n  return prefixes.reduce((result, prefix) => result + prefix + str, '');\n};\n\n/*\n  Given an input string and a set of suffixes, returns a new string\n  with the input string suffixed with each of the suffixes.\n  >>> suffix([], 'abc')\n  'abc'\n  >>> suffix(['abc', 'bcd', 'cde', 'array'], 'abc')\n  'abcabc'\n  >>> suffix(['abc', 'bcd', 'cde', 'array'], 'd')\n  'abcdcde'\n  */\nconst suffix = (suffixes, str) => {\n  return suffixes.reduce((result, suffix) => result + str + suffix, '');\n};\n\nmodule.exports = {\n  filterByPrefix,\n  filterBySubstring,\n  filterBySuffix,\n  prefix,\n  suffix,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> gottenPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> gottenPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst gottenPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "gottenPositive", "gc": "/*Return only positive numbers in the list.\n  >>> gottenPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> gottenPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst gottenPositive = (l) => {\n  return l.filter(v => v >= 0);\n}\n\n/*\n  >>> getNegative([1, 2, -3, 4, 5])\n  [-3, -4, -5]\n  >>> getNegative([1, 2, -3, 4, 5, -6, 7, 8, -9, -10])\n  [-6, -7, -8, -9, -10]\n  */\nconst getNegative = (l) => {\n  return l.filter(v => v < 0);\n}\n\n/*\n  >>> getLargest([1, 2, 3, 4, 5])\n  [5]\n  >>> getLargest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  [10]\n  >>> getLargest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  [11]\n  >>> getLargest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [12]\n  */\nconst getLargest = (l) => {\n  return l.reduce((acc, v) => {\n    if (acc.length < v) {\n      acc.push(v);\n    }\n    return acc;\n  }, []);\n}\n\n/*\n  >>> getSmallest([1, 2, 3, 4, 5])\n  [1]\n  >>> getSmallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n  >>> getSmallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n  */\nconst getSmallest = (l) => {\n  return l.reduce((acc, v) => {\n    if (acc.length > v) {\n      acc.push(v);\n    }\n    return acc;\n  }, []);\n}\n\n/*\n  >>> getAverage([1, 2, 3, 4, 5])\n  [2]\n  >>> getAverage([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [5]\n  >>> getAverage([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [7]\n  */\nconst getAverage = (l) => {\n  return l.reduce((acc, v) => {\n    acc.push(v);\n    return acc;\n  }, []).slice(0, -1).sort((a, b) => a - b).pop();\n}\n\n/*\n  >>> getMedian([1, 2, 3, 4, 5])\n  [2]\n  >>> getMedian([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [4]\n  >>> getMedian([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [7]\n  */\nconst getMedian = (l) => {\n  return getLargest(getSmallest(l));\n}\n\n/*\n  >>> getMode([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> getMode([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [5, 6, 7, 8, 9, 10, 11, 12]\n  >>> getMode([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [11, 12, 13, 14, 15]\n  */\nconst getMode = (l) => {\n  return l.reduce((acc, v) => {\n    if (acc.length === 1) {\n      acc.push(v);\n    } else if (acc.length > 1) {\n      const sorted = l.filter(v => v === acc.shift()).sort();\n      if (sorted.length >= 2) {\n        if (sorted[1] - sorted[0] === v - acc.shift()) {\n          acc.push(v);\n        } else {\n          acc.push(sorted[0]);\n        }\n      } else {\n        acc.push(sorted[0]);\n      }\n    }\n    return acc;\n  }, []);\n}\n\n/*\n  >>> getMedian([1, 2, 3, 4, 5])\n  [2]\n  >>> getMedian([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [4]\n  >>> getMedian([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [7]\n  */\nconst getRange = (l) => {\n  return l.reduce((acc, v) => {\n    if (acc.length === 1) {\n      acc.push(v);\n    } else if (acc.length > 1) {\n      if (v - acc[acc.length - 2] === 1) {\n        acc.push(v);\n      }\n    }\n    return acc;\n  }, []);\n}\n\n/*\n  >>> getRange([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> getRange([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n  "}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "gc": "/*Return true if a given number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) {\n    return false\n  }\n  let p = n\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  * Return the smallest prime number that is greater than a given number.\n  * If the given number is not prime, it returns the largest prime that is less\n  * than the given number.\n  * If the given number is not prime, it returns -1.\n  *\n  * Examples:\n  *   >>> nextPrime(2)\n  *   3\n  *   >>> nextPrime(3)\n  *   7\n  *   >>> nextPrime(7)\n  *   11\n  *   >>> nextPrime(11)\n  *   13\n  *   >>> nextPrime(13)\n  *   -1\n  *   >>> nextPrime(15)\n  *   -1\n  *   >>> nextPrime(20)\n  *   -1\n  *   >>> nextPrime(21)\n  *   -1\n  *   >>> nextPrime(22)\n  *   23\n  *   >>> nextPrime(23)\n  *   -1\n  *   >>> nextPrime(25)\n  *   -1\n  *   >>> nextPrime(26)\n  *   -1\n  *   >>> nextPrime(29)\n  *   -1\n  *   >>> nextPrime(30)\n  *   -1\n  *   >>> nextPrime(31)\n  *   -1\n  *   >>> nextPrime(32)\n  *   33\n  *   >>> nextPrime(33)\n  *   -1\n  *   >>> nextPrime(40)\n  *   -1\n  *   >>> nextPrime(41)\n  *   -1\n  *   >>> nextPrime(42)\n  *   -1\n  *   >>> nextPrime(43)\n  *   -1\n  *   >>> nextPrime(44)\n  *   -1\n  *   >>> nextPrime(45)\n  *   -1\n  *   >>> nextPrime(46)\n  *   -1\n  *   >>> nextPrime(47)\n  *   -1\n  *   >>> nextPrime(48)\n  *   -1\n  *   >>> nextPrime(49)\n  *   -1\n  *   >>> nextPrime(50)\n  *   -1\n  *   >>> nextPrime(51)\n  *   -1\n  *   >>> nextPrime(52)\n  *   -1\n  *   >>> nextPrime(53)\n  *   -1\n  *   >>> nextPrime(54)\n  *   -1\n  *   >>> nextPrime(55)\n  *   -1\n  *   >>> nextPrime(56)\n  *   -1\n  *   >>> nextPrime(57)\n  *   -1\n  *   >>> nextPrime(58)\n  *   -1\n  *   >>> nextPrime(59)\n  *   -1\n  *   >>> nextPrime(60)\n  *   -1\n  *   >>> nextPrime(61)\n  *   -1\n  *   >>> nextPrime(62)\n  *   -1\n  *   >>> nextPrime(63)\n  *   -1\n  *   >>> nextPrime(64)\n  *   -1\n  *   >>> nextPrime(65)\n  *   -1\n  *   >>> nextPrime(66)\n  *   -1\n  *   >>> nextPrime(67)\n  *   -1\n  *   >>> nextPrime(68)\n  *   -1\n  *   >>> nextPrime(69)\n  *   -1\n  *   >>> nextPrime(70)\n  *   -1\n  *   >>> nextPrime(71)\n  *   -1\n  *   >>> nextPrime(72)\n  *   -1\n  *   >>> nextPrime(73)\n  *   -1\n  *   >>> nextPrime(74)\n  *   -1\n  *   >>> nextPrime(75)\n  *   -1\n  *   >>> nextPrime(76)\n  *   -1\n  *   >>> nextPrime(77)\n  *   -1\n  *   >>> nextPrime(78)\n  *   -1\n  *   >>> nextPrime(79)\n  *   -1\n  *   >>> nextPrime(80)\n  *   -1\n  *   >>> nextPrime(81)\n  *   -1\n  *   >>> nextPrime(82)\n  *   -1\n  *   >>> nextPrime(83)\n  *   -1\n  *   >>> nextPrime(84)\n  *   -1\n  *   >>> nextPrime(85)\n  *   -1\n  *   >>> nextPrime(86)\n  *   -1\n  *   >>> nextPrime(87)\n  *   -1\n  *   >>> nextPrime(88)\n  *   -1\n  *   >>> nextPrime(89)\n  *   -1\n  *   >>> nextPrime(90)\n  *   -1\n  *   >>> nextPrime(91)\n  *   -1\n  *   >>> nextPrime(92)\n  *   -1\n  *   >>> nextPrime(93)\n  *   -1\n  *   >>> nextPrime(94)\n  *   -1\n  *   >>> nextPrime(95)\n  *   -1\n  *   >>> nextPrime(96)\n  *   -1\n  *   >>> nextPrime(97)\n  *   -1\n  *   >>> nextPrime(98)\n  *   -1\n  *   >>> nextPrime(99)\n  *   -1\n  *   >>> nextPrime(100)\n  *   -1\n  *   >>> nextPrime(101)\n  *   -1\n  *   >>> nextPrime(102)\n  *   -1\n  *   >>> nextPrime(103)\n  *   -1\n"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "gc": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const n = xs.length;\n  if (n % 2 === 0) {\n    return (xs[n/2 - 1] - xs[n/2]) / (xs[n/2] - xs[n/2 - 1]);\n  } else {\n    return -1;\n  }\n}\n\nconst findSolution = (xs) => {\n  return findZero(xs);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findSolution finds x such that poly(x) = 0.\n  findSolution returns only only one solution,\n  even if there are many.\n  Moreover, findSolution only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findSolution([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findSolution([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findSolution = (xs) => {\n  const n = xs.length;\n  if (n % 2 === 0) {\n    return findZero(xs);\n  } else {\n    return -1;\n  }\n}\n\nmodule.exports = {\n  poly,\n  findSolution,\n  findZero\n}\n<|endoftext|>"}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortsThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortsThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortsThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortsThird", "gc": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortsThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortsThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortsThird = (l) => {\n  const sorted = sortByThird(l);\n  const sorted2 = sortByThird2(l);\n  return sorted.concat(sorted2);\n};\n\nmodule.exports = sortsThird;\n<|endoftext|>"}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "gc": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const ret = [];\n  const unique = (e) => {\n    if (ret.indexOf(e) === -1) ret.push(e);\n  };\n  for (const e of l) {\n    if (e!== undefined) {\n      unique(e);\n    }\n  }\n  return ret;\n};\n\nmodule.exports = unique;\n<|endoftext|>"}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxElements([1, 2, 3])\n  3\n  >>> maxElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElements = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElements", "gc": "/*Return maximum element in the list.\n  >>> maxElements([1, 2, 3])\n  3\n  >>> maxElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElements = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzzes", "gc": "/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzzes(50)\n  0\n  >>> fizzBuzzes(78)\n  2\n  >>> fizzBuzzes(79)\n  3\n  */\nconst fizzBuzzes = (n) => {\n  let fizzBuzz = 1;\n  while (fizzBuzz <= n) {\n    if (fizzBuzz % 3 === 0 && fizzBuzz % 5 === 0) {\n      fizzBuzz = fizzBuzz + 1;\n    }\n    if (fizzBuzz % 3 === 0) {\n      fizzBuzz = fizzBuzz + 2;\n    }\n    if (fizzBuzz % 5 === 0) {\n      fizzBuzz = fizzBuzz + 3;\n    }\n    console.log(fizzBuzz);\n  }\n};\n\nfizzBuzzes(100);\n<|endoftext|>"}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortsEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortsEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortsEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortsEven", "gc": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortsEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortsEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortsEven = (l) => {\n    let result = [];\n    let i = 0;\n    while(i < l.length) {\n        let j = 0;\n        while(j < l.length && l[j] == l[i]) {\n            j++;\n        }\n        if(j < l.length) {\n            result.push(l[i]);\n            result.push(l[j]);\n            i = j + 1;\n        } else {\n            result.push(l[i]);\n            i++;\n        }\n    }\n    return result;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "gc": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  const groups = s.split('');\n  const decoded = [];\n  for (const group of groups) {\n    if (group.length == 3)\n      decoded.push(group[0] + group.slice(1, 3));\n    else\n      decoded.push(group);\n  }\n  return decoded.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicSimple = (s) => {\n  const groups = s.split('');\n  const decoded = [];\n  for (const group of groups) {\n    if (group.length == 3)\n      decoded.push(group.slice(1));\n    else\n      decoded.push(group);\n  }\n  return decoded.join('');\n}\n\n/*\n  returns string with groups of 3 characters from array.\n  */\nconst getGroups = (arr) => {\n  var groups = [];\n  for (var i = 0; i < arr.length; i += 3) {\n    groups.push(arr.slice(i, Math.min(arr.length, i + 3)));\n  }\n  return groups.join('');\n}\n\nconst encode = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < s.length; i++) {\n    groups.push(s.slice(i, Math.min(s.length, i + 3)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decode = (s) => {\n  const groups = s.split('');\n  const decoded = [];\n  for (const group of groups) {\n    if (group.length == 3)\n      decoded.push(group[0] + group.slice(1, 3));\n    else\n      decoded.push(group);\n  }\n  return decoded.join('');\n}\n\nconst decodeSimple = (s) => {\n  const groups = s.split('');\n  const decoded = [];\n  for (const group of groups) {\n    if (group.length == 3)\n      decoded.push(group.slice(1));\n    else\n      decoded.push(group);\n  }\n  return decoded.join('');\n}\n\nexport default { encode, decode, decodeSimple, getGroups, encodeCyclic, decodeCyclic, decodeCyclicSimple };\n<|endoftext|>"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFibs returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFibs(1)\n  2\n  >>> primeFibs(2)\n  3\n  >>> primeFibs(3)\n  5\n  >>> primeFibs(4)\n  13\n  >>> primeFibs(5)\n  89\n  */\nconst primeFibs = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFibs", "gc": "/*\n  primeFibs returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFibs(1)\n  2\n  >>> primeFibs(2)\n  3\n  >>> primeFibs(3)\n  5\n  >>> primeFibs(4)\n  13\n  >>> primeFibs(5)\n  89\n  */\nconst primeFibs = (n) => {\n    return fib(n)\n       .filter(prime => prime.toString()[0]!== '2')\n       .sort((a, b) => a - b)\n       .reduce((a, b) => a + b, 0);\n};\n\nconsole.log(primeFibs(1));\nconsole.log(primeFibs(2));\nconsole.log(primeFibs(3));\nconsole.log(primeFibs(4));\nconsole.log(primeFibs(5));\n<|endoftext|>"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSummingToZeroed takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSummingToZeroed([1, 3, 5, 0])\n  false\n  >>> triplesSummingToZeroed([1, 3, -2, 1])\n  true\n  >>> triplesSummingToZeroed([1, 2, 3, 7])\n  false\n  >>> triplesSummingToZeroed([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSummingToZeroed([1])\n  false\n  */\nconst triplesSummingToZeroed = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSummingToZeroed", "gc": "/*\n  triplesSummingToZeroed takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSummingToZeroed([1, 3, 5, 0])\n  false\n  >>> triplesSummingToZeroed([1, 3, -2, 1])\n  true\n  >>> triplesSummingToZeroed([1, 2, 3, 7])\n  false\n  >>> triplesSummingToZeroed([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSummingToZeroed([1])\n  false\n  */\nconst triplesSummingToZeroed = (l) => {\n  const sum = sumAll(l)\n  const n = l.length\n  const sums = new Array(n)\n  for (let i = 0; i < n; i++) {\n    sums[i] = sum - l[i]\n  }\n  return l.every((_, i) => {\n    return sums[i] === 0\n  })\n}\n\nmodule.exports = triplesSummingToZeroed\n<|endoftext|>"}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carsRacesCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carsRacesCollision", "gc": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carsRacesCollision = (n) => {\n  let lcars = n\n   , rcars = n\n   , collisions = 0\n   , i = 0\n   , j = 0\n   , k = 0\n   , carL = []\n   , carR = []\n   , carLR = []\n\n    // We're going to store the car's positions in an array,\n    // since we're going to use arrays in the next loop.\n    // We'll store the left car's position first, then the right car's.\n    // Then we'll calculate the distance between the two.\n    // And finally, we'll use that distance to calculate the number of collisions.\n    while (i < lcars) {\n      carL[i] = i\n      carLR[k] = i\n      k++\n      i++\n    }\n\n    while (j < rcars) {\n      carR[j] = j\n      carLR[k] = j\n      k++\n      j++\n    }\n\n    i = 0\n    j = 0\n    // For each car in the left array, we'll check if it has collided with any car in the right array.\n    while (i < lcars) {\n      j = 0\n      while (j < rcars) {\n        if (carLR[i] + carLR[j] < carLR[i] - carLR[j]) {\n          collisions++\n        }\n        j++\n      }\n      i++\n    }\n\n    return collisions\n}\n\n//console.log(carsRacesCollision(0))\n//console.log(carsRacesCollision(1))\n//console.log(carsRacesCollision(2))\n//console.log(carsRacesCollision(3))\n//console.log(carsRacesCollision(4))\n//console.log(carsRacesCollision(5))\n//console.log(carsRacesCollision(6))\n//console.log(carsRacesCollision(7))\n//console.log(carsRacesCollision(8))\n//console.log(carsRacesCollision(9))\n//console.log(carsRacesCollision(10))\n//console.log(carsRacesCollision(11))\n//console.log(carsRacesCollision(12))\n//console.log(carsRacesCollision(13))\n//console.log(carsRacesCollision(14))\n//console.log(carsRacesCollision(15))\n//console.log(carsRacesCollision(16))\n//console.log(carsRacesCollision(17))\n//console.log(carsRacesCollision(18))\n//console.log(carsRacesCollision(19))\n//console.log(carsRacesCollision(20))\n//console.log(carsRacesCollision(21))\n//console.log(carsRacesCollision(22))\n//console.log(carsRacesCollision(23))\n//console.log(carsRacesCollision(24))\n//console.log(carsRacesCollision(25))\n//console.log(carsRacesCollision(26))\n//console.log(carsRacesCollision(27))\n//console.log(carsRacesCollision(28))\n//console.log(carsRacesCollision(29))\n//console.log(carsRacesCollision(30))\n//console.log(carsRacesCollision(31))\n//console.log(carsRacesCollision(32))\n//console.log(carsRacesCollision(33))\n//console.log(carsRacesCollision(34))\n//console.log(carsRacesCollision(35))\n//console.log(carsRacesCollision(36))\n//console.log(carsRacesCollision(37))\n//console.log(carsRacesCollision(38))\n//console.log(carsRacesCollision(39))\n//console.log(carsRacesCollision(40))\n//console.log(carsRacesCollision(41))\n//console.log(carsRacesCollision(42))\n//console.log(carsRacesCollision(43))\n//console.log(carsRacesCollision(44))\n//console.log(carsRacesCollision(45))\n//console.log(carsRacesCollision(46))\n//console.log(carsRacesCollision(47))\n//console.log(carsRacesCollision(48))\n//console.log(carsRacesCollision(49))\n//console.log(carsRacesCollision(50))\n//console.log(carsRacesCollision(51))\n//console.log(carsRacesCollision(52))\n//console.log(carsRacesCollision(53))\n//console.log(carsRacesCollision(54))\n//console.log(carsRacesCollision(55))\n//console.log(carsRacesCollision(56))\n//console.log(carsRacesCollision(57))\n//console.log(carsRacesCollision(58))\n//console.log(carsRacesCollision(59))\n//console.log(carsRacesCollision(60))\n//console.log(carsRacesCollision(61))\n//console.log(carsRacesCollision(62))\n//console.log(carsRacesCollision(63))\n//console.log(carsRacesCollision(64))\n//console.log(carsRacesCollision(65))\n//console.log(carsRacesCollision(66))\n//console.log(carsRacesCollision(67))\n//console.log(carsRacesCollision(68))\n//console.log(carsRacesCollision(69))\n//console.log(carsRacesCollision(70))\n//console.log(carsRacesCollision(71))\n//console.log(carsRacesCollision(72))\n//console.log(carsRacesCollision(73))\n//console.log(carsR"}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrLists([1, 2, 3])\n  [2, 3, 4]\n  >>> incrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrLists = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrLists", "gc": "/*Return list with elements incremented by 1.\n  >>> incrLists([1, 2, 3])\n  [2, 3, 4]\n  >>> incrLists([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrLists = (l) => {\n  let newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + 1);\n  }\n  return newList;\n};\n\n//BEGIN EXERCISE 1\n/**\n  * Return a list containing elements from a list of ints,\n  * starting at index i, and continuing for n elements.\n  * Note that the result is not sorted.\n  * @param {Array} l - list of ints\n  * @param {Number} i - starting index\n  * @param {Number} n - number of elements\n  * @return {Array} - list of ints\n  * @example\n  * incrLists([1, 2, 3], 2, 3)\n  * //=> [3, 4, 5]\n  */\nconst incrLists = (l, i, n) => {\n  let newList = [];\n  for (let j = i; j < i + n; j++) {\n    newList.push(l[j]);\n  }\n  return newList;\n};\n//END EXERCISE 1\n\n//BEGIN EXERCISE 2\n/**\n  * Return a list containing elements from a list of ints,\n  * starting at index i, and continuing for n elements,\n  * but incrementing the elements.\n  * Note that the result is not sorted.\n  * @param {Array} l - list of ints\n  * @param {Number} i - starting index\n  * @param {Number} n - number of elements\n  * @return {Array} - list of ints\n  * @example\n  * incrLists([1, 2, 3], 2, 3)\n  * //=> [3, 4, 5]\n  */\nconst incrLists = (l, i, n) => {\n  let newList = [];\n  for (let j = i; j < i + n; j++) {\n    newList.push(l[j] + 1);\n  }\n  return newList;\n};\n//END EXERCISE 2\n\n//BEGIN EXERCISE 3\n/**\n  * Return a list containing elements from a list of ints,\n  * starting at index i, and continuing for n elements,\n  * but incrementing the elements.\n  * Note that the result is not sorted.\n  * @param {Array} l - list of ints\n  * @param {Number} i - starting index\n  * @param {Number} n - number of elements\n  * @return {Array} - list of ints\n  * @example\n  * incrLists([1, 2, 3], 2, 3)\n  * //=> [3, 4, 5]\n  */\nconst incrLists = (l, i, n) => {\n  let newList = [];\n  for (let j = i; j < i + n; j++) {\n    newList.push(l[j] + 1);\n  }\n  return newList;\n};\n//END EXERCISE 3\n\n//BEGIN EXERCISE 4\n/**\n  * Return a list containing elements from a list of ints,\n  * starting at index i, and continuing for n elements,\n  * but incrementing the elements, but keeping them in\n  * descending order.\n  * Note that the result is not sorted.\n  * @param {Array} l - list of ints\n  * @param {Number} i - starting index\n  * @param {Number} n - number of elements\n  * @return {Array} - list of ints\n  * @example\n  * incrLists([1, 2, 3], 2, 3)\n  * //=> [3, 4, 5]\n  */\nconst incrLists = (l, i, n) => {\n  let newList = [];\n  for (let j = i; j < i + n; j++) {\n    newList.push(l[j] + 1);\n  }\n  return newList.reverse();\n};\n//END EXERCISE 4\n\n//BEGIN EXERCISE 5\n/**\n  * Return a list containing elements from a list of ints,\n  * starting at index i, and continuing for n elements,\n  * but incrementing the elements, but keeping them in\n  * descending order, and sorting the list.\n  * @param {Array} l - list of ints\n  * @param {Number} i - starting index\n  * @param {Number} n - number of elements\n  * @return {Array} - list of ints\n  * @example\n  * incrLists([1, 2, 3], 2, 3)\n  * //=> [3, 4, 5]\n  */\nconst incrLists = (l, i, n) => {\n  let newList = [];\n  for (let j = i; j < i + n; j++) {\n    newList.push(l[j] + 1);\n  }\n  newList.sort((a, b) => b - a);\n  return newList;\n};\n//END EXERCISE 5\n\n//BEGIN EXERCISE 6\n/**\n  * Return a list containing elements from a list of ints,\n  * starting at index i, and continuing for n elements,\n  * but incrementing the elements, but keeping them in\n  * descending order, and sorting the list.\n  * @param {Array} l - list of ints\n  * @param {Number} i - starting index\n  * @param {Number} n - number of elements\n  * @return {Array} - list of ints\n  * @example\n  * incrLists([1, 2, 3], 2, 3)\n  * //=> [3, 4, 5]\n  */\nconst incrLists = (l, i, n) => {\n  let newList = [];\n  for (let j = i; j < i + n; j++) {\n    newList.push(l[j] + 1);\n  }\n  newList.sort((a, b) => b - a);\n  return newList;\n};\n//END EXERCISE 6\n\n//BEGIN EXERCISE 7\n/**\n  "}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairSumsToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairSumsToZero([1, 3, 5, 0])\n  false\n  >>> pairSumsToZero([1, 3, -2, 1])\n  false\n  >>> pairSumsToZero([1, 2, 3, 7])\n  false\n  >>> pairSumsToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairSumsToZero([1])\n  false\n  */\nconst pairSumsToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairSumsToZero", "gc": "/*\n  pairSumsToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairSumsToZero([1, 3, 5, 0])\n  false\n  >>> pairSumsToZero([1, 3, -2, 1])\n  false\n  >>> pairSumsToZero([1, 2, 3, 7])\n  false\n  >>> pairSumsToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairSumsToZero([1])\n  false\n  */\nconst pairSumsToZero = (l) => {\n    const d = [0, 0];\n    l.forEach(x => d[x > 0? 0 : 1] += x);\n    return d[0] == 0 && d[1] == 0;\n};\n\n/*\n  pairSumToZero takes a list of integers as an input.\n  it returns true if there is a pair of distinct elements in the list\n  that sum to zero, and false otherwise.\n  >>> pairSumToZero([1, 3, 5, 7])\n  false\n  >>> pairSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairSumToZero([1, 2, 3, 7])\n  false\n  >>> pairSumToZero([1, 2, 3, 4, 5])\n  false\n  >>> pairSumToZero([1, 2, 3, 4, 5, 7])\n  false\n  >>> pairSumToZero([1, 2, 3, 7, 8, 9])\n  false\n  >>> pairSumToZero([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  true\n  >>> pairSumToZero([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10])\n  false\n  >>> pairSumToZero([1, 2, 3, 7, 8, 9, 10])\n  false\n  */\nconst pairSumToZero = (l) => {\n    const d = [0, 0];\n    l.forEach(x => d[x > 0? 0 : 1] += x);\n    return d[0] == 0 && d[1] == 0;\n};\n\nconst test = () => {\n    const a = [1, 3, 5, 7];\n    console.log(\"pairSumsToZero\", pairSumsToZero(a));\n    console.log(\"pairSumToZero\", pairSumToZero(a));\n};\n\ntest();\n<|endoftext|>"}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBases(8, 3)\n  '22'\n  >>> changeBases(8, 2)\n  '1000'\n  >>> changeBases(7, 2)\n  '111'\n  */\nconst changeBases = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBases", "gc": "/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBases(8, 3)\n  '22'\n  >>> changeBases(8, 2)\n  '1000'\n  >>> changeBases(7, 2)\n  '111'\n  */\nconst changeBases = (x, base) => {\n  let output = x.toString(base);\n  while(output.length < x.toString().length) {\n    output = `0${output}`;\n  }\n  return output;\n};\n\nconst findCommonFactor = (n1, n2) => {\n  const divisor = n1.toString().split('').reduce((a, b) => a*b, 1);\n  const divisor2 = n2.toString().split('').reduce((a, b) => a*b, 1);\n  const difference = divisor2 - divisor;\n  return Math.abs(difference);\n};\n\nconst getFactors = (number) => {\n  const factors = [];\n  let n = number;\n  while(n > 1) {\n    const factor = findCommonFactor(n, number);\n    factors.push(factor);\n    n = n / factor;\n  }\n  return factors;\n};\n\nconst getCommonFactors = (n1, n2) => {\n  const n1Factors = getFactors(n1);\n  const n2Factors = getFactors(n2);\n  return n1Factors.concat(n2Factors);\n};\n\nconst isPerfect = (number) => {\n  const factors = getCommonFactors(number, number);\n  return factors.length === 1 && factors[0] === 1;\n};\n\nconst getPermutations = (list) => {\n  const permutation = [];\n  for(let i = 0; i < list.length; i++) {\n    const permutationItem = list.slice(0);\n    permutationItem.splice(i, 1, list[i]);\n    permutation.push(permutationItem);\n  }\n  return permutation;\n};\n\nconst getPermutationsOfFactors = (factors) => {\n  const permutations = getPermutations(factors);\n  return permutations;\n};\n\nconst isValidPermutation = (permutation, factors) => {\n  for(let i = 0; i < permutation.length; i++) {\n    const factor = factors[i];\n    const permutationItem = permutation[i];\n    if(permutationItem.length!== factor) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst getPermutationsOfPermutations = (permutations) => {\n  const permutationsOfPermutations = [];\n  for(let i = 0; i < permutations.length; i++) {\n    const permutation = permutations[i];\n    for(let j = 0; j < permutations.length; j++) {\n      const permutation2 = permutations[j];\n      if(permutation.length!== permutation2.length) {\n        continue;\n      }\n      const permutationsOfPermutationsItem = [...permutation,...permutation2];\n      if(isValidPermutation(permutationsOfPermutationsItem, factors)) {\n        permutationsOfPermutations.push(permutationsOfPermutationsItem);\n      }\n    }\n  }\n  return permutationsOfPermutations;\n};\n\nconst getPermutationsOfPermutationsOfPermutations = (permutationsOfPermutations) => {\n  const permutationsOfPermutationsOfPermutations = [];\n  for(let i = 0; i < permutationsOfPermutations.length; i++) {\n    const permutationsOfPermutationsItem = permutationsOfPermutations[i];\n    for(let j = 0; j < permutationsOfPermutations.length; j++) {\n      const permutationsOfPermutationsItem2 = permutationsOfPermutations[j];\n      const permutationsOfPermutationsItem3 = [...permutationsOfPermutationsItem,...permutationsOfPermutationsItem2];\n      if(isValidPermutation(permutationsOfPermutationsItem3, factors)) {\n        permutationsOfPermutationsOfPermutations.push(permutationsOfPermutationsItem3);\n      }\n    }\n  }\n  return permutationsOfPermutationsOfPermutations;\n};\n\nconst isPalindrome = (number) => {\n  const numberString = number.toString();\n  const reverse = numberString.split('').reverse().join('');\n  return numberString === reverse;\n};\n\nconst getPalindromes = (n) => {\n  const palindromes = [];\n  for(let i = 0; i < n; i++) {\n    if(isPalindrome(i)) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\nconst getDivisors = (number) => {\n  const divisors = [];\n  for(let i = 1; i < number; i++) {\n    const factor = number / i;\n    if(factor % 1 === 0) {\n      divisors.push(factor);\n    }\n  }\n  return divisors;\n};\n\nconst isDivisor = (number, divisors) => {\n  return divisors.indexOf(number) >= 0;\n};\n\nconst getDivisorsOfFactors = (factors) => {\n  const divisors = [];\n  for(let i = 0; i < factors.length; i++) {\n    const factor = factors[i];\n    const divisorsOfFactor = getDivisors(factor);\n    divisors.push(...divisorsOfFactor);\n  }\n  return divisors;\n};\n\nconst isDivisorOfFactors = (factors, divisors) => {\n  for(let i = 0; i < factors.length; i++) {\n    const factor = factors[i];\n    const divisorsOfFactor = getDivisors(factor);\n    if(divisorsOfFactor.indexOf(divisors[i]) < 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst getDivisorsOfDivisors = (divisors"}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area for a triangle.\n  >>> trianglesAreas(5, 3)\n  7.5\n  */\nconst trianglesAreas = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "trianglesAreas", "gc": "/*Given length of a side and high return area for a triangle.\n  >>> trianglesAreas(5, 3)\n  7.5\n  */\nconst trianglesAreas = (a, h) => {\n  let area = (a * h) / 2\n  return area\n}\n\n/*Given length of a side and high return volume for a triangle.\n  >>> trianglesVolumes(5, 3)\n  9\n  */\nconst trianglesVolumes = (a, h) => {\n  let area = (a * h) / 2\n  return area * area\n}\n\n/*Given length of a side and high return surface for a triangle.\n  >>> trianglesSurfaces(5, 3)\n  7\n  */\nconst trianglesSurfaces = (a, h) => {\n  let area = (a * h) / 2\n  return area * h\n}\n\n/*Given length of a side and high return area for a triangle.\n  >>> trianglesAreas(5, 3)\n  7.5\n  */\nconst trianglesArea = (a, h) => {\n  let area = (a * h) / 2\n  return area\n}\n\n/*Given length of a side and high return volume for a triangle.\n  >>> trianglesVolumes(5, 3)\n  9\n  */\nconst trianglesVolume = (a, h) => {\n  let area = (a * h) / 2\n  return area * area\n}\n\n/*Given length of a side and high return surface for a triangle.\n  >>> trianglesSurfaces(5, 3)\n  7\n  */\nconst trianglesSurface = (a, h) => {\n  let area = (a * h) / 2\n  return area * h\n}\n<|endoftext|>"}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "gc": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 0;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  if (n === 3) {\n    return 0;\n  }\n  let a = fib4(n - 1);\n  let b = fib4(n - 2);\n  let c = fib4(n - 3);\n  return a + b + c;\n};\n\nconsole.log(fib4(5));\nconsole.log(fib4(6));\nconsole.log(fib4(7));\n\n/*\nWhat is the value of the first triangle number to have over five hundred divisors?\n\nThe first triangle number is a triangle number, which is a number that is a sum of three naturals (1, 2, and 3). For example, the first triangle number to have over five hundred divisors is 6.\n\nThe number of divisors of a number is the number of ways in which a number can be divided into its positive parts. For example, the number 6 has five positive divisors (1, 2, 3, 4, and 6).\n\nThe first triangle number to have over five hundred divisors is 12.\n\nThe first triangle number to have over five hundred divisors is 144.\n\nFind the first triangle number to have over five hundred divisors.\n\n*/\nconst find_triangle_number = (n) => {\n  let arr = [];\n  let a = 1;\n  let b = 1;\n  let c = 0;\n  let n1 = 1;\n  let n2 = 1;\n  let n3 = 0;\n  while (n1 <= n) {\n    a = n1;\n    b = n2;\n    c = n3;\n    while (b <= n) {\n      if (n % a === 0) {\n        if (a > b) {\n          arr.push(a);\n          a = a * b;\n        } else {\n          arr.push(b);\n          a = a * b;\n        }\n      }\n      b++;\n    }\n    n3 = n3 + 1;\n    n1 = n1 * 2;\n    n2 = n2 * 3;\n  }\n  let arr_sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    arr_sum = arr_sum + arr[i];\n  }\n  let divisors = 0;\n  for (let i = 1; i <= arr_sum; i++) {\n    divisors = divisors + 1;\n  }\n  if (divisors > 500) {\n    console.log(arr_sum);\n  }\n};\n\nfind_triangle_number(144);\n<|endoftext|>"}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "gc": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  l = l.sort();\n  const half = Math.floor(l.length / 2);\n  return (l[half] + l[l.length - 1]) / 2;\n};\n\n/* Return a list of unique elements in the list l.\n  >>> unique([1, 1, 2, 3, 3])\n  [1, 2, 3]\n  >>> unique([1, 1, 2, 3, 3, 3, 4])\n  [1, 2, 3, 4]\n  */\nconst unique = (l) => {\n  return l.reduce((arr, val) => {\n    if (arr.indexOf(val) === -1) {\n      arr.push(val);\n    }\n    return arr;\n  }, []);\n};\n\nmodule.exports = {\n  median,\n  unique\n};\n<|endoftext|>"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "gc": "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    if (text.length === 0) {\n        return true;\n    }\n\n    let left = 0, right = text.length - 1, i = 0, j = text.length - 1;\n    while (i <= j) {\n        if (text.charAt(i)!== text.charAt(j)) {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n\n    return true;\n};\n\n/*\n  Takes a string and reverse the order of all the characters\n  >>> reverse('abcdef')\n  'fedcba'\n  >>> reverse('abc')\n  'cba'\n  >>> reverse('')\n  ''\n  */\nconst reverse = (text) => {\n    if (text.length === 0) {\n        return text;\n    }\n\n    let temp = text.charAt(0), i = 0;\n    while (i < text.length - 1) {\n        text = text.substring(0, i + 1) + text.substring(i + 1);\n        i += 1;\n    }\n\n    text = text.substring(0, i + 1) + temp;\n\n    return text;\n};\n\n/*\n  Takes a string and reverse the order of all the words\n  >>> reverseWords('hello world')\n  'world hello'\n  >>> reverseWords('hello')\n  'hello'\n  >>> reverseWords('hello world')\n  'world hello'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  >>> reverseWords('hello world and the other world')\n  'other world world and'\n  "}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "gc": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0) return n + p\n  let result = n % p\n  while (result < 0) result += p\n  return result\n}\n\n/*\n  >>> modp(2, 7)\n  0\n  >>> modp(1, 7)\n  6\n  >>> modp(10, 11)\n  0\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modf = (n, p) => {\n  return modp(n, p) / p\n}\n\n/*\n  >>> modf(2, 7)\n  0\n  >>> modf(1, 7)\n  6\n  >>> modf(10, 11)\n  0\n  >>> modf(3, 11)\n  8\n  >>> modf(100, 101)\n  1\n  */\nconst modf2 = (n, p) => {\n  let modp = modp(n, p)\n  return modp + modp * (p - 1)\n}\n\n/*\n  >>> modf2(2, 7)\n  0\n  >>> modf2(1, 7)\n  6\n  >>> modf2(10, 11)\n  0\n  >>> modf2(3, 11)\n  8\n  >>> modf2(100, 101)\n  1\n  */\n\nconst gcd = (a, b) => {\n  let r = a % b\n  while (r!== 0) {\n    a = b\n    b = r\n    r = a % b\n  }\n  return b\n}\n\nconst lcm = (a, b) => {\n  return a * b / gcd(a, b)\n}\n\n/*\n  >>> gcd(4, 8)\n  4\n  >>> gcd(9, 10)\n  1\n  >>> gcd(2, 9)\n  2\n  >>> gcd(5, 0)\n  5\n  >>> gcd(0, 5)\n  5\n  >>> gcd(5, -5)\n  5\n  >>> gcd(0, 0)\n  0\n  >>> gcd(-5, 0)\n  5\n  >>> gcd(0, -5)\n  5\n  >>> gcd(1, 0)\n  1\n  >>> gcd(0, 1)\n  1\n  */\n\nconst isPrime = (n) => {\n  if (n <= 1) return false\n  if (n <= 3) return true\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  let i = 5\n  while (i * i <= n) {\n    if (n % i === 0) return false\n    i += 6\n  }\n  return true\n}\n\nconst p2 = (n) => {\n  if (n <= 1) return 0\n  if (n <= 3) return 1\n  if (n <= 7) return 2\n  if (n <= 13) return 3\n  if (n <= 31) return 4\n  if (n <= 127) return 5\n  if (n <= 1021) return 6\n  if (n <= 2039) return 7\n  if (n <= 4093) return 8\n  if (n <= 8191) return 9\n  if (n <= 16381) return 10\n  if (n <= 32767) return 11\n  if (n <= 65537) return 12\n  return 13\n}\n\n/*\n  >>> p2(1)\n  1\n  >>> p2(2)\n  2\n  >>> p2(3)\n  3\n  >>> p2(4)\n  4\n  >>> p2(5)\n  5\n  >>> p2(6)\n  6\n  >>> p2(7)\n  7\n  >>> p2(8)\n  8\n  >>> p2(9)\n  9\n  >>> p2(10)\n  10\n  >>> p2(11)\n  11\n  >>> p2(12)\n  12\n  >>> p2(13)\n  13\n  >>> p2(14)\n  14\n  >>> p2(15)\n  15\n  >>> p2(16)\n  16\n  >>> p2(17)\n  17\n  >>> p2(18)\n  18\n  >>> p2(19)\n  19\n  >>> p2(20)\n  20\n  >>> p2(21)\n  21\n  >>> p2(22)\n  22\n  >>> p2(23)\n  23\n  >>> p2(24)\n  24\n  >>> p2(25)\n  25\n  >>> p2(26)\n  26\n  >>> p2(27)\n  27\n  >>> p2(28)\n  28\n  >>> p2(29)\n  29\n  >>> p2(30)\n  30\n  >>> p2(31)\n  31\n  >>> p2(32)\n  32\n  >>> p2(33)\n  33\n  >>> p2(34)\n  34\n  >>> p2(35)\n  35\n  >>> p2(36)\n  36\n  >>> p2(37)\n  37\n  >>> p2(38)\n  38\n  >>> p2(39)\n  39\n  >>> p2(40)\n  40\n  >>> p2(41)\n  41\n  >>> p2(42)\n  42\n  >>> p2(43)\n  43\n  >>> p2(44)\n  44\n  >>> p2(45)\n  45\n  >>> p2(46)\n  46\n  >>> p2(47)\n  47\n  >>> p2(48)\n  48\n  >>> p2(49)\n  49\n  >>> p2(50)\n  50\n  >>> p2(51)\n  51\n  >>> p2(52)\n  52\n  >>> p2(53)\n  53\n  >>> p2(54)\n  54\n  >>> p2(55)\n  55\n  >>> p2(56)\n  56\n  >>> p2(57)\n"}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "gc": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  let result = \"\";\n  for (let i = 0; i < s.length; i++) {\n    result += String.fromCharCode(((s.charCodeAt(i) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0));\n  }\n  return result;\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns string\n  without spaces.\n  */\nconst trimShift = (s) => {\n  return s.replace(/\\s/g, \"\");\n}\n\nconst validate = (str) => {\n  if (str.length < 3) {\n    return false;\n  }\n  let result = true;\n  if (str.indexOf(\"-\") === -1) {\n    return false;\n  }\n  for (let i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) < \"a\".charCodeAt(0)) {\n      return false;\n    }\n  }\n  return result;\n}\n\n/*\n  Returns encoded string.\n  */\nconst encode = (str) => {\n  let result = \"\";\n  for (let i = 0; i < str.length; i++) {\n    let char = str.charAt(i);\n    if (char.charCodeAt(0) < \"a\".charCodeAt(0)) {\n      return false;\n    }\n    result += String.fromCharCode(char.charCodeAt(0) - \"a\".charCodeAt(0));\n  }\n  return result;\n}\n\n/*\n  Returns decoded string.\n  */\nconst decode = (str) => {\n  let result = \"\";\n  for (let i = 0; i < str.length; i++) {\n    let char = str.charCodeAt(i);\n    if (char > \"z\".charCodeAt(0)) {\n      return false;\n    }\n    result += String.fromCharCode(char + \"a\".charCodeAt(0));\n  }\n  return result;\n}\n\n/*\n  Returns string without spaces.\n  */\nconst trim = (str) => {\n  return str.replace(/\\s/g, \"\");\n}\n\nmodule.exports = {\n  validate,\n  encode,\n  decode,\n  trim,\n  encodeShift,\n  decodeShift,\n  trimShift,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowel is a function that takes string and returns string without vowels.\n  >>> removeVowel('')\n  ''\n  >>> removeVowel(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowel('abcdef')\n  'bcdf'\n  >>> removeVowel('aaaaa')\n  ''\n  >>> removeVowel('aaBAA')\n  'B'\n  >>> removeVowel('zbcd')\n  'zbcd'\n  */\nconst removeVowel = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowel", "gc": "/*\n  removeVowel is a function that takes string and returns string without vowels.\n  >>> removeVowel('')\n  ''\n  >>> removeVowel(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowel('abcdef')\n  'bcdf'\n  >>> removeVowel('aaaaa')\n  ''\n  >>> removeVowel('aaBAA')\n  'B'\n  >>> removeVowel('zbcd')\n  'zbcd'\n  */\nconst removeVowel = (text) => {\n  if (!text) {\n    return ''\n  }\n\n  return text.replace(/[aeiouAEIOU]/g, '')\n}\n\n/*\n  removePunctuation is a function that takes string and returns string without punctuation.\n  >>> removePunctuation(\"abcd\")\n  'abcd'\n  >>> removePunctuation(\"\")\n  ''\n  >>> removePunctuation(\"a.b.c.d\")\n  'abcd'\n  >>> removePunctuation(\"a,b.c,d\")\n  'abcd'\n  >>> removePunctuation(\"a:b.c;d\")\n  'abcd'\n  >>> removePunctuation(\"a.b.c.\")\n  'abcd'\n  >>> removePunctuation(\".a.b.c\")\n  'abcd'\n  >>> removePunctuation(\";a.b.c\")\n  'abcd'\n  >>> removePunctuation(\";a.b.c\")\n  'abcd'\n  >>> removePunctuation(\";a.b.c\")\n  'abcd'\n  >>> removePunctuation(\"a b.c\")\n  'abcd'\n  >>> removePunctuation(\"a.b.c;\")\n  'abcd'\n  >>> removePunctuation(\"a.b.c,d\")\n  'abcd'\n  >>> removePunctuation(\"a.b.c.d;\")\n  'abcd'\n  >>> removePunctuation(\"a.b.c.d.\")\n  'abcd'\n  >>> removePunctuation(\"a.b.c.d.e\")\n  'abcd.e'\n  >>> removePunctuation(\"a.b.c.d.e\")\n  'abcd.e'\n  >>> removePunctuation(\"a.b.c.d.e.\")\n  'abcd.e'\n  >>> removePunctuation(\"a.b.c.d.e.f\")\n  'abcd.ef'\n  >>> removePunctuation(\"a.b.c.d.e.f\")\n  'abcd.ef'\n  >>> removePunctuation(\"a.b.c.d.e.f.\")\n  'abcd.ef'\n  >>> removePunctuation(\"a.b.c.d.e.f.g\")\n  'abcd.efg'\n  >>> removePunctuation(\"a.b.c.d.e.f.g\")\n  'abcd.efg'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.\")\n  'abcd.efg'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h\")\n  'abcd.efgh'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h\")\n  'abcd.efgh'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.\")\n  'abcd.efgh'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i\")\n  'abcd.efghi'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i\")\n  'abcd.efghi'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.\")\n  'abcd.efghi'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j\")\n  'abcd.efghij'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j\")\n  'abcd.efghij'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j.\")\n  'abcd.efghij'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j.k\")\n  'abcd.efghijk'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j.k\")\n  'abcd.efghijk'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j.k.\")\n  'abcd.efghijk'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j.k.l\")\n  'abcd.efghijk.l'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j.k.l\")\n  'abcd.efghijk.l'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j.k.l.\")\n  'abcd.efghijk.l'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j.k.l.m\")\n  'abcd.efghijk.lm'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j.k.l.m\")\n  'abcd.efghijk.lm'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j.k.l.m.\")\n  'abcd.efghijk.lm'\n  >>> removePunctuation(\"a.b.c.d.e.f.g.h.i.j.k.l.m.n\")\n  'abcd.efghijk.lmn'\n  >>> removePunctuation(\"a.b"}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThresholds", "gc": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] > t) return false\n  }\n  return true\n}\n\n/*\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds2 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] >= t) return false\n  }\n  return true\n}\n\n/*\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds3 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t) return false\n  }\n  return true\n}\n\n/*\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds4 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] <= t) return false\n  }\n  return true\n}\n\n/*\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds5 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] <= t) return false\n  }\n  return true\n}\n\nconst belowThresholds6 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] > t) return false\n  }\n  return true\n}\n\nconst belowThresholds7 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t) return false\n  }\n  return true\n}\n\n/*\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds8 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t) return false\n  }\n  return true\n}\n\n/*\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds9 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] > t) return false\n  }\n  return true\n}\n\n/*\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds10 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] <= t) return false\n  }\n  return true\n}\n\n/*\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds11 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] >= t) return false\n  }\n  return true\n}\n\n/*\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds12 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] >= t) return false\n  }\n  return true\n}\n\n/*\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds13 = (l, t) => {\n  const len = l.length\n  if (len === 0) return false\n  for (let i = 0; i < len; i++) {\n    if (l[i] < t) return false\n  }\n  return true\n}\n\n/*\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds14 = (l, t) => {\n  const len = l.length\n"}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> adding(2, 3)\n  5\n  >>> adding(5, 7)\n  12\n  */\nconst adding = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "adding", "gc": "/*Add two numbers x and y\n  >>> adding(2, 3)\n  5\n  >>> adding(5, 7)\n  12\n  */\nconst adding = (x, y) => {\n    return x + y;\n};\n\nconst adding2 = (x, y) => {\n    return x + y;\n};\n\n/*\n  * Multiply two numbers x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  210\n  *\n  */\nconst multiply = (x, y) => {\n    return x * y;\n};\n\nconst multiply2 = (x, y) => {\n    return x * y;\n};\n\n/*\n  * Divide two numbers x and y\n  >>> divide(2, 3)\n  0\n  >>> divide(5, 7)\n  2.0\n  *\n  */\nconst divide = (x, y) => {\n    return x / y;\n};\n\nconst divide2 = (x, y) => {\n    return x / y;\n};\n\n/*\n  * Subtract two numbers x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  4\n  *\n  */\nconst subtract = (x, y) => {\n    return x - y;\n};\n\nconst subtract2 = (x, y) => {\n    return x - y;\n};\n\n/*\n  * Divide two numbers x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  4\n  *\n  */\nconst modulo = (x, y) => {\n    return x % y;\n};\n\nconst modulo2 = (x, y) => {\n    return x % y;\n};\n\n/*\n  *\n  * */\nconst pow = (x, y) => {\n    return Math.pow(x, y);\n};\n\nconst pow2 = (x, y) => {\n    return Math.pow(x, y);\n};\n\n/*\n  *\n  * */\nconst sqrt = (x) => {\n    return Math.sqrt(x);\n};\n\nconst sqrt2 = (x) => {\n    return Math.sqrt(x);\n};\n\n/*\n  *\n  * */\nconst abs = (x) => {\n    return Math.abs(x);\n};\n\nconst abs2 = (x) => {\n    return Math.abs(x);\n};\n\n/*\n  *\n  * */\nconst round = (x) => {\n    return Math.round(x);\n};\n\nconst round2 = (x) => {\n    return Math.round(x);\n};\n\n/*\n  *\n  * */\nconst ceil = (x) => {\n    return Math.ceil(x);\n};\n\nconst ceil2 = (x) => {\n    return Math.ceil(x);\n};\n\n/*\n  *\n  * */\nconst floor = (x) => {\n    return Math.floor(x);\n};\n\nconst floor2 = (x) => {\n    return Math.floor(x);\n};\n\n/*\n  *\n  * */\nconst min = (x, y) => {\n    return Math.min(x, y);\n};\n\nconst min2 = (x, y) => {\n    return Math.min(x, y);\n};\n\n/*\n  *\n  * */\nconst max = (x, y) => {\n    return Math.max(x, y);\n};\n\nconst max2 = (x, y) => {\n    return Math.max(x, y);\n};\n\n/*\n  *\n  * */\nconst exp = (x) => {\n    return Math.exp(x);\n};\n\nconst exp2 = (x) => {\n    return Math.exp(x);\n};\n\n/*\n  *\n  * */\nconst ln = (x) => {\n    return Math.log(x);\n};\n\nconst ln2 = (x) => {\n    return Math.log(x);\n};\n\n/*\n  *\n  * */\nconst log = (x, base = 10) => {\n    return Math.log(x) / Math.log(base);\n};\n\nconst log2 = (x, base = 10) => {\n    return Math.log(x) / Math.log(base);\n};\n\n/*\n  *\n  * */\nconst sqrt = (x) => {\n    return Math.sqrt(x);\n};\n\nconst sqrt2 = (x) => {\n    return Math.sqrt(x);\n};\n\n/*\n  *\n  * */\nconst abs = (x) => {\n    return Math.abs(x);\n};\n\nconst abs2 = (x) => {\n    return Math.abs(x);\n};\n\n/*\n  *\n  * */\nconst round = (x) => {\n    return Math.round(x);\n};\n\nconst round2 = (x) => {\n    return Math.round(x);\n};\n\n/*\n  *\n  * */\nconst ceil = (x) => {\n    return Math.ceil(x);\n};\n\nconst ceil2 = (x) => {\n    return Math.ceil(x);\n};\n\n/*\n  *\n  * */\nconst floor = (x) => {\n    return Math.floor(x);\n};\n\nconst floor2 = (x) => {\n    return Math.floor(x);\n};\n\n/*\n  *\n  * */\nconst min = (x, y) => {\n    return Math.min(x, y);\n};\n\nconst min2 = (x, y) => {\n    return Math.min(x, y);\n};\n\n/*\n  *\n  * */\nconst max = (x, y) => {\n    return Math.max(x, y);\n};\n\nconst max2 = (x, y) => {\n    return Math.max(x, y);\n};\n\n/*\n  *\n  * */\nconst exp = (x) => {\n    return Math.exp(x);\n};\n\nconst exp2 = (x) => {\n    return Math.exp(x);\n};\n\n/*\n  *\n  * */\nconst ln = (x) => {\n    return Math.log(x);\n};\n\nconst ln2 = (x) => {\n    return"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> sameChar('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChar('abcd', 'dddddddabc')\n  true\n  >>> sameChar('dddddddabc', 'abcd')\n  true\n  >>> sameChar('eabcd', 'dddddddabc')\n  false\n  >>> sameChar('abcd', 'dddddddabce')\n  false\n  >>> sameChar('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChar = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChar", "gc": "/*\n  Check if two words have the same characters.\n  >>> sameChar('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChar('abcd', 'dddddddabc')\n  true\n  >>> sameChar('dddddddabc', 'abcd')\n  true\n  >>> sameChar('eabcd', 'dddddddabc')\n  false\n  >>> sameChar('abcd', 'dddddddabce')\n  false\n  >>> sameChar('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChar = (s0, s1) => {\n    let s = [],\n        l = s0.length,\n        i = 0,\n        j = 0;\n\n    for (; i < l; i++) {\n        if (s0[i] === s1[i]) {\n            s.push(s0[i]);\n        } else {\n            break;\n        }\n    }\n\n    l = s1.length;\n    i = 0;\n    while (i < l) {\n        if (s0[i] === s1[i]) {\n            s.push(s1[i]);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    return s.length === l;\n};\n\nmodule.exports = sameChar;\n<|endoftext|>"}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fibs", "gc": "/*Return n-th Fibonacci number.\n  >>> fibs(10)\n  55\n  >>> fibs(1)\n  1\n  >>> fibs(8)\n  21\n  */\nconst fibs = (n) => {\n    const a = 1, b = 1;\n    for (let i = 0; i < n; i++) {\n        b = a + b;\n        a = b - a;\n    }\n    return b;\n};\n\nmodule.exports = fibs;\n<|endoftext|>"}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "gc": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  if (brackets.length === 0) {\n    return false\n  }\n\n  let leftOpen = 0\n  let rightOpen = 0\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"<\") {\n      leftOpen++\n    } else if (brackets[i] === \">\") {\n      rightOpen++\n    }\n  }\n\n  return leftOpen === rightOpen\n}\n\nmodule.exports = correctBracketing\n<|endoftext|>"}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "gc": "/*Return true is list elements are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let ln = l.length\n  let last = l[ln - 1]\n  for (let i = 0; i < ln - 1; i++) {\n    if (l[i] > last) return false\n    last = l[i]\n  }\n  return true\n}\n\n/*\n  Return true if array of values are monotonic increasing.\n  >>> monotonicIncreasing([1, 2, 4, 20])\n  true\n  >>> monotonicIncreasing([1, 20, 4, 10])\n  false\n  >>> monotonicIncreasing([4, 1, 0, -10])\n  true\n  */\nconst monotonicIncreasing = (l) => {\n  let ln = l.length\n  let last = l[ln - 1]\n  for (let i = 0; i < ln - 1; i++) {\n    if (l[i] < last) return false\n    last = l[i]\n  }\n  return true\n}\n\n/*\n  Return true if array of values are monotonic decreasing.\n  >>> monotonicDecreasing([1, 2, 4, 20])\n  false\n  >>> monotonicDecreasing([1, 20, 4, 10])\n  true\n  >>> monotonicDecreasing([4, 1, 0, -10])\n  false\n  */\nconst monotonicDecreasing = (l) => {\n  let ln = l.length\n  let last = l[ln - 1]\n  for (let i = 0; i < ln - 1; i++) {\n    if (l[i] > last) return false\n    last = l[i]\n  }\n  return true\n}\n\n/*\n  Return true if array of values are unique.\n  >>> unique([1, 2, 3, 4, 5])\n  false\n  >>> unique([1, 2, 3, 4, 5, 5])\n  true\n  >>> unique([1, 2, 2, 4, 5, 6])\n  true\n  >>> unique([1, 2, 2, 2, 2, 2, 4, 5, 6])\n  true\n  */\nconst unique = (l) => {\n  return l.length === 1? l[0] === l[l.length - 1] : l.every((_, i) => {\n    return l[i]!== l[i - 1]\n  })\n}\n\n/*\n  Return true if values are sorted.\n  >>> sorted([1, 2, 3, 4, 5])\n  false\n  >>> sorted([1, 2, 3, 4, 5, 5])\n  true\n  >>> sorted([1, 2, 2, 2, 2, 2, 4, 5, 6])\n  true\n  >>> sorted([1, 2, 2, 4, 5, 6])\n  true\n  */\nconst sorted = (l) => {\n  return l.every((_, i) => {\n    return l[i] >= l[i + 1]\n  })\n}\n\n/*\n  Return true if values are sorted in increasing order.\n  >>> sortedIncreasing([1, 2, 3, 4, 5])\n  false\n  >>> sortedIncreasing([1, 2, 3, 4, 5, 5])\n  true\n  >>> sortedIncreasing([1, 2, 2, 2, 2, 2, 4, 5, 6])\n  true\n  >>> sortedIncreasing([1, 2, 2, 4, 5, 6])\n  true\n  */\nconst sortedIncreasing = (l) => {\n  return l.every((_, i) => {\n    return l[i] >= l[i + 1]\n  })\n}\n\n/*\n  Return true if values are sorted in decreasing order.\n  >>> sortedDecreasing([1, 2, 3, 4, 5])\n  false\n  >>> sortedDecreasing([1, 2, 3, 4, 5, 5])\n  true\n  >>> sortedDecreasing([1, 2, 2, 2, 2, 2, 4, 5, 6])\n  true\n  >>> sortedDecreasing([1, 2, 2, 4, 5, 6])\n  true\n  */\nconst sortedDecreasing = (l) => {\n  return l.every((_, i) => {\n    return l[i] <= l[i + 1]\n  })\n}\n\n/*\n  Return true if values are sorted in increasing order, and\n  values are monotonic increasing.\n  >>> sortedIncreasingIncreasing([1, 2, 3, 4, 5])\n  false\n  >>> sortedIncreasingIncreasing([1, 2, 3, 4, 5, 5])\n  true\n  >>> sortedIncreasingIncreasing([1, 2, 2, 2, 2, 2, 4, 5, 6])\n  true\n  >>> sortedIncreasingIncreasing([1, 2, 2, 4, 5, 6])\n  true\n  */\nconst sortedIncreasingIncreasing = (l) => {\n  return l.every((_, i) => {\n    return l[i] >= l[i + 1] && monotonicIncreasing(l.slice(0, i + 1))\n  })\n}\n\n/*\n  Return true if values are sorted in decreasing order, and\n  values are monotonic decreasing.\n  >>> sortedDecreasingDecreasing([1, 2, 3, 4, 5])\n  false\n  >>> sortedDecreasingDecreasing([1, 2, 3, 4, 5, 5])\n  true\n  >>> sortedDecreasingDecreasing([1, 2, 2, 2, 2, 2, 4, 5, 6])\n  true\n  >>> sortedDecreasingDecreasing([1, 2, 2, 4, 5, 6])\n  true\n  */\nconst sortedDecreasingDecreasing = (l) => {\n  return l.every((_, i) => {\n    return l[i] <= l[i + 1] && monotonicDecreasing(l.slice(0, i + 1))\n  })\n}\n\n/*\n  Return true if values are sorted in increasing order, and\n  values are monotonic decreasing.\n  >>> sortedIncreasingDecreasing([1, 2, 3, 4, 5])\n  false\n  >>> sortedIncreasingDecreasing([1, 2, 3, 4, 5, 5])\n"}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "gc": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let common = []\n  let l1Pos = 0\n  let l2Pos = 0\n  let l1Len = l1.length\n  let l2Len = l2.length\n  while (l1Pos < l1Len && l2Pos < l2Len) {\n    if (l1[l1Pos] === l2[l2Pos]) {\n      common.push(l1[l1Pos])\n      l1Pos++\n      l2Pos++\n    } else if (l1[l1Pos] < l2[l2Pos]) {\n      l1Pos++\n    } else {\n      l2Pos++\n    }\n  }\n  return common\n}\n\nexport default common\n<|endoftext|>"}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largerPrimeFactor(13195)\n  29\n  >>> largerPrimeFactor(2048)\n  2\n  */\nconst largerPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largerPrimeFactor", "gc": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largerPrimeFactor(13195)\n  29\n  >>> largerPrimeFactor(2048)\n  2\n  */\nconst largerPrimeFactor = (n) => {\n  const num = n - 1;\n  let factor = 2;\n  let i = 0;\n\n  while (num % factor!== 0) {\n    factor++;\n  }\n\n  return factor;\n};\n\nexport default largerPrimeFactor;\n<|endoftext|>"}
{"task_id": "JavaScript/60", "prompt": "/*sumsToN is a function that sums numbers from 1 to n.\n  >>> sumsToN(30)\n  465\n  >>> sumsToN(100)\n  5050\n  >>> sumsToN(5)\n  15\n  >>> sumsToN(10)\n  55\n  >>> sumsToN(1)\n  1\n  */\nconst sumsToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumsToN", "gc": "/*sumsToN is a function that sums numbers from 1 to n.\n  >>> sumsToN(30)\n  465\n  >>> sumsToN(100)\n  5050\n  >>> sumsToN(5)\n  15\n  >>> sumsToN(10)\n  55\n  >>> sumsToN(1)\n  1\n  */\nconst sumsToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  The number of prime numbers less than or equal to n.\n  >>> primesToN(30)\n  4\n  >>> primesToN(100)\n  10\n  >>> primesToN(1)\n  0\n  >>> primesToN(5)\n  2\n  >>> primesToN(10)\n  5\n  */\nconst primesToN = (n) => {\n  const primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (primes.indexOf(i) === -1) {\n      primes.push(i);\n    }\n  }\n  return primes.length;\n};\n\n/*\n  Sum of squares to a number.\n  >>> squaresToN(30)\n  162500\n  >>> squaresToN(100)\n  87600\n  >>> squaresToN(1)\n  0\n  >>> squaresToN(5)\n  25\n  >>> squaresToN(10)\n  55\n  */\nconst squaresToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n/*\n  Finds the nth prime number.\n  >>> nthPrime(0)\n  0\n  >>> nthPrime(1)\n  2\n  >>> nthPrime(2)\n  3\n  >>> nthPrime(3)\n  5\n  >>> nthPrime(4)\n  7\n  >>> nthPrime(5)\n  11\n  >>> nthPrime(6)\n  13\n  >>> nthPrime(7)\n  17\n  >>> nthPrime(8)\n  19\n  >>> nthPrime(9)\n  23\n  >>> nthPrime(10)\n  31\n  >>> nthPrime(11)\n  33\n  >>> nthPrime(12)\n  37\n  >>> nthPrime(13)\n  41\n  >>> nthPrime(14)\n  43\n  >>> nthPrime(15)\n  47\n  >>> nthPrime(16)\n  49\n  >>> nthPrime(17)\n  53\n  >>> nthPrime(18)\n  59\n  >>> nthPrime(19)\n  67\n  >>> nthPrime(20)\n  71\n  >>> nthPrime(21)\n  73\n  >>> nthPrime(22)\n  79\n  >>> nthPrime(23)\n  83\n  >>> nthPrime(24)\n  89\n  >>> nthPrime(25)\n  97\n  >>> nthPrime(26)\n  101\n  >>> nthPrime(27)\n  103\n  >>> nthPrime(28)\n  107\n  >>> nthPrime(29)\n  109\n  >>> nthPrime(30)\n  113\n  >>> nthPrime(31)\n  127\n  >>> nthPrime(32)\n  131\n  >>> nthPrime(33)\n  137\n  >>> nthPrime(34)\n  139\n  >>> nthPrime(35)\n  143\n  >>> nthPrime(36)\n  147\n  >>> nthPrime(37)\n  151\n  >>> nthPrime(38)\n  157\n  >>> nthPrime(39)\n  163\n  >>> nthPrime(40)\n  167\n  >>> nthPrime(41)\n  173\n  >>> nthPrime(42)\n  179\n  >>> nthPrime(43)\n  181\n  >>> nthPrime(44)\n  191\n  >>> nthPrime(45)\n  193\n  >>> nthPrime(46)\n  197\n  >>> nthPrime(47)\n  199\n  >>> nthPrime(48)\n  211\n  >>> nthPrime(49)\n  223\n  >>> nthPrime(50)\n  227\n  >>> nthPrime(51)\n  229\n  >>> nthPrime(52)\n  233\n  >>> nthPrime(53)\n  239\n  >>> nthPrime(54)\n  241\n  >>> nthPrime(55)\n  251\n  >>> nthPrime(56)\n  257\n  >>> nthPrime(57)\n  263\n  >>> nthPrime(58)\n  269\n  >>> nthPrime(59)\n  271\n  >>> nthPrime(60)\n  277\n  >>> nthPrime(61)\n  281\n  >>> nthPrime(62)\n  283\n  >>> nthPrime(63)\n  293\n  >>> nthPrime(64)\n  307\n  >>> nthPrime(65)\n  311\n  >>> nthPrime(66)\n  313\n  >>> nthPrime(67)\n  317\n  >>> nthPrime(68)\n  331\n  >>> nthPrime(69)\n  337\n  >>> nthPrime(70)\n  347\n  >>> nthPrime(71)\n  349\n  >>> nthPrime(72)\n  353\n  >>> nthPrime(73)\n  359\n  >>> nthPrime(74)\n  373\n  >>> nthPrime(75)\n  379\n  >>> nthPrime(76)\n  383\n  >>> nthPrime(77)\n  389\n  >>> nthPrime(78)\n  397\n  >>> nthPrime(79)\n  401\n  >>> nthPrime(80)\n  409\n  >>> nthPrime(81)\n  419\n  >>> nthPrime(82)\n  421\n  >>> nthPrime(83)\n  431\n  >>> nthPrime(84)\n  433\n  >>> nthPrime(85)\n  439\n  >>> nthPrime(86)\n  443\n  >>> nthPrime(87)\n  449\n  >>> nthPrime(88)\n  457\n  >>> nthPrime(89)\n  461\n  >>> nthPrime(90)\n  463\n  >>> nthPrime(91)"}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "gc": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  if (brackets === '') {\n    return true\n  }\n\n  let open = 1\n  let closed = 1\n\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === '(') {\n      open += 1\n    } else if (brackets[i] === ')') {\n      closed += 1\n    } else {\n      return false\n    }\n  }\n\n  return open === closed\n}\n\n/*\n  >>> bracketsAreValid(\")(\")\n  false\n  >>> bracketsAreValid(\"(\")\n  true\n  >>> bracketsAreValid(\"()\")\n  true\n  >>> bracketsAreValid(\"(())\")\n  true\n  >>> bracketsAreValid(\")(\")\n  false\n  */\nconst bracketsAreValid = (brackets) => {\n  if (brackets === '') {\n    return true\n  }\n\n  let open = 1\n  let closed = 1\n\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === '(') {\n      open += 1\n    } else if (brackets[i] === ')') {\n      closed += 1\n    }\n  }\n\n  return open === closed\n}\n\n/*\n  >>> isValid(\")(\")\n  false\n  >>> isValid(\"(\")\n  true\n  >>> isValid(\"()\")\n  true\n  >>> isValid(\"(())\")\n  true\n  >>> isValid(\")\")\n  false\n  */\nconst isValid = (brackets) => {\n  if (brackets === '') {\n    return true\n  }\n\n  let open = 1\n  let closed = 1\n\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === '(') {\n      open += 1\n    } else if (brackets[i] === ')') {\n      closed += 1\n    } else {\n      return false\n    }\n  }\n\n  return open === closed\n}\n\nconst isValid2 = (brackets) => {\n  if (brackets === '') {\n    return true\n  }\n\n  let open = 1\n  let closed = 1\n\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === '(') {\n      open += 1\n    } else if (brackets[i] === ')') {\n      closed += 1\n    } else {\n      return false\n    }\n  }\n\n  return open === closed\n}\n\n/*\n  >>> isValid2(\")(\")\n  false\n  >>> isValid2(\"(\")\n  true\n  >>> isValid2(\"()\")\n  true\n  >>> isValid2(\"(())\")\n  true\n  >>> isValid2(\")(\")\n  false\n  */\n\n/*\n  >>> bracketsAreBalanced(\")(\")\n  false\n  >>> bracketsAreBalanced(\"(\")\n  true\n  >>> bracketsAreBalanced(\"()\")\n  true\n  >>> bracketsAreBalanced(\"(())\")\n  true\n  >>> bracketsAreBalanced(\")\")\n  false\n  */\nconst bracketsAreBalanced = (brackets) => {\n  if (brackets === '') {\n    return true\n  }\n\n  let open = 1\n  let closed = 1\n\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === '(') {\n      open += 1\n    } else if (brackets[i] === ')') {\n      closed += 1\n    } else {\n      return false\n    }\n  }\n\n  return open === closed\n}\n\n/*\n  >>> bracketsAreBalanced(\")(\")\n  false\n  >>> bracketsAreBalanced(\"(\")\n  true\n  >>> bracketsAreBalanced(\"()\")\n  true\n  >>> bracketsAreBalanced(\"(())\")\n  true\n  >>> bracketsAreBalanced(\")\")\n  false\n  */\n\n/*\n  >>> isBalanced(\")(\")\n  false\n  >>> isBalanced(\"(\")\n  true\n  >>> isBalanced(\"()\")\n  true\n  >>> isBalanced(\"(())\")\n  true\n  >>> isBalanced(\")\")\n  false\n  */\n\nconst isBalanced = (brackets) => {\n  if (brackets === '') {\n    return true\n  }\n\n  let open = 1\n  let closed = 1\n\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === '(') {\n      open += 1\n    } else if (brackets[i] === ')') {\n      closed += 1\n    } else {\n      return false\n    }\n  }\n\n  return open === closed\n}\n\n/*\n  >>> isBalanced(\")(\")\n  false\n  >>> isBalanced(\"(\")\n  true\n  >>> isBalanced(\"()\")\n  true\n  >>> isBalanced(\"(())\")\n  true\n  >>> isBalanced(\")\")\n  false\n  */\n\n/*\n  >>> bracketsAreWellFormed(\")()\")\n  false\n  >>> bracketsAreWellFormed(\"()\")\n  true\n  >>> bracketsAreWellFormed(\"()())\")\n  true\n  >>> bracketsAreWellFormed(\"())\")\n  false\n  >>> bracketsAreWellFormed(\"(())\")\n  false\n  >>> bracketsAreWellFormed(\"(())\")\n  true\n  >>> bracketsAreWellFormed(\")()\")\n  false\n  >>> bracketsAreWellFormed(\")()\")\n  true\n  >>> bracketsAreWellFormed(\"())()\")\n  true\n  >>> bracketsAreWellFormed(\"()())\")\n  true\n  >>> bracketsAreWellFormed(\"()()\")\n  false\n  >>> bracketsAreWellFormed(\"()\")\n  false\n  >>> bracketsAreWellFormed(\"()())\")\n  true\n  >>> bracketsAreWellFormed(\"()())\")\n  true\n  >>> bracketsAreWellFormed(\"()())\")\n  true\n  >>> bracketsAreWellFormed(\"()()\")\n  false\n  */\n"}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "gc": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let derivative = xs[0];\n  for (let i = 1; i < xs.length; i++) {\n    derivative = derivative + xs[i] * (xs[i] - xs[i - 1]);\n  }\n  return derivative;\n};\n\n/*\n  Let xs represent coefficients of a polynomial.\n  Return the total of these polynomials.\n  >>> sum([3, 1, 2, 4, 5])\n  26\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([4, 2, 3, 1])\n  0\n  */\nconst sum = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum = sum + xs[i];\n  }\n  return sum;\n};\n\n/*\n  Let xs represent coefficients of a polynomial.\n  Let ys represent coefficients of a polynomial.\n  Return the product of these two polynomials.\n  >>> product([3, 1, 2, 4, 5], [2, 3, 4, 1, 2])\n  [3, 4, 15, 4, 8]\n  >>> product([1, 2, 3], [4, 2, 3, 1])\n  [4, 12]\n  >>> product([3, 1, 2, 4, 5], [4, 2, 3, 1])\n  [4, 12]\n  */\nconst product = (xs, ys) => {\n  let product = [];\n  for (let i = 0; i < xs.length; i++) {\n    for (let j = 0; j < ys.length; j++) {\n      product[i + j] = xs[i] * ys[j];\n    }\n  }\n  return product;\n};\n\n/*\n  Let xs represent coefficients of a polynomial.\n  Let ys represent coefficients of a polynomial.\n  Return the quotient of these two polynomials.\n  >>> quotient([3, 1, 2, 4, 5], [2, 3, 4, 1, 2])\n  [4, 1, 2]\n  >>> quotient([3, 1, 2, 4, 5], [4, 2, 3, 1])\n  [1, 1, 1]\n  >>> quotient([1, 2, 3], [4, 2, 3, 1])\n  [0]\n  */\nconst quotient = (xs, ys) => {\n  let quotient = [];\n  for (let i = 0; i < xs.length; i++) {\n    quotient[i] = xs[i] / ys[i];\n  }\n  return quotient;\n};\n\n// Run the tests\ndescribe(\"Polynomial\", function () {\n  describe(\"evaluate\", function () {\n    it(\"should return the result of evaluating the polynomial with the given value\", function () {\n      expect(evaluate([3, 1, 2, 4, 5], 4)).toBe(26);\n    });\n  });\n\n  describe(\"derivative\", function () {\n    it(\"should return the derivative of the polynomial\", function () {\n      expect(derivative([3, 1, 2, 4, 5])).toEqual([1, 4, 12, 20]);\n    });\n  });\n\n  describe(\"sum\", function () {\n    it(\"should return the total of the given polynomials\", function () {\n      expect(sum([3, 1, 2, 4, 5])).toBe(26);\n    });\n  });\n\n  describe(\"product\", function () {\n    it(\"should return the product of the given polynomials\", function () {\n      expect(product([3, 1, 2, 4, 5], [2, 3, 4, 1, 2])).toEqual([3, 4, 15, 4, 8]);\n    });\n  });\n\n  describe(\"quotient\", function () {\n    it(\"should return the quotient of the given polynomials\", function () {\n      expect(quotient([3, 1, 2, 4, 5], [2, 3, 4, 1, 2])).toEqual([4, 1, 2]);\n    });\n  });\n});\n<|endoftext|>"}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "gc": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n/*The FibSeq number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibseq(0) == 0\n  fibseq(1) == 0\n  fibseq(2) == 1\n  fibseq(n) == fibseq(n-1) + fibseq(n-2) + fibseq(n-3).\n  Please write a function to efficiently compute the n-th element of the fibseq number sequence.\n  >>> fibseq(1)\n  0\n  >>> fibseq(5)\n  4\n  >>> fibseq(8)\n  24\n  */\nconst fibseq = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibseq(n - 1) + fibseq(n - 2) + fibseq(n - 3);\n}\n\n/*The FibSeq2 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibseq2(0) == 0\n  fibseq2(1) == 0\n  fibseq2(2) == 1\n  fibseq2(n) == fibseq2(n-1) + fibseq2(n-2) + fibseq2(n-3).\n  Please write a function to efficiently compute the n-th element of the fibseq2 number sequence.\n  >>> fibseq2(1)\n  0\n  >>> fibseq2(5)\n  4\n  >>> fibseq2(8)\n  24\n  */\nconst fibseq2 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibseq2(n - 1) + fibseq2(n - 2) + fibseq2(n - 3);\n}\n\n/*The FibSeq3 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibseq3(0) == 0\n  fibseq3(1) == 0\n  fibseq3(2) == 1\n  fibseq3(n) == fibseq3(n-1) + fibseq3(n-2) + fibseq3(n-3).\n  Please write a function to efficiently compute the n-th element of the fibseq3 number sequence.\n  >>> fibseq3(1)\n  0\n  >>> fibseq3(5)\n  4\n  >>> fibseq3(8)\n  24\n  */\nconst fibseq3 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibseq3(n - 1) + fibseq3(n - 2) + fibseq3(n - 3);\n}\n\n/*The FibSeq4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibseq4(0) == 0\n  fibseq4(1) == 0\n  fibseq4(2) == 1\n  fibseq4(n) == fibseq4(n-1) + fibseq4(n-2) + fibseq4(n-3).\n  Please write a function to efficiently compute the n-th element of the fibseq4 number sequence.\n  >>> fibseq4(1)\n  0\n  >>> fibseq4(5)\n  4\n  >>> fibseq4(8)\n  24\n  */\nconst fibseq4 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibseq4(n - 1) + fibseq4(n - 2) + fibseq4(n - 3);\n}\n\n/*The FibSeq5 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibseq5(0) == 0\n  fibseq5(1) == 0\n  fibseq5(2) == 1\n  fibseq5(n) == fibseq5(n-1) + fibseq5(n-2) + fibseq5(n-3).\n  Please write a function to efficiently compute the n-th element of the fibseq5 number sequence.\n  >>> fibseq5(1)\n  0\n  >>> fibseq5(5)\n  4\n  >>> fibseq5(8)\n  24\n  */\nconst fibseq5 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibseq5(n - 1) + fibseq5(n - 2) + fibseq5(n - 3);\n}\n\n/*The FibSeq6 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibseq6(0) == 0\n  fibseq6(1) == 0\n  fibseq6(2) == 1\n  fibseq6(n) == fibseq6(n-1) + fibseq6(n-2) + fibseq6(n-3).\n  Please write a function to efficiently compute the n-th element of the fibseq6 number sequence.\n  >>> fibseq6(1)\n  0\n  >>> fibseq6(5)\n  4\n  >>> fibseq6(8)\n  24\n  */\nconst fibseq6 = (n) => {\n  if (n <= 1) {\n    return n;\n  }\n  return fibseq6(n - 1) + fibseq6(n - 2) + fibseq6(n - 3);\n}\n\n/*The FibSeq7 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibseq7(0"}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelCount(\"abcde\")\n  2\n  >>> vowelCount(\"ACEDY\")\n  3\n  */\nconst vowelCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelCount", "gc": "/*Write a function vowelCount which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelCount(\"abcde\")\n  2\n  >>> vowelCount(\"ACEDY\")\n  3\n  */\nconst vowelCount = (s) => {\n  let count = 0\n  let vowel = /[AEIOU]/\n  for (let i = 0; i < s.length - 1; i++) {\n    if (vowel.test(s[i])) {\n      count++\n    }\n  }\n  if (vowel.test(s[s.length - 1])) {\n    count++\n  }\n  return count\n}\n\n/*Write a function allVowels which takes a string representing a word as input\n  and returns a boolean stating whether all the vowels are in the string.\n\n  Example:\n  >>> allVowels(\"abcde\")\n  False\n  >>> allVowels(\"ABCDE\")\n  True\n  */\nconst allVowels = (s) => {\n  let count = 0\n  let vowel = /[AEIOU]/\n  for (let i = 0; i < s.length; i++) {\n    if (vowel.test(s[i])) {\n      count++\n    }\n  }\n  return count === s.length\n}\n\n/*Write a function stringCount which takes a string representing a word as input\n  and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u' and 'y'.\n\n  Example:\n  >>> stringCount(\"abcde\")\n  2\n  >>> stringCount(\"ACEDY\")\n  3\n  */\nconst stringCount = (s) => {\n  let count = 0\n  let vowel = /[AEIOUY]/\n  for (let i = 0; i < s.length - 1; i++) {\n    if (vowel.test(s[i])) {\n      count++\n    }\n  }\n  if (vowel.test(s[s.length - 1])) {\n    count++\n  }\n  return count\n}\n\n/*Write a function wordLength which takes a string representing a word as input\n  and returns the number of characters in the word.\n\n  Example:\n  >>> wordLength(\"abc\")\n  3\n  >>> wordLength(\"abcde\")\n  5\n  >>> wordLength(\"aaaaa\")\n  6\n  */\nconst wordLength = (s) => s.length\n\n/*Write a function removeVowels which takes a string representing a word as input\n  and returns the string with all the vowels removed.\n\n  Example:\n  >>> removeVowels(\"abcde\")\n  \"bcd\"\n  >>> removeVowels(\"ACEDY\")\n  \"ACY\"\n  */\nconst removeVowels = (s) => s.replace(/[AEIOUY]/g, '')\n\n/*Write a function isPalindrome which takes a string representing a word as input\n  and returns a boolean stating whether the word is a palindrome.\n\n  Example:\n  >>> isPalindrome(\"abcde\")\n  False\n  >>> isPalindrome(\"ABCDE\")\n  True\n  >>> isPalindrome(\"aaaaa\")\n  False\n  */\nconst isPalindrome = (s) => s === removeVowels(s)\n\n/*Write a function getVowels which takes a string representing a word as input\n  and returns a list of all the vowels in the word.\n\n  Example:\n  >>> getVowels(\"abcde\")\n  ['a', 'e', 'i', 'o', 'u', 'y']\n  >>> getVowels(\"ACEDY\")\n  ['A', 'E', 'I', 'O', 'U', 'Y']\n  */\nconst getVowels = (s) => s.split('')\n\n/*Write a function reverse which takes a string representing a word as input\n  and returns the string reversed.\n\n  Example:\n  >>> reverse(\"abcde\")\n  \"edcb\"\n  >>> reverse(\"ABCDE\")\n  \"EDCB\"\n  */\nconst reverse = (s) => s.split('').reverse().join('')\n\n/*Write a function isPermutation which takes two strings representing two words\n  as input and returns a boolean stating whether the two words are permutations\n  of each other.\n\n  Example:\n  >>> isPermutation(\"abcde\", \"ABDEE\")\n  True\n  >>> isPermutation(\"abcde\", \"ABDEE\")\n  True\n  >>> isPermutation(\"abcde\", \"ABDEE\")\n  False\n  >>> isPermutation(\"ABDEE\", \"abcde\")\n  True\n  */\nconst isPermutation = (a, b) => a === reverse(b)\n\n/*Write a function isReflection which takes two strings representing two words\n  as input and returns a boolean stating whether the two words reflect each other.\n\n  Example:\n  >>> isReflection(\"abcde\", \"AEBDC\")\n  True\n  >>> isReflection(\"abcde\", \"AEBDC\")\n  True\n  >>> isReflection(\"ABCDE\", \"aeBdc\")\n  True\n  >>> isReflection(\"abcde\", \"ABCDE\")\n  False\n  */\nconst isReflection = (a, b) => a === reverse(b)\n\n/*Write a function isSymmetry which takes two strings representing two words\n  as input and returns a boolean stating whether the two words are symmetrical.\n\n  Example:\n  >>> isSymmetry(\"abcde\", \"ABDEE\")\n  False\n  >>> isSymmetry(\"ABCDE\", \"aeBdc\")\n  False\n  >>> isSymmetry(\"abcde\", \"ABCDE\")\n  True\n  */\nconst isSymmetry = (a, b) => a === reverse(b) && b === reverse(a)\n\n/*Write a function isReflection which takes two strings representing two words\n  as input and returns a boolean stating whether the two words reflect each other.\n\n  Example:\n  >>> isReflection(\"abcde\", \"AEBDC\")\n  True\n  >>> isReflection(\"ABCDE\", \"aeBdc\")\n  True\n  >>> isReflection(\"abcde\", \""}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "gc": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const n = x.toString().length\n  if (shift >= n) {\n    return x.toString().split('').reverse().join('')\n  } else {\n    return x.toString().split('').reverse().join('')\n  }\n}\n\n/*Given a list of strings, return the list sorted in reverse alphabetical order.\n  If two items are identical, they are sorted based on their first character.\n  >>> sortList([\"Java\", \"javascript\", \"Python\", \"python\"])\n  [\"javascript\", \"Java\", \"Python\", \"python\"]\n  >>> sortList([\"Java\", \"python\", \"javascript\"])\n  [\"Java\", \"javascript\", \"python\"]\n  >>> sortList([\"python\", \"javascript\", \"Java\"])\n  [\"Java\", \"javascript\", \"python\"]\n  */\nconst sortList = (list) => list.sort((a, b) => a.localeCompare(b))\n\n/*Given a string, return a new string where the first letter of each word\n  is lowercase.\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  */\nconst lowercase = (string) => string.toLowerCase()\n\n/*Given a string, return a new string where each word is made of letters\n  that are in upper case.\n  >>> uppercase(\"JavaScript\")\n  \"JAVASCRIPT\"\n  >>> uppercase(\"JavaScript\")\n  \"JAVASCRIPT\"\n  */\nconst uppercase = (string) => string.toUpperCase()\n\n/*Given a string, return a new string where each word is made of letters\n  that are in lower case.\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  */\nconst lowercase = (string) => string.toLowerCase()\n\n/*Given a string, return a new string where each letter is made of the\n  characters from a given string.\n  >>> replace(\"JavaScript\", \"JS\", \"C\")\n  \"CSCRIPT\"\n  >>> replace(\"JavaScript\", \"JS\", \"C\")\n  \"CSCRIPT\"\n  >>> replace(\"JavaScript\", \"JS\", \"C\")\n  \"CSCRIPT\"\n  */\nconst replace = (string, from, to) => string.replace(from, to)\n\n/*Given a string, return a new string where all the letters are replaced by\n  uppercase.\n  >>> replace(\"JavaScript\", \"JS\", \"C\")\n  \"CSCRIPT\"\n  >>> replace(\"JavaScript\", \"JS\", \"C\")\n  \"CSCRIPT\"\n  >>> replace(\"JavaScript\", \"JS\", \"C\")\n  \"CSCRIPT\"\n  */\nconst replace = (string, from, to) => string.replace(from, to)\n\n/*Given a string, return a new string where all the letters are replaced by\n  lowercase.\n  >>> replace(\"JavaScript\", \"JS\", \"C\")\n  \"CSCRIPT\"\n  >>> replace(\"JavaScript\", \"JS\", \"C\")\n  \"CSCRIPT\"\n  >>> replace(\"JavaScript\", \"JS\", \"C\")\n  \"CSCRIPT\"\n  */\nconst replace = (string, from, to) => string.replace(from, to)\n\n/*Given a string, return a new string where all the words are replaced by\n  the word given as parameter.\n  >>> replace(\"JavaScript\", \"JS\", \"C\")\n  \"CSCRIPT\"\n  >>> replace(\"JavaScript\", \"JS\", \"C\")\n  \"CSCRIPT\"\n  >>> replace(\"JavaScript\", \"JS\", \"C\")\n  \"CSCRIPT\"\n  */\nconst replace = (string, from, to) => string.replace(from, to)\n\n/*Given a string, return a new string where the first character of each word\n  is lowercase.\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  */\nconst lowercase = (string) => string.toLowerCase()\n\n/*Given a string, return a new string where the first character of each word\n  is uppercase.\n  >>> uppercase(\"JavaScript\")\n  \"JAVASCRIPT\"\n  >>> uppercase(\"JavaScript\")\n  \"JAVASCRIPT\"\n  >>> uppercase(\"JavaScript\")\n  \"JAVASCRIPT\"\n  */\nconst uppercase = (string) => string.toUpperCase()\n\n/*Given a string, return a new string where the first character of each word\n  is lowercase.\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  */\nconst lowercase = (string) => string.toLowerCase()\n\n/*Given a string, return a new string where the first character of each word\n  is uppercase.\n  >>> uppercase(\"JavaScript\")\n  \"JAVASCRIPT\"\n  >>> uppercase(\"JavaScript\")\n  \"JAVASCRIPT\"\n  >>> uppercase(\"JavaScript\")\n  \"JAVASCRIPT\"\n  */\nconst uppercase = (string) => string.toUpperCase()\n\n/*Given a string, return a new string where the first character of each word\n  is lowercase.\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  >>> lowercase(\"JavaScript\")\n  \"java script\"\n  */\nconst lowercase = (string) => string.toLowerCase()\n\n/*Given a string, return a new string where the first character of each word\n  is uppercase.\n  >>> uppercase(\"JavaScript\")\n  \"JAVASCRIPT\"\n  >>> uppercase(\"JavaScript\")\n  \"JAVASCRIPT\"\n  >>> uppercase(\"JavaScript\")\n  \"JAVASCRIPT\"\n  */\nconst uppercase = (string)"}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSums", "gc": "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSums(\"\") => 0\n      digitSums(\"abAB\") => 131\n      digitSums(\"abcCd\") => 67\n      digitSums(\"helloE\") => 69\n      digitSums(\"woArBld\") => 131\n      digitSums(\"aAaaaXa\") => 153\n  */\nconst digitSums = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] > 57 && s[i] < 91) sum += s[i] - 55;\n    else if (s[i] > 96 && s[i] < 123) sum += s[i] - 87;\n  }\n  return sum;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "gc": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const nApples = s.match(/\\d+/g)[0];\n  const nOranges = s.match(/\\d+/g)[1];\n  const nMango = n - nApples - nOranges;\n  return nMango;\n};\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges\", 19));\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\", 3));\nconsole.log(fruitDistribution(\"2 apples and 3 oranges\", 100));\nconsole.log(fruitDistribution(\"100 apples and 1 oranges\", 120));\n<|endoftext|>"}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "gc": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const nodes = arr.slice(0)\n  const tree = buildTree(nodes)\n  const result = pluck(tree)\n  return result\n}\n\nfunction buildTree (nodes) {\n  const tree = []\n  const min = nodes.reduce((a, b) => {\n    return a < b? a : b\n  })\n  const max = nodes.reduce((a, b) => {\n    return a > b? a : b\n  })\n  const root = nodes.reduce((a, b) => {\n    return a + b\n  })\n  nodes.forEach(node => {\n    if (node < min) {\n      tree.unshift(node)\n    } else if (node > max) {\n      tree.push(node)\n    } else {\n      tree.push(root)\n    }\n  })\n  return tree\n}\n\nfunction pluck (tree) {\n  const even = [].concat(tree).reduce((a, b) => {\n    return a + b\n  }, 0)\n  if (even === 0) {\n    return []\n  }\n  const min = tree.reduce((a, b) => {\n    return a < b? a : b\n  })\n  const max = tree.reduce((a, b) => {\n    return a > b? a : b\n  })\n  const index = tree.indexOf(min)\n  const result = [min, index]\n  if (index === 0 && min % 2 === 0) {\n    return result\n  }\n  if (index === tree.length - 1 && max % 2 === 0) {\n    return result\n  }\n  return [min, index]\n}\n<|endoftext|>"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "gc": "/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n    const len = lst.length\n    const sorted = lst.sort((a, b) => a - b)\n    let low = 1\n    let high = len\n    while (low < high) {\n        const mid = (low + high) >> 1\n        const midVal = sorted[mid]\n        if (midVal === 0) {\n            high = mid\n        } else if (midVal > 0) {\n            low = mid + 1\n        } else {\n            high = mid\n        }\n    }\n    return sorted[low]\n}\n\nconsole.log(search([4, 1, 2, 2, 3, 1]))\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]))\nconsole.log(search([5, 5, 4, 4, 4]))\n<|endoftext|>"}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangerSortsLists", "gc": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangerSortsLists([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangerSortsLists([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangerSortsLists([]) == []\n  */\nconst strangerSortsLists = (lst) => {\n    let arr = lst.slice();\n    let min = arr[0];\n    let max = arr[0];\n\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n\n    arr.sort((a, b) => a - b);\n\n    arr.push(min);\n    arr.push(max);\n\n    return arr;\n};\n\nmodule.exports = strangerSortsLists;\n<|endoftext|>"}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  trianglesAreas(3, 4, 5) == 6.00\n  trianglesAreas(1, 2, 10) == -1\n  */\nconst trianglesAreas = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "trianglesAreas", "gc": "/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  trianglesAreas(3, 4, 5) == 6.00\n  trianglesAreas(1, 2, 10) == -1\n  */\nconst trianglesAreas = (a, b, c) => {\n  if (a + b > c && b + c > a && a + c > b) {\n    return (Math.round((a + b + c) / 2 * 100) / 100)\n  }\n  return -1\n}\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlied([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlied([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlied([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlied = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFlied", "gc": "/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlied([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlied([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlied([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlied = (q, w) => {\n  const l = q.length;\n  const max = w;\n  if (l === 0) return false;\n  if (l === 1) return true;\n  if (l === 2) return q[0] === q[1];\n  if (l === 3) return q[0] + q[1] === q[2];\n  const n = q[l - 1];\n  const m = q[l - 2];\n  const p = q[l - 3];\n  const sum = n + m + p;\n  return sum <= max && (n === p && m === n) || (n === p && m === m) || (n === m && p === n);\n};\n\nconst willItFlied2 = (q, w) => {\n  const l = q.length;\n  const max = w;\n  if (l === 0) return false;\n  if (l === 1) return true;\n  if (l === 2) return q[0] === q[1];\n  if (l === 3) return q[0] + q[1] === q[2];\n  const n = q[l - 1];\n  const m = q[l - 2];\n  const p = q[l - 3];\n  const sum = n + m + p;\n  return sum <= max && (n === p && m === n) || (n === p && m === m) || (n === m && p === n);\n};\n\nconst isPalindrome = (n) => {\n  if (n.length === 1) return true;\n  return n[0] === n[n.length - 1] && isPalindrome(n.slice(1, n.length - 1));\n};\n\nconst willItFlied3 = (q, w) => {\n  const l = q.length;\n  const max = w;\n  if (l === 0) return false;\n  if (l === 1) return true;\n  if (l === 2) return q[0] === q[1];\n  if (l === 3) return q[0] + q[1] === q[2];\n  const n = q[l - 1];\n  const m = q[l - 2];\n  const p = q[l - 3];\n  const sum = n + m + p;\n  return sum <= max && (n === p && m === n) || (n === p && m === m) || (n === m && p === n);\n};\n\nconst willItFlied4 = (q, w) => {\n  const l = q.length;\n  const max = w;\n  if (l === 0) return false;\n  if (l === 1) return true;\n  if (l === 2) return q[0] === q[1];\n  if (l === 3) return q[0] + q[1] === q[2];\n  const n = q[l - 1];\n  const m = q[l - 2];\n  const p = q[l - 3];\n  const sum = n + m + p;\n  return sum <= max && (n === p && m === n) || (n === p && m === m) || (n === m && p === n);\n};\n\nconst willItFlied5 = (q, w) => {\n  const l = q.length;\n  const max = w;\n  if (l === 0) return false;\n  if (l === 1) return true;\n  if (l === 2) return q[0] === q[1];\n  if (l === 3) return q[0] + q[1] === q[2];\n  const n = q[l - 1];\n  const m = q[l - 2];\n  const p = q[l - 3];\n  const sum = n + m + p;\n  return sum <= max && (n === p && m === n) || (n === p && m === m) || (n === m && p === n);\n};\n\nconst willItFlied6 = (q, w) => {\n  const l = q.length;\n  const max = w;\n  if (l === 0) return false;\n  if (l === 1) return true;\n  if (l === 2) return q[0] === q[1];\n  if (l === 3) return q[0] + q[1] === q[2];\n  const n = q[l - 1];\n  const m = q[l - 2];\n  const p = q[l - 3];\n  const sum = n + m + p;\n  return sum <= max && (n === p && m === n) || (n === p && m === m) || (n === m && p === n);\n};\n\nconst willItFlied7 = (q, w) => {\n  const l = q.length;\n  const max = w;\n  if (l === 0) return false;\n  if (l === 1) return true;\n  if (l === 2) return q[0] === q[1];\n  if (l === 3) return q[0] + q[1] === q[2];\n  const n = q[l - 1];\n  const m = q[l - 2];\n  const p = q[l - 3];\n  const sum = n + m + p;\n  return sum <= max && (n === p && m === n) || (n === p && m === m) || (n === m && p === n);\n};\n\nconst willItFlied8 = (q, w) => {\n  const l = q."}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallerChange([1,2,3,5,4,7,9,6]) == 4\n  smallerChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallerChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallerChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallerChange", "gc": "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallerChange([1,2,3,5,4,7,9,6]) == 4\n  smallerChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallerChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallerChange = (arr) => {\n    if (!arr) return 0;\n    const len = arr.length;\n    let min = len;\n    let left = 0;\n    let right = len - 1;\n    while (left <= right) {\n        let mid = (left + right) / 2;\n        if (isPalindrome(arr, mid)) {\n            min = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return min;\n}\n\nconst isPalindrome = (arr, i) => {\n    let left = i;\n    let right = arr.length - i - 1;\n    while (left < right) {\n        if (arr[left]!== arr[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}\n\nexport default smallerChange;\n<|endoftext|>"}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "gc": "/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  return lst1.length === lst2.length? lst1 : lst1.concat(lst2.filter((el) => lst1.length > el.length));\n};\n\nmodule.exports = totalMatch;\n<|endoftext|>"}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "gc": "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a % 2 === 0) {\n    return false;\n  }\n  let c = 3;\n  while (c < a) {\n    if (a % c === 0) {\n      return false;\n    }\n    c += 2;\n  }\n  return true;\n};\n\nconst isMultiplyPrime2 = (a) => {\n  let c = 3;\n  while (c < a) {\n    if (a % c === 0) {\n      return false;\n    }\n    c += 2;\n  }\n  return true;\n};\n\nconst isPrime = (a) => {\n  if (a === 2 || a === 3) {\n    return true;\n  }\n  for (let i = 2; i < Math.sqrt(a); i++) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrimeFast = (a) => {\n  if (a === 2 || a === 3) {\n    return true;\n  }\n  for (let i = 2; i * i <= a; i++) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrimeFast2 = (a) => {\n  for (let i = 2; i * i <= a; i++) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime3 = (a) => {\n  if (a === 2 || a === 3) {\n    return true;\n  }\n  for (let i = 2; i * i <= a; i++) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime4 = (a) => {\n  if (a === 1) {\n    return false;\n  }\n  if (a === 2 || a === 3) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  for (let i = 3; i * i <= a; i += 2) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime5 = (a) => {\n  if (a === 1) {\n    return false;\n  }\n  if (a === 2 || a === 3) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  for (let i = 3; i * i <= a; i += 2) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime6 = (a) => {\n  if (a === 1) {\n    return false;\n  }\n  if (a === 2 || a === 3) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  for (let i = 5; i * i <= a; i += 2) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime7 = (a) => {\n  if (a === 1) {\n    return false;\n  }\n  if (a === 2 || a === 3) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  for (let i = 5; i * i <= a; i += 2) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime8 = (a) => {\n  if (a === 1) {\n    return false;\n  }\n  if (a === 2 || a === 3) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  for (let i = 7; i * i <= a; i += 2) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime9 = (a) => {\n  if (a === 1) {\n    return false;\n  }\n  if (a === 2 || a === 3) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  for (let i = 11; i * i <= a; i += 2) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime10 = (a) => {\n  if (a === 1) {\n    return false;\n  }\n  if (a === 2 || a === 3) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  for (let i = 13; i * i <= a; i += 2) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime11 = (a) => {\n  if (a === 1) {\n    return false;\n  }\n  if (a === 2 || a === 3) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  for (let i = 17; i * i <= a; i += 2) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime12 = (a) => {\n  if (a === 1) {\n    return false;\n  }\n  if (a === 2 || a === 3) {\n    return true;\n  }\n  if (a % 2 === 0) {\n    return false;\n  }\n  for (let i = 19"}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "gc": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  const xn = x * n;\n  return xn === x && (xn === n)? true : false;\n};\n\nconsole.log(isSimplePower(1, 4)); // true\nconsole.log(isSimplePower(2, 2)); // true\nconsole.log(isSimplePower(8, 2)); // true\nconsole.log(isSimplePower(3, 2)); // false\nconsole.log(isSimplePower(3, 1)); // false\nconsole.log(isSimplePower(5, 3)); // false\n<|endoftext|>"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "gc": "/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  let i = 0\n  while (i < a) {\n    if (a === Math.pow(i, 3)) {\n      return true\n    }\n    i++\n  }\n  return false\n}\n<|endoftext|>"}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexesKeys = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexesKeys", "gc": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexesKeys = (num) => {\n  const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n  const digits = num.split('');\n  let numOfDigits = 0;\n  digits.forEach((digit) => {\n    numOfDigits += parseInt(digit, 16) === parseInt(digit, 16)? 1 : 0;\n  });\n  return numOfDigits;\n};\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n < 2) {\n    return false;\n  }\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime2 = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst hexesDigits = (num) => {\n  const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n  const digits = num.split('');\n  let numOfDigits = 0;\n  digits.forEach((digit) => {\n    numOfDigits += parseInt(digit, 16) === parseInt(digit, 16)? 1 : 0;\n  });\n  return numOfDigits;\n};\n\nconst main = (num) => {\n  console.log(`${num} ===> ${hexesKeys(num)} ${isPrime(parseInt(num, 16))? 'primes' : 'not primes'}`);\n};\n\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`);\nmain(`2020`);\nmain(`ABED1A33`);\nmain(`ABCDEF1A33`);\nmain(`123456789ABCDEF0`"}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalsToBinary(15)   # returns \"db1111db\"\n  decimalsToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalsToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalsToBinary", "gc": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalsToBinary(15)   # returns \"db1111db\"\n  decimalsToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalsToBinary = (decimal) => {\n  const number = decimal || 0;\n  const binary = 'b';\n  const result = [];\n  let current = number;\n  let currentBits = 0;\n  let binaryDigits = 0;\n  let numOfBits = 0;\n\n  while (current > 0) {\n    currentBits = current % 2;\n    result.push(binary[currentBits]);\n    current = current / 2;\n    binaryDigits += 1;\n    numOfBits += 1;\n  }\n  result.push(binary[currentBits]);\n  return result.join('') + binary.slice(0, numOfBits);\n};\n\nconst binaryToDecimal = (binary) => {\n  const result = 0;\n  let current = binary;\n  let currentBits = 0;\n  let decimalDigits = 0;\n\n  while (current.length > 0) {\n    currentBits = current.slice(-1, -1) * 2;\n    result += currentBits;\n    current = current.slice(0, -1);\n    decimalDigits += 1;\n  }\n  return result;\n};\n\nexport {\n  decimalsToBinary,\n  binaryToDecimal\n};\n<|endoftext|>"}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHappiest(a) => false\n  isHappiest(aa) => false\n  isHappiest(abcd) => true\n  isHappiest(aabb) => false\n  isHappiest(adb) => true\n  isHappiest(xyy) => false\n  */\nconst isHappiest = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappiest", "gc": "/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHappiest(a) => false\n  isHappiest(aa) => false\n  isHappiest(abcd) => true\n  isHappiest(aabb) => false\n  isHappiest(adb) => true\n  isHappiest(xyy) => false\n  */\nconst isHappiest = (s) => {\n  const l = s.length\n  if (l < 3) {\n    return false\n  }\n  const arr = []\n  for (let i = 0; i < l; i += 3) {\n    const t = s.substring(i, i + 3)\n    if (arr.indexOf(t) === -1) {\n      arr.push(t)\n    }\n  }\n  if (arr.length!== 3) {\n    return false\n  }\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i - 1] === arr[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nconsole.log(isHappiest('a'))\nconsole.log(isHappiest('aa'))\nconsole.log(isHappiest('abcd'))\nconsole.log(isHappiest('aabb'))\nconsole.log(isHappiest('adb'))\nconsole.log(isHappiest('xyy'))\n<|endoftext|>"}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "gc": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const map = new Map();\n  for (const gpa of grades) {\n    map.set(gpa, gpa > 3.7? 'A' :\n      gpa > 3.3? 'A-' :\n      gpa > 2.7? 'B' :\n      gpa > 2.3? 'B-' :\n      gpa > 1.7? 'C' :\n      gpa > 1.3? 'C-' :\n      gpa > 0.7? 'D' :\n      gpa > 0.0? 'D-' :\n      'E');\n  }\n  return map.values().sort().reverse();\n};\n\nconsole.log(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]));\n<|endoftext|>"}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "gc": "/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const length = string.length\n  const num = Math.floor(Math.sqrt(length))\n  const prime = new Array(num).fill(true)\n  for (let i = 2; i < num; i++) {\n    if (prime[i]) {\n      for (let j = 2; j <= length / i; j++) {\n        if (!(length % i)) {\n          prime[j * i] = false\n        }\n      }\n    }\n  }\n  return prime.every(prime => prime)\n}\n\nconsole.log(primeLength('Hello'))\nconsole.log(primeLength('abcdcba'))\nconsole.log(primeLength('kittens'))\nconsole.log(primeLength('orange'))\n<|endoftext|>"}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startOneEnds", "gc": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startOneEnds = (n) => {\n  let start = 0\n  let ends = 0\n\n  // Counting the starting ones\n  for (let i = 1; i <= n; i++) {\n    if (i % 10 === 1) {\n      start += 1\n    }\n  }\n\n  // Counting the ending ones\n  for (let i = n; i >= 1; i--) {\n    if (i % 10 === 1) {\n      ends += 1\n    }\n  }\n\n  return start + ends\n}\n\nconsole.log(startOneEnds(20))\n<|endoftext|>"}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "gc": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve2 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve3 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve4 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve5 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve6 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve7 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve8 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve9 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve10 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve11 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve12 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve13 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve14 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve15 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve16 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve17 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve18 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve19 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve20 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve21 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve22 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve23 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve24 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve25 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve26 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        N = N / 2;\n    }\n    return sum;\n};\n\nconst solve27 = (N) => {\n    let sum = 0;\n    while (N > 0) {\n        sum += N % 2;\n        "}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. adding the even elements that are at odd indices..\n\n\n  Examples:\n      adding([4, 2, 6, 7]) ==> 2 \n  */\nconst adding = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "adding", "gc": "/*Given a non-empty list of integers lst. adding the even elements that are at odd indices..\n\n\n  Examples:\n      adding([4, 2, 6, 7]) ==> 2 \n  */\nconst adding = (lst) => {\n    let result = 0;\n    for (let i = 0; i < lst.length; i++) {\n        result += lst[i];\n        if (i % 2 == 0) {\n            result -= lst[i];\n        }\n    }\n    return result;\n};\n\n// adding([4, 2, 6, 7]) ==> 2\n\nconsole.log(adding([4, 2, 6, 7]));\n\n// adding([1, 2, 3, 4, 5]) ==> 10\n\nconsole.log(adding([1, 2, 3, 4, 5]));\n\n// adding([5, 4, 3, 2, 1]) ==> 5\n\nconsole.log(adding([5, 4, 3, 2, 1]));\n\n// adding([9, 8, 7, 6, 5, 4, 3, 2, 1]) ==> 10\n\nconsole.log(adding([9, 8, 7, 6, 5, 4, 3, 2, 1]));<|endoftext|>"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antisShuffles('Hi') returns 'Hi'\n  antisShuffles('hello') returns 'ehllo'\n  antisShuffles('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antisShuffles = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antisShuffles", "gc": "/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antisShuffles('Hi') returns 'Hi'\n  antisShuffles('hello') returns 'ehllo'\n  antisShuffles('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antisShuffles = (s) => {\n    const array = s.split(' ');\n    let index = 0;\n    const reverseArray = array.reverse();\n    let res = '';\n    for(let i = 0; i < reverseArray.length; i++){\n        res += reverseArray[i];\n        if(i!== reverseArray.length - 1){\n            res +='';\n        }\n    }\n    return res;\n}\n\nconsole.log(antisShuffles('Hello World!!!'));\n<|endoftext|>"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRows([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRows([], 1) == []\n  getRows([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRows = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRows", "gc": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRows([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRows([], 1) == []\n  getRows([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRows = (lst, x) => {\n  const getRow = row => [...row.slice(0, row.length - 1), row.slice(row.length - 1)[0]];\n  \n  const rows = lst.map(getRow);\n  rows = rows.sort((a, b) => a[0] - b[0]);\n  rows = rows.sort((a, b) => b[1] - a[1]);\n  \n  return rows.filter(row => row[0] === x);\n};\n<|endoftext|>"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortsArray([]) => []\n  * sortsArray([5]) => [5]\n  * sortsArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortsArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortsArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortsArray", "gc": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortsArray([]) => []\n  * sortsArray([5]) => [5]\n  * sortsArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortsArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortsArray = (array) => {\n  const copy = array.slice(0);\n  for (let i = 0; i < array.length - 1; i++) {\n    const current = copy[i];\n    const next = copy[i + 1];\n    const sum = current + next;\n    if (sum % 2 === 0) {\n      copy.splice(i, 1);\n      copy.splice(i + 1, 0, next);\n      copy.splice(i, 0, current);\n      i--;\n    }\n  }\n  return copy;\n};\n\nmodule.exports = sortsArray;\n<|endoftext|>"}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "gc": "/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let len = s.length;\n  let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let str = '';\n  let rot = 2;\n  for (let i = 0; i < len; i++) {\n    let char = s.charAt(i);\n    let index = chars.indexOf(char);\n    str += chars[(index + rot) % chars.length];\n  }\n  return str;\n}\n\n/*\n  Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  encrypt('lm') returns 'hi'\n  encrypt('ewhjklnop') returns 'gf'\n  encrypt('kj') returns 'et'\n  encrypt('ix') returns 'jt'\n  */\nconst decrypt = (s) => {\n  let len = s.length;\n  let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let str = '';\n  let rot = -2;\n  for (let i = 0; i < len; i++) {\n    let char = s.charAt(i);\n    let index = chars.indexOf(char);\n    str += chars[(index + rot) % chars.length];\n  }\n  return str;\n}\n\nconst encrypt = (s) => {\n  let len = s.length;\n  let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let str = '';\n  let rot = 2;\n  for (let i = 0; i < len; i++) {\n    let char = s.charAt(i);\n    let index = chars.indexOf(char);\n    str += chars[(index + rot) % chars.length];\n  }\n  return str;\n}\n\nconst decrypt = (s) => {\n  let len = s.length;\n  let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let str = '';\n  let rot = -2;\n  for (let i = 0; i < len; i++) {\n    let char = s.charAt(i);\n    let index = chars.indexOf(char);\n    str += chars[(index + rot) % chars.length];\n  }\n  return str;\n}\n\nconst encrypt = (s) => {\n  let len = s.length;\n  let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let str = '';\n  let rot = 2;\n  for (let i = 0; i < len; i++) {\n    let char = s.charAt(i);\n    let index = chars.indexOf(char);\n    str += chars[(index + rot) % chars.length];\n  }\n  return str;\n}\n\nconst decrypt = (s) => {\n  let len = s.length;\n  let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let str = '';\n  let rot = -2;\n  for (let i = 0; i < len; i++) {\n    let char = s.charAt(i);\n    let index = chars.indexOf(char);\n    str += chars[(index + rot) % chars.length];\n  }\n  return str;\n}\n\n/*\n  Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by one multiplied to two places.\n  For example:\n  encrypt('hi') returns 'i'\n  encrypt('asdfghjkl') returns 'hkli'\n  encrypt('gf') returns 'ghi'\n  encrypt('et') returns 'ft'\n  */\nconst encrypt = (s) => {\n  let len = s.length;\n  let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let str = '';\n  let rot = 1;\n  for (let i = 0; i < len; i++) {\n    let char = s.charAt(i);\n    let index = chars.indexOf(char);\n    str += chars[(index + rot) % chars.length];\n  }\n  return str;\n}\n\nconst decrypt = (s) => {\n  let len = s.length;\n  let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let str = '';\n  let rot = -1;\n  for (let i = 0; i < len; i++) {\n    let char = s.charAt(i);\n    let index = chars.indexOf(char);\n    str += chars[(index + rot) % chars.length];\n  }\n  return str;\n}\n\nconst encrypt = (s) => {\n  let len = s.length;\n  let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let str = '';\n  let rot = -1;\n  for (let i = 0; i < len; i++) {\n    let char = s.charAt(i);\n    let index = chars.indexOf(char);\n    str += chars[(index + rot) % chars.length];\n  }\n  return str;\n}\n\nconst decrypt = (s) => {\n  let len = s.length;\n  let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let str = '';\n  let rot = 1;\n  for (let i = 0; i < len; i++) {\n    let char = s.charAt(i);\n    let index = chars.indexOf(char);"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "gc": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  const len = lst.length\n  if (len < 2) return null\n  let min = lst[0]\n  for (let i = 1; i < len; i++) {\n    min = Math.min(min, lst[i])\n  }\n  const max = lst[len - 1]\n  if (min === max) return null\n  const next = max - min\n  if (next === 1) return null\n  const idx = lst.indexOf(min)\n  if (idx === -1) return null\n  return lst[(idx + 1) % len]\n}\n\nconst lst = [1, 2, 3, 4, 5]\nconsole.log(nextSmallest(lst))\n<|endoftext|>"}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBore(\"Hello world\")\n  0\n  >>> isBore(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBore = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBore", "gc": "/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBore(\"Hello world\")\n  0\n  >>> isBore(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBore = (S) => {\n    const re = /^I/;\n    const bored = S.match(re);\n    return bored;\n}\n\n/*\n  The task is to create a function that will return the number of boredoms in the\n  given string.\n \n  For example:\n  >>> countBoredoms(\"Hello world\")\n  1\n  >>> countBoredoms(\"The sky is blue. The sun is shining. I love this weather\")\n  2\n  */\nconst countBoredoms = (S) => {\n    let nbBoredoms = 0;\n    const re = /^I/;\n    const bored = S.match(re);\n    if (bored) {\n        nbBoredoms++;\n        let start = bored[0].indexOf(\"I\");\n        let end = bored[0].indexOf(\".\", start);\n        let end = bored[0].indexOf(\"?\", start);\n        nbBoredoms++;\n    }\n    return nbBoredoms;\n}\n\nconst isBored = (S) => {\n    const re = /^I/;\n    const bored = S.match(re);\n    return bored;\n}\n\nconst countBoredoms = (S) => {\n    let nbBoredoms = 0;\n    const re = /^I/;\n    const bored = S.match(re);\n    if (bored) {\n        nbBoredoms++;\n        let start = bored[0].indexOf(\"I\");\n        let end = bored[0].indexOf(\".\", start);\n        let end = bored[0].indexOf(\"?\", start);\n        nbBoredoms++;\n    }\n    return nbBoredoms;\n}\n\n/*\n  The task is to create a function that will return the number of boredoms in the\n  given string.\n \n  For example:\n  >>> countBoredoms(\"Hello world\")\n  1\n  >>> countBoredoms(\"The sky is blue. The sun is shining. I love this weather\")\n  2\n  */\nconst countBoredoms = (S) => {\n    let nbBoredoms = 0;\n    const re = /^I/;\n    const bored = S.match(re);\n    if (bored) {\n        nbBoredoms++;\n        let start = bored[0].indexOf(\"I\");\n        let end = bored[0].indexOf(\".\", start);\n        let end = bored[0].indexOf(\"?\", start);\n        nbBoredoms++;\n    }\n    return nbBoredoms;\n}\n\nconst countBoredoms = (S) => {\n    let nbBoredoms = 0;\n    const re = /^I/;\n    const bored = S.match(re);\n    if (bored) {\n        nbBoredoms++;\n        let start = bored[0].indexOf(\"I\");\n        let end = bored[0].indexOf(\".\", start);\n        let end = bored[0].indexOf(\"?\", start);\n        nbBoredoms++;\n    }\n    return nbBoredoms;\n}\n\nconst countBoredoms = (S) => {\n    let nbBoredoms = 0;\n    const re = /^I/;\n    const bored = S.match(re);\n    if (bored) {\n        nbBoredoms++;\n        let start = bored[0].indexOf(\"I\");\n        let end = bored[0].indexOf(\".\", start);\n        let end = bored[0].indexOf(\"?\", start);\n        nbBoredoms++;\n    }\n    return nbBoredoms;\n}\n\nconst countBoredoms = (S) => {\n    let nbBoredoms = 0;\n    const re = /^I/;\n    const bored = S.match(re);\n    if (bored) {\n        nbBoredoms++;\n        let start = bored[0].indexOf(\"I\");\n        let end = bored[0].indexOf(\".\", start);\n        let end = bored[0].indexOf(\"?\", start);\n        nbBoredoms++;\n    }\n    return nbBoredoms;\n}\n\nconst countBoredoms = (S) => {\n    let nbBoredoms = 0;\n    const re = /^I/;\n    const bored = S.match(re);\n    if (bored) {\n        nbBoredoms++;\n        let start = bored[0].indexOf(\"I\");\n        let end = bored[0].indexOf(\".\", start);\n        let end = bored[0].indexOf(\"?\", start);\n        nbBoredoms++;\n    }\n    return nbBoredoms;\n}\n\nconst countBoredoms = (S) => {\n    let nbBoredoms = 0;\n    const re = /^I/;\n    const bored = S.match(re);\n    if (bored) {\n        nbBoredoms++;\n        let start = bored[0].indexOf(\"I\");\n        let end = bored[0].indexOf(\".\", start);\n        let end = bored[0].indexOf(\"?\", start);\n        nbBoredoms++;\n    }\n    return nbBoredoms;\n}\n\nconst countBoredoms = (S) => {\n    let nbBoredoms = 0;\n    const re = /^I/;\n    const bored = S.match(re);\n    if (bored) {\n        nbBoredoms++;\n        let start = bored[0].indexOf(\"I\");\n        let end = bored[0].indexOf(\".\", start);\n        let end = bored[0].indexOf(\"?\", start);\n        nbBoredoms++;\n    }\n    return nbBoredoms;\n}\n\nconst countBoredoms = (S) => {\n    let nbBoredoms = 0;\n    const re = /^I/;\n    const bored = S.match(re);\n    if (bored) {\n        nbBoredoms++;\n        let start = bored[0].indexOf(\"I\");\n        "}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "gc": "/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  return x === z + y? true : false;\n};\n\nconst anyInt2 = (x, y, z) => {\n  return x === y + z? true : false;\n};\n\nconst anyInt3 = (x, y, z) => {\n  return x === y - z? true : false;\n};\n\nconst anyInt4 = (x, y, z) => {\n  return x + y === z? true : false;\n};\n\nconst anyInt5 = (x, y, z) => {\n  return x - y === z? true : false;\n};\n\nconst anyInt6 = (x, y, z) => {\n  return x * y === z? true : false;\n};\n\nconst anyInt7 = (x, y, z) => {\n  return x / y === z? true : false;\n};\n\nconst anyInt8 = (x, y, z) => {\n  return x % y === z? true : false;\n};\n\nconst anyInt9 = (x, y, z) => {\n  return x - (y - z) === z? true : false;\n};\n\nconst anyInt10 = (x, y, z) => {\n  return x + (y + z) === z? true : false;\n};\n\nconst anyInt11 = (x, y, z) => {\n  return x - (y + z) === z? true : false;\n};\n\nconst anyInt12 = (x, y, z) => {\n  return x + (y - z) === z? true : false;\n};\n\nconst anyInt13 = (x, y, z) => {\n  return x * (y + z) === z? true : false;\n};\n\nconst anyInt14 = (x, y, z) => {\n  return x / (y + z) === z? true : false;\n};\n\nconst anyInt15 = (x, y, z) => {\n  return x % (y + z) === z? true : false;\n};\n\nconst anyInt16 = (x, y, z) => {\n  return x - (y - z) === z? true : false;\n};\n\nconst anyInt17 = (x, y, z) => {\n  return x + (y - z) === z? true : false;\n};\n\nconst anyInt18 = (x, y, z) => {\n  return x - (y + z) === z? true : false;\n};\n\nconst anyInt19 = (x, y, z) => {\n  return x * (y - z) === z? true : false;\n};\n\nconst anyInt20 = (x, y, z) => {\n  return x / (y - z) === z? true : false;\n};\n\nconst anyInt21 = (x, y, z) => {\n  return x % (y - z) === z? true : false;\n};\n\nconst anyInt22 = (x, y, z) => {\n  return x - (y + z) === z? true : false;\n};\n\nconst anyInt23 = (x, y, z) => {\n  return x + (y + z) === z? true : false;\n};\n\nconst anyInt24 = (x, y, z) => {\n  return x - (y - z) === z? true : false;\n};\n\nconst anyInt25 = (x, y, z) => {\n  return x * (y - z) === z? true : false;\n};\n\nconst anyInt26 = (x, y, z) => {\n  return x / (y - z) === z? true : false;\n};\n\nconst anyInt27 = (x, y, z) => {\n  return x % (y - z) === z? true : false;\n};\n\nconst anyInt28 = (x, y, z) => {\n  return x - (y + z) === z? true : false;\n};\n\nconst anyInt29 = (x, y, z) => {\n  return x + (y + z) === z? true : false;\n};\n\nconst anyInt30 = (x, y, z) => {\n  return x - (y - z) === z? true : false;\n};\n\nconst anyInt31 = (x, y, z) => {\n  return x * (y - z) === z? true : false;\n};\n\nconst anyInt32 = (x, y, z) => {\n  return x / (y - z) === z? true : false;\n};\n\nconst anyInt33 = (x, y, z) => {\n  return x % (y - z) === z? true : false;\n};\n\nconst anyInt34 = (x, y, z) => {\n  return x - (y + z) === z? true : false;\n};\n\nconst anyInt35 = (x, y, z) => {\n  return x + (y + z) === z? true : false;\n};\n\nconst anyInt36 = (x, y, z) => {\n  return x - (y - z) === z? true : false;\n};\n\nconst anyInt37 = (x, y, z) => {\n  return x * (y - z) === z? true : false;\n};\n\nconst anyInt38 = (x, y, z) => {\n  return x / (y - z) === z? true : false;\n};\n\nconst anyInt39 = (x, y, z) => {\n  return x % (y - z) === z? true : false;\n};\n\nconst anyInt40 = (x, y, z) => {\n  return x - (y + z) === z? true : false;\n};\n\nconst anyInt41 = (x, y, z) => {\n  return x + (y + z) === z? true : false;\n};\n\nconst anyInt42 = (x, y, z) => {\n  return x"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "gc": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n    return message.replace(/[A-Z]/g, (letter) => {\n        const letterNext = (letter + 1) % 26;\n        if (letterNext === 0) {\n            return letter + 1;\n        }\n        return String.fromCharCode(letterNext);\n    });\n}\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> decode('TGST')\n  'This is a message'\n  >>> decode('This is a message')\n  'TEST'\n  */\nconst decode = (message) => {\n    return message.replace(/[A-Z]/g, (letter) => {\n        const letterNext = (letter + 1) % 26;\n        if (letterNext === 0) {\n            return letter + 1;\n        }\n        return String.fromCharCode(letterNext);\n    });\n}\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> decode('TGSST')\n  'This is a message'\n  >>> decode('THKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decode2 = (message) => {\n    return message.replace(/[A-Z]/g, (letter) => {\n        const letterNext = (letter + 1) % 26;\n        if (letterNext === 0) {\n            return letter + 1;\n        }\n        return String.fromCharCode(letterNext);\n    });\n}\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> decode2('TGST')\n  'This is a message'\n  >>> decode2('TKS C MGSSCGG')\n  'This is a message'\n  */\nconst decode3 = (message) => {\n    return message.replace(/[A-Z]/g, (letter) => {\n        const letterNext = (letter + 1) % 26;\n        if (letterNext === 0) {\n            return letter + 1;\n        }\n        return String.fromCharCode(letterNext);\n    });\n}\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> decode3('TGST')\n  'This is a message'\n  >>> decode3('TKS C MGSSCGG')\n  'This is a message'\n  */\nconst decode4 = (message) => {\n    return message.replace(/[A-Z]/g, (letter) => {\n        const letterNext = (letter + 1) % 26;\n        if (letterNext === 0) {\n            return letter + 1;\n        }\n        return String.fromCharCode(letterNext);\n    });\n}\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> decode4('TGST')\n  'This is a message'\n  >>> decode4('TKS C MGSSCGG')\n  'This is a message'\n  */\nconst decode5 = (message) => {\n    return message.replace(/[A-Z]/g, (letter) => {\n        const letterNext = (letter + 1) % 26;\n        if (letterNext === 0) {\n            return letter + 1;\n        }\n        return String.fromCharCode(letterNext);\n    });\n}\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> decode5('TGST')\n  'This is a message'\n  >>> decode5('TKS C MGSSCGG')\n  'This is a message'\n  */\nconst decode6 = (message) => {\n    return message.replace(/[A-Z]/g, (letter) => {\n        const letterNext = (letter + 1) % 26;\n        if (letterNext === 0) {\n            return letter + 1;\n        }\n        return String.fromCharCode(letterNext);\n    });\n}\n\n/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> decode6('TGST')\n  'This is a message'\n  >>> decode6('TKS C MGSSCGG')\n  'This is a message'\n  */\nconst decode7 = (message) => {\n    return message.replace(/[A-Z]/g"}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "gc": "/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let len = lst.length;\n  let max = lst[0];\n  let min = lst[0];\n  for (let i = 0; i < len; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    } else if (lst[i] < min) {\n      min = lst[i];\n    }\n  }\n  let maxPrime = max;\n  while (maxPrime > 0) {\n    let prime = parseInt(maxPrime, 10);\n    let lenPrime = prime.toString().length;\n    let sum = 0;\n    for (let i = 0; i < lenPrime; i++) {\n      sum += parseInt(lst[i + 1], 10);\n    }\n    if (sum > max) {\n      max = sum;\n      maxPrime = maxPrime;\n    }\n    maxPrime--;\n  }\n  return maxPrime;\n};\n\nlet res = skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]);\nconsole.log(res);\n<|endoftext|>"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCases({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCases({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCases({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCases({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCases({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCases = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCases", "gc": "/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCases({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCases({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCases({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCases({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCases({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCases = (dict) => {\n  const keys = Object.keys(dict)\n  return keys.every((key) => {\n    if (typeof(key)!=='string') {\n      return false\n    }\n    return (key.toUpperCase() === key) || (key.toLowerCase() === key)\n  })\n}\n\n/*\n  Given an array, return true if all elements are numbers and in range [0,999], else return false.\n  The function should return false is the given array is empty.\n  Examples:\n  checkArrayOfInts([\"10\", \"1\", \"100\", \"12345\", \"23456\"]) should return true.\n  checkArrayOfInts([\"10\", \"1\", \"100\", \"12345\", \"23456\", \"123456\"]) should return false.\n  checkArrayOfInts([\"10\", \"1\", \"100\", \"12345\", \"23456\", \"2345\"]) should return false.\n  checkArrayOfInts([\"10\", \"1\", \"100\", \"12345\", \"23456\", \"12345\", \"123456\"]) should return false.\n  checkArrayOfInts([\"10\", \"1\", \"100\", \"12345\", \"23456\", \"23456\", \"123456\"]) should return false.\n  */\nconst checkArrayOfInts = (array) => {\n  return array.every((value) => {\n    return typeof(value) === 'number' && value >= 0 && value <= 999\n  })\n}\n\n/*\n  Given a string, return true if string starts with one of the given \n  substrings, else return false.\n  The function should return false is the given string is empty.\n  Examples:\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\", \"b\", \"c\", \"c\", \"b\", \"a\"]) should return true.\n  checkArrayOfInts([\"a\","}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "gc": "/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) {\n        return false;\n      }\n    }\n    return true;\n  };\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (isPrime(i)) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst testCountUpTo = () => {\n  console.log(countUpTo(5));\n  console.log(countUpTo(11));\n  console.log(countUpTo(0));\n  console.log(countUpTo(20));\n  console.log(countUpTo(1));\n  console.log(countUpTo(18));\n};\n\ntestCountUpTo();\n<|endoftext|>"}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "gc": "/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  if (b === 0) {\n    return 0\n  }\n  if (a === 0) {\n    return 0\n  }\n  let sum = a\n  let carry = 0\n  while (sum > 0) {\n    let product = sum * b\n    carry = product % 10\n    sum = product / 10\n  }\n  if (carry === 1) {\n    return sum + 1\n  } else {\n    return sum\n  }\n}\n\nconsole.log(multiply(148, 412))\nconsole.log(multiply(19, 28))\nconsole.log(multiply(2020, 1851))\nconsole.log(multiply(14, -15))\n<|endoftext|>"}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "gc": "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  const index = (s.indexOf('A') + 1) % 26;\n  const count = (s.indexOf('A') + 1) % 26;\n  if (index > 0) {\n    return count;\n  }\n  return 0;\n};\n\n/*\n  Given a string s, count the number of uppercase vowels in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 2\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  const index = (s.indexOf('a') + 1) % 26;\n  const count = (s.indexOf('a') + 1) % 26;\n  if (index > 0) {\n    return count;\n  }\n  return 0;\n};\n\n/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countMixed = (s) => {\n  const index = (s.indexOf('a') + 1) % 26;\n  const count = (s.indexOf('a') + 1) % 26;\n  if (index > 0) {\n    return count;\n  }\n  return 0;\n};\n\n/*\n  Given a string s, count the number of uppercase vowels in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 2\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countMixed2 = (s) => {\n  const index = (s.indexOf('a') + 1) % 26;\n  const count = (s.indexOf('a') + 1) % 26;\n  if (index > 0) {\n    return count;\n  }\n  return 0;\n};\n\nconst count = (s) => {\n  return countUpper(s) + countLower(s) + countMixed(s) + countMixed2(s);\n};\n\nconsole.log(count('aBCdEf'));\nconsole.log(count('abcdefg'));\nconsole.log(count('dBBE'));\n<|endoftext|>"}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closerIntegers(\"10\")\n  10\n  >>> closerIntegers(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closerIntegers(\"14.5\") should\n  return 15 and closerIntegers(\"-14.5\") should return -15.\n  */\nconst closerIntegers = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closerIntegers", "gc": "/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closerIntegers(\"10\")\n  10\n  >>> closerIntegers(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closerIntegers(\"14.5\") should\n  return 15 and closerIntegers(\"-14.5\") should return -15.\n  */\nconst closerIntegers = (value) => {\n  let intValue = parseInt(value);\n  if(value === intValue) {\n    return intValue;\n  }\n\n  let valueAsStr = value;\n  let intValues = [0, parseInt(value), intValue];\n\n  let closest = intValues[0];\n  let closestDistance = Math.abs(closest - intValue);\n  for (let i = 1; i < intValues.length; i++) {\n    let distance = Math.abs(closest - intValues[i]);\n    if (distance < closestDistance) {\n      closest = intValues[i];\n      closestDistance = distance;\n    }\n  }\n\n  if (closestDistance > 0) {\n    valueAsStr = closest.toString();\n  }\n\n  return parseInt(valueAsStr);\n};\n\nmodule.exports = closerIntegers;\n<|endoftext|>"}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> madeAPiles(3)\n  [3, 5, 7]\n  */\nconst madeAPiles = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "madeAPiles", "gc": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> madeAPiles(3)\n  [3, 5, 7]\n  */\nconst madeAPiles = (n) => {\n    const isOdd = n % 2!== 0;\n    const isEven = n % 2 === 0;\n    return [n, isOdd? n - 1 : n, isEven? n - 1 : n];\n};\n\nexport {\n    madeAPiles\n};\n<|endoftext|>"}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordString", "gc": "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordString = (s) => {\n  const words = s.split(/\\s*[,\\s]+\\s*/);\n  const result = words.map((word) => {\n    return word.toLowerCase();\n  });\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words in reverse order.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"John\", \"my\", \"Hi\"]\n  wordString(\"One, two, three, four, five, six\") == [\"six\", \"five\", \"four\", \"three\", \"two\", \"one\"]\n  */\nconst reverseWordsString = (s) => {\n  const words = s.split(/\\s*[,\\s]+\\s*/);\n  const result = words.map((word) => {\n    return word.toLowerCase();\n  });\n  result.reverse();\n  return result;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words with the first and\n  last word removed.\n  \n  For example:\n  wordString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"John\"]\n  wordString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst firstLastWordsString = (s) => {\n  const words = s.split(/\\s*[,\\s]+\\s*/);\n  const result = words.map((word) => {\n    return word.toLowerCase();\n  });\n  const first = result.shift();\n  const last = result.pop();\n  return [first, last];\n};\n\nmodule.exports = {\n  wordString,\n  reverseWordsString,\n  firstLastWordsString\n};\n<|endoftext|>"}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "gc": "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n    if (x > y) {\n        return -1;\n    }\n    let x_2 = x + x;\n    let y_2 = y + y;\n    let x_1 = x + 1;\n    let y_1 = y + 1;\n    let min = Math.min(x_1, y_1);\n    if (x_2 < min) {\n        return chooseNum(x_1, y_1);\n    } else if (y_2 < min) {\n        return chooseNum(x_2, y_1);\n    } else {\n        let x_half = Math.floor(x / 2);\n        let y_half = Math.floor(y / 2);\n        return chooseNum(x_half, y_half) + chooseNum(x_half + 1, y_half + 1);\n    }\n}\n\n/*\n  This function takes two positive numbers x and y and returns the\n  smallest odd number that is in the range [x, y] inclusive. If there's no\n  such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 9\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum2 = (x, y) => {\n    if (x > y) {\n        return -1;\n    }\n    let x_2 = x + x;\n    let y_2 = y + y;\n    let x_1 = x + 1;\n    let y_1 = y + 1;\n    let min = Math.min(x_1, y_1);\n    if (x_2 < min) {\n        return chooseNum2(x_1, y_1);\n    } else if (y_2 < min) {\n        return chooseNum2(x_2, y_1);\n    } else {\n        let x_half = Math.floor(x / 2);\n        let y_half = Math.floor(y / 2);\n        return chooseNum2(x_half, y_half) + chooseNum2(x_half + 1, y_half + 1);\n    }\n}\n\n/*\n  This function takes two positive numbers x and y and returns the\n  smallest even number that is in the range [x, y] inclusive. If there's no\n  such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum3 = (x, y) => {\n    if (x > y) {\n        return -1;\n    }\n    let x_2 = x + x;\n    let y_2 = y + y;\n    let x_1 = x + 1;\n    let y_1 = y + 1;\n    let min = Math.min(x_1, y_1);\n    if (x_2 < min) {\n        return chooseNum3(x_1, y_1);\n    } else if (y_2 < min) {\n        return chooseNum3(x_2, y_1);\n    } else {\n        let x_half = Math.floor(x / 2);\n        let y_half = Math.floor(y / 2);\n        return chooseNum3(x_half, y_half) + chooseNum3(x_half + 1, y_half + 1);\n    }\n}\n\nconst result = chooseNum(1, 3);\nconsole.log(result);\n<|endoftext|>"}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundingAvg(1, 5) => \"0b11\"\n  roundingAvg(7, 5) => -1\n  roundingAvg(10, 20) => \"0b1111\"\n  roundingAvg(20, 33) => \"0b11010\"\n  */\nconst roundingAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundingAvg", "gc": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundingAvg(1, 5) => \"0b11\"\n  roundingAvg(7, 5) => -1\n  roundingAvg(10, 20) => \"0b1111\"\n  roundingAvg(20, 33) => \"0b11010\"\n  */\nconst roundingAvg = (n, m) => {\n  let avg = 0\n  while (n <= m) {\n    avg += n\n    n += 1\n  }\n  return Math.floor(avg / 2)\n}\n\nconsole.log(roundingAvg(1, 5))\nconsole.log(roundingAvg(7, 5))\nconsole.log(roundingAvg(10, 20))\nconsole.log(roundingAvg(20, 33))\n<|endoftext|>"}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigit([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigit([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigit = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigit", "gc": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigit([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigit([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigit = (x) => {\n  let temp = x.sort((a, b) => a - b);\n  let result = [];\n  for(let i = 0; i < temp.length; i++) {\n    if(temp[i].toString().indexOf('0') == -1) {\n      result.push(temp[i]);\n    }\n  }\n  return result;\n};\n\nlet testcase = [15, 33, 1422, 1];\nconsole.log(uniqueDigit(testcase));\n<|endoftext|>"}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "gc": "/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  arr.sort((a, b) => {\n    return a - b\n  })\n  arr.reverse()\n  return arr.map(() => {\n    return arr[Math.floor(Math.random() * arr.length)]\n  })\n}\n\nconst byReverse = (arr) => {\n  arr.reverse()\n  return arr\n}\n\nconst byLengthAndReverse = (arr) => {\n  let arr2 = arr.slice()\n  arr2.reverse()\n  return byLength(arr2)\n}\n\nconst byReverseAndSort = (arr) => {\n  let arr2 = arr.slice()\n  arr2.reverse()\n  arr2.sort()\n  return arr2\n}\n\nconst main = () => {\n  let arr = [2, 1, 1, 4, 5, 8, 2, 3]\n  let names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  let names2 = [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n  console.log(byLength(arr))\n  console.log(names)\n  console.log(byReverse(arr))\n  console.log(names2)\n  console.log(byLengthAndReverse(arr))\n  console.log(names2)\n  console.log(byReverseAndSort(arr))\n  console.log(names2)\n}\n\nmain()\n<|endoftext|>"}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "gc": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const ret = [];\n  for (let i = 1; i <= n; i++) {\n    const sum = i;\n    if (i % 2 === 0) {\n      ret.push(sum);\n    }\n    for (let j = i + 1; j <= n; j++) {\n      sum += j;\n      ret.push(sum);\n    }\n  }\n  return ret;\n};\n\nf(5);\n<|endoftext|>"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOdderPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOdderPalindrome", "gc": "/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOdderPalindrome = (n) => {\n  let oddPals = 0, evenPals = 0, i = 0;\n  while (i <= n) {\n    i += 2;\n    if (i % 2 === 0) {\n      evenPals++;\n    } else {\n      oddPals++;\n    }\n  }\n  return [evenPals, oddPals];\n};\n\nexport default evenOdderPalindrome;\n<|endoftext|>"}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "gc": "/*\n  Write a function countNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const num = arr[i];\n    if (num > 0) {\n      count++;\n    } else if (num < 0) {\n      const sign = Math.sign(num);\n      const digit = Math.floor(Math.abs(num) / sign);\n      if (digit > 0) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  movingOneBalls([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  movingOneBalls([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst movingOneBalls = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "movingOneBalls", "gc": "/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  movingOneBalls([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  movingOneBalls([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst movingOneBalls = (arr) => {\n    let n = arr.length;\n    if (n === 0) return true;\n\n    let i = n - 1;\n    let last = arr[i];\n    while (i > 0) {\n        if (arr[i - 1] > last) {\n            arr[i] = last;\n            arr[i - 1] = arr[--i];\n        } else {\n            i--;\n        }\n    }\n\n    return!(arr[0] > last);\n};\n\nconsole.log(movingOneBalls([3, 4, 5, 1, 2]));\nconsole.log(movingOneBalls([3, 5, 4, 1, 2]));\n<|endoftext|>"}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an exchanges of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchangesd elements between lst1 and lst2.\n  If it is possible to exchanges elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchanges([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchanges([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchanges = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchanges", "gc": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an exchanges of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchangesd elements between lst1 and lst2.\n  If it is possible to exchanges elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchanges([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchanges([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchanges = (lst1, lst2) => {\n  let odd = false;\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      lst1[i] = lst1[i] + lst2[i];\n      if (lst1[i] % 2!== 0) {\n        odd = true;\n      }\n    } else {\n      odd = false;\n    }\n  }\n  return odd? \"YES\" : \"NO\";\n};\n<|endoftext|>"}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histograms('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histograms('a b b a') == {'a': 2, 'b': 2}\n  histograms('a b c a b') == {'a': 2, 'b': 2}\n  histograms('b b b b a') == {'b': 4}\n  histograms('') == {}\n\n  */\nconst histograms = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histograms", "gc": "/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histograms('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histograms('a b b a') == {'a': 2, 'b': 2}\n  histograms('a b c a b') == {'a': 2, 'b': 2}\n  histograms('b b b b a') == {'b': 4}\n  histograms('') == {}\n\n  */\nconst histograms = (test) => {\n  const histogram = new Map();\n  const string = test.split(' ');\n  for (let i = 0; i < string.length; i++) {\n    const letter = string[i].toLowerCase();\n    histogram.set(letter, (histogram.get(letter) || 0) + 1);\n  }\n  return histogram;\n};\n\n/* Given a string representing a space separated lowercase letters, return the letter that\n  has the most repetition.\n  \n  Example:\n  histograms('a b c') == 'a'\n  histograms('a b c a') == 'a'\n  histograms('b b b b a') == 'b'\n  histograms('') == ''\n  \n  */\nconst mostRepeatedLetter = (test) => {\n  const histogram = histograms(test);\n  const max = histogram.get(Object.keys(histogram)[0]);\n  const maxCount = Object.keys(histogram).find(key => histogram[key] === max);\n  return maxCount;\n};\n\nconst parse = (test) => {\n  const histogram = histograms(test);\n  return Object.keys(histogram).reduce((result, letter) => {\n    result[letter] = histogram[letter];\n    return result;\n  }, {});\n};\n\nconst getMax = (test) => {\n  const histogram = histograms(test);\n  const max = Object.keys(histogram).reduce((result, key) => {\n    result[key] = histogram[key];\n    return result;\n  }, {});\n  return max;\n};\n\nconst getMaxCount = (test) => {\n  const histogram = histograms(test);\n  const maxCount = Object.keys(histogram).reduce((result, key) => {\n    result[key] = histogram[key];\n    return result;\n  }, {});\n  return maxCount;\n};\n\nconst isValid = (test) => {\n  const histogram = histograms(test);\n  const maxCount = Object.keys(histogram).reduce((result, key) => {\n    result[key] = histogram[key];\n    return result;\n  }, {});\n  return Object.keys(maxCount).every(key => maxCount[key] === histogram[key]);\n};\n\nconst getMostRepeated = (test) => {\n  const histogram = histograms(test);\n  const max = Object.keys(histogram).reduce((result, key) => {\n    result[key] = histogram[key];\n    return result;\n  }, {});\n  return max;\n};\n\nconst getMostRepeatedCount = (test) => {\n  const histogram = histograms(test);\n  const maxCount = Object.keys(histogram).reduce((result, key) => {\n    result[key] = histogram[key];\n    return result;\n  }, {});\n  return maxCount;\n};\n\nconst getMostFrequent = (test) => {\n  const histogram = histograms(test);\n  const max = Object.keys(histogram).reduce((result, key) => {\n    result[key] = histogram[key];\n    return result;\n  }, {});\n  return max;\n};\n\nconst getMostFrequentCount = (test) => {\n  const histogram = histograms(test);\n  const maxCount = Object.keys(histogram).reduce((result, key) => {\n    result[key] = histogram[key];\n    return result;\n  }, {});\n  return maxCount;\n};\n\nconst getMostFrequentMax = (test) => {\n  const histogram = histograms(test);\n  const max = Object.keys(histogram).reduce((result, key) => {\n    result[key] = histogram[key];\n    return result;\n  }, {});\n  return max;\n};\n\nconst getMostFrequentMaxCount = (test) => {\n  const histogram = histograms(test);\n  const maxCount = Object.keys(histogram).reduce((result, key) => {\n    result[key] = histogram[key];\n    return result;\n  }, {});\n  return maxCount;\n};\n\nconst getMostFrequentMaxCountAndLetter = (test) => {\n  const histogram = histograms(test);\n  const maxCount = Object.keys(histogram).reduce((result, key) => {\n    result[key] = histogram[key];\n    return result;\n  }, {});\n  return maxCount, Object.keys(histogram).find(key => histogram[key] === maxCount);\n};\n\nconst isUnique = (test) => {\n  const histogram = histograms(test);\n  return Object.keys(histogram).every(key => histogram[key] === 1);\n};\n\nconst isUniqueWithLetter = (test) => {\n  const histogram = histograms(test);\n  return Object.keys(histogram).every(key => histogram[key] === 1);\n};\n\nconst isUniqueWithLetterAndCount = (test) => {\n  const histogram = histograms(test);\n  return Object.keys(histogram).every(key => histogram[key] === 1);\n};\n\nconst isUniqueMax = (test) => {\n  const histogram = histograms(test);\n  const max = Object.keys(histogram).reduce((result, key) => {\n    result[key] = histogram[key];\n    return result;\n  }, {});\n  return Object.keys(histogram).every(key => histogram[key] === 1);\n};\n\nconst isUniqueMaxWithCount = (test) => {\n  const histogram = histograms(test);\n  const max = Object.keys("}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reversesDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reversesDelete", "gc": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reversesDelete = (s, c) => {\n  if (!s ||!c) return {s, isPalindrome: false}\n  let count = 0\n  const isPalindrome = () => {\n    const s2 = s.slice()\n    const c2 = c.slice()\n    s2.forEach(x => {\n      if (c2.indexOf(x)!== -1) count++\n    })\n    return count === s.length\n  }\n  const str = c.split('')\n  const result = []\n  str.forEach(x => {\n    if (c.indexOf(x) === -1) result.push(x)\n  })\n  if (result.length === 0) return {s: s, isPalindrome: true}\n  s = result.join('')\n  if (isPalindrome()) return {s, isPalindrome: true}\n  return {s, isPalindrome: false}\n}\n\n// console.log(reversesDelete(\"abcdedcba\", \"ab\"))\n// console.log(reversesDelete(\"abcdedcba\", \"b\"))\n// console.log(reversesDelete(\"abcdedcba\", \"ac\"))\n// console.log(reversesDelete(\"abcdedcba\", \"c\"))\n// console.log(reversesDelete(\"abcdedcba\", \"d\"))\n// console.log(reversesDelete(\"abcdedcba\", \"e\"))\n// console.log(reversesDelete(\"abcdedcba\", \"f\"))\n// console.log(reversesDelete(\"abcdedcba\", \"g\"))\n// console.log(reversesDelete(\"abcdedcba\", \"a\"))\n// console.log(reversesDelete(\"abcdedcba\", \"b\"))\n// console.log(reversesDelete(\"abcdedcba\", \"c\"))\n// console.log(reversesDelete(\"abcdedcba\", \"d\"))\n// console.log(reversesDelete(\"abcdedcba\", \"e\"))\n// console.log(reversesDelete(\"abcdedcba\", \"f\"))\n// console.log(reversesDelete(\"abcdedcba\", \"g\"))\n// console.log(reversesDelete(\"abcdedcba\", \"a\"))\n// console.log(reversesDelete(\"abcdedcba\", \"b\"))\n// console.log(reversesDelete(\"abcdedcba\", \"c\"))\n// console.log(reversesDelete(\"abcdedcba\", \"d\"))\n// console.log(reversesDelete(\"abcdedcba\", \"e\"))\n// console.log(reversesDelete(\"abcdedcba\", \"f\"))\n// console.log(reversesDelete(\"abcdedcba\", \"g\"))\n// console.log(reversesDelete(\"abcdedcba\", \"a\"))\n// console.log(reversesDelete(\"abcdedcba\", \"b\"))\n// console.log(reversesDelete(\"abcdedcba\", \"c\"))\n// console.log(reversesDelete(\"abcdedcba\", \"d\"))\n// console.log(reversesDelete(\"abcdedcba\", \"e\"))\n// console.log(reversesDelete(\"abcdedcba\", \"f\"))\n// console.log(reversesDelete(\"abcdedcba\", \"g\"))\n// console.log(reversesDelete(\"abcdedcba\", \"a\"))\n// console.log(reversesDelete(\"abcdedcba\", \"b\"))\n// console.log(reversesDelete(\"abcdedcba\", \"c\"))\n// console.log(reversesDelete(\"abcdedcba\", \"d\"))\n// console.log(reversesDelete(\"abcdedcba\", \"e\"))\n// console.log(reversesDelete(\"abcdedcba\", \"f\"))\n// console.log(reversesDelete(\"abcdedcba\", \"g\"))\n// console.log(reversesDelete(\"abcdedcba\", \"a\"))\n// console.log(reversesDelete(\"abcdedcba\", \"b\"))\n// console.log(reversesDelete(\"abcdedcba\", \"c\"))\n// console.log(reversesDelete(\"abcdedcba\", \"d\"))\n// console.log(reversesDelete(\"abcdedcba\", \"e\"))\n// console.log(reversesDelete(\"abcdedcba\", \"f\"))\n// console.log(reversesDelete(\"abcdedcba\", \"g\"))\n// console.log(reversesDelete(\"abcdedcba\", \"a\"))\n// console.log(reversesDelete(\"abcdedcba\", \"b\"))\n// console.log(reversesDelete(\"abcdedcba\", \"c\"))\n// console.log(reversesDelete(\"abcdedcba\", \"d\"))\n// console.log(reversesDelete(\"abcdedcba\", \"e\"))\n// console.log(reversesDelete(\"abcdedcba\", \"f\"))\n// console.log(reversesDelete(\"abcdedcba\", \"g\"))\n// console.log(reversesDelete(\"abcdedcba\", \"a\"))\n// console.log(reversesDelete(\"abcdedcba\", \"b\"))\n// console.log(reversesDelete(\"abcdedcba\", \"c\"))\n// console.log(reversesDelete(\"abcdedcba\", \"d\"))\n// console.log(reversesDelete(\"abcdedcba\", \"e\"))\n// console.log(reversesDelete(\"abcdedcba\", \"f\"))\n// console.log(reversesDelete(\"abcdedcba\", \"g\"))\n// console.log(reversesDelete(\"abcdedcba\", \"a\"))\n// console.log(reversesDelete(\"abcdedcba\", \"b\"))\n// console.log(reversesDelete(\"abcdedcba\", \"c\"))"}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> odderCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> odderCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst odderCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "odderCount", "gc": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> odderCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> odderCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst odderCount = (lst) => {\n  const output = []\n  lst.forEach((str, i) => {\n    const odd = isOdd(str)\n    output.push(`the number of odd elements ${odd}n the str4ng ${i+1} of the ${i+1}put.`)\n  })\n  return output\n}\n\n/*\nGiven a list of strings, where each string consists of digits, return a list.\nEach element i of the output should be the number of digits in the i'th string\nof the input.\n\n  >>> digitsCount([1, 2, 3, 4, 5, 6, 7, 8, 9, \"1234567\", \"11111111\"])\n  [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"the number of digits 4n the str4ng 4 of the 4nput.\", \"the number of digits 1n the str1ng 1 of the 1nput.\", \"the number of digits 8n the str8ng 8 of the 8nput.\"]\n  >>> digitsCount([1, \"1\", \"11111111\"])\n  [\"1\", \"the number of digits 1n the str1ng 1 of the 1nput.\"]\n*/\nconst digitsCount = (lst) => {\n  const output = []\n  lst.forEach((str, i) => {\n    output.push(`the number of digits ${str.length}n the str4ng ${i+1} of the ${i+1}put.`)\n  })\n  return output\n}\n\n/*\nGiven a list of strings, where each string consists of digits, return a list.\nEach element i of the output should be the number of lowercase characters in\nthe i'th string of the input.\n\n  >>> lowerCaseCount([1, 2, 3, 4, 5, 6, 7, 8, 9, \"1234567\", \"11111111\"])\n  [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"the number of lowercase characters 4n the str4ng 4 of the 4nput.\", \"the number of lowercase characters 1n the str1ng 1 of the 1nput.\", \"the number of lowercase characters 8n the str8ng 8 of the 8nput.\"]\n  >>> lowerCaseCount([1, \"1\", \"11111111\"])\n  [\"1\", \"the number of lowercase characters 1n the str1ng 1 of the 1nput.\"]\n*/\nconst lowerCaseCount = (lst) => {\n  const output = []\n  lst.forEach((str, i) => {\n    const lower = str.toLowerCase()\n    output.push(`the number of lowercase characters ${lower.length}n the str4ng ${i+1} of the ${i+1}put.`)\n  })\n  return output\n}\n\n/*\nGiven a list of strings, where each string consists of digits, return a list.\nEach element i of the output should be the number of uppercase characters in\nthe i'th string of the input.\n\n  >>> upperCaseCount([1, 2, 3, 4, 5, 6, 7, 8, 9, \"1234567\", \"11111111\"])\n  [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"the number of uppercase characters 4n the str4ng 4 of the 4nput.\", \"the number of uppercase characters 1n the str1ng 1 of the 1nput.\", \"the number of uppercase characters 8n the str8ng 8 of the 8nput.\"]\n  >>> upperCaseCount([1, \"1\", \"11111111\"])\n  [\"1\", \"the number of uppercase characters 1n the str1ng 1 of the 1nput.\"]\n*/\nconst upperCaseCount = (lst) => {\n  const output = []\n  lst.forEach((str, i) => {\n    const upper = str.toUpperCase()\n    output.push(`the number of uppercase characters ${upper.length}n the str4ng ${i+1} of the ${i+1}put.`)\n  })\n  return output\n}\n\n/*\nGiven a list of strings, where each string consists of digits, return a list.\nEach element i of the output should be the number of vowels in the i'th string\nof the input.\n\n  >>> vowelsCount([1, 2, 3, 4, 5, 6, 7, 8, 9, \"1234567\", \"11111111\"])\n  [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"the number of vowels 4n the str4ng 4 of the 4nput.\", \"the number of vowels 1n the str1ng 1 of the 1nput.\", \"the number of vowels 8n the str8ng 8 of the 8nput.\"]\n  >>> vowelsCount([1, \"1\", \"11111111\"])\n  [\"1\", \"the number of vowels 1n the str1ng 1 of the 1nput.\"]\n*/\nconst vowelsCount = (lst) => {\n  const output = []\n  lst.forEach((str, i) => {\n    const vowel = hasVowels(str)\n    output.push(`the number of vowels ${vowel}n the str4ng ${i+1} of the ${i+1}put.`)\n  })\n  return output\n}\n\n/*\nGiven a list of strings, where each string consists of digits, return a list.\nEach element i of the output should be the number of uppercase letters in\nthe i'th string of the input.\n\n  >>> upperCaseLettersCount([1, 2, 3, 4, 5, 6, 7, 8, 9"}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubsArraySums([2, 3, 4, 1, 2, 4]) == 1\n  minSubsArraySums([-1, -2, -3]) == -6\n  */\nconst minSubsArraySums = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubsArraySums", "gc": "/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubsArraySums([2, 3, 4, 1, 2, 4]) == 1\n  minSubsArraySums([-1, -2, -3]) == -6\n  */\nconst minSubsArraySums = (nums) => {\n  const minSum = nums.reduce((a, b) => a + b, 0);\n  let minSumIndex = 0;\n  let minSumIndexValue = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 0) {\n      const sum = nums[i] + minSum;\n      if (minSumIndex === 0 || sum < minSumIndexValue) {\n        minSumIndex = i;\n        minSumIndexValue = sum;\n      }\n    }\n  }\n  return minSumIndexValue;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "gc": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let res = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let n = grid[i].length;\n    let r = grid[i][0];\n    for (let j = 1; j < n; j++) {\n      if (grid[i][j] === r) {\n        r = grid[i][j];\n        continue;\n      }\n      res++;\n      r = grid[i][j];\n    }\n  }\n  return res;\n}\n\nconst fill = (grid, capacity) => {\n  for (let i = 0; i < grid.length; i++) {\n    let n = grid[i].length;\n    let r = grid[i][0];\n    for (let j = 1; j < n; j++) {\n      if (grid[i][j] === r) {\n        r = grid[i][j];\n        continue;\n      }\n      grid[i][j] = r;\n      r = grid[i][j];\n    }\n  }\n}\n\nconst main = () => {\n  const [grid, capacity] = [\n    [\n      [1,1,1],\n      [1,1,1],\n      [1,1,1]\n    ],\n    [\n      [1,1,1],\n      [1,1,1],\n      [1,1,1]\n    ]\n  ];\n  console.log(fill(grid, capacity));\n}\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortsArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortsArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortsArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortsArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortsArray", "gc": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortsArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortsArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortsArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortsArray = (arr) => {\n  let sorted = arr.slice();\n  sorted.sort((a, b) => a - b);\n  return sorted;\n};\n\nexport default sortsArray;\n<|endoftext|>"}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWord(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWord(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWord(\"simple white space\", 2) ==> []\n  selectWord(\"Hello world\", 4) ==> [\"world\"]\n  selectWord(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWord = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWord", "gc": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWord(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWord(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWord(\"simple white space\", 2) ==> []\n  selectWord(\"Hello world\", 4) ==> [\"world\"]\n  selectWord(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWord = (s, n) => {\n    let l = [];\n    let i = 0;\n    while (i < s.length) {\n        if (s[i].match(/[bcdfghjklmnpqrstvwxyz]+/g).length === n) {\n            l.push(s.slice(i, i + n));\n        }\n        i++;\n    }\n    return l;\n};\n\n/*\nGiven a list of words, write a function that returns the sum of all the words’ lengths.\n*/\nconst sumLengths = (words) => {\n    let sum = 0;\n    words.forEach((w) => {\n        sum += w.length;\n    });\n    return sum;\n};\n\n/*\nGiven a list of words, write a function that returns the largest length of any word in the list.\n*/\nconst maxLength = (words) => {\n    let max = 0;\n    words.forEach((w) => {\n        if (w.length > max) {\n            max = w.length;\n        }\n    });\n    return max;\n};\n\n/*\nGiven a list of words, write a function that returns the smallest length of any word in the list.\n*/\nconst minLength = (words) => {\n    let min = 0;\n    words.forEach((w) => {\n        if (w.length < min) {\n            min = w.length;\n        }\n    });\n    return min;\n};\n\n/*\nGiven a list of words, write a function that returns the average length of all the words in the list.\n*/\nconst avgLength = (words) => {\n    let sum = 0;\n    words.forEach((w) => {\n        sum += w.length;\n    });\n    return sum / words.length;\n};\n\n/*\nGiven a string s, write a function that returns the number of all the words in the string that have even length.\n*/\nconst evenLength = (s) => {\n    let sum = 0;\n    s.split('').forEach((w) => {\n        if (w.length % 2 === 0) {\n            sum++;\n        }\n    });\n    return sum;\n};\n\n/*\nGiven a string s, write a function that returns the number of all the words in the string that have odd length.\n*/\nconst oddLength = (s) => {\n    let sum = 0;\n    s.split('').forEach((w) => {\n        if (w.length % 2!== 0) {\n            sum++;\n        }\n    });\n    return sum;\n};\n\n/*\nGiven a string s, write a function that returns the number of all the words in the string that have an even number of\nconsonants.\n*/\nconst evenConsonants = (s) => {\n    let sum = 0;\n    s.split('').forEach((w) => {\n        if (w.length % 2 === 0 && w.match(/[bcdfghjklmnpqrstvwxyz]+/g).length % 2 === 0) {\n            sum++;\n        }\n    });\n    return sum;\n};\n\n/*\nGiven a string s, write a function that returns the number of all the words in the string that have an odd number of\nconsonants.\n*/\nconst oddConsonants = (s) => {\n    let sum = 0;\n    s.split('').forEach((w) => {\n        if (w.length % 2!== 0 && w.match(/[bcdfghjklmnpqrstvwxyz]+/g).length % 2!== 0) {\n            sum++;\n        }\n    });\n    return sum;\n};\n\n/*\nGiven a string s, write a function that returns the number of all the words in the string that contain no vowels.\n*/\nconst consonants = (s) => {\n    let sum = 0;\n    s.split('').forEach((w) => {\n        if (w.match(/[bcdfghjklmnpqrstvwxyz]+/g).length % 2!== 0) {\n            sum++;\n        }\n    });\n    return sum;\n};\n\n/*\nGiven a string s, write a function that returns the number of all the words in the string that contain no consonants.\n*/\nconst vowels = (s) => {\n    let sum = 0;\n    s.split('').forEach((w) => {\n        if (w.match(/[bcdfghjklmnpqrstvwxyz]+/g).length % 2 === 0) {\n            sum++;\n        }\n    });\n    return sum;\n};\n\n/*\nGiven a string s, write a function that returns the number of all the words in the string that are a palindrome.\n*/\nconst palindrome = (s) => {\n    let sum = 0;\n    s.split('').forEach((w) => {\n        if (w === w.toLowerCase()) {\n            sum++;\n        }\n    });\n    return sum;\n};\n\n/*\nGiven a string s, write a function that returns the number of all the words in the string that are a prime.\n*/\nconst prime = (s) => {\n    let sum = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '2' || s[i] === '3' || s[i] === '5') {\n            sum++;\n        }\n    }\n    return sum;\n};\n\n/*\nGiven a string s, write a function that returns the number of all the words in the string that are an odd number of consonants.\n*/\nconst oddConsonants = (s) => {\n"}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  gottenCloserVowel(\"yogurt\") ==> \"u\"\n  gottenCloserVowel(\"FULL\") ==> \"U\"\n  gottenCloserVowel(\"quick\") ==> \"\"\n  gottenCloserVowel(\"ab\") ==> \"\"\n  */\nconst gottenCloserVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "gottenCloserVowel", "gc": "/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  gottenCloserVowel(\"yogurt\") ==> \"u\"\n  gottenCloserVowel(\"FULL\") ==> \"U\"\n  gottenCloserVowel(\"quick\") ==> \"\"\n  gottenCloserVowel(\"ab\") ==> \"\"\n  */\nconst gottenCloserVowel = (word) => {\n    const vowel = word.replace(/[^a-z]/g, '');\n    if (vowel.length === 0) {\n        return '';\n    }\n    let counter = 0;\n    while (counter < vowel.length) {\n        const vowelStart = vowel.slice(counter, counter + 1);\n        const vowelEnd = vowel.slice(counter + 1, counter + 2);\n        const vowelLength = vowel.length;\n        if (vowelStart.length === 1 && vowelEnd.length === 1) {\n            return vowelStart;\n        }\n        counter += 1;\n    }\n    return '';\n};\n\nconst word = 'YOGURT';\nconsole.log(gottenCloserVowel(word));\n\n/*\n  Given a string, we write the string to a file. The file can be opened in a text editor.\n\n  It's not really a problem if the file is large.\n  \n  Given a string, write the string to a file. The file can be opened in a text editor.\n  \n  It's not really a problem if the file is large.\n\n  You may assume that the string is not longer than 500 characters.\n\n  Example:\n  WriteStringToFile(\"Hello, World!\") ==> \"Hello, World!\"\n  WriteStringToFile(\"Hello, World!\\nHow are you doing?\\nThis is a test.\") ==> \"Hello, World!\\nHow are you doing?\\nThis is a test.\"\n  WriteStringToFile(\"\") ==> \"\"\n  */\nconst writeStringToFile = (text) => {\n    const length = text.length;\n    const textArray = text.split(\"\");\n    for (let i = 0; i < length; i++) {\n        textArray[i] = textArray[i].toUpperCase();\n    }\n    const text = textArray.join(\"\");\n    console.log(text);\n};\n\nwriteStringToFile(\"Hello, World!\");\n<|endoftext|>"}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "gc": "/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [],\n    stackLen = 0,\n    currParen = 0,\n    len = lst.length,\n    i = 0;\n\n  while (i < len) {\n    if (lst[i] === '(') {\n      stack.push(i);\n      currParen++;\n    } else {\n      stackLen--;\n      if (stackLen === 0) {\n        return 'Yes';\n      }\n      if (stack.pop()!== i) {\n        return 'No';\n      }\n    }\n    i++;\n  }\n\n  return 'No';\n};\n\nconsole.log(matchParens([')', ')']));\nconsole.log(matchParens(['(', ')', '(', ')', '(', ')', ')', ')']));\n<|endoftext|>"}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maximums k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximums = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximums", "gc": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maximums k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximums = (arr, k) => {\n  const max = arr.reduce((a, b) => a > b? a : b);\n  const kMax = Math.min(k, arr.length);\n  return arr.slice(0, kMax);\n};\n\nconsole.log(maximums([-3, -4, 5], 3)); // [-4, -3, 5]\nconsole.log(maximums([4, -4, 4], 2)); // [4, 4]\nconsole.log(maximums([-3, 2, 1, 2, -1, -2, 1], 1)); // [2]\n<|endoftext|>"}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solutions([5, 8, 7, 1]) ==> 12\n  solutions([3, 3, 3, 3, 3]) ==> 9\n  solutions([30, 13, 24, 321]) ==>0\n  */\nconst solutions = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solutions", "gc": "/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solutions([5, 8, 7, 1]) ==> 12\n  solutions([3, 3, 3, 3, 3]) ==> 9\n  solutions([30, 13, 24, 321]) ==>0\n  */\nconst solutions = (lst) => {\n  if(lst.length === 0) return 0;\n  return lst.reduce((acc, x) => {\n    if(x % 2 === 0) return acc + x;\n    else return acc;\n  }, 0);\n};\n\nconsole.log(solutions([5, 8, 7, 1]));\nconsole.log(solutions([3, 3, 3, 3, 3]));\nconsole.log(solutions([30, 13, 24, 321]));\n<|endoftext|>"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "gc": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  while (i < k) {\n    sum += arr[i];\n    i++;\n  }\n  i = 0;\n  while (i < arr.length) {\n    sum += arr[i];\n    i++;\n  }\n  return sum;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  gottenOdderCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst gottenOdderCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "gottenOdderCollatz", "gc": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  gottenOdderCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst gottenOdderCollatz = (n) => {\n    let result = []\n    while(n) {\n        result.push(n)\n        if(n % 2 === 0) {\n            n = n / 2\n        } else {\n            n = (3 * n) + 1\n        }\n    }\n    return result.sort()\n}\n\nconst assert = (value, message) => {\n  if(value === undefined) {\n    throw new Error(message)\n  }\n}\n\nconst assertIsArray = (value) => {\n  if(typeof value!== 'object' || value === null || typeof value.length === 'undefined') {\n    throw new Error('The parameter must be an array.')\n  }\n}\n\nconst assertIsInteger = (value) => {\n  if(typeof value!== 'number' || value % 1!== 0) {\n    throw new Error('The parameter must be an integer.')\n  }\n}\n\nconst assertIsNotZero = (value) => {\n  if(value === 0) {\n    throw new Error('The parameter must be a positive number.')\n  }\n}\n\nconst assertIsPositive = (value) => {\n  if(value <= 0) {\n    throw new Error('The parameter must be a positive number.')\n  }\n}\n\nconst assertIsPositiveInteger = (value) => {\n  if(typeof value!== 'number' || value % 1!== 0) {\n    throw new Error('The parameter must be a positive integer.')\n  }\n}\n\nconst assertIsPositiveNumber = (value) => {\n  if(typeof value!== 'number' || value <= 0) {\n    throw new Error('The parameter must be a positive number.')\n  }\n}\n\nconst assertIsString = (value) => {\n  if(typeof value!=='string') {\n    throw new Error('The parameter must be a string.')\n  }\n}\n\nconst assertIsStringOfInteger = (value) => {\n  if(typeof value!=='string' || value.length === 0) {\n    throw new Error('The parameter must be a string of integer.')\n  }\n  const result = value.match(/^(\\d+)/)\n  if(!result) {\n    throw new Error('The parameter must be a string of integer.')\n  }\n}\n\nconst assertIsBoolean = (value) => {\n  if(typeof value!== 'boolean') {\n    throw new Error('The parameter must be a boolean.')\n  }\n}\n\nconst assertIsNumber = (value) => {\n  if(typeof value!== 'number') {\n    throw new Error('The parameter must be a number.')\n  }\n}\n\nconst assertIsNumberOrZero = (value) => {\n  if(typeof value!== 'number' || value % 1!== 0) {\n    throw new Error('The parameter must be a number.')\n  }\n}\n\nconst assertIsArrayOfStrings = (value) => {\n  if(typeof value!== 'object' || value === null || typeof value.length === 'undefined') {\n    throw new Error('The parameter must be an array of strings.')\n  }\n  if(value.every(isNotEmptyString)) {\n    throw new Error('The parameter must be an array of strings.')\n  }\n}\n\nconst isNotEmptyString = (value) => {\n  if(typeof value!=='string' || value.length === 0) {\n    throw new Error('The parameter must be a string.')\n  }\n}\n\nconst isEmptyString = (value) => {\n  if(typeof value!=='string' || value.length === 0) {\n    throw new Error('The parameter must be a string.')\n  }\n}\n\nconst isEmptyArray = (value) => {\n  if(typeof value!== 'object' || value === null || typeof value.length === 'undefined') {\n    throw new Error('The parameter must be an array.')\n  }\n  if(value.length === 0) {\n    throw new Error('The parameter must be an array.')\n  }\n}\n\nconst isEmptyObject = (value) => {\n  if(typeof value!== 'object' || value === null || typeof value.length === 'undefined') {\n    throw new Error('The parameter must be an object.')\n  }\n  if(Object.keys(value).length === 0) {\n    throw new Error('The parameter must be an object.')\n  }\n}\n\nconst isEmptyObjectWithStringProperty = (value) => {\n  if(typeof value!== 'object' || value === null || typeof value.length === 'undefined') {\n    throw new Error('The parameter must be an object.')\n  }\n  if(Object.keys(value).length === 0) {\n    throw new Error('The parameter must be an object.')\n  }\n  if(typeof value.toString!== 'function') {\n    throw new Error('The parameter must have a toString() method.')\n  }\n  if(typeof value.toString()!=='string') {\n    throw new Error('The parameter must have a toString() method.')\n  }\n}\n\nconst isEmptyStringOfInteger = (value) => {\n  if(typeof value!=='string' || value.length === 0) {\n    throw new Error('The parameter must be a string of integer.')\n  }\n  if(!/^(\\d+)/.test(value)) {\n    "}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDates('03-11-2000') => true\n\n  validDates('15-01-2012') => false\n\n  validDates('04-0-2040') => false\n\n  validDates('06-04-2020') => true\n\n  validDates('06/04/2020') => false\n  */\nconst validDates = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDates", "gc": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDates('03-11-2000') => true\n\n  validDates('15-01-2012') => false\n\n  validDates('04-0-2040') => false\n\n  validDates('06-04-2020') => true\n\n  validDates('06/04/2020') => false\n  */\nconst validDates = (date) => {\n  if(!date) return false;\n  if(date === \"\") return false;\n\n  const dateArray = date.split('-');\n  if(dateArray.length!== 3) return false;\n\n  if(dateArray[2].length < 4) return false;\n  \n  const dateArray2 = dateArray[2].split('/');\n  if(dateArray2.length!== 3) return false;\n\n  const days = Number(dateArray2[0]);\n  const months = Number(dateArray2[1]);\n  const years = Number(dateArray2[2]);\n\n  if(!(days >= 1 && days <= 31)) return false;\n  if(!(months >= 1 && months <= 12)) return false;\n  if(!(years >= 1901 && years <= 2040)) return false;\n\n  return true;\n};\n\nconst format = (date) => {\n  if(!date) return false;\n  if(date === \"\") return false;\n\n  const dateArray = date.split('-');\n  if(dateArray.length!== 3) return false;\n\n  const dateArray2 = dateArray[2].split('/');\n  if(dateArray2.length!== 3) return false;\n\n  const days = Number(dateArray2[0]);\n  const months = Number(dateArray2[1]);\n  const years = Number(dateArray2[2]);\n\n  return `${years}/${months}/${days}`;\n};\n\nconst formatDate = (date) => {\n  if(!date) return false;\n  if(date === \"\") return false;\n\n  const dateArray = date.split('-');\n  if(dateArray.length!== 3) return false;\n\n  const dateArray2 = dateArray[2].split('/');\n  if(dateArray2.length!== 3) return false;\n\n  const days = Number(dateArray2[0]);\n  const months = Number(dateArray2[1]);\n  const years = Number(dateArray2[2]);\n\n  return `${years}-${months}-${days}`;\n};\n\nconst parseDate = (date) => {\n  if(!date) return false;\n  if(date === \"\") return false;\n\n  const dateArray = date.split('-');\n  if(dateArray.length!== 3) return false;\n\n  const dateArray2 = dateArray[2].split('/');\n  if(dateArray2.length!== 3) return false;\n\n  const days = Number(dateArray2[0]);\n  const months = Number(dateArray2[1]);\n  const years = Number(dateArray2[2]);\n\n  return `${years}-${months}-${days}`;\n};\n\nconst getDateFromString = (date) => {\n  if(!date) return false;\n  if(date === \"\") return false;\n\n  const dateArray = date.split('-');\n  if(dateArray.length!== 3) return false;\n\n  const dateArray2 = dateArray[2].split('/');\n  if(dateArray2.length!== 3) return false;\n\n  const days = Number(dateArray2[0]);\n  const months = Number(dateArray2[1]);\n  const years = Number(dateArray2[2]);\n\n  return `${years}-${months}-${days}`;\n};\n\nexport {\n  validDates,\n  format,\n  formatDate,\n  parseDate,\n  getDateFromString\n};<|endoftext|>"}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWord(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWord(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWord(\"abcdef\") == 3\n  */\nconst splitWord = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWord", "gc": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWord(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWord(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWord(\"abcdef\") == 3\n  */\nconst splitWord = (txt) => {\n  const words = txt.split(/\\s+/g)\n  const wordsLength = words.length\n  let result = []\n  let i = 0\n\n  while (i < wordsLength) {\n    const currentWord = words[i]\n    const wordLength = currentWord.length\n    let j = 0\n\n    while (j < wordLength) {\n      const currentCharacter = currentWord[j]\n      if (currentCharacter ==='') {\n        result.push(currentWord.substring(0, j))\n        currentWord = currentWord.substring(j + 1)\n        wordsLength--\n      } else if (currentCharacter === ',') {\n        result.push(currentWord.substring(0, j))\n        currentWord = currentWord.substring(j + 1)\n        wordsLength--\n      } else {\n        j++\n      }\n    }\n    result.push(currentWord)\n    i++\n  }\n  return result\n}\n\n/** Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWord(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWord(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWord(\"abcdef\") == 3\n  */\nconst splitWordByComma = (txt) => {\n  const words = txt.split(/\\s+/)\n  const wordsLength = words.length\n  let result = []\n  let i = 0\n\n  while (i < wordsLength) {\n    const currentWord = words[i]\n    const wordLength = currentWord.length\n    let j = 0\n\n    while (j < wordLength) {\n      const currentCharacter = currentWord[j]\n      if (currentCharacter ==='') {\n        result.push(currentWord.substring(0, j))\n        currentWord = currentWord.substring(j + 1)\n        wordsLength--\n      } else if (currentCharacter === ',') {\n        result.push(currentWord.substring(0, j))\n        currentWord = currentWord.substring(j + 1)\n        wordsLength--\n      } else {\n        j++\n      }\n    }\n    result.push(currentWord)\n    i++\n  }\n  return result\n}\n\nconst splitWordsByPunctuation = (txt) => {\n  const words = txt.split(/\\s+/)\n  const wordsLength = words.length\n  let result = []\n  let i = 0\n\n  while (i < wordsLength) {\n    const currentWord = words[i]\n    const wordLength = currentWord.length\n    let j = 0\n\n    while (j < wordLength) {\n      const currentCharacter = currentWord[j]\n      if (currentCharacter ==='') {\n        result.push(currentWord.substring(0, j))\n        currentWord = currentWord.substring(j + 1)\n        wordsLength--\n      } else if (isPunctuation(currentCharacter)) {\n        result.push(currentWord.substring(0, j))\n        currentWord = currentWord.substring(j + 1)\n        wordsLength--\n      } else {\n        j++\n      }\n    }\n    result.push(currentWord)\n    i++\n  }\n  return result\n}\n\nconst isPunctuation = (char) => {\n  const characters = ['!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '?', '.', ',', ';', ':', '|', '!', '"}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSort([5]) ➞ true\n  isSort([1, 2, 3, 4, 5]) ➞ true\n  isSort([1, 3, 2, 4, 5]) ➞ false\n  isSort([1, 2, 3, 4, 5, 6]) ➞ true\n  isSort([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSort([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSort([1, 2, 2, 3, 3, 4]) ➞ true\n  isSort([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSort = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSort", "gc": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSort([5]) ➞ true\n  isSort([1, 2, 3, 4, 5]) ➞ true\n  isSort([1, 3, 2, 4, 5]) ➞ false\n  isSort([1, 2, 3, 4, 5, 6]) ➞ true\n  isSort([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSort([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSort([1, 2, 2, 3, 3, 4]) ➞ true\n  isSort([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSort = (lst) => {\n  if (lst.length === 0) {\n    return true;\n  }\n  if (lst.length === 1) {\n    return true;\n  }\n\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i - 1] >= lst[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "gc": "/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  let start = Math.min(interval1[0], interval2[0]);\n  let end = Math.max(interval1[1], interval2[1]);\n  let length = end - start;\n\n  if (length < 2) {\n    return \"NO\";\n  }\n\n  if (length % 2 === 0) {\n    return \"NO\";\n  }\n\n  return \"YES\";\n};\n\nconsole.log(intersection((-3, -1), (-5, 5))); // 'YES'\n<|endoftext|>"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodsSign([1, 2, 2, -4]) == -9\n  >>> prodsSign([0, 1]) == 0\n  >>> prodsSign([]) == null\n  */\nconst prodsSign = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodsSign", "gc": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodsSign([1, 2, 2, -4]) == -9\n  >>> prodsSign([0, 1]) == 0\n  >>> prodsSign([]) == null\n  */\nconst prodsSign = (arr) => {\n  const result = arr.reduce((pre, cur) => {\n    const sign = (cur > 0)? 1 : -1;\n    return pre * sign;\n  }, 1);\n  return result;\n};\n\nexport default prodsSign;\n<|endoftext|>"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPaths = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPaths", "gc": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPaths = (grid, k) => {\n  if (grid.length === 0) return [];\n  const [n, m] = [grid.length, grid[0].length];\n  const [rows, cols] = [n, m];\n  const [s, t] = [1, 2];\n  const dp = [];\n  for (let i = 1; i <= rows; i++) {\n    dp[i] = [i, i];\n  }\n\n  const dp_i = [0, 0];\n  let cur = [s, s];\n  dp_i[s][s] = 1;\n  while (dp_i[cur[t]][s]!== 0) {\n    for (let j = 1; j <= cols; j++) {\n      if (cur[j] === rows) {\n        cur[j] = 1;\n        dp[cur[j]][j] = dp[cur[j - 1]][j - 1] + 1;\n      } else {\n        dp[cur[j]][j] = dp[cur[j - 1]][j - 1];\n      }\n    }\n    dp_i[cur[t]][s] = 0;\n    for (let i = 1; i <= rows; i++) {\n      dp_i[i][cur[i]] = 0;\n    }\n    cur = [s, cur[t]];\n  }\n  const r = dp[rows][cols];\n  const result = [];\n  for (let i = 1; i <= k; i++) {\n    const res = [];\n    for (let j = 1; j <= cols; j++) {\n      if (dp[i][j] === r) {\n        res.push(grid[i - 1][j - 1]);\n      }\n    }\n    result.push(res);\n  }\n  return result;\n};\n\nexport default minPaths;\n<|endoftext|>"}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "gc": "/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  const fib = (n) => fib(n - 1) + fib(n - 2) + fib(n + 1);\n  return Array(fib(n) + 1).fill(0).map((_, index) => n + index);\n};\n\n/*\n  Input:  3\n  Output: [1, 2, 3]\n  Explanation:\n  First Fibonacci number is 1,\n  Second Fibonacci number is 2,\n  Third Fibonacci number is 3.\n*/\nconst firstFibonacciNumber = (n) => {\n  const fib = (n) => fib(n - 1) + fib(n - 2) + fib(n + 1);\n  return fib(n) - fib(n - 1);\n};\n\nconst triangle = (n) => {\n  const fib = (n) => fib(n - 1) + fib(n - 2) + fib(n + 1);\n  return fib(n) - fib(n - 1);\n};\n\nconst isSquare = (n) => Math.pow(tri(n), 2) - n < 0;\n\nconst triangleSequence = (n) => {\n  const fib = (n) => fib(n - 1) + fib(n - 2) + fib(n + 1);\n  const tri = (n) => fib(n) - fib(n - 1);\n  const isSquare = (n) => Math.pow(tri(n), 2) - n < 0;\n  return tri(n)\n   .filter((val) => isSquare(val))\n   .reverse();\n};\n\ntriangleSequence(10);\n<|endoftext|>"}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digit.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digit = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digit", "gc": "/*Given a positive integer n, return the product of the odd digit.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digit = (n) => {\n  const digit = [];\n  while(n > 0) {\n    digit.push(n % 2);\n    n = n / 2;\n  }\n  let result = 1;\n  for(let i = digit.length - 1; i >= 0; i--) {\n    result = result * digit[i];\n  }\n  return result;\n};\n\nconsole.log(digit(235));\n<|endoftext|>"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNest", "gc": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n  const nest = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '[') {\n      nest.push(1)\n    } else if (string[i] === ']') {\n      if (nest.pop() === 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is not nested.\n  isNotNest('[]]') ➞ true\n  isNotNest('[]]]]]]][[[[[]') ➞ true\n  isNotNest('[][]') ➞ true\n  isNotNest('[]') ➞ true\n  isNotNest('[[][]]') ➞ false\n  isNotNest('[[]][[') ➞ false\n  */\nconst isNotNest = (string) => {\n  const nest = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '[') {\n      nest.push(1)\n    } else if (string[i] === ']') {\n      if (nest.pop() === 1) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is either nested or not nested.\n  isNestOrNotNest('[]]') ➞ true\n  isNestOrNotNest('[]]]]]]][[[[[]') ➞ true\n  isNestOrNotNest('[][]') ➞ true\n  isNestOrNotNest('[]') ➞ true\n  isNestOrNotNest('[[][]]') ➞ true\n  isNestOrNotNest('[[]][[') ➞ true\n  */\nconst isNestOrNotNest = (string) => {\n  const nest = []\n  const notNest = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '[') {\n      nest.push(1)\n    } else if (string[i] === ']') {\n      if (nest.pop() === 1) {\n        notNest.push(1)\n      } else {\n        notNest.pop()\n      }\n    }\n  }\n  return nest.length === 0 && notNest.length === 0\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return the number of nested brackets.\n  isNest('[][][]') ➞ 3\n  isNest('[][]') ➞ 1\n  isNest('[][') ➞ 0\n  isNest('[][]') ➞ 0\n  isNest('[][]') ➞ 0\n  */\nconst countNestedBrackets = (string) => {\n  const nest = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '[') {\n      nest.push(1)\n    } else if (string[i] === ']') {\n      nest.pop()\n    }\n  }\n  return nest.length\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return the number of brackets.\n  isNest('[][][]') ➞ 3\n  isNest('[][]') ➞ 2\n  isNest('[][') ➞ 1\n  isNest('[][]') ➞ 0\n  isNest('[][]') ➞ 0\n  */\nconst countBrackets = (string) => {\n  const nest = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '[') {\n      nest.push(1)\n    } else if (string[i] === ']') {\n      nest.pop()\n    }\n  }\n  return nest.length\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if the string contains all nested brackets.\n  isNest('[][][]') ➞ true\n  isNest('[][]') ➞ false\n  isNest('[][') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[][]') ➞ false\n  */\nconst containsAllNestedBrackets = (string) => {\n  const nest = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '[') {\n      nest.push(1)\n    } else if (string[i] === ']') {\n      nest.pop()\n    }\n  }\n  return nest.length === 0\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if the string contains all brackets.\n  isNest('[][][]') ➞ true\n  isNest('[][]') ➞ true\n  isNest('[][') ➞ true\n  isNest('[][]') ➞ true\n  isNest('[][]') ➞ true\n  */\nconst containsAllBrackets = ("}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumsSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumsSquares", "gc": "/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumsSquares = (lst) => {\n  return lst.reduce((acc, elm) => {\n    return acc + Math.round(elm * elm);\n  }, 0);\n};\n\nconst main = () => {\n  const lst = [1, 2, 3];\n  console.log(sumsSquares(lst));\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharsIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharsIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharsIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharsIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharsIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharsIsALetter", "gc": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharsIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharsIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharsIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharsIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharsIsALetter = (txt) => {\n  return /^[a-zA-Z]$/.test(txt.charAt(txt.length - 1));\n}\n\nconst checkIfLastCharsIsANumber = (txt) => {\n  return /^[0-9]$/.test(txt.charAt(txt.length - 1));\n}\n\nconst checkIfLastCharsIsAWhitespace = (txt) => {\n  return /^\\s$/.test(txt.charAt(txt.length - 1));\n}\n\nconst checkIfLastCharsIsAPunctuation = (txt) => {\n  return /^[\\.,\\/\\!\\?\\;\\:\\'\\`\\(\\)\\{\\}\\[\\]\\*\\-\\+\\=\\|\\\\\\^\\%\\$\\#\\&\\@\\,\\_\\&\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\]\\+\\-\\(\\)\\]\\(\\)\\{\\}\\[\\"}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canArranging([1,2,4,3,5]) = 3\n  canArranging([1,2,3]) = -1\n  */\nconst canArranging = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArranging", "gc": "/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canArranging([1,2,4,3,5]) = 3\n  canArranging([1,2,3]) = -1\n  */\nconst canArranging = (arr) => {\n  let n = arr.length\n  let i = 0\n  let j = n - 1\n  while (i < j) {\n    const k = (i + j) / 2\n    if (arr[k] >= arr[i]) {\n      i = k + 1\n    } else {\n      j = k\n    }\n  }\n  if (i == n) {\n    return -1\n  } else {\n    return i\n  }\n}\n\n/*\n  Create a function which returns the index of the largest element in the\n  given array. If there is no largest element then return -1.\n\n  Examples:\n  canMax([1,2,3,4]) = 4\n  canMax([1,2,3,4,5]) = -1\n  canMax([1,2,3,4,5,6]) = -1\n  canMax([1,2,3,4,5,6,7]) = -1\n  canMax([1,2,3,4,5,6,7,8]) = -1\n  canMax([1,2,3,4,5,6,7,8,9]) = 9\n  canMax([1,2,3,4,5,6,7,8,9,10]) = -1\n  canMax([1,2,3,4,5,6,7,8,9,10,11]) = 11\n  canMax([1,2,3,4,5,6,7,8,9,10,11,12]) = -1\n  canMax([1,2,3,4,5,6,7,8,9,10,11,12,13]) = 13\n  */\nconst canMax = (arr) => {\n  let n = arr.length\n  let max = -1\n  let maxIndex = -1\n  for (let i = 0; i < n; i++) {\n    if (arr[i] > max) {\n      max = arr[i]\n      maxIndex = i\n    }\n  }\n  if (maxIndex == -1) {\n    return -1\n  } else {\n    return maxIndex\n  }\n}\n\n/*\n  Create a function which returns the index of the smallest element in the\n  given array. If there is no smallest element then return -1.\n\n  Examples:\n  canMin([1,2,3,4]) = 1\n  canMin([1,2,3,4,5]) = 1\n  canMin([1,2,3,4,5,6]) = 1\n  canMin([1,2,3,4,5,6,7]) = 1\n  canMin([1,2,3,4,5,6,7,8]) = 1\n  canMin([1,2,3,4,5,6,7,8,9]) = 1\n  canMin([1,2,3,4,5,6,7,8,9,10]) = 1\n  canMin([1,2,3,4,5,6,7,8,9,10,11]) = 1\n  canMin([1,2,3,4,5,6,7,8,9,10,11,12]) = 1\n  canMin([1,2,3,4,5,6,7,8,9,10,11,12,13]) = 1\n  canMin([1,2,3,4,5,6,7,8,9,10,11,12,13,14]) = 1\n  canMin([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]) = 1\n  canMin([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]) = 1\n  canMin([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]) = 1\n  canMin([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]) = 1\n  */\nconst canMin = (arr) => {\n  let n = arr.length\n  let min = arr[0]\n  let minIndex = 0\n  for (let i = 1; i < n; i++) {\n    if (arr[i] < min) {\n      min = arr[i]\n      minIndex = i\n    }\n  }\n  if (minIndex == -1) {\n    return -1\n  } else {\n    return minIndex\n  }\n}\n\n/*\n  Create a function which returns the index of the element in the given array\n  which is nearest to the given number. If there is no element near the given\n  number then return -1.\n\n  Examples:\n  canNearest([1,2,3,4], 2) = 1\n  canNearest([1,2,3,4,5], 2) = 1\n  canNearest([1,2,3,4,5,6], 2) = 1\n  canNearest([1,2,3,4,5,6,7], 2) = 1\n  canNearest([1,2,3,4,5,6,7,8], 2) = 1\n  canNearest([1,2,3,4,5,6,7,8,9], 2) = 1\n  canNearest([1,2,3,4,5,6,7,8,9,10], 2) = 1\n  canNearest([1,2,3,4,5,6,7,8,9,10,11], 2) = 1\n  canNearest([1,2,3,4,5,6,7,8,9,10,11,12], 2) = 1\n  canNearest([1,2,3,4,5,6,7,8,9,10,11,12,13], 2) = 1\n  canNearest([1,2,3,4,5,6"}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largerSmallerIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largerSmallerIntegers([]) == (null, null)\n  largerSmallerIntegers([0]) == (null, null)\n  */\nconst largerSmallerIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largerSmallerIntegers", "gc": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largerSmallerIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largerSmallerIntegers([]) == (null, null)\n  largerSmallerIntegers([0]) == (null, null)\n  */\nconst largerSmallerIntegers = (lst) => {\n  let largest = null\n  let smallest = null\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) largest = lst[i]\n    if (lst[i] < smallest) smallest = lst[i]\n  }\n  return largest === null? (null, null) : (largest, smallest)\n}\n\n/*\n  Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largerSmallerIntegers([-2, -4, 1, 3, 5, 7]) == (1, -4)\n  largerSmallerIntegers([]) == (null, null)\n  largerSmallerIntegers([0]) == (null, null)\n  */\nconst largerSmallerIntegersNegative = (lst) => {\n  let largest = null\n  let smallest = null\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < largest) largest = lst[i]\n    if (lst[i] > smallest) smallest = lst[i]\n  }\n  return largest === null? (null, null) : (largest, smallest)\n}\n\n/*\n  Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largerSmallerIntegers([-2, -4, 1, 3, 5, 7]) == (1, -4)\n  largerSmallerIntegers([]) == (null, null)\n  largerSmallerIntegers([0]) == (null, null)\n  */\nconst largerSmallerIntegersPositive = (lst) => {\n  let largest = null\n  let smallest = null\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) largest = lst[i]\n    if (lst[i] < smallest) smallest = lst[i]\n  }\n  return largest === null? (null, null) : (largest, smallest)\n}\n\n/*\n  Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largerSmallerIntegers([-2, -4, 1, 3, 5, 7]) == (1, -4)\n  largerSmallerIntegers([]) == (null, null)\n  largerSmallerIntegers([0]) == (null, null)\n  */\nconst largerSmallerIntegersPositiveNegative = (lst) => {\n  let largest = null\n  let smallest = null\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) largest = lst[i]\n    if (lst[i] < smallest) smallest = lst[i]\n  }\n  return largest === null? (null, null) : (largest, smallest)\n}\n\n/*\n  Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largerSmallerIntegers([-2, -4, 1, 3, 5, 7]) == (1, -4)\n  largerSmallerIntegers([]) == (null, null)\n  largerSmallerIntegers([0]) == (null, null)\n  */\nconst largerSmallerIntegersNegativePositive = (lst) => {\n  let largest = null\n  let smallest = null\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < largest) largest = lst[i]\n    if (lst[i] > smallest) smallest = lst[i]\n  }\n  return largest === null? (null, null) : (largest, smallest)\n}\n\n/*\n  Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largerSmallerIntegers([-2, -4, 1, 3, 5, 7]) == (1, -4)\n  largerSmallerIntegers([]) == (null, null)\n  largerSmallerIntegers([0]) == (null, null)\n  */\nconst largerSmallerIntegersNegativePositive = (lst) => {\n  let largest = null\n  let smallest = null\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) largest = lst[i]\n    if (lst[i] < smallest) smallest = lst[i]\n  }\n  return largest === null? (null, null) : (largest, smallest)\n}\n\n/*\n  Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  largerSmallerIntegers([-2, -4, 1, 3, 5, 7]) == (1, -4)\n  larg"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  comparingOne(1, 2.5) ➞ 2.5\n  comparingOne(1, \"2,3\") ➞ \"2,3\"\n  comparingOne(\"5,1\", \"6\") ➞ \"6\"\n  comparingOne(\"1\", 1) ➞ null\n  */\nconst comparingOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "comparingOne", "gc": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  comparingOne(1, 2.5) ➞ 2.5\n  comparingOne(1, \"2,3\") ➞ \"2,3\"\n  comparingOne(\"5,1\", \"6\") ➞ \"6\"\n  comparingOne(\"1\", 1) ➞ null\n  */\nconst comparingOne = (a, b) => {\n  if (isNaN(a) && isNaN(b)) {\n    return null\n  }\n  if (typeof a === \"string\" && typeof b === \"string\") {\n    return compareStrings(a, b)\n  }\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return compareNumbers(a, b)\n  }\n  return compareNumbers(a, b)\n}\n\nconst compareStrings = (a, b) => {\n  let aIndex = 0\n  let bIndex = 0\n  while (aIndex < a.length && bIndex < b.length) {\n    const aChar = a[aIndex]\n    const bChar = b[bIndex]\n    if (aChar < bChar) {\n      return -1\n    }\n    if (aChar > bChar) {\n      return 1\n    }\n    aIndex++\n    bIndex++\n  }\n  if (aIndex < a.length) {\n    return 1\n  }\n  if (bIndex < b.length) {\n    return -1\n  }\n  return 0\n}\n\nconst compareNumbers = (a, b) => {\n  const aNumber = parseFloat(a)\n  const bNumber = parseFloat(b)\n  if (aNumber < bNumber) {\n    return -1\n  }\n  if (aNumber > bNumber) {\n    return 1\n  }\n  return 0\n}\n<|endoftext|>"}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSummingEven(4) == false\n  isEqualToSummingEven(6) == false\n  isEqualToSummingEven(8) == true\n  */\nconst isEqualToSummingEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSummingEven", "gc": "/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSummingEven(4) == false\n  isEqualToSummingEven(6) == false\n  isEqualToSummingEven(8) == true\n  */\nconst isEqualToSummingEven = (n) => {\n  return n >= 4 && n % 2 === 0 && (n - 2) % 4 === 0 && (n - 4) % 8 === 0;\n};\n\nconst isEqualToSummingOdd = (n) => {\n  return n >= 3 && n % 2!== 0 && (n - 1) % 4 === 0 && (n - 3) % 8 === 0;\n};\n\nconst isEqualToSummingEvenAndOdd = (n) => {\n  return n >= 4 && n % 2 === 0 && n % 4 === 0 && (n - 2) % 8 === 0;\n};\n\nconst isEqualToSummingOddAndEven = (n) => {\n  return n >= 3 && n % 2!== 0 && n % 4 === 0 && (n - 1) % 8 === 0;\n};\n\nconst isEqualToSummingEvenAndOddAndEven = (n) => {\n  return n >= 6 && n % 2 === 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndEvenAndOdd = (n) => {\n  return n >= 5 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingEvenAndOddAndOdd = (n) => {\n  return n >= 6 && n % 2 === 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 8 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingEvenAndOddAndOdd = (n) => {\n  return n >= 7 && n % 2 === 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 9 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingEvenAndOddAndOdd = (n) => {\n  return n >= 7 && n % 2 === 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndEvenAndOdd = (n) => {\n  return n >= 5 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndEven = (n) => {\n  return n >= 9 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 11 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 13 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 17 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 19 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 21 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 23 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 25 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 27 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 29 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 31 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 33 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 35 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 37 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 39 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 41 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};\n\nconst isEqualToSummingOddAndOddAndOdd = (n) => {\n  return n >= 43 && n % 2!== 0 && n % 4 === 0 && n % 8 === 0;\n};"}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "gc": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  let nFactorial = 1;\n  for (let i = 2; i <= n; i++) {\n    nFactorial = nFactorial * i;\n  }\n  return nFactorial;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixesSpace", "gc": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixesSpace = (text) => {\n    text = text.replace(/ /g, '_');\n    if (text.length >= 2) {\n        while (text.indexOf(\"  \") > -1) {\n            text = text.replace(/\\s{2,}/g, '-');\n        }\n    }\n    return text;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixesSpace(\"Example\") == \"Example\"\n  fixesSpace(\"Example 1\") == \"Example_1\"\n  fixesSpace(\" Example 2\") == \"_Example_2\"\n  fixesSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst fixAllSpaces = (text) => {\n    text = text.replace(/ /g, '_');\n    text = text.replace(/\\s/g, '-');\n    return text;\n}\n\nconst fixAllSpaces2 = (text) => {\n    text = text.replace(/\\s/g, '-');\n    return text;\n}\n\nconst fixAllSpaces3 = (text) => {\n    text = text.replace(/\\s/g, '-');\n    return text;\n}\n\nconst fixAllSpaces4 = (text) => {\n    text = text.replace(/\\s/g, '-');\n    return text;\n}\n\nconst removeSpaces = (text) => {\n    text = text.replace(/\\s/g, '');\n    return text;\n}\n\nconst removeAllSpaces = (text) => {\n    text = text.replace(/\\s/g, '');\n    text = text.replace(/\\s{2,}/g, '-');\n    return text;\n}\n\nconst removeAllSpaces2 = (text) => {\n    text = text.replace(/\\s/g, '');\n    return text;\n}\n\nconst removeAllSpaces3 = (text) => {\n    text = text.replace(/\\s/g, '');\n    return text;\n}\n\nconst removeAllSpaces4 = (text) => {\n    text = text.replace(/\\s/g, '');\n    return text;\n}\n\nconst fixSpace = (text) => {\n    text = text.replace(/ /g, '_');\n    return text;\n}\n\nconst fixSpace2 = (text) => {\n    text = text.replace(/\\s/g, '-');\n    return text;\n}\n\nconst fixSpace3 = (text) => {\n    text = text.replace(/\\s/g, '-');\n    return text;\n}\n\nconst fixSpace4 = (text) => {\n    text = text.replace(/\\s/g, '-');\n    return text;\n}\n\nconst fixAllSpaces2 = (text) => {\n    text = text.replace(/\\s/g, '-');\n    return text;\n}\n\nconst fixAllSpaces3 = (text) => {\n    text = text.replace(/\\s/g, '-');\n    return text;\n}\n\nconst fixAllSpaces4 = (text) => {\n    text = text.replace(/\\s/g, '-');\n    return text;\n}\n\nconst removeSpace = (text) => {\n    text = text.replace(/\\s/g, '');\n    return text;\n}\n\nconst removeAllSpaces = (text) => {\n    text = text.replace(/\\s/g, '');\n    text = text.replace(/\\s{2,}/g, '-');\n    return text;\n}\n\nconst removeAllSpaces2 = (text) => {\n    text = text.replace(/\\s/g, '');\n    return text;\n}\n\nconst removeAllSpaces3 = (text) => {\n    text = text.replace(/\\s/g, '');\n    return text;\n}\n\nconst removeAllSpaces4 = (text) => {\n    text = text.replace(/\\s/g, '');\n    return text;\n}\n\nmodule.exports = {\n    fixesSpace,\n    fixAllSpaces,\n    fixAllSpaces2,\n    fixAllSpaces3,\n    fixAllSpaces4,\n    removeSpaces,\n    removeAllSpaces,\n    removeAllSpaces2,\n    removeAllSpaces3,\n    removeAllSpaces4,\n    fixSpace,\n    fixSpace2,\n    fixSpace3,\n    fixSpace4,\n    fixAllSpaces2,\n    fixAllSpaces3,\n    fixAllSpaces4,\n    removeSpace,\n    removeAllSpaces\n}\n<|endoftext|>"}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filesNamesCheck(\"example.txt\") # => 'Yes'\n  filesNamesCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filesNamesCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "filesNamesCheck", "gc": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filesNamesCheck(\"example.txt\") # => 'Yes'\n  filesNamesCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst filesNamesCheck = (file_name) => {\n  const valid_name = /[^0-9]\\.txt[^0-9]\\.exe[^0-9]\\.dll[^0-9]/.test(file_name)\n  return valid_name? 'Yes' : 'No'\n}\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - The file's name contains exactly one dot '.'\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filesNamesCheck(\"example.exe\") # => 'Yes'\n  filesNamesCheck(\"1example.exe\") # => 'No' (the name should end with one of the following: 'txt', 'exe', 'dll')\n  */\nconst filesNamesCheckEnd = (file_name) => {\n  const valid_name = /\\.txt[^0-9]\\.exe[^0-9]\\.dll/.test(file_name)\n  return valid_name? 'Yes' : 'No'\n}\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should be one of these: ['txt', 'exe', 'dll']\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filesNamesCheck(\"example.txt.txt\") # => 'Yes'\n  filesNamesCheck(\"example.exe.exe\") # => 'Yes'\n  filesNamesCheck(\"example.exe.dll\") # => 'No' (the file's name should not contain a dot)\n  */\nconst filesNamesCheckMiddle = (file_name) => {\n  const valid_name = /\\.txt[^0-9]\\.exe[^0-9]\\.dll/.test(file_name)\n  return valid_name? 'Yes' : 'No'\n}\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should be one of these: ['txt', 'exe', 'dll']\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filesNamesCheck(\"example.txt.exe\") # => 'Yes'\n  filesNamesCheck(\"example.exe.txt\") # => 'No' (the file's name should not contain a dot)\n  */\nconst filesNamesCheckMiddleEnd = (file_name) => {\n  const valid_name = /\\.txt[^0-9]\\.exe[^0-9]\\.dll/.test(file_name)\n  return valid_name? 'Yes' : 'No'\n}\n\nconst filesNamesCheckEmpty = (file_name) => {\n  const valid_name = /^[^0-9]$/.test(file_name)\n  return valid_name? 'Yes' : 'No'\n}\n\nconst filesNamesCheck_empty_start = (file_name) => {\n  const valid_name = /^[^0-9]$/.test(file_name)\n  return valid_name? 'Yes' : 'No'\n}\n\nconst filesNamesCheck_empty_end = (file_name) => {\n  const valid_name = /^[^0-9]$/.test(file_name)\n  return valid_name? 'Yes' : 'No'\n}\n\nconst filesNamesCheck_empty_middle = (file_name) => {\n  const valid_name = /^[^0-9]$/.test(file_name)\n  return valid_name? 'Yes' : 'No'\n}\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should be one of these: ['txt', 'exe', 'dll']\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  filesNamesCheck(\"example.txt\") # => 'Yes'\n  filesNamesCheck(\"example.exe\") # => 'Yes'\n  filesNamesCheck(\"example.dll\") # => 'Yes'\n  */\nconst filesNamesCheck_empty_end_start = (file_name) => {\n  const valid_name = /\\.txt[^0-9]\\.exe[^0-9]\\.dll/.test(file_name)\n  return valid_name? 'Yes' : 'No'\n}\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumsSquares", "gc": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquares = (lst) => {\n    return (lst.reduce((a, b) => (a + b ** 2), 0));\n}\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquaresNoReturn = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (i % 3 === 0 || i % 4 === 0) {\n            sum += lst[i] ** 2;\n        }\n    }\n    return sum;\n}\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquaresReturnSum = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (i % 3 === 0 || i % 4 === 0) {\n            sum += lst[i] ** 2;\n        }\n    }\n    return sum;\n}\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumsSquaresReturnSumSquared = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (i % 3 === 0 || i % 4 === 0) {\n            sum += lst[i] ** 2;\n        }\n    }\n    return sum;\n}\n\nexport {\n    sumsSquares,\n    sumsSquaresNoReturn,\n    sumsSquaresReturnSum,\n    sumsSquaresReturnSumSquared\n};<|endoftext|>"}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordInSentences = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordInSentences", "gc": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordInSentences = (sentence) => {\n  const arr = sentence.split(' ');\n  const newSentence = [];\n  for (let i = 0; i < arr.length; i++) {\n    const len = arr[i].length;\n    while (len <= 10) {\n      let num = 2;\n      while (num <= len) {\n        if (isPrime(num) && isPrime(len - num)) {\n          newSentence.push(arr[i]);\n          break;\n        }\n        num += 1;\n      }\n    }\n  }\n  return newSentence.join(' ');\n};\n\n// https://www.hackerrank.com/challenges/prime-numbers\n\nconst isPrime = (n) => {\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// TEST\n\nconst sentence = \"This is a test\";\nconsole.log(wordInSentences(sentence));\n<|endoftext|>"}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "gc": "/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  const xs = x.split('/')\n  const ns = n.split('/')\n  const xi = parseInt(xs[0], 10)\n  const ni = parseInt(ns[0], 10)\n  if (ni === 0) return false\n  return (xi * ni) === parseInt(ns[1], 10)\n}\n\nconst simplified = simplify(input, number)\nconsole.log(simplified)\n<|endoftext|>"}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoint([]) == []\n  */\nconst orderByPoint = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoint", "gc": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoint([]) == []\n  */\nconst orderByPoint = (nums) => {\n    const sum = [0, 0, 0];\n    for (let i = 0; i < nums.length; i++) {\n        const num = nums[i];\n        const index = num - Math.floor(num);\n        sum[index % 3]++;\n    }\n\n    const index = nums.length - 1;\n    const len = sum.length;\n    let start = 0;\n    let end = 0;\n    for (let i = 0; i < len; i++) {\n        if (sum[i] > 0) {\n            start = i;\n            break;\n        }\n    }\n\n    for (let i = 0; i < len; i++) {\n        if (sum[i] < 0) {\n            end = i;\n            break;\n        }\n    }\n\n    const result = [];\n    for (let i = start; i <= end; i++) {\n        result.push(nums[i]);\n    }\n\n    return result;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "gc": "/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const oddArray = [];\n  const evenArray = [];\n  for (let i = 0; i < nums.length; i += 1) {\n    if (nums[i] % 2 === 1) {\n      oddArray.push(nums[i]);\n    }\n    if (nums[i] % 2 === 0) {\n      evenArray.push(nums[i]);\n    }\n  }\n  return oddArray.length + evenArray.length;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst gottenMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "gottenMaxTriples", "gc": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst gottenMaxTriples = (n) => {\n  let maxTriples = 0;\n  let a = new Array(n);\n  for(let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1;\n  }\n  for(let i = 0; i < n - 1; i++) {\n    for(let j = i + 1; j < n; j++) {\n      for(let k = j + 1; k < n; k++) {\n        if(a[i] + a[j] + a[k] % 3 === 0) {\n          maxTriples++;\n        }\n      }\n    }\n  }\n  return maxTriples;\n}\n\nmodule.exports = gottenMaxTriples;\n<|endoftext|>"}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "gc": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1Arr = planet1.split(\" \")\n  const planet2Arr = planet2.split(\" \")\n  const planets = []\n  let i = 0\n  let j = 0\n  const planet1Distance = Math.abs(Math.cos(Math.PI / 6.0 * Math.pow(Math.pow(planet1Arr[0], 2.0) + Math.pow(planet1Arr[1], 2.0) + Math.pow(planet1Arr[2], 2.0) - Math.pow(planet2Arr[0], 2.0) - Math.pow(planet2Arr[1], 2.0) - Math.pow(planet2Arr[2], 2.0), 1.0 / 3.0)))\n  while (i < 8) {\n    if (Math.pow(planet2Arr[i], 2.0) + Math.pow(planet1Arr[j], 2.0) < Math.pow(planet1Distance, 2.0)) {\n      if (i!= 0) {\n        if (planet1Arr[j] == planet2Arr[i - 1]) {\n          planets.push(planet1Arr[j])\n        } else {\n          planets.push(planet1Arr[j])\n          planets.push(planet2Arr[i - 1])\n        }\n      } else {\n        planets.push(planet1Arr[j])\n      }\n    }\n    i++\n    j++\n  }\n  return planets\n}\n\nconsole.log(bf(\"Jupiter\", \"Saturn\"))\nconsole.log(bf(\"Earth\", \"Mercury\"))\nconsole.log(bf(\"Mercury\", \"Uranus\"))\n<|endoftext|>"}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortListsSums = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortListsSums", "gc": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortListsSums = (lst) => {\n  const nums = [];\n  for (const element of lst) {\n    nums.push(parseInt(element, 10));\n  }\n  return nums.sort((a, b) => {\n    if (a % 2 === 0) {\n      if (b % 2 === 0) {\n        return a - b;\n      } else {\n        return a - b + 1;\n      }\n    } else {\n      if (b % 2 === 0) {\n        return b - a + 1;\n      } else {\n        return b - a;\n      }\n    }\n  });\n};\n\n// [2, 3, 1, 4, 1, 5, 7, 2, 3, 6, 9, 8, 6, 2, 3, 1]\nsortListsSums([2, 3, 1, 4, 1, 5, 7, 2, 3, 6, 9, 8, 6, 2, 3, 1]);\n// [2, 3, 1, 4, 1, 5, 7, 2, 3, 6, 9, 8, 6, 2, 3, 1]\nsortListsSums([2, 3, 1, 4, 1, 5, 7, 2, 3, 6, 9, 8, 6, 2, 3, 1, 1, 2]);\n// [2, 3, 1, 4, 1, 5, 7, 2, 3, 6, 9, 8, 6, 2, 3, 1, 1, 2]\nsortListsSums([2, 3, 1, 4, 1, 5, 7, 2, 3, 6, 9, 8, 6, 2, 3, 1, 1, 2, 1]);\n// [2, 3, 1, 4, 1, 5, 7, 2, 3, 6, 9, 8, 6, 2, 3, 1, 1, 2, 1]\nsortListsSums([2, 3, 1, 4, 1, 5, 7, 2, 3, 6, 9, 8, 6, 2, 3, 1, 1, 2, 1, 2]);\n// [2, 3, 1, 4, 1, 5, 7, 2, 3, 6, 9, 8, 6, 2, 3, 1, 1, 2, 1, 2]\nsortListsSums([2, 3, 1, 4, 1, 5, 7, 2, 3, 6, 9, 8, 6, 2, 3, 1, 1, 2, 1, 2, 1]);\n// [2, 3, 1, 4, 1, 5, 7, 2, 3, 6, 9, 8, 6, 2, 3, 1, 1, 2, 1, 2, 1]\nsortListsSums([2, 3, 1, 4, 1, 5, 7, 2, 3, 6, 9, 8, 6, 2, 3, 1, 1, 2, 1, 2, 1, 2]);\n<|endoftext|>"}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "gc": "/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst primeNumbers = primeNumbers.map(xOrY);\nconst primeNumbersLength = primeNumbers.length;\n\nconsole.log(primeNumbers[primeNumbersLength - 1]);\n<|endoftext|>"}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "gc": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  return (lst.length? lst.reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0) : 0)\n}\n\nconst evenPairs = (lst) => {\n  return lst.filter((x) => {\n    return x % 2 === 0\n  })\n}\n\nconst oddPairs = (lst) => {\n  return lst.filter((x) => {\n    return x % 2 === 1\n  })\n}\n\nconst pairDifference = (lst) => {\n  return (evenPairs(lst).reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0) + oddPairs(lst).reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0))\n}\n\nconst tripleDifference = (lst) => {\n  return (lst.reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0) + pairDifference(lst) + oddPairs(lst).reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0))\n}\n\nconst tripleDifference = (lst) => {\n  return (lst.reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0) + pairDifference(lst) + oddPairs(lst).reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0))\n}\n\nconst tripleDifference = (lst) => {\n  return (lst.reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0) + pairDifference(lst) + oddPairs(lst).reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0))\n}\n\nconst tripleDifference = (lst) => {\n  return (lst.reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0) + pairDifference(lst) + oddPairs(lst).reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0))\n}\n\nconst tripleDifference = (lst) => {\n  return (lst.reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0) + pairDifference(lst) + oddPairs(lst).reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0))\n}\n\nconst tripleDifference = (lst) => {\n  return (lst.reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0) + pairDifference(lst) + oddPairs(lst).reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0))\n}\n\nconst tripleDifference = (lst) => {\n  return (lst.reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0) + pairDifference(lst) + oddPairs(lst).reduce((previous, current) => {\n    const difference = current - previous\n    return (difference > 0? (previous + current) * difference : 0)\n  }, 0))\n}\n\nmodule.exports = tripleDifference\n<|endoftext|>"}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "gc": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let [score, guess] = game.map(Number);\n  let [length] = guess;\n\n  let diff = [];\n  for (let i = 0; i < length; i++) {\n    if (guess[i] === score[i]) {\n      diff.push(0);\n    } else {\n      diff.push(Math.abs(guess[i] - score[i]));\n    }\n  }\n\n  return diff;\n};\n\nmodule.exports = compare;\n<|endoftext|>"}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "gc": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const extension_names = extensions.map(extension => extension.toUpperCase());\n  return class_name.toUpperCase() +\n    Math.max(...extension_names)\n     .toString()\n     .replace(/\\W/g, '');\n};\n\nmodule.exports = strongestExtension;\n<|endoftext|>"}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "gc": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  if (a.length > b.length) return false;\n\n  const a1 = a.split('');\n  const b1 = b.split('');\n\n  const length = Math.min(a1.length, b1.length);\n  let i = 0;\n  while (i < length) {\n    if (a1[i]!== b1[i]) return false;\n    i++;\n  }\n\n  if (a1.length > b1.length) return false;\n  return true;\n}\n\nconst isSubstring = (a, b) => {\n  return a.indexOf(b) >= 0;\n}\n\n/*\n  Problem 2\n  Given two strings, write a function to check if one string is a permutation of the other.\n  Example:\n  solution(\"ab\", \"c\") => false\n  solution(\"ab\", \"ba\") => true\n  solution(\"abc\", \"bac\") => false\n  solution(\"ab\", \"ab\") => true\n  solution(\"abc\", \"cba\") => true\n  solution(\"a\", \"aa\") => false\n  solution(\"aa\", \"aaa\") => false\n  solution(\"aa\", \"a\") => true\n  solution(\"abc\", \"abc\") => true\n  */\nconst solution = (a, b) => {\n  if (a.length > b.length) return false;\n\n  const a1 = a.split('');\n  const b1 = b.split('');\n\n  const length = Math.min(a1.length, b1.length);\n  let i = 0;\n  while (i < length) {\n    if (a1[i]!== b1[i]) return false;\n    i++;\n  }\n\n  if (a1.length > b1.length) return false;\n  return true;\n}\n\n/*\n  Problem 3\n  Given a string, we may transform it to a palindrome by adding characters in front of it.\n  However, it is not allowed to add any character to the end of the string.\n  Given a string, return whether we can make it a palindrome after the transformation.\n  solution(\"\", \"\") => true\n  solution(\"abc\", \"ab\") => true\n  solution(\"ab\", \"ba\") => true\n  solution(\"ab\", \"ab\") => true\n  solution(\"abc\", \"cba\") => true\n  solution(\"ab\", \"abab\") => true\n  solution(\"abc\", \"ac\") => true\n  solution(\"a\", \"a\") => true\n  solution(\"aa\", \"aa\") => true\n  solution(\"a\", \"aa\") => true\n  solution(\"aa\", \"a\") => true\n  solution(\"abc\", \"abc\") => true\n  solution(\"abc\", \"aabc\") => true\n  solution(\"abc\", \"abc\") => true\n  solution(\"a\", \"a\") => true\n  solution(\"ab\", \"aba\") => false\n  solution(\"aa\", \"aaa\") => false\n  solution(\"a\", \"aa\") => false\n  solution(\"aa\", \"aa\") => false\n  solution(\"ab\", \"abab\") => false\n  solution(\"abc\", \"ac\") => false\n  solution(\"a\", \"aa\") => false\n  solution(\"aa\", \"aaa\") => false\n  solution(\"a\", \"aa\") => false\n  solution(\"aa\", \"a\") => false\n  solution(\"ab\", \"aba\") => false\n  solution(\"ab\", \"abab\") => false\n  solution(\"ab\", \"ab\") => false\n  solution(\"abc\", \"cba\") => false\n  solution(\"ab\", \"abab\") => false\n  solution(\"ab\", \"ab\") => false\n  solution(\"a\", \"a\") => false\n  solution(\"aa\", \"aa\") => false\n  solution(\"a\", \"aa\") => false\n  solution(\"aa\", \"a\") => false\n  solution(\"abc\", \"abc\") => false\n  solution(\"abc\", \"aabc\") => false\n  solution(\"abc\", \"abc\") => false\n  solution(\"a\", \"a\") => false\n  solution(\"aa\", \"aaa\") => false\n  solution(\"a\", \"aa\") => false\n  solution(\"aa\", \"a\") => false\n  solution(\"ab\", \"aba\") => false\n  solution(\"ab\", \"abab\") => false\n  solution(\"ab\", \"ab\") => false\n  solution(\"abc\", \"cba\") => false\n  solution(\"ab\", \"abab\") => false\n  solution(\"ab\", \"ab\") => false\n  solution(\"a\", \"aa\") => false\n  solution(\"aa\", \"aaa\") => false\n  solution(\"a\", \"aa\") => false\n  solution(\"aa\", \"a\") => false\n  solution(\"ab\", \"aba\") => false\n  solution(\"ab\", \"abab\") => false\n  solution(\"ab\", \"ab\") => false\n  solution(\"abc\", \"ac\") => false\n  solution(\"a\", \"aa\") => false\n  solution(\"aa\", \"aaa\") => false\n  solution(\"a\", \"aa\") => false\n  solution(\"aa\", \"a\") => false\n  solution(\"ab\", \"aba\") => false\n  solution(\"ab\", \"abab\") => false\n  solution(\"ab\", \"ab\") => false\n  solution(\"abc\", \"cba\") => false\n  solution(\"ab\", \"abab\") => false\n  solution(\"ab\", \"ab\") => false\n  solution(\"a\", \"a\") => false\n  solution(\"aa\", \"aaa\") => false\n  solution(\"a\", \"aa\") => false\n  solution(\"aa\", \"a\") => false\n  solution(\"ab\", \"aba\") => false\n  solution(\"ab\", \"abab\") => false\n  solution(\"ab\", \"ab\") => false\n  solution(\"abc"}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOdderCount(-12) ==> (1, 1)\n      evenOdderCount(123) ==> (1, 2)\n  */\nconst evenOdderCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOdderCount", "gc": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOdderCount(-12) ==> (1, 1)\n      evenOdderCount(123) ==> (1, 2)\n  */\nconst evenOdderCount = (num) => {\n    let count = 0\n    while (num > 0) {\n        if (num % 2 === 0) {\n            count++\n        } else {\n            count--\n        }\n        num = num / 2\n    }\n    return (count, num)\n}\n\n/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOdderCount(-12) ==> (1, 1)\n      evenOdderCount(123) ==> (1, 2)\n  */\nconst oddOdderCount = (num) => {\n    let count = 0\n    while (num > 0) {\n        if (num % 2!== 0) {\n            count++\n        } else {\n            count--\n        }\n        num = num / 2\n    }\n    return (count, num)\n}\n\nexport {\n    evenOdderCount,\n    oddOdderCount\n}\n<|endoftext|>"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "gc": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let numeral = '';\n  let number = number;\n\n  while (number > 0) {\n    if (number % 10 == 1) {\n      numeral = 'i' + numeral;\n    }\n    else if (number % 10 == 2) {\n      numeral = 'ii' + numeral;\n    }\n    else if (number % 10 == 3) {\n      numeral = 'iii' + numeral;\n    }\n    else if (number % 10 == 4) {\n      numeral = 'iv' + numeral;\n    }\n    else if (number % 10 == 5) {\n      numeral = 'v' + numeral;\n    }\n    else if (number % 10 == 6) {\n      numeral = 'vi' + numeral;\n    }\n    else if (number % 10 == 7) {\n      numeral = 'vii' + numeral;\n    }\n    else if (number % 10 == 8) {\n      numeral = 'viii' + numeral;\n    }\n    else if (number % 10 == 9) {\n      numeral = 'ix' + numeral;\n    }\n    number = number / 10;\n  }\n  return numeral;\n}\n\nexport default intToMiniRoman;\n<|endoftext|>"}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangles(3, 4, 5) == true\n  rightAngleTriangles(1, 2, 3) == false\n  */\nconst rightAngleTriangles = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangles", "gc": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangles(3, 4, 5) == true\n  rightAngleTriangles(1, 2, 3) == false\n  */\nconst rightAngleTriangles = (a, b, c) => {\n  return (Math.abs(Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a + b + c, 2)) - Math.pow(a, 2)) === 0) && (Math.abs(Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a + c, 2)) - Math.pow(b, 2)) === 0) && (Math.abs(Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a + b, 2)) - Math.pow(c, 2)) === 0);\n}\n<|endoftext|>"}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  foundMax([\"name\", \"of\", \"string\"]) === \"string\"\n  foundMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  foundMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst foundMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "foundMax", "gc": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  foundMax([\"name\", \"of\", \"string\"]) === \"string\"\n  foundMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  foundMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst foundMax = (words) => {\n  let count = 0\n  let max = 0\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const chars = word.split(\"\").sort()\n    const charsLength = chars.length\n    const diff = charsLength - count\n    if (diff > max) {\n      max = diff\n      count = charsLength\n    }\n  }\n  return words[count - 1]\n}\n\nconsole.log(foundMax([\"name\", \"of\", \"string\"]))\nconsole.log(foundMax([\"name\", \"enam\", \"game\"]))\nconsole.log(foundMax([\"aaaaaaa\", \"bb\",\"cc\"]))\n<|endoftext|>"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "gc": "/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let total = number + need\n  let eaten = number\n  let total = remaining - eaten\n  return [total, remaining]\n}\n\nconsole.log(eat(2, 10, 5))\n<|endoftext|>"}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "gc": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const listOfOperators = Object.keys(operator)\n  const listOfOperands = operand.slice(1).map(v => Number(v))\n  const result = eval(listOfOperators.map((operator, i) => {\n    return operator +'' + (i + 1) +'' + listOfOperands[i]\n  }).join(' '))\n  return result\n}\n\nconst getOperator = (operator, operand) => {\n  if (operand.length < 2) {\n    throw new Error(`operand must have at least 2 elements`)\n  }\n  return {\n    '+': operator[operand[0] +'' + operand[1]],\n    '-': operator[operand[0] +'' + operand[1]],\n    '*': operator[operand[0] +'' + operand[1]],\n    '/': operator[operand[0] +'' + operand[1]],\n    '**': operator[operand[0] +'' + operand[1]],\n  }\n}\n\nconst listOperators = {\n  '+': (operand) => {\n    const operator = getOperator(operand, operand)\n    return {\n      '+': operator,\n      '-': operator,\n      '*': operator,\n      '/': operator,\n      '**': operator,\n    }\n  },\n  '*': (operand) => {\n    const operator = getOperator(operand, operand)\n    return {\n      '+': operator,\n      '-': operator,\n      '*': operator,\n      '/': operator,\n      '**': operator,\n    }\n  },\n  '/': (operand) => {\n    const operator = getOperator(operand, operand)\n    return {\n      '+': operator,\n      '-': operator,\n      '*': operator,\n      '/': operator,\n      '**': operator,\n    }\n  },\n  '**': (operand) => {\n    const operator = getOperator(operand, operand)\n    return {\n      '+': operator,\n      '-': operator,\n      '*': operator,\n      '/': operator,\n      '**': operator,\n    }\n  },\n}\n\nconst listOperands = (operand) => {\n  const operators = listOperators(operand)\n  return Object.keys(operators).map((key) => {\n    return operators[key](operand)\n  })\n}\n\nconst doAlgebra2 = (operator, operand) => {\n  const listOfOperators = Object.keys(operator)\n  const listOfOperands = operand.slice(1).map(v => Number(v))\n  const result = eval(listOfOperators.map((operator, i) => {\n    return operator +'' + (i + 1) +'' + listOfOperands[i]\n  }).join(' '))\n  return result\n}\n\nconst listOperators2 = {\n  '+': (operand) => {\n    const operator = getOperator(operand, operand)\n    return {\n      '+': operator,\n      '-': operator,\n      '*': operator,\n      '/': operator,\n      '**': operator,\n    }\n  },\n  '*': (operand) => {\n    const operator = getOperator(operand, operand)\n    return {\n      '+': operator,\n      '-': operator,\n      '*': operator,\n      '/': operator,\n      '**': operator,\n    }\n  },\n  '/': (operand) => {\n    const operator = getOperator(operand, operand)\n    return {\n      '+': operator,\n      '-': operator,\n      '*': operator,\n      '/': operator,\n      '**': operator,\n    }\n  },\n  '**': (operand) => {\n    const operator = getOperator(operand, operand)\n    return {\n      '+': operator,\n      '-': operator,\n      '*': operator,\n      '/': operator,\n      '**': operator,\n    }\n  },\n}\n\nconst listOperands2 = (operand) => {\n  const operators = listOperators2(operand)\n  return Object.keys(operators).map((key) => {\n    return operators[key](operand)\n  })\n}\n\nconst doAlgebra3 = (operator, operand) => {\n  const listOfOperators = Object.keys(operator)\n  const listOfOperands = operand.slice(1).map(v => Number(v))\n  const result = eval(listOfOperators.map((operator, i) => {\n    return operator +'' + (i + 1) +'' + listOfOperands[i]\n  }).join(' '))\n  return result\n}\n\nconst listOperators3 = {\n  '+': (operand) => {\n    const operator = getOperator(operand, operand)\n    return {\n      '+': operator,\n      '-': operator,\n      '*': operator,\n      '/': operator,\n      '**': operator,\n    }\n  },\n  '*': (operand) => {\n    const operator = getOperator(operand, operand)\n    return {\n      '+': operator,\n      '-': operator,\n      '*': operator,\n      '/': operator,\n      '**': operator"}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "gc": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  if (s === '') return ''\n  return s.split('').reduce((prev, curr) => {\n    if (curr.match(/[a-z]/i)) {\n      return prev.toUpperCase() + curr.toLowerCase()\n    }\n    return prev + curr\n  })\n}\n\n// console.log(solve('1234'))\n// console.log(solve('ab'))\n// console.log(solve('#a@C'))\nconsole.log(solve('aBc'))\n<|endoftext|>"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "gc": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) return null\n  return md5(text)\n}\n\n/**\n  Given a md5 hash string 'text', return the original string.\n  If 'text' is an empty string, return null.\n\n  >>> md5ToString('3e25960a79dbc69b674cd4ec67a72c62') == 'Hello world'\n  */\nconst md5ToString = (text) => {\n  if (!text) return null\n  return new Buffer(text, 'base64').toString('utf8')\n}\n\nexport {\n  stringToMd5,\n  md5ToString\n}\n<|endoftext|>"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "gc": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const digits = []\n  let aDigit = a\n\n  while (aDigit < b) {\n    const digit = aDigit % 10\n    aDigit = Math.floor(aDigit / 10)\n    digits.push(digit)\n  }\n  return digits\n}\n\n/*\n  Given a positive integer n, return the number of trailing zeros in n.\n  For example:\n  trailingZeros(42) => 2\n  trailingZeros(1) => 0\n  trailingZeros(0) => 1\n  */\nconst trailingZeros = (n) => {\n  const zeros = 0\n  const remainder = n % 10\n  if (remainder === 0) {\n    return zeros\n  }\n  return trailingZeros(remainder) + 1\n}\n\n/*\n  Given two positive integers a and b, return the smallest positive integer\n  that is larger than both a and b.\n\n  For example:\n  nextLarger(5, 8) => 10\n  nextLarger(10, 5) => 15\n  nextLarger(0, 9) => 1\n  */\nconst nextLarger = (a, b) => {\n  if (a < b) {\n    return b\n  }\n  return nextLarger(a + 1, b + 1)\n}\n\n/*\n  Given two positive integers a and b, return the largest positive integer\n  that is smaller than both a and b.\n\n  For example:\n  nextSmaller(5, 8) => 5\n  nextSmaller(10, 5) => 5\n  nextSmaller(0, 9) => 9\n  */\nconst nextSmaller = (a, b) => {\n  if (a < b) {\n    return a\n  }\n  return nextSmaller(a - 1, b - 1)\n}\n\nmodule.exports = {\n  generateIntegers,\n  trailingZeros,\n  nextLarger,\n  nextSmaller\n}\n<|endoftext|>"}
