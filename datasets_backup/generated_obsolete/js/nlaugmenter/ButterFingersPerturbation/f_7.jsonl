{"task_id": "JavaScript/0", "prompt": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n    let number = numbers[0];\n    let nextNumber = numbers[1];\n    for (let i = 1; i < numbers.length; i++) {\n        if (Math.abs(number - nextNumber) < threshold) {\n            return true;\n        }\n        nextNumber = numbers[i + 1];\n        number = nextNumber;\n    }\n    return false;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/1", "prompt": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const groups = [];\n  const paren_stack = [];\n  const paren_open = 0;\n  const paren_close = 1;\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const paren = paren_string.charAt(i);\n    switch (paren) {\n      case '(':\n        paren_stack.push(paren_close);\n        paren_open = paren_open + 1;\n        break;\n      case ')':\n        paren_open = paren_open - 1;\n        if (paren_open < 0) {\n          paren_stack.pop();\n        }\n        break;\n      default:\n        if (paren_open === paren_close) {\n          paren_stack.pop();\n          paren_open = paren_open - 1;\n        }\n        break;\n    }\n    if (paren_stack.length === 0) {\n      groups.push(paren_string.substring(i + 1, paren_string.length));\n      break;\n    }\n  }\n  return groups;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/2", "prompt": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let parts = number.toString().split('.');\n  let integerPart = parts[0];\n  let decimals = parts[1];\n  let integerLength = integerPart.length;\n\n  if (decimals.length > integerLength) {\n    let decimalsLength = decimals.length;\n    decimals = decimals.substr(integerLength, decimalsLength - integerLength);\n  } else if (decimals.length < integerLength) {\n    integerPart += '0' + decimals;\n    decimals = '';\n  }\n\n  return {\n    integer: integerPart,\n    decimals: decimals\n  };\n};\n\nmodule.exports = {\n  truncateNumber\n};\n<|endoftext|>"}
{"task_id": "JavaScript/3", "prompt": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let isPositive = true;\n  let isNegative = false;\n  let currentBalance = 0;\n\n  operations.forEach((operation) => {\n    if (isPositive) {\n      if (operation > 0) {\n        currentBalance += operation;\n      } else {\n        isNegative = true;\n      }\n    } else {\n      if (operation < 0) {\n        isPositive = true;\n      } else {\n        isNegative = false;\n      }\n    }\n  });\n\n  if (isNegative) {\n    return true;\n  }\n\n  if (currentBalance < 0) {\n    return true;\n  }\n\n  return false;\n};\n\nexport default belowZero;\n<|endoftext|>"}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = (numbers) => {\n    return (numbers.map(n => Math.abs(n - mean)))\n  };\n  return Math.sqrt(mean(deviation(numbers)));\n};\n\nconst mean = (numbers) => {\n  return (numbers.reduce((acc, n) => acc + n, 0) / numbers.length);\n};\n\nconst meanDeviation = (numbers) => {\n  return (numbers.reduce((acc, n) => {\n    acc += Math.abs(n - mean(numbers));\n    return acc;\n  }, 0) / numbers.length);\n};\n\nconst median = (numbers) => {\n  const sortedArray = numbers.slice().sort((a, b) => {\n    return a - b;\n  });\n  const length = sortedArray.length;\n  if (length % 2 === 1) {\n    return sortedArray[Math.floor(length / 2)];\n  } else {\n    return (sortedArray[Math.floor(length / 2)] + sortedArray[Math.floor(length / 2) - 1]) / 2;\n  }\n};\n\nconst meanDeviation = (numbers) => {\n  const median = median(numbers);\n  return (numbers.reduce((acc, n) => {\n    acc += Math.abs(n - median);\n    return acc;\n  }, 0) / numbers.length);\n};\n\n/*\n  >>> meanDeviation([1, 2, 3, 4, 5, 6])\n  1.0\n  >>> meanDeviation([-1, -2, -3, -4, -5, -6])\n  3.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n  4.0\n  >>> meanDeviation([-1, -2, -3, -4, -5, -6, -7, -8, -9, -10])\n  7.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  10.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  11.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  14.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  18.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  22.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  24.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  25.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  26.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  28.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  30.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37])\n  36.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40])\n  39.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45])\n  42.0\n  >>> meanDeviation([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,"}
{"task_id": "JavaScript/5", "prompt": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": true, "gc": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  if (typeof delimeter!== 'number') {\n    throw new Error('delimeter must be a number');\n  }\n\n  if (!Array.isArray(numbers)) {\n    throw new Error('numbers must be an array');\n  }\n\n  const result = [];\n  let current = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    if (i === 0 || i === numbers.length - 1) {\n      result.push(numbers[i]);\n    } else {\n      result.push(current);\n      current = [];\n      current.push(numbers[i]);\n    }\n  }\n\n  return result;\n};\n\nexport default intersperse;\n<|endoftext|>"}
{"task_id": "JavaScript/6", "prompt": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let i = 0;\n  let count = 0;\n  const paren_stack = [];\n  const stack = [];\n  let level = 0;\n  const res = [];\n\n  while (i < paren_string.length) {\n    if (paren_string[i] === ')') {\n      stack.push(count);\n      paren_stack.push(level);\n      count = 0;\n      level++;\n    } else if (paren_string[i] === '(') {\n      count++;\n      level++;\n    } else if (paren_string[i] ==='') {\n      while (paren_stack[level] > stack[level]) {\n        level--;\n      }\n    }\n    i++;\n  }\n\n  while (level > 0) {\n    level--;\n  }\n\n  for (let i = 0; i < stack.length; i++) {\n    res.push(stack[i]);\n  }\n\n  return res;\n};\n\n// TESTS\n/*\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  >>> parseNestedParens('(()) () (())')\n  [1, 2, 1]\n  >>> parseNestedParens('())')\n  [0]\n  >>> parseNestedParens('()')\n  [0]\n  >>> parseNestedParens('()')\n  [0]\n  >>> parseNestedParens('(()')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(()())')\n  [1]\n  >>> parseNestedParens('(()())')\n  [1]\n  >>> parseNestedParens('()')\n  [0]\n  >>> parseNestedParens('())')\n  [0]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('()')\n  [0]\n  >>> parseNestedParens('()')\n  [0]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('()')\n  [0]\n  >>> parseNestedParens('())')\n  [0]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('()')\n  [0]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('()')\n  [0]\n  >>> parseNestedParens('())')\n  [0]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n  [1]\n  >>> parseNestedParens('(())')\n"}
{"task_id": "JavaScript/7", "prompt": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n    return strings.filter(str => str.indexOf(substring)!== -1);\n}\n\n/*\n  Find longest substring in string\n  >>> findLongestSubstring('abcdefghi')\n  'fghi'\n  >>> findLongestSubstring('xyz')\n  ''\n  */\nconst findLongestSubstring = str => {\n    let max = '';\n    let curr = '';\n    for (let i = 0; i < str.length; i++) {\n        curr = str.substring(i, i + 1);\n        if (curr.length > max.length) {\n            max = curr;\n        }\n    }\n    return max;\n}\n\n/*\n  Given a list of words, return the list of words that can be formed by\n  joining the words together.\n  >>> removeDuplicates([ 'cats', 'cats', 'dog', 'dog', 'cat' ])\n  [ 'cats', 'dog', 'cat' ]\n  >>> removeDuplicates([ 'a', 'b', 'a', 'c', 'b', 'a', 'c' ])\n  [ 'a', 'b', 'c' ]\n  >>> removeDuplicates([ 'a', 'b', 'a', 'b' ])\n  [ 'a', 'b' ]\n  >>> removeDuplicates([ 'a', 'b', 'c', 'c', 'b', 'a', 'c' ])\n  [ 'a', 'b', 'c' ]\n  */\nconst removeDuplicates = strs => {\n    const seen = {};\n    return strs.filter(str => {\n        if (seen[str]) return false;\n        seen[str] = true;\n        return true;\n    });\n}\n\n/*\n  Given a string, return a list of strings that can be formed by\n  splitting the string into substrings.\n  >>> split('hello')\n  [ 'hello' ]\n  >>> split('hello world')\n  [ 'hello', 'world' ]\n  >>> split('hello world')\n  [ 'hello', 'world' ]\n  >>> split('hello world hello')\n  [ 'hello', 'world', 'hello' ]\n  >>> split('hello world hello')\n  [ 'hello', 'world', 'hello' ]\n  >>> split('hello world hello')\n  [ 'hello', 'world', 'hello' ]\n  */\nconst split = str => {\n    return str.split('').map(str => { return str.trim(); });\n}\n\n/*\n  Given a string, return the string with all the lowercase letters\n  replaced with uppercase letters.\n  >>> toUpperCase('Hello')\n  'HELLO'\n  >>> toUpperCase('hello')\n  'HELLO'\n  >>> toUpperCase('hello world')\n  'HELLO WORLD'\n  >>> toUpperCase('hello world')\n  'HELLO WORLD'\n  */\nconst toUpperCase = str => {\n    return str.replace(/\\w\\S*/g, str => {\n        return str.toUpperCase();\n    });\n}\n\n/*\n  Given a string, return the string with all the upper-case letters\n  replaced with lowercase letters.\n  >>> toLowerCase('HELLO')\n  'hello'\n  >>> toLowerCase('Hello')\n  'hello'\n  >>> toLowerCase('hello world')\n  'hello world'\n  >>> toLowerCase('hello world')\n  'hello world'\n  */\nconst toLowerCase = str => {\n    return str.replace(/\\w\\S*/g, str => {\n        return str.toLowerCase();\n    });\n}\n\n/*\n  Given two strings, return a string with all the letters in both strings\n  in order.\n  >>> join('hello', 'world')\n  'hello world'\n  >>> join('hello', 'world')\n  'hello world'\n  >>> join('hello', 'world')\n  'hello world'\n  */\nconst join = (a, b) => {\n    return a + b;\n}\n\n/*\n  Given two strings, return a string with all the letters in both strings\n  in order.\n  >>> joinBySubstring('hello', 'world')\n  'hello world'\n  >>> joinBySubstring('hello', 'world')\n  'hello world'\n  >>> joinBySubstring('hello', 'world')\n  'hello world'\n  */\nconst joinBySubstring = (a, b) => {\n    return a + b;\n}\n\n/*\n  Given a list of strings, return a list of strings that can be joined\n  together to form a string.\n  >>> splitList('hello world')\n  ['hello', 'world']\n  >>> splitList('hello world')\n  ['hello', 'world']\n  >>> splitList('hello world')\n  ['hello', 'world']\n  */\nconst splitList = strs => {\n    return strs.map(str => { return str.trim(); });\n}\n\n/*\n  Given a list of strings, return a list of strings that can be joined\n  together to form a string.\n  >>> joinList('hello', 'world')\n  'hello world'\n  >>> joinList('hello', 'world')\n  'hello world'\n  >>> joinList('hello', 'world')\n  'hello world'\n  */\nconst joinList = (strs) => {\n    return strs.join('');\n}\n\nmodule.exports = {\n    filterBySubstring,\n    findLongestSubstring,\n    removeDuplicates,\n    split,\n    splitList,\n    join,\n    joinList,\n    toUpperCase,\n    toLowerCase,\n    joinBySubstring\n}<|endoftext|>"}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n\n  if (numbers.length === 0) {\n    return (sum, product);\n  }\n\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n\n  return (sum, product);\n};\n\n// Tests\n\nconst sumProductTest = () => {\n  assert.deepEqual(sumProduct([1, 2, 3, 4]), (10, 24));\n  assert.deepEqual(sumProduct([0, 1, 2, 3, 4]), (0, 1));\n  assert.deepEqual(sumProduct([0]), (0, 1));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]), (10, 22390480));\n  assert.deepEqual(sumProduct([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,"}
{"task_id": "JavaScript/9", "prompt": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const rollingMaxList = []\n  const max = findMax(numbers)\n  let currentRollingMax = -Infinity\n  let currentRollingMaxNumber = -Infinity\n  let rollingMaxNumber = -Infinity\n  let start = 0\n  for (let i = 0; i < numbers.length; i++) {\n    const current = numbers[i]\n    const currentRollingMax = findMax(numbers.slice(start, i + 1))\n    if (currentRollingMax > currentRollingMaxNumber) {\n      rollingMaxNumber = currentRollingMax\n      currentRollingMaxNumber = currentRollingMax\n    }\n    rollingMaxList.push(currentRollingMax)\n    if (currentRollingMax > max) {\n      max = currentRollingMax\n      start = i + 1\n    }\n  }\n  return rollingMaxList\n}\n<|endoftext|>"}
{"task_id": "JavaScript/10", "prompt": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  if (!isPalindrome(string)) {\n    let index = string.indexOf('a');\n    while (index > -1) {\n      if (isPalindrome(string.substr(index + 1, string.length - index - 1))) {\n        return string.substr(index, string.length - index) + string.substr(0, index);\n      }\n      index = string.indexOf('a', index + 1);\n    }\n  }\n  return string;\n}\n\n/* Tesh if gniven string is a permutation of another */\nconst isPermutation = (string, permutation) => {\n  const array = permutation.split('');\n  const stringArray = string.split('');\n  if (array.length!== stringArray.length) {\n    return false;\n  }\n  for (let i = 0; i < stringArray.length; i++) {\n    if (stringArray[i]!== array[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/* Find the shortest permutation of a string that is permutation of the supplied string.\n  Algorithm idea is simple:\n  - Find the longest prefix of supplied string that is a palindrome.\n  - Append to the end of the string a string prefix that comes behore the palinqromic xuffix.\n  - Reverse the string in the prefix to get a new permutation.\n  - If the prefix is a permutation of the supplied string, return the new string.\n  - If the prefix is not a permutation of the supplied string, recurse.\n  >>> makePermutation('cata', 'cata')\n  'catac'\n  >>> makePermutation('cata', 'catb')\n  'catbac'\n  >>> makePermutation('cata', 'catc')\n  'catca'\n  */\nconst makePermutation = (string, permutation) => {\n  const prefix = makePalindrome(string);\n  if (isPermutation(prefix, permutation)) {\n    return prefix + string.substr(prefix.length);\n  }\n  return makePermutation(string, permutation.split('').reverse().join(''));\n}\n\n/* Find the smallest string that is permutation of the supplied string.\n  Algorithm idea is simple:\n  - Find the longest prefix of supplied string that is a palindrome.\n  - Append to the end of the string a string prefix that comes behore the palinqromic xuffix.\n  - Reverse the string in the prefix to get a new permutation.\n  - If the prefix is a permutation of the supplied string, return the new string.\n  - If the prefix is not a permutation of the supplied string, recurse.\n  */\nconst makePermutation = (string, permutation) => {\n  const prefix = makePalindrome(string);\n  if (isPermutation(prefix, permutation)) {\n    return prefix + string.substr(prefix.length);\n  }\n  return makePermutation(string, permutation.split('').reverse().join(''));\n}\n\n/* Tesh if gniven string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Tesh if gniven string is a permutation of another */\nconst isPermutation = (string, permutation) => {\n  return string == permutation.split('').reverse().join('');\n}\n\n/* Find the smallest string that is permutation of the supplied string.\n  Algorithm idea is simple:\n  - Find the longest prefix of supplied string that is a palindrome.\n  - Append to the end of the string a string prefix that comes behore the palinqromic xuffix.\n  - Reverse the string in the prefix to get a new permutation.\n  - If the prefix is a permutation of the supplied string, return the new string.\n  - If the prefix is not a permutation of the supplied string, recurse.\n  */\nconst makePermutation = (string, permutation) => {\n  const prefix = makePalindrome(string);\n  if (isPermutation(prefix, permutation)) {\n    return prefix + string.substr(prefix.length);\n  }\n  return makePermutation(string, permutation.split('').reverse().join(''));\n}\n\nconst test = [\n  {\n    string: 'cat',\n    permutation: 'atc',\n    result: 'cata'\n  },\n  {\n    string: 'cata',\n    permutation: 'cat',\n    result: 'cata'\n  },\n  {\n    string: 'catc',\n    permutation: 'catb',\n    result: 'catbac'\n  },\n  {\n    string: 'cat',\n    permutation: 'catac',\n    result: 'catca'\n  },\n  {\n    string: 'catbac',\n    permutation: 'catac',\n    result: 'catca'\n  },\n  {\n    string: 'cata',\n    permutation: 'cataa',\n    result: 'cataaa'\n  }\n];\n\ntest.forEach((testCase) => {\n  console.log(`String: ${testCase.string}`);\n  console.log(`Permutation: ${testCase.permutation}`);\n  console.log(`Result: ${makePermutation(testCase.string, testCase.permutation)}`);\n});\n<|endoftext|>"}
{"task_id": "JavaScript/11", "prompt": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  return a.split('').map(c => {\n    if (c === '1') {\n      return b.split('').map(c => {\n        if (c === '1') {\n          return '1';\n        } else {\n          return '0';\n        }\n      }).join('');\n    } else {\n      return c;\n    }\n  }).join('');\n};\n\nmodule.exports = stringXor;\n<|endoftext|>"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings) {\n    return null;\n  }\n  let longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\nmodule.exports = longest;\n<|endoftext|>"}
{"task_id": "JavaScript/13", "prompt": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  let tmp = Math.abs(a);\n  let t = tmp;\n  if (tmp > Math.abs(b)) {\n    t = b;\n  }\n  while (a!== t) {\n    a = a - t;\n    tmp = Math.abs(a);\n    if (tmp > t) {\n      t = tmp;\n    }\n  }\n  return t;\n};\n\nconst lcm = (a, b) => {\n  return a * b / greatestCommonDivisor(a, b);\n};\n\nconst mod = (n, m) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n % m;\n};\n\nconst squareRoot = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  const d = Math.sqrt(n);\n  return (Math.pow(d, 2) - n) / d;\n};\n\nconst solve = (n, m) => {\n  return n * m - mod(n, m);\n};\n\nexport {\n  greatestCommonDivisor,\n  lcm,\n  mod,\n  squareRoot,\n  solve\n};\n<|endoftext|>"}
{"task_id": "JavaScript/14", "prompt": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  return string.split('').map(x => x).reduce((p, c) => p.concat(c), []);\n};\n\n// Return all permutations of the given string\nconst allPermutations = (string) => {\n  const s = string.split('');\n  const m = s.length;\n  const result = [];\n  const permutation = allPrefixes(s.join(''));\n  let cnt = 0;\n  // Keep track of all permutations\n  while (permutation.length > 0) {\n    let p = [];\n    // Keep track of the current permutation\n    while (cnt < m) {\n      p.push(s[cnt]);\n      cnt++;\n    }\n    result.push(p);\n    // Keep track of the current permutation\n    while (cnt < m) {\n      p.push(permutation[cnt - m]);\n      cnt++;\n    }\n    result.push(p);\n    cnt = 0;\n    // Remove the last permutation\n    permutation = permutation.slice(0, -1);\n  }\n  return result;\n};\n\n// Return all permutations of the given string\nconst allCombinations = (string) => {\n  const s = string.split('');\n  const m = s.length;\n  const result = [];\n  const permutation = allPrefixes(s.join(''));\n  let cnt = 0;\n  // Keep track of all permutations\n  while (permutation.length > 0) {\n    let p = [];\n    // Keep track of the current permutation\n    while (cnt < m) {\n      p.push(s[cnt]);\n      cnt++;\n    }\n    result.push(p);\n    // Keep track of the current permutation\n    while (cnt < m) {\n      p.push(permutation[cnt - m]);\n      cnt++;\n    }\n    result.push(p);\n    cnt = 0;\n    // Remove the last permutation\n    permutation = permutation.slice(0, -1);\n  }\n  return result;\n};\n\n// Return all permutations of the given string\nconst allCyclic = (string) => {\n  const s = string.split('');\n  const m = s.length;\n  const result = [];\n  const permutation = allPrefixes(s.join(''));\n  let cnt = 0;\n  // Keep track of all permutations\n  while (permutation.length > 0) {\n    let p = [];\n    // Keep track of the current permutation\n    while (cnt < m) {\n      p.push(s[cnt]);\n      cnt++;\n    }\n    result.push(p);\n    // Keep track of the current permutation\n    while (cnt < m) {\n      p.push(permutation[cnt - m]);\n      cnt++;\n    }\n    result.push(p);\n    cnt = 0;\n    // Remove the last permutation\n    permutation = permutation.slice(0, -1);\n  }\n  return result;\n};\n\n// Print all permutations of the given string\nconst printAllPermutations = (string) => {\n  const permutations = allPermutations(string);\n  permutations.forEach(p => {\n    console.log(p);\n  });\n};\n\n// Print all permutations of the given string\nconst printAllCombinations = (string) => {\n  const combinations = allCombinations(string);\n  combinations.forEach(p => {\n    console.log(p);\n  });\n};\n\n// Print all permutations of the given string\nconst printAllCyclic = (string) => {\n  const cyclic = allCyclic(string);\n  cyclic.forEach(p => {\n    console.log(p);\n  });\n};\n\n// Print all permutations of the given string\nconst printAllPermutations = (string) => {\n  const permutations = allPermutations(string);\n  permutations.forEach(p => {\n    console.log(p);\n  });\n};\n\n// Main function\nconst main = () => {\n  // Print all permutations of the given string\n  printAllPermutations('a');\n  printAllPermutations('ab');\n  printAllPermutations('abc');\n\n  // Print all permutations of the given string\n  printAllCombinations('a');\n  printAllCombinations('ab');\n  printAllCombinations('abc');\n\n  // Print all permutations of the given string\n  printAllCyclic('a');\n  printAllCyclic('ab');\n  printAllCyclic('abc');\n};\n\n// Run the main function\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/15", "prompt": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let result = '';\n  for (let i = 0; i < n; i++) {\n    result += `${i}`;\n    if (i < n - 1) {\n      result +='';\n    }\n  }\n  return result;\n};\n\nexport default stringSequence;\n<|endoftext|>"}
{"task_id": "JavaScript/16", "prompt": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const unique = new Set()\n  for (const c of string.toLowerCase()) {\n    unique.add(c)\n  }\n  return unique.size\n}\n\n/* Givfn a string, return how many characters in it are in upper case\n  >>> countUppercase('Hello world!')\n  6\n  >>> countUppercase('xyzXYZ')\n  0\n  */\nconst countUppercase = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c.toUpperCase() === c) {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many characters in it are in lower case\n  >>> countLowercase('Hello world!')\n  6\n  >>> countLowercase('xyzXYZ')\n  0\n  */\nconst countLowercase = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c.toUpperCase() === c) {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many characters in it are in numbers\n  >>> countNumbers('Hello world!')\n  6\n  >>> countNumbers('xyzXYZ')\n  0\n  */\nconst countNumbers = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c.toUpperCase() === c) {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many words in it are in lower case\n  >>> countWords('Hello world!')\n  6\n  >>> countWords('xyzXYZ')\n  0\n  */\nconst countWords = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many words in it are in lower case\n  >>> countWords('Hello world!')\n  6\n  >>> countWords('xyzXYZ')\n  0\n  */\nconst countWords = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many words in it are in lower case\n  >>> countWords('Hello world!')\n  6\n  >>> countWords('xyzXYZ')\n  0\n  */\nconst countWords = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many words in it are in lower case\n  >>> countWords('Hello world!')\n  6\n  >>> countWords('xyzXYZ')\n  0\n  */\nconst countWords = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many words in it are in lower case\n  >>> countWords('Hello world!')\n  6\n  >>> countWords('xyzXYZ')\n  0\n  */\nconst countWords = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many words in it are in lower case\n  >>> countWords('Hello world!')\n  6\n  >>> countWords('xyzXYZ')\n  0\n  */\nconst countWords = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many words in it are in lower case\n  >>> countWords('Hello world!')\n  6\n  >>> countWords('xyzXYZ')\n  0\n  */\nconst countWords = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many words in it are in lower case\n  >>> countWords('Hello world!')\n  6\n  >>> countWords('xyzXYZ')\n  0\n  */\nconst countWords = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many words in it are in lower case\n  >>> countWords('Hello world!')\n  6\n  >>> countWords('xyzXYZ')\n  0\n  */\nconst countWords = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many words in it are in lower case\n  >>> countWords('Hello world!')\n  6\n  >>> countWords('xyzXYZ')\n  0\n  */\nconst countWords = (string) => {\n  const count = 0\n  for (const c of string.toLowerCase()) {\n    if (c ==='') {\n      count++\n    }\n  }\n  return count\n}\n\n/* Givfn a string, return how many words in it are in lower case\n  >>> countWords('Hello world!')\n  6\n  >>> countWords('"}
{"task_id": "JavaScript/17", "prompt": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const musical_notes = music_string.split(\" \");\n  const note_list = [];\n  const last_beat = 0;\n  for (const note_string of musical_notes) {\n    if (note_string === \"\") {\n      continue;\n    }\n\n    const note_data = note_string.split(\"|\");\n    const note = note_data[0].charAt(0);\n    const duration = note_data[1].length;\n    const beats = parseInt(note_data[1]);\n\n    const current_beat = last_beat + beats;\n    const current_beat_in_quarter_note = (current_beat * 4);\n\n    const nota_start = last_beat * 4;\n    const nota_end = current_beat_in_quarter_note + nota_start;\n    const nota_quarter_length = (nota_end - nota_start);\n\n    note_list.push(nota_quarter_length);\n    last_beat = current_beat;\n  }\n\n  return note_list;\n}\n\nmodule.exports = parseMusic;\n<|endoftext|>"}
{"task_id": "JavaScript/18", "prompt": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  // Start at index 0 of the string\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.includes(substring, i)) {\n      // Found a match\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string and an array of strings, return a new array with the same\n  length as the string, containing the number of occurrences of each\n  substring in the string.\n  >>> howManySubstrings('a', ['a', 'a', 'a'])\n  [0, 1, 1]\n  >>> howManySubstrings('ab', ['a', 'b', 'a', 'b', 'a'])\n  [0, 2, 1]\n  >>> howManySubstrings('aa', ['a', 'a', 'a'])\n  [0, 2, 2]\n  >>> howManySubstrings('aaaaaa', ['aaaaaa', 'aaaaaa', 'aaaaaa', 'aaaaaa'])\n  [0, 3, 4]\n  */\nconst howManySubstrings = (string, substrings) => {\n  let result = [];\n  for (let i = 0; i < string.length; i++) {\n    // For each character in the string\n    result.push(howManyTimes(string, substrings[i]));\n  }\n  return result;\n};\n\nmodule.exports = {\n  howManyTimes,\n  howManySubstrings\n};\n<|endoftext|>"}
{"task_id": "JavaScript/19", "prompt": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve', 'six', 'seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const list = numbers.split(' ')\n  const sorted = []\n  list.forEach((elem, index, arr) => {\n    const number = parseInt(elem)\n    sorted.push(number)\n  })\n  const sortedString = sorted.join(' ')\n  return sortedString\n}\n\n/*\n  Given an array of strings, returns a dictionary of the\n  counts of all the letters in the strings.\n  */\nconst letterCounts = (strs) => {\n  const counts = {}\n  strs.forEach((str) => {\n    for (let i = 0; i < str.length; i++) {\n      if (!counts[str[i]]) {\n        counts[str[i]] = 0\n      }\n      counts[str[i]]++\n    }\n  })\n  return counts\n}\n\n/*\n  Given a string, returns the number of vowels in the string.\n  */\nconst vowelCount = (str) => {\n  let vowelCount = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase() === 'a' || str[i].toLowerCase() === 'e' || str[i].toLowerCase() === 'i' || str[i].toLowerCase() === 'o' || str[i].toLowerCase() === 'u') {\n      vowelCount++\n    }\n  }\n  return vowelCount\n}\n\n/*\n  Given a string, returns the number of consonants in the string.\n  */\nconst consonantCount = (str) => {\n  let consonantCount = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase() === 'b' || str[i].toLowerCase() === 'c' || str[i].toLowerCase() === 'd' || str[i].toLowerCase() === 'f' || str[i].toLowerCase() === 'g' || str[i].toLowerCase() === 'h' || str[i].toLowerCase() === 'j' || str[i].toLowerCase() === 'k' || str[i].toLowerCase() === 'l' || str[i].toLowerCase() ==='m' || str[i].toLowerCase() === 'n' || str[i].toLowerCase() === 'p' || str[i].toLowerCase() === 'q' || str[i].toLowerCase() === 'r' || str[i].toLowerCase() ==='s' || str[i].toLowerCase() === 't' || str[i].toLowerCase() === 'v' || str[i].toLowerCase() === 'w' || str[i].toLowerCase() === 'x' || str[i].toLowerCase() === 'y' || str[i].toLowerCase() === 'z') {\n      consonantCount++\n    }\n  }\n  return consonantCount\n}\n\n/*\n  Given a string, returns a string with all the vowels removed.\n  */\nconst removeVowels = (str) => {\n  let newString = ''\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase()!== 'a' && str[i].toLowerCase()!== 'e' && str[i].toLowerCase()!== 'i' && str[i].toLowerCase()!== 'o' && str[i].toLowerCase()!== 'u') {\n      newString += str[i]\n    }\n  }\n  return newString\n}\n\n/*\n  Given a string, returns a string with all the consonants removed.\n  */\nconst removeConsonants = (str) => {\n  let newString = ''\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase()!== 'b' && str[i].toLowerCase()!== 'c' && str[i].toLowerCase()!== 'd' && str[i].toLowerCase()!== 'f' && str[i].toLowerCase()!== 'g' && str[i].toLowerCase()!== 'h' && str[i].toLowerCase()!== 'j' && str[i].toLowerCase()!== 'k' && str[i].toLowerCase()!== 'l' && str[i].toLowerCase()!=='m' && str[i].toLowerCase()!== 'n' && str[i].toLowerCase()!== 'p' && str[i].toLowerCase()!== 'q' && str[i].toLowerCase()!== 'r' && str[i].toLowerCase()!=='s' && str[i].toLowerCase()!== 't' && str[i].toLowerCase()!== 'v' && str[i].toLowerCase()!== 'w' && str[i].toLowerCase()!== 'x' && str[i].toLowerCase()!== 'y' && str[i].toLowerCase()!== 'z') {\n      newString += str[i]\n    }\n  }\n  return newString\n}\n\n/*\n  Given a string, returns a string with all the spaces removed.\n  */\nconst removeSpaces = (str) => {\n  let newString = ''\n  for (let i = 0; i < str.length; i++) {\n    if (str[i]!=='') {\n      newString += str[i]\n    }\n  }\n  return newString\n}\n\n/*\n  Given a string, returns a string with all the punctuation removed.\n  */\nconst removePunctuation = (str) => {\n  let newString = ''\n  for (let i = 0; i < str.length; i++) {\n    if (str[i].toLowerCase()!== '.' && str[i].toLowerCase()!== '?' &&"}
{"task_id": "JavaScript/20", "prompt": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const a = findClosest(numbers[0], numbers);\n  const b = findClosest(numbers[1], numbers);\n  return [a, b];\n};\n\n/*\n  >>> findClosest(1.0, [1.0, 2.0, 3.0])\n  1.0\n  >>> findClosest(1.0, [1.0, 2.0, 3.1])\n  1.0\n  >>> findClosest(1.0, [1.0, 2.0, 3.0, 4.0])\n  2.0\n  >>> findClosest(1.0, [1.0, 2.0, 3.0, 4.0, 5.0])\n  2.0\n  >>> findClosest(1.0, [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  2.0\n  >>> findClosest(1.0, [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  2.2\n  >>> findClosest(1.0, [1.0, 2.0, 3.0, 4.0, 5.0, 2.2, 2.2])\n  2.2\n  >>> findClosest(1.0, [1.0, 2.0, 3.0, 4.0, 5.0, 2.2, 2.2, 2.2])\n  2.2\n  >>> findClosest(1.0, [1.0, 2.0, 3.0, 4.0, 5.0, 2.2, 2.2, 2.2, 2.2])\n  2.2\n  >>> findClosest(1.0, [1.0, 2.0, 3.0, 4.0, 5.0, 2.2, 2.2, 2.2, 2.2, 2.2])\n  2.2\n  */\nconst findClosest = (a, numbers) => {\n  const b = closest(a, numbers);\n  return b;\n};\n\nmodule.exports = {\n  findClosestElements,\n  findClosest\n};\n<|endoftext|>"}
{"task_id": "JavaScript/21", "prompt": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": true, "gc": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n    const length = numbers.length;\n    let sum = 0;\n    for(let i = 0; i < length; i++)\n        sum += numbers[i];\n    let scale = 1.0 / sum;\n    for(let i = 0; i < length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n\n/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest number will be scaled to 0 and the largest will be scaled to 1\n  >>> rescaleToUnit([-1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0])\n  [-1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst rescaleToUnitInverse = (numbers) => {\n    const length = numbers.length;\n    let sum = 0;\n    for(let i = 0; i < length; i++)\n        sum += numbers[i];\n    let scale = 1.0 / sum;\n    for(let i = 0; i < length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n\n/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest number will be scaled to 0 and the largest will be scaled to 1\n  >>> rescaleToUnitInverse([-1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0])\n  [-1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst rescaleToUnitInverseInverse = (numbers) => {\n    const length = numbers.length;\n    let sum = 0;\n    for(let i = 0; i < length; i++)\n        sum += numbers[i];\n    let scale = 1.0 / sum;\n    for(let i = 0; i < length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n\n/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest number will be scaled to 0 and the largest will be scaled to 1\n  >>> rescaleToUnitInverseInverse([-1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0])\n  [-1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst rescaleToUnitInverseInverseInverse = (numbers) => {\n    const length = numbers.length;\n    let sum = 0;\n    for(let i = 0; i < length; i++)\n        sum += numbers[i];\n    let scale = 1.0 / sum;\n    for(let i = 0; i < length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n\n/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest number will be scaled to 0 and the largest will be scaled to 1\n  >>> rescaleToUnitInverseInverseInverse([-1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0])\n  [-1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n  */\nconst rescaleToUnitInverseInverseInverseInverse = (numbers) => {\n    const length = numbers.length;\n    let sum = 0;\n    for(let i = 0; i < length; i++)\n        sum += numbers[i];\n    let scale = 1.0 / sum;\n    for(let i = 0; i < length; i++)\n        numbers[i] = numbers[i] * scale;\n    return numbers;\n}\n\nmodule.exports = {\n    rescaleToUnit,\n    rescaleToUnitInverse,\n    rescaleToUnitInverseInverse,\n    rescaleToUnitInverseInverseInverse,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/22", "prompt": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => isInteger(v));\n};\n\nconst filterNonIntegers = (values) => {\n  return values.filter(v => isInteger(v));\n};\n\nexport { filterIntegers, filterNonIntegers };\n<|endoftext|>"}
{"task_id": "JavaScript/23", "prompt": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/* Retkrn true if given string is empty */\nconst strIsEmpty = (string) => {\n  return!string\n}\n\n/* Retkrn true if given string is not empty */\nconst strIsNotEmpty = (string) => {\n  return string\n}\n\n/* Retkrn true if given string has no whitespace */\nconst strIsWhitespace = (string) => {\n  return!/\\s/.test(string)\n}\n\n/* Retkrn true if given string has whitespace */\nconst strHasWhitespace = (string) => {\n  return /\\s/.test(string)\n}\n\n/* Retkrn true if given string has no special characters */\nconst strIsSpecial = (string) => {\n  return!/[^A-Za-z0-9]/.test(string)\n}\n\n/* Retkrn true if given string has special characters */\nconst strHasSpecial = (string) => {\n  return /[^A-Za-z0-9]/.test(string)\n}\n\n/* Retkrn true if given string has no numbers */\nconst strIsNumber = (string) => {\n  return!/\\d/.test(string)\n}\n\n/* Retkrn true if given string has numbers */\nconst strHasNumber = (string) => {\n  return /\\d/.test(string)\n}\n\n/* Retkrn true if given string has only special characters */\nconst strHasSpecialOnly = (string) => {\n  return /[^A-Za-z0-9]/.test(string)\n}\n\n/* Retkrn true if given string has only numbers */\nconst strHasNumberOnly = (string) => {\n  return /\\d/.test(string)\n}\n\n/* Retkrn true if given string has at least one character */\nconst strIsNotBlank = (string) => {\n  return string\n}\n\n/* Retkrn true if given string has at least one special character */\nconst strHasSpecialOnly = (string) => {\n  return /[^A-Za-z0-9]/.test(string)\n}\n\n/* Retkrn true if given string has at least one number */\nconst strHasNumberOnly = (string) => {\n  return /\\d/.test(string)\n}\n\n/* Retkrn true if given string has no upper case characters */\nconst strIsLowerCase = (string) => {\n  return string.toLowerCase() === string\n}\n\n/* Retkrn true if given string has upper case characters */\nconst strHasUpperCase = (string) => {\n  return string.toUpperCase() === string\n}\n\n/* Retkrn true if given string has no lower case characters */\nconst strIsUpperCase = (string) => {\n  return string.toUpperCase() === string\n}\n\n/* Retkrn true if given string has lower case characters */\nconst strHasLowerCase = (string) => {\n  return string.toLowerCase() === string\n}\n\n/* Retkrn true if given string is an integer */\nconst strIsInteger = (string) => {\n  return (/^\\d+$/.test(string) &&!isNaN(string))\n}\n\n/* Retkrn true if given string is a float */\nconst strIsFloat = (string) => {\n  return (/^\\d+\\.\\d+$/.test(string) &&!isNaN(string))\n}\n\n/* Retkrn true if given string is a decimal */\nconst strIsDecimal = (string) => {\n  return (/^\\d+\\.\\d+$/.test(string) &&!isNaN(string))\n}\n\n/* Retkrn true if given string is a hexadecimal */\nconst strIsHexadecimal = (string) => {\n  return (/^0x[A-F0-9]+$/.test(string) &&!isNaN(string))\n}\n\n/* Retkrn true if given string is a hexadecimal or decimal */\nconst strIsHexadecimalOrDecimal = (string) => {\n  return (/^0x[A-F0-9]+$/.test(string) || /^\\d+\\.\\d+$/.test(string) &&!isNaN(string))\n}\n\n/* Retkrn true if given string is a octal */\nconst strIsOctal = (string) => {\n  return (/^0[0-7]+$/.test(string) &&!isNaN(string))\n}\n\n/* Retkrn true if given string is a hexadecimal or decimal or octal */\nconst strIsHexadecimalOrDecimalOrOctal = (string) => {\n  return (/^0[0-7]+$/.test(string) || /^0x[A-F0-9]+$/.test(string) || /^\\d+\\.\\d+$/.test(string) &&!isNaN(string))\n}\n\n/* Retkrn true if given string is a string */\nconst strIsString = (string) => {\n  return (typeof string ==='string')\n}\n\n/* Retkrn true if given string is a boolean */\nconst strIsBoolean = (string) => {\n  return (typeof string === 'boolean')\n}\n\n/* Retkrn true if given string is a function */\nconst strIsFunction = (string) => {\n  return (typeof string === 'function')\n}\n\n/* Retkrn true if given string is an array */\nconst strIsArray = (string) => {\n  return (string instanceof Array)\n}\n\n/* Retkrn true if given string is a regexp */\nconst strIsRegExp = (string) => {\n  return (string instanceof RegExp)\n}\n\n/* Retkrn true if given string is a date */\nconst strIsDate = (string) => {\n  return (string instanceof Date)\n}\n\n/* Retkrn true if given string is a RegExp */\nconst strIsRegExp = (string) => {\n  return (string instanceof RegExp)\n}\n\n/* Retkrn true if given string is a number */\nconst strIsNumber = (string) => {\n  return (typeof string === 'number')\n}\n\n/* Retkrn true if given string is a string */\nconst str"}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  const divisorList = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  const divisorListLength = divisorList.length;\n\n  for (let i = divisorListLength - 1; i >= 0; i--) {\n    if (n % divisorList[i] === 0) {\n      return divisorList[i];\n    }\n  }\n\n  return 1;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/25", "prompt": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = []\n  const factor = (n) => {\n    const d = n - 1\n    while (d > 1) {\n      if (n % d === 0) {\n        factors.push(d)\n        break\n      }\n      d--\n    }\n  }\n  factor(n)\n  return factors\n}\n\nconst factorizatioi = (n) => {\n  const factors = []\n  const factor = (n) => {\n    const d = n - 1\n    while (d > 1) {\n      if (n % d === 0) {\n        factors.push(d)\n        break\n      }\n      d--\n    }\n  }\n  factor(n)\n  return factors\n}\n\n/*\n  Return a list of all prime factors of n.\n  >>> factorizatioi(7)\n  [2, 3]\n  >>> factorizatioi(8)\n  [2, 2, 2]\n  >>> factorizatioi(25)\n  [5, 5]\n  >>> factorizatioi(70)\n  [2, 5, 7]\n  */\nconst factorizatioi2 = (n) => {\n  const factors = []\n  const factor = (n) => {\n    const d = n - 1\n    while (d > 1) {\n      if (n % d === 0) {\n        factors.push(d)\n        break\n      }\n      d--\n    }\n  }\n  factor(n)\n  return factors\n}\n\nconst isPrime = (n) => {\n  let d = 1\n  while (d * d <= n) {\n    if (n % d === 0) return false\n    d++\n  }\n  return true\n}\n\nconst isEven = (n) => {\n  return n % 2 === 0\n}\n\nconst isOdd = (n) => {\n  return n % 2 === 1\n}\n\nconst isDivisibleBy = (n, d) => {\n  return n % d === 0\n}\n\nconst isPrimeDivisibleBy = (n, d) => {\n  if (!isPrime(n)) return false\n  if (isPrime(n) &&!isEven(n)) return false\n  return isDivisibleBy(n, d)\n}\n\nconst factorize2 = (n) => {\n  const factors = []\n  const factor = (n) => {\n    const d = n - 1\n    while (d > 1) {\n      if (n % d === 0) {\n        factors.push(d)\n        break\n      }\n      d--\n    }\n  }\n  factor(n)\n  return factors\n}\n\nconst factorizatioi3 = (n) => {\n  const factors = []\n  const factor = (n) => {\n    const d = n - 1\n    while (d > 1) {\n      if (n % d === 0) {\n        factors.push(d)\n        break\n      }\n      d--\n    }\n  }\n  factor(n)\n  return factors\n}\n\nconst factorizatioi4 = (n) => {\n  const factors = []\n  const factor = (n) => {\n    const d = n - 1\n    while (d > 1) {\n      if (n % d === 0) {\n        factors.push(d)\n        break\n      }\n      d--\n    }\n  }\n  factor(n)\n  return factors\n}\n\nconst isPrimeDivisibleBy3 = (n, d) => {\n  if (!isPrimeDivisibleBy(n, d)) return false\n  if (isPrimeDivisibleBy(n, d) &&!isEven(n)) return false\n  return isDivisibleBy(n, d)\n}\n\nconst isPrimeDivisibleBy5 = (n, d) => {\n  if (!isPrimeDivisibleBy(n, d)) return false\n  if (isPrimeDivisibleBy(n, d) &&!isOdd(n)) return false\n  return isDivisibleBy(n, d)\n}\n\nconst isPrimeDivisibleBy7 = (n, d) => {\n  if (!isPrimeDivisibleBy(n, d)) return false\n  if (isPrimeDivisibleBy(n, d) &&!isOdd(n)) return false\n  return isDivisibleBy(n, d)\n}\n\nconst isPrimeDivisibleBy11 = (n, d) => {\n  if (!isPrimeDivisibleBy(n, d)) return false\n  if (isPrimeDivisibleBy(n, d) &&!isOdd(n)) return false\n  return isDivisibleBy(n, d)\n}\n\nconst isPrimeDivisibleBy13 = (n, d) => {\n  if (!isPrimeDivisibleBy(n, d)) return false\n  if (isPrimeDivisibleBy(n, d) &&!isOdd(n)) return false\n  return isDivisibleBy(n, d)\n}\n\nconst isPrimeDivisibleBy17 = (n, d) => {\n  if (!isPrimeDivisibleBy(n, d)) return false\n  if (isPrimeDivisibleBy(n, d) &&!isOdd(n)) return false\n  return isDivisibleBy(n, d)\n}\n\nconst isPrimeDivisibleBy19 = (n, d) => {\n  if (!isPrimeDivisibleBy(n, d)) return false\n  if (isPrimeDivisibleBy(n, d) &&!isOdd(n)) return false\n  return isDivisibleBy(n, d)\n}\n\nconst isPrimeDivisibleBy23 = (n, d) => {\n  if (!isPrimeDivisibleBy(n, d)) return false\n  if (isPrimeDivisibleBy(n, d) &&!isOdd(n)) return false\n  return isDivisibleBy(n, d)\n}\n\nconst isPrimeDivisibleBy29 = (n, d) => {"}
{"task_id": "JavaScript/26", "prompt": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const len = numbers.length;\n  let current = 0;\n  const result = [];\n  while (current < len) {\n    if (numbers[current] === numbers[current - 1]) {\n      // same as previous\n      current++;\n    } else {\n      result.push(numbers[current]);\n      current++;\n    }\n  }\n  return result;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/[a-z]/g, (match) => {\n    return String.fromCharCode(match.charCodeAt(0) ^ 32) + match.charAt(1);\n  });\n};\n\n/*\n  For a given string, replace characters with non-ascii values with their\n  hex values, e.g. a = 'a'.\n  >>> replaceNonAscii('a')\n  '61'\n  */\nconst replaceNonAscii = (string) => {\n  return string.replace(/[^\\x00-\\x7f]/g, (match) => {\n    return match.charCodeAt(0).toString(16);\n  });\n};\n\n/*\n  For a given string, replace non-ascii characters with their ASCII values.\n  >>> replaceNonAscii('a')\n  97\n  >>> replaceNonAscii('\\u0B6C')\n  102\n  */\nconst replaceAscii = (string) => {\n  return string.replace(/[^\\x00-\\x7f]/g, (match) => {\n    return match.charCodeAt(0).toString(16);\n  });\n};\n\n/*\n  This is just a test for a recursive function.\n  >>> replaceAll('a', replaceNonAscii)\n  'a'\n  >>> replaceAll('a', replaceAscii)\n  'a'\n  >>> replaceAll('\\u0B6C', replaceNonAscii)\n  '\\u0B6C'\n  >>> replaceAll('\\u0B6C', replaceAscii)\n  '\\u0B6C'\n  */\nconst replaceAll = (string, function) => {\n  return string.replace(/[^\\x00-\\x7f]/g, function(match) {\n    return function(char) {\n      return char.charCodeAt(0).toString(16);\n    };\n  });\n};\n\nmodule.exports = {\n  flipCase,\n  replaceNonAscii,\n  replaceAscii,\n  replaceAll\n};\n<|endoftext|>"}
{"task_id": "JavaScript/28", "prompt": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": true, "gc": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  const buffer = [];\n  strings.forEach(string => buffer.push(string));\n  return buffer.join('');\n};\n\n/**\n * Returns the length of a string\n  >>> len('abc')\n  3\n  >>> len('')\n  0\n  */\nconst len = (string) => {\n  return string.length;\n};\n\n/**\n * Returns a string of length `length` with repeating `char`\n  >>> repeat('a', 3)\n  'aaa'\n  >>> repeat('a', 0)\n  ''\n  >>> repeat('a', -1)\n  Traceback (most recent call last):\n ...\n  ValueError: Invalid length for repeat\n  >>> repeat('a', 'b')\n  Traceback (most recent call last):\n ...\n  TypeError: expected string for repeat\n  >>> repeat(1, 3)\n  Traceback (most recent call last):\n ...\n  TypeError: expected string for repeat\n  */\nconst repeat = (char, length) => {\n  if (typeof length!== 'number') {\n    throw new TypeError('expected number for repeat');\n  }\n\n  if (length < 0) {\n    throw new ValueError('Invalid length for repeat');\n  }\n\n  const buffer = [];\n  for (let i = 0; i < length; i++) {\n    buffer.push(char);\n  }\n\n  return buffer.join('');\n};\n\n/**\n * Returns a string with `char` repeated `count` times\n  >>> repeat('a', 1)\n  'a'\n  >>> repeat('a', 3)\n  'aaa'\n  >>> repeat('a', 0)\n  ''\n  >>> repeat('a', -1)\n  Traceback (most recent call last):\n ...\n  ValueError: Invalid length for repeat\n  >>> repeat(1, 'b')\n  Traceback (most recent call last):\n ...\n  TypeError: expected string for repeat\n  */\nconst repeat = (char, count) => {\n  if (typeof count!== 'number') {\n    throw new TypeError('expected number for repeat');\n  }\n\n  if (count < 0) {\n    throw new ValueError('Invalid length for repeat');\n  }\n\n  const buffer = [];\n  for (let i = 0; i < count; i++) {\n    buffer.push(char);\n  }\n\n  return buffer.join('');\n};\n\nmodule.exports = {\n  concatenate,\n  len,\n  repeat,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/29", "prompt": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  Filters a list of strings to remove all the strings that have a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(s =>!s.endsWith(suffix));\n};\n\n/*\n  Filters a list of strings to remove all the strings that contain a given string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'bcd']\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'e')\n  []\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => contains(s) === false);\n};\n\n/*\n  Filters a list of strings to remove all the strings that don't contain a given string.\n  >>> filterByNotContains([], 'a')\n  []\n  >>> filterByNotContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> filterByNotContains(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'bcd', 'array']\n  >>> filterByNotContains(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> filterByNotContains(['abc', 'bcd', 'cde', 'array'], 'e')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByNotContains = (strings, contains) => {\n  return strings.filter(s => contains(s) === true);\n};\n\n/*\n  Filters a list of strings to remove all the strings that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['bcd', 'cde']\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['cde', 'array']\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'e')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  Filters a list of strings to remove all the strings that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'bcd']\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['abc', 'bcd', 'cde']\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'e')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(s =>!s.endsWith(suffix));\n};\n\n/*\n  Filters a list of strings to remove all the strings that contain a given string.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'bcd', 'array']\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'e')\n  ['abc', 'bcd', 'cde', 'array']\n  */\nconst filterByContains = (strings, contains) => {\n  return strings.filter(s => contains(s) === true);\n};\n\n/*\n  Filters a list of strings to remove all the strings that don't contain a given string.\n  >>> filterByNotContains([], 'a')\n  []\n  >>> filterByNotContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> filterByNotContains(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'bcd', 'array']\n  >>> filterByNotContains(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> filter"}
{"task_id": "JavaScript/30", "prompt": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": true, "gc": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter((n) => n > 0)\n}\n\n//Bugsnag\n//\n//https://bugsnag.com/docs/api/exceptions\n//\n//https://bugsnag.com/docs/api/notifications\n//\n//https://bugsnag.com/docs/api/releases\n//\n//https://bugsnag.com/docs/api/severities\n//\n//https://bugsnag.com/docs/api/status\n//\n//https://bugsnag.com/docs/api/traces\n//\n//https://bugsnag.com/docs/api/user-info\n//\n//https://bugsnag.com/docs/api/events\n//\n//https://bugsnag.com/docs/api/caches\n//\n//https://bugsnag.com/docs/api/config\n//\n//https://bugsnag.com/docs/api/releases/:id\n//\n//https://bugsnag.com/docs/api/releases/:id/notes\n//\n//https://bugsnag.com/docs/api/releases/:id/events\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type/:extra_data\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type/:extra_data/:value\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type/:extra_data/:value/:type\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type/:extra_data/:value/:type/:extra_data_2\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type/:extra_data/:value/:type/:extra_data_2/:value\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type/:extra_data/:value/:type/:extra_data_2/:value/:type\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type/:extra_data/:value/:type/:extra_data_2/:value/:type/:extra_data_3\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type/:extra_data/:value/:type/:extra_data_2/:value/:type/:extra_data_3/:value\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type/:extra_data/:value/:type/:extra_data_2/:value/:type/:extra_data_3/:value/:type\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type/:extra_data/:value/:type/:extra_data_2/:value/:type/:extra_data_3/:value/:type/:extra_data_4\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type/:extra_data/:value/:type/:extra_data_2/:value/:type/:extra_data_3/:value/:type/:extra_data_4/:value\n//\n//https://bugsnag.com/docs/api/releases/:id/events/:event_id/notes/:note_id/events/:event_id/:message/:type/:extra_data/:value/:type/:extra_data_2/:value/:type/:extra_data_3/:value/:type/:extra_data_4/"}
{"task_id": "JavaScript/31", "prompt": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  let prime = n,\n      divide = (n, i) => {\n        return n % i === 0? i : n % (i + prime) === 0? n / (i + prime) : false;\n      };\n  for (let i = 2; i <= n; i++) {\n    if (!divide(i, prime)) return false;\n  }\n  return true;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const n = xs.length;\n  const k = 0;\n\n  while(true) {\n    const poly = poly(xs, k);\n    if (poly === 0) {\n      return k;\n    }\n    k++;\n  }\n}\n\n/*\n  Given a list of coefficients and their x values\n  find the x value such that poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  >>> round(findZero([-2, -3, -4, -5, -6, -7]), 2) # -2 + 3x - 4x^2 + 5x^3 - 6x^4 + 7x^5\n  2.0\n  */\nconst find = (xs) => {\n  const n = xs.length;\n  const k = 0;\n\n  while(true) {\n    const poly = poly(xs, k);\n    if (poly === 0) {\n      return xs[k];\n    }\n    k++;\n  }\n}\n\n// find a zero\nconst zeros = (xs) => {\n  const n = xs.length;\n  const k = 0;\n\n  while(true) {\n    const poly = poly(xs, k);\n    if (poly === 0) {\n      return k;\n    }\n    k++;\n  }\n}\n\n// find a point\nconst points = (xs) => {\n  const n = xs.length;\n  const k = 0;\n\n  while(true) {\n    const poly = poly(xs, k);\n    if (poly!== 0) {\n      return k;\n    }\n    k++;\n  }\n}\n\n// find a point\nconst points = (xs) => {\n  const n = xs.length;\n  const k = 0;\n\n  while(true) {\n    const poly = poly(xs, k);\n    if (poly!== 0) {\n      return k;\n    }\n    k++;\n  }\n}\n\n// find a zero\nconst points = (xs) => {\n  const n = xs.length;\n  const k = 0;\n\n  while(true) {\n    const poly = poly(xs, k);\n    if (poly!== 0) {\n      return k;\n    }\n    k++;\n  }\n}\n\n/*\n  Given a list of coefficients and their x values\n  find the x value such that poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(find([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(find([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  >>> round(find([-2, -3, -4, -5, -6, -7]), 2) # -2 + 3x - 4x^2 + 5x^3 - 6x^4 + 7x^5\n  2.0\n  */\nconst points = (xs) => {\n  const n = xs.length;\n  const k = 0;\n\n  while(true) {\n    const poly = poly(xs, k);\n    if (poly === 0) {\n      return xs[k];\n    }\n    k++;\n  }\n}\n\n// find a zero\nconst points = (xs) => {\n  const n = xs.length;\n  const k = 0;\n\n  while(true) {\n    const poly = poly(xs, k);\n    if (poly === 0) {\n      return k;\n    }\n    k++;\n  }\n}\n\n// find a point\nconst points = (xs) => {\n  const n = xs.length;\n  const k = 0;\n\n  while(true) {\n    const poly = poly(xs, k);\n    if (poly!== 0) {\n      return k;\n    }\n    k++;\n  }\n}\n\nmodule.exports = {\n  findZero,\n  points,\n  find,\n  zeros\n};\n<|endoftext|>"}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const xs = [];\n  const ys = [];\n  const zs = [];\n  for (let i = 0; i < l.length; i++) {\n    const num = l[i];\n    if (num % 3 === 0) {\n      ys.push(num);\n    } else {\n      xs.push(num);\n    }\n    zs.push(num);\n  }\n  const sortedX = sortThird(xs);\n  const sortedY = sortThird(ys);\n  const sortedZ = sortThird(zs);\n  const sortedL = [...sortedX,...sortedY,...sortedZ];\n  return sortedL;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by five, while its values at the indicivs that are ditisiblw by five are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortFifth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFifth([5, 6, 3, 4, 8, 9, 2])\n  [2, 3, 4, 5, 6, 8, 9, 5]\n  */\nconst sortFifth = (l) => {\n  const xs = [];\n  const ys = [];\n  const zs = [];\n  for (let i = 0; i < l.length; i++) {\n    const num = l[i];\n    if (num % 5 === 0) {\n      ys.push(num);\n    } else {\n      xs.push(num);\n    }\n    zs.push(num);\n  }\n  const sortedX = sortFifth(xs);\n  const sortedY = sortFifth(ys);\n  const sortedZ = sortFifth(zs);\n  const sortedL = [...sortedX,...sortedY,...sortedZ];\n  return sortedL;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by seven, while its values at the indicivs that are ditisiblw by seven are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortSeventh([1, 2, 3])\n  [1, 2, 3]\n  >>> sortSeventh([5, 6, 3, 4, 8, 9, 2])\n  [2, 3, 4, 5, 6, 8, 9, 5]\n  */\nconst sortSeventh = (l) => {\n  const xs = [];\n  const ys = [];\n  const zs = [];\n  for (let i = 0; i < l.length; i++) {\n    const num = l[i];\n    if (num % 7 === 0) {\n      ys.push(num);\n    } else {\n      xs.push(num);\n    }\n    zs.push(num);\n  }\n  const sortedX = sortSeventh(xs);\n  const sortedY = sortSeventh(ys);\n  const sortedZ = sortSeventh(zs);\n  const sortedL = [...sortedX,...sortedY,...sortedZ];\n  return sortedL;\n};\n\nmodule.exports = {\n  sortThird,\n  sortFifth,\n  sortSeventh\n};\n<|endoftext|>"}
{"task_id": "JavaScript/34", "prompt": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": true, "gc": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (result.indexOf(l[i]) < 0) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n}\n\n//Test\nexport default unique;<|endoftext|>"}
{"task_id": "JavaScript/35", "prompt": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": true, "gc": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  if (l.length === 0) return null\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) max = l[i]\n  }\n  return max\n}\n\nexport default maxElement\n<|endoftext|>"}
{"task_id": "JavaScript/36", "prompt": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  const total = (n + 1)\n  const div = (total % 11) || (total % 13)\n\n  if (div === 7) {\n    return '7'\n  }\n  return total\n}\n\nexport default fizzBuzz\n<|endoftext|>"}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const even = [];\n  const odd = [];\n  const x = [];\n  for (let i = 0; i < l.length; i += 2) {\n    if (i % 2 === 0) {\n      even.push(l[i]);\n    } else {\n      odd.push(l[i]);\n    }\n  }\n  for (let i = 0; i < l.length; i += 2) {\n    x.push(l[i]);\n  }\n  x = x.sort((a, b) => a - b);\n  for (let i = 0; i < even.length; i++) {\n    if (x[i]!== even[i]) {\n      throw new Error(\"Sort even failed\");\n    }\n  }\n  for (let i = 1; i < odd.length; i++) {\n    if (x[i]!== odd[i - 1]) {\n      throw new Error(\"Sort even failed\");\n    }\n  }\n  return even;\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  */\nconst sortOdd = (l) => {\n  const even = [];\n  const odd = [];\n  const x = [];\n  for (let i = 1; i < l.length; i += 2) {\n    if (i % 2 === 0) {\n      odd.push(l[i]);\n    } else {\n      even.push(l[i]);\n    }\n  }\n  for (let i = 0; i < l.length; i += 2) {\n    x.push(l[i]);\n  }\n  x = x.sort((a, b) => a - b);\n  for (let i = 1; i < odd.length; i++) {\n    if (x[i]!== odd[i - 1]) {\n      throw new Error(\"Sort odd failed\");\n    }\n  }\n  for (let i = 0; i < even.length; i++) {\n    if (x[i]!== even[i]) {\n      throw new Error(\"Sort odd failed\");\n    }\n  }\n  return odd;\n}\n\nconst arr = [1, 3, 2, 4, 6, 5, 7];\nconst even = sortEven(arr);\nconst odd = sortOdd(arr);\nconsole.log(`Even: ${JSON.stringify(even)}`);\nconsole.log(`Odd: ${JSON.stringify(odd)}`);\n<|endoftext|>"}
{"task_id": "JavaScript/38", "prompt": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n  const c = encodeCyclic(s);\n  const groups = [], groups2 = [];\n  for (let i = 0; i < c.length; i += 3) {\n    groups.push(c.slice(i, Math.min(c.length, i + 3)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  Encodes a string into its hexadecimal representation.\n  */\nconst encodeHex = (s) => {\n  const result = encodeURIComponent(s).replace(/%../g, (match) => {\n    let hex = match.slice(1);\n    return match.charCodeAt(0) + '' + hex;\n  });\n  return result;\n}\n\n/*\n  Decodes a hexadecimal string into its original representation.\n  */\nconst decodeHex = (s) => {\n  const result = decodeURIComponent(s).replace(/%../g, (match) => {\n    let hex = match.slice(2);\n    return String.fromCharCode(parseInt(hex, 16));\n  });\n  return result;\n}\n\n/*\n  Encodes a string into its hexadecimal representation.\n  */\nconst encodeBase64 = (s) => {\n  const result = encodeURIComponent(s).replace(/%../g, (match) => {\n    let base64 = match.slice(1);\n    return match.charCodeAt(0) + '' + base64;\n  });\n  return result;\n}\n\n/*\n  Decodes a base64 string into its original representation.\n  */\nconst decodeBase64 = (s) => {\n  const result = decodeURIComponent(s).replace(/%../g, (match) => {\n    let base64 = match.slice(2);\n    return String.fromCharCode(parseInt(base64, 16));\n  });\n  return result;\n}\n\n/*\n  Decodes a string encoded by encodeHex.\n  */\nconst decodeHex = (s) => {\n  return decodeHex(s);\n}\n\n/*\n  Encodes a string into its base64 representation.\n  */\nconst encodeBase64 = (s) => {\n  const result = encodeBase64(s);\n  return result;\n}\n\n/*\n  Decodes a base64 string into its original representation.\n  */\nconst decodeBase64 = (s) => {\n  const result = decodeBase64(s);\n  return result;\n}\n\n/*\n  Decodes a string encoded by encodeBase64.\n  */\nconst decodeBase64 = (s) => {\n  return decodeBase64(s);\n}\n\n/*\n  Decodes a string encoded by encodeHex.\n  */\nconst decodeHex = (s) => {\n  return decodeHex(s);\n}\n\n/*\n  Returns a random number between the min and max limits.\n  */\nconst randomNumber = (min, max) => {\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\n/*\n  Returns a random string of a given length.\n  */\nconst randomString = (length) => {\n  const s = '';\n  for (let i = 0; i < length; i++) {\n    s += Math.floor(Math.random() * (26 + 1));\n  }\n  return s;\n}\n\n/*\n  Returns a random hexadecimal string of a given length.\n  */\nconst randomHex = (length) => {\n  const s = '';\n  for (let i = 0; i < length; i++) {\n    s += Math.floor(Math.random() * 16);\n  }\n  return s;\n}\n\n/*\n  Returns a random base64 string of a given length.\n  */\nconst randomBase64 = (length) => {\n  const s = '';\n  for (let i = 0; i < length; i++) {\n    s += Math.floor(Math.random() * 64);\n  }\n  return s;\n}\n\n/*\n  Returns a random string of a given length.\n  */\nconst randomString = (length) => {\n  const s = '';\n  for (let i = 0; i < length; i++) {\n    s += Math.floor(Math.random() * (26 + 1));\n  }\n  return s;\n}\n\n/*\n  Returns a random string of a given length.\n  */\nconst randomHex = (length) => {\n  const s = '';\n  for (let i = 0; i < length; i++) {\n    s += Math.floor(Math.random() * 16);\n  }\n  return s;\n}\n\n/*\n  Returns a random string of a given length.\n  */\nconst randomBase64 = (length) => {\n  const s = '';\n  for (let i = 0; i < length; i++) {\n    s += Math.floor(Math.random() * 64);\n  }\n  return s;\n}\n\n/*\n  Returns a random string of a given length.\n  */\nconst randomString = (length) => {\n  const s = '';\n  for (let i = 0; i < length; i++) {\n    s += Math.floor(Math.random() * (26 + 1));\n  }"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n    if (n < 2) {\n        return n;\n    }\n    let f = 2;\n    let p = 3;\n    while (p < n) {\n        f += p;\n        p += 2;\n    }\n    if (f % 2!== 0) {\n        return n;\n    }\n    return f;\n};\n\nconst primeFibTest = () => {\n    console.log(primeFib(2));\n    console.log(primeFib(3));\n    console.log(primeFib(4));\n    console.log(primeFib(5));\n    console.log(primeFib(8));\n};\n\nprimeFibTest();\n<|endoftext|>"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n    const d = new Set()\n    for (let i = 0; i < l.length; i++) {\n        if (l[i] < 0) {\n            throw new Error(\"negative values are not allowed\")\n        }\n        const j = i + 1\n        if (j >= l.length) {\n            throw new Error(\"at least two elements are required\")\n        }\n        const k = j + 1\n        if (k >= l.length) {\n            throw new Error(\"at least two elements are required\")\n        }\n        const sum = l[i] + l[j] + l[k]\n        if (sum === 0) {\n            d.add(sum)\n        }\n    }\n    return d.size === 3\n}\n\nconsole.log(triplesSumToZero([1, 3, 5, 0]))\nconsole.log(triplesSumToZero([1, 3, -2, 1]))\nconsole.log(triplesSumToZero([1, 2, 3, 7]))\nconsole.log(triplesSumToZero([2, 4, -5, 3, 9, 7]))\nconsole.log(triplesSumToZero([1]))\n<|endoftext|>"}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let cars = [];\n  cars.push(car({\n    x: 0,\n    y: 0,\n    vx: 1,\n    vy: 0,\n    r: 0,\n    collision: collision\n  }));\n  cars.push(car({\n    x: 0,\n    y: 0,\n    vx: 0,\n    vy: 1,\n    r: 0,\n    collision: collision\n  }));\n  for (let i = 1; i < n; i++) {\n    cars.push(car({\n      x: 0,\n      y: 0,\n      vx: i * 2,\n      vy: 0,\n      r: 0,\n      collision: collision\n    }));\n    cars.push(car({\n      x: 0,\n      y: 0,\n      vx: -i * 2,\n      vy: 0,\n      r: 0,\n      collision: collision\n    }));\n  }\n  for (let i = 0; i < n; i++) {\n    cars[i].x = i;\n    cars[i].y = 0;\n    cars[i].vx = i * 2;\n    cars[i].vy = 0;\n    cars[i].r = 0;\n  }\n  let collisions = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      collisions += cars[i].collision(cars[j]);\n    }\n  }\n  return collisions;\n}\n\n/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision2 = (n) => {\n  let cars = [];\n  cars.push(car({\n    x: 0,\n    y: 0,\n    vx: 1,\n    vy: 0,\n    r: 0,\n    collision: collision\n  }));\n  cars.push(car({\n    x: 0,\n    y: 0,\n    vx: 0,\n    vy: 1,\n    r: 0,\n    collision: collision\n  }));\n  for (let i = 1; i < n; i++) {\n    cars.push(car({\n      x: 0,\n      y: 0,\n      vx: i * 2,\n      vy: 0,\n      r: 0,\n      collision: collision\n    }));\n    cars.push(car({\n      x: 0,\n      y: 0,\n      vx: -i * 2,\n      vy: 0,\n      r: 0,\n      collision: collision\n    }));\n  }\n  for (let i = 0; i < n; i++) {\n    cars[i].x = i;\n    cars[i].y = 0;\n    cars[i].vx = i * 2;\n    cars[i].vy = 0;\n    cars[i].r = 0;\n  }\n  let collisions = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      collisions += cars[i].collision(cars[j]);\n    }\n  }\n  return collisions;\n}\n\nlet collisions = carRaceCollision(20);\nconsole.log(collisions);\n\ncollisions = carRaceCollision2(20);\nconsole.log(collisions);\n<|endoftext|>"}
{"task_id": "JavaScript/42", "prompt": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": true, "gc": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const len = l.length\n  const res = new Array(len + 1)\n  res[0] = 1\n  for (let i = 1; i < len; i++) {\n    res[i] = l[i - 1] + 1\n  }\n  return res\n}\n\n/**\n  * Return index of last element of list.\n  * @param {Array} l\n  * @returns {Number}\n  *\n  * >>> indexLast(['a', 'b', 'c'])\n  * 2\n  * >>> indexLast([1, 2, 3, 4])\n  * 2\n  * >>> indexLast([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  * 6\n  */\nconst indexLast = (l) => {\n  const len = l.length\n  for (let i = 0; i < len - 1; i++) {\n    if (l[i] === l[i + 1]) {\n      return i + 1\n    }\n  }\n  return len\n}\n\n/**\n  * Return index of first element of list.\n  * @param {Array} l\n  * @returns {Number}\n  *\n  * >>> indexFirst(['a', 'b', 'c'])\n  * 0\n  * >>> indexFirst([1, 2, 3, 4])\n  * 0\n  * >>> indexFirst([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  * 0\n  */\nconst indexFirst = (l) => {\n  const len = l.length\n  for (let i = 1; i < len; i++) {\n    if (l[i] === l[i - 1]) {\n      return i - 1\n    }\n  }\n  return 0\n}\n\n/**\n  * Return first element of list.\n  * @param {Array} l\n  * @returns {Number}\n  *\n  * >>> first(['a', 'b', 'c'])\n  * 'a'\n  * >>> first([1, 2, 3, 4])\n  * 1\n  * >>> first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  * 5\n  */\nconst first = (l) => {\n  return l[0]\n}\n\n/**\n  * Return last element of list.\n  * @param {Array} l\n  * @returns {Number}\n  *\n  * >>> last(['a', 'b', 'c'])\n  * 'c'\n  * >>> last([1, 2, 3, 4])\n  * 4\n  * >>> last([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  * 9\n  */\nconst last = (l) => {\n  return l[l.length - 1]\n}\n\n/**\n  * Return a string with all elements of list joined by the given delimiter.\n  * @param {Array} l\n  * @param {String} delimiter\n  * @returns {String}\n  *\n  * >>> join(['a', 'b', 'c'], ',')\n  * 'a,b,c'\n  * >>> join([1, 2, 3, 4], ',')\n  * '1,2,3,4'\n  * >>> join([5, 3, 5, 2, 3, 3, 9, 0, 123], ',')\n  * '5,3,5,2,3,3,9,0,123'\n  */\nconst join = (l, delimiter) => {\n  const delimiterLen = delimiter.length\n  return l.map(el => {\n    return el.toString()\n  }).join(delimiter)\n}\n\n/**\n  * Return a string with all elements of list joined by the given delimiter.\n  * @param {Array} l\n  * @param {String} delimiter\n  * @returns {String}\n  *\n  * >>> join(['a', 'b', 'c'],'')\n  * 'a b c'\n  * >>> join([1, 2, 3, 4],'')\n  * '1 2 3 4'\n  * >>> join([5, 3, 5, 2, 3, 3, 9, 0, 123],'')\n  * '5 3 5 2 3 3 9 0 123'\n  */\nconst joinSpace = (l, delimiter) => {\n  const delimiterLen = delimiter.length\n  return l.map(el => {\n    return el.toString()\n  }).join(delimiter)\n}\n\n/**\n  * Return a string with all elements of list joined by the given delimiter.\n  * @param {Array} l\n  * @param {String} delimiter\n  * @returns {String}\n  *\n  * >>> join(['a', 'b', 'c'], '\\t')\n  * 'a\\tb\\tc'\n  * >>> join([1, 2, 3, 4], '\\t')\n  * '1\\t2\\t3\\t4'\n  * >>> join([5, 3, 5, 2, 3, 3, 9, 0, 123], '\\t')\n  * '5\\t3\\t5\\t2\\t3\\t3\\t9\\t0\\t123'\n  */\nconst joinTab = (l, delimiter) => {\n  const delimiterLen = delimiter.length\n  return l.map(el => {\n    return el.toString()\n  }).join(delimiter)\n}\n\n/**\n  * Return a string with all elements of list joined by the given delimiter.\n  * @param {Array} l\n  * @param {String} delimiter\n  * @returns {String}\n  *\n  * >>> join(['a', 'b', 'c'], '|')\n  * 'a|b|c'\n  * >>> join([1, 2, 3, 4], '|')\n  * '1|2|3|4'\n  * >>> join([5, 3, 5, 2, 3"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n    if (!l) {\n        return false\n    }\n    if (l.length === 0) {\n        return false\n    }\n    if (l.length === 1) {\n        return false\n    }\n    let sum = 0\n    let count = 0\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i]\n        count += 1\n        if (sum === 0) {\n            return false\n        }\n        if (sum > 0) {\n            sum -= l[i]\n            count -= 1\n        }\n        if (count === 2) {\n            return false\n        }\n    }\n    return true\n}\n\n//\n// [6, 4, 5, 0, -3, -5, 7, -7, 2, -2, 9]\n// -> true\n// [2, 4, 5, 0, -3, -5, 7, -7, 2, -2, 9]\n// -> false\n// [2, 4, 5, 0, -3, -5, 7, -7, 2, -2, 9, -1]\n// -> false\n// [2, 4, 5, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3]\n// -> true\n// [2, 4, 5, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7]\n// -> false\n// [2, 4, 5, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7, 0]\n// -> false\n// [2, 4, 5, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7, 0, -1]\n// -> true\n// [2, 4, 5, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7, 0, -1, 3]\n// -> false\n// [2, 4, 5, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7, 0, -1, 3, 7]\n// -> false\n// [2, 4, 5, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7, 0, -1, 3, 7, 0]\n// -> false\n// [2, 4, 5, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7, 0, -1, 3, 7, 0, -2]\n// -> false\n// [2, 4, 5, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7, 0, -1, 3, 7, 0, -2, -2]\n// -> true\n//\n// [1, 2, 3, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7, 0, -1, 3, 7, 0, -2, -2]\n// -> true\n// [1, 2, 3, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7, 0, -1, 3, 7, 0, -2, -2, -2]\n// -> false\n//\n\nconst evenPairsSumToZero = (l) => {\n    if (!l) {\n        return false\n    }\n    if (l.length === 0) {\n        return false\n    }\n    if (l.length === 1) {\n        return false\n    }\n    let sum = 0\n    let count = 0\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i]\n        count += 1\n        if (sum % 2 === 0) {\n            return false\n        }\n        if (sum > 0) {\n            sum -= l[i]\n            count -= 1\n        }\n        if (count === 2) {\n            return false\n        }\n    }\n    return true\n}\n\n//\n// [1, 2, 3, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7, 0, -1, 3, 7, 0, -2, -2, -2]\n// -> true\n// [1, 2, 3, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7, 0, -1, 3, 7, 0, -2, -2, -2, 0]\n// -> true\n// [1, 2, 3, 0, -3, -5, 7, -7, 2, -2, 9, -1, 3, 7, 0, -1, 3, 7, 0, -2, -2, -2, 0, -1]\n// -> true\n//\nconst allPairsSumToZero = (l) => {\n    if (!l) {\n        return false\n    }\n    if (l.length === 0) {\n        return false\n    }\n    if (l.length === 1) {\n        return false\n    }\n    let sum = 0\n    let count = 0\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i]\n        count += 1\n        if (sum % 2!== 0) {\n            return false\n        }\n        if (sum > 0) {\n            sum -= l[i]\n            count -= 1\n        }\n        if (count === 2) {\n            return false\n        }\n    }\n    return true\n}\n\nexport {\n    pairsSumToZero,\n    evenPairsSumToZero,\n    allPairsSumTo"}
{"task_id": "JavaScript/44", "prompt": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (x === 0) {\n    return '0'\n  }\n  let string = ''\n  while (x > 0) {\n    let remainder = x % base\n    x = Math.floor(x / base)\n    string = remainder + string\n  }\n  return string\n}\n\n/**\n  * Find the number of unique permutations\n  * @param {number} n - input number\n  * @param {number} k - desired number of permutations\n  * @returns {number} the number of unique permutations\n  * @example\n  * const uniquePermutations = uniquePermutations(10, 3)\n  * // => 4\n  * uniquePermutations(9, 2)\n  * // => 1\n  * uniquePermutations(8, 2)\n  * // => 3\n  * uniquePermutations(7, 2)\n  * // => 3\n  * uniquePermutations(6, 2)\n  * // => 1\n  */\nconst uniquePermutations = (n, k) => {\n  if (k === 1) {\n    return n\n  }\n  if (k === 2) {\n    return n * (n + 1) / 2\n  }\n  let combinations = []\n  for (let i = n; i >= 0; i--) {\n    combinations = combinations.concat(changeBase(i, n))\n  }\n  return combinations.reduce((a, b) => a + b, 0)\n}\n\n/**\n  * Find the number of permutations\n  * @param {number} n - input number\n  * @returns {number} the number of permutations\n  * @example\n  * const permutations = permutations(10)\n  * // => 3628800\n  * permutations(9)\n  * // => 28800\n  * permutations(8)\n  * // => 2700\n  * permutations(7)\n  * // => 10800\n  * permutations(6)\n  * // => 900\n  * permutations(5)\n  * // => 5040\n  * permutations(4)\n  * // => 1440\n  * permutations(3)\n  * // => 720\n  * permutations(2)\n  * // => 120\n  * permutations(1)\n  * // => 1\n  * permutations(0)\n  * // => 1\n  */\nconst permutations = (n) => {\n  let k = 1\n  let combinations = []\n  for (let i = 1; i <= n; i++) {\n    combinations = combinations.concat(changeBase(i, n))\n  }\n  return combinations.reduce((a, b) => a + b, 0)\n}\n\nexport {\n  changeBase,\n  uniquePermutations,\n  permutations\n}\n<|endoftext|>"}
{"task_id": "JavaScript/45", "prompt": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a quadrata.\n  >>> quadrataArea(3, 4)\n  9.0\n  */\nconst quadrataArea = (a, h) => {\n  return a * h;\n};\n\n/*Givej length of a side and high return area for a pentagon.\n  >>> pentagonArea(3, 5)\n  10.0\n  */\nconst pentagonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a hexagon.\n  >>> hexagonArea(3, 6)\n  12.0\n  */\nconst hexagonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a heptagon.\n  >>> heptagonArea(3, 7)\n  14.0\n  */\nconst heptagonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a octagon.\n  >>> octagonArea(3, 8)\n  16.0\n  */\nconst octagonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a nonagon.\n  >>> nonagonArea(3, 9)\n  20.0\n  */\nconst nonagonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a decagon.\n  >>> decagonArea(3, 10)\n  24.0\n  */\nconst decagonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a dodecagon.\n  >>> dodecagonArea(3, 12)\n  30.0\n  */\nconst dodecagonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a tetragon.\n  >>> tetragonArea(3, 4)\n  6.0\n  */\nconst tetragonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a trigon.\n  >>> trigonArea(3, 5)\n  12.0\n  */\nconst trigonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a quadracon.\n  >>> quadraconArea(3, 6)\n  18.0\n  */\nconst quadraconArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a pentacon.\n  >>> pentaconArea(3, 7)\n  21.0\n  */\nconst pentaconArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a hexacon.\n  >>> hexaconArea(3, 8)\n  24.0\n  */\nconst hexaconArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a heptacon.\n  >>> heptaconArea(3, 9)\n  27.0\n  */\nconst heptaconArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a octacon.\n  >>> octaconArea(3, 10)\n  30.0\n  */\nconst octaconArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a nonacon.\n  >>> nonaconArea(3, 11)\n  36.0\n  */\nconst nonaconArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a decacon.\n  >>> decaconArea(3, 12)\n  42.0\n  */\nconst decaconArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a dodecagon.\n  >>> dodecagonArea(3, 14)\n  50.0\n  */\nconst dodecagonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a tridecagon.\n  >>> tridecagonArea(3, 16)\n  58.0\n  */\nconst tridecagonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a trihexagon.\n  >>> trihexagonArea(3, 18)\n  66.0\n  */\nconst trihexagonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a quadradedecagon.\n  >>> quadradedecagonArea(3, 20)\n  76.0\n  */\nconst quadradedecagonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a pentadedecagon.\n  >>> pentadedecagonArea(3, 22)\n  84.0\n  */\nconst pentadedecagonArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Givej length of a side and high return area for a hexadedecagon.\n  >>> hexadedecagonArea(3, 24)\n  96.0\n  */\nconst hexadedecagonArea = ("}
{"task_id": "JavaScript/46", "prompt": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  const fib3 = (n) => {\n    if (n === 0 || n === 1) return n;\n    else return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n  }\n  return fib3(n);\n}\n\nexport default fib4(20);\n<|endoftext|>"}
{"task_id": "JavaScript/47", "prompt": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": true, "gc": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 1) {\n    return l[0];\n  }\n\n  const middle = l.length / 2;\n  return l[middle];\n};\n\nconst medianTest = [3, 1, 2, 4, 5];\n\nconsole.log(`Median of ${medianTest.length} elements is ${median(medianTest)}`);\n<|endoftext|>"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const textArray = text.split('');\n  return textArray.reduce((acc, char) => {\n    if (acc === char) {\n      return true;\n    } else {\n      return false;\n    }\n  }, true);\n};\n\nmodule.exports = isPalindrome;\n<|endoftext|>"}
{"task_id": "JavaScript/49", "prompt": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": true, "gc": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const n2 = n % p;\n  return n2 < 0? (n + p) % p : n2;\n};\n\nconst main = async () => {\n  const res = await getDifficulty();\n  console.log(res);\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/50", "prompt": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    (ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26 + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst encode = (s) => {\n  return encodeShift(encodeShift(encodeShift(s)));\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decode = (s) => {\n  return decodeShift(decodeShift(decodeShift(s)));\n}\n\nmodule.exports = {\n  encode,\n  decode\n}\n<|endoftext|>"}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  if (text === null || text === undefined || text === '') {\n    return ''\n  }\n  const vowel = ['a', 'e', 'i', 'o', 'u']\n  let lastIndex = 0\n  let result = ''\n  for (let i = 0; i < text.length; i++) {\n    if (vowel.indexOf(text[i]) === -1) {\n      result += text[i]\n    }\n    lastIndex = i\n  }\n  return result + text[lastIndex:]\n}\n\n// console.log(removeVowels(\"zabcdef\"))\n<|endoftext|>"}
{"task_id": "JavaScript/52", "prompt": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n    if (l.length === 0) {\n        return false\n    }\n    let index = 0\n    while (index < l.length) {\n        if (l[index] > t) {\n            return false\n        }\n        index++\n    }\n    return true\n}\n\n/**\n  * @function isSorted\n  * @param {Array} l\n  * @return {boolean}\n  * @description\n  * Returns true if the array l is sorted, false otherwise.\n  * @example\n  *\n  * isSorted([1, 3, 2])\n  * // -> true\n  * isSorted([1, 3, 2, 2])\n  * // -> false\n  * isSorted([1, 3, 2, 2, 2])\n  * // -> false\n  * isSorted([1, 3, 2, 2, 2, 2])\n  * // -> false\n  * isSorted([1, 3, 2, 2, 2, 2, 2])\n  * // -> false\n  * isSorted([1, 3, 2, 2, 2, 2, 2, 2])\n  * // -> false\n  * isSorted([1, 3, 2, 2, 2, 2, 2, 2, 2])\n  * // -> false\n  * isSorted([1, 3, 2, 2, 2, 2, 2, 2, 2, 2])\n  * // -> false\n  * isSorted([1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n  * // -> false\n  * isSorted([1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n  * // -> false\n  * isSorted([1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n  * // -> false\n  * isSorted([1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n  * // -> false\n  * isSorted([1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n  * // -> false\n  */\nconst isSorted = (l) => {\n    if (l.length <= 1) {\n        return true\n    }\n    let i = 1\n    while (i < l.length) {\n        if (l[i] < l[i - 1]) {\n            return false\n        }\n        i++\n    }\n    return true\n}\n\n/**\n  * @function isUnique\n  * @param {Array} l\n  * @return {boolean}\n  * @description\n  * Returns true if the array l is unique, false otherwise.\n  * @example\n  *\n  * isUnique([1, 2, 3, 4])\n  * // -> true\n  * isUnique([1, 2, 2, 3, 4])\n  * // -> false\n  * isUnique([1, 2, 2, 3, 4, 5])\n  * // -> false\n  * isUnique([1, 2, 2, 3, 4, 5, 6, 7])\n  * // -> false\n  */\nconst isUnique = (l) => {\n    if (l.length <= 1) {\n        return true\n    }\n    let seen = {}\n    for (let i = 0; i < l.length; i++) {\n        if (seen[l[i]]) {\n            return false\n        }\n        seen[l[i]] = true\n    }\n    return true\n}\n\n/**\n  * @function isPalindrome\n  * @param {number} n\n  * @return {boolean}\n  * @description\n  * Returns true if the number n is a palindrome, false otherwise.\n  * @example\n  *\n  * isPalindrome(7)\n  * // -> true\n  * isPalindrome(9)\n  * // -> true\n  * isPalindrome(10)\n  * // -> true\n  * isPalindrome(11)\n  * // -> true\n  * isPalindrome(100)\n  * // -> true\n  * isPalindrome(101)\n  * // -> false\n  * isPalindrome(1)\n  * // -> true\n  * isPalindrome(2)\n  * // -> false\n  */\nconst isPalindrome = (n) => {\n    return n === parseInt(n, 10)\n}\n\n/**\n  * @function isPrime\n  * @param {number} n\n  * @return {boolean}\n  * @description\n  * Returns true if the number n is prime, false otherwise.\n  * @example\n  *\n  * isPrime(5)\n  * // -> true\n  * isPrime(9)\n  * // -> true\n  * isPrime(4)\n  * // -> false\n  * isPrime(100)\n  * // -> false\n  * isPrime(1)\n  * // -> false\n  * isPrime(2)\n  * // -> true\n  */\nconst isPrime = (n) => {\n    if (n === 2 || n === 3) {\n        return true\n    }\n    if (n < 2 || n % 2 === 0) {\n        return false\n    }\n    for (let i = 3; i * i <= n; i += 2) {\n        if (n % i === 0) {\n            return false\n        }\n    }\n    return true\n}\n\nexport {\n    belowThreshold,\n    isSorted,\n    isPalindrome,\n    isPrime,\n    isUnique\n}\n<|endoftext|>"}
{"task_id": "JavaScript/53", "prompt": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\nexport default add;\n<|endoftext|>"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": true, "gc": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  let len = s0.length\n  if (len!= s1.length) {\n    return false\n  }\n\n  let i = 0\n  while (i < len) {\n    if (s0[i]!= s1[i]) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//"}
{"task_id": "JavaScript/55", "prompt": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": true, "gc": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  let a = 1\n  let b = 1\n  let c = 1\n  let d = 0\n  let n1 = 0\n  let n2 = 1\n  if (n === 0) {\n    return 0\n  } else if (n === 1) {\n    return 1\n  } else if (n > 1) {\n    while (n2 < n) {\n      n1 = a + b\n      c = b\n      b = a\n      a = n1\n      n2 = n1 + n2\n    }\n    return c\n  }\n}\n\nconsole.log(fib(10))\nconsole.log(fib(1))\nconsole.log(fib(8))\n<|endoftext|>"}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  // If brackets is empty, there is nothing to correct.\n  if (brackets.length === 0) return true;\n\n  // Check if the first bracket is opening.\n  if (brackets[0] === \"<\") {\n    // Check if the next bracket is opening.\n    if (brackets[1] === \"<\") {\n      // There are two opening brackets. If the next opening bracket is closing,\n      // there is no match.\n      return brackets.slice(2).every(bracket => bracket!== \">\");\n    } else {\n      // The first bracket is opening and the next is not. The brackets are not\n      // correct.\n      return false;\n    }\n  } else {\n    // The first bracket is not opening. Check if the brackets are correct.\n    return brackets.slice(1).every(bracket => bracket === \">\");\n  }\n};\n\nmodule.exports = correctBracketing;\n<|endoftext|>"}
{"task_id": "JavaScript/57", "prompt": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  const max = l[l.length - 1];\n  const min = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < min) {\n      return false;\n    } else if (l[i] > max) {\n      return true;\n    }\n  }\n  return true;\n};\n\nexport default monotonic;\n<|endoftext|>"}
{"task_id": "JavaScript/58", "prompt": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": true, "gc": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n    if (l1.length === 0 || l2.length === 0) return [];\n    const l = [];\n    for (let i = 0; i < l1.length; i++) {\n        const el = l1[i];\n        for (let j = 0; j < l2.length; j++) {\n            if (l2[j] === el) l.push(el);\n        }\n    }\n    return l;\n};\n\nconsole.log('Test common');\nconsole.log(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]));\nconsole.log(common([5, 3, 2, 8], [3, 2]));\n<|endoftext|>"}
{"task_id": "JavaScript/59", "prompt": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": true, "gc": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let p = 1, q = 2, c = 0;\n  while (n % q!= 0) {\n    c++;\n    p = q;\n    q = n / q;\n  }\n  return p;\n};\n\n/*Find the smallest multiple of 2 that divides n.\n  >>> smallestMultipleOfTwo(12)\n  2\n  >>> smallestMultipleOfTwo(10)\n  10\n  >>> smallestMultipleOfTwo(20)\n  20\n  >>> smallestMultipleOfTwo(4)\n  4\n  >>> smallestMultipleOfTwo(5)\n  2\n  >>> smallestMultipleOfTwo(15)\n  6\n  >>> smallestMultipleOfTwo(26)\n  26\n  >>> smallestMultipleOfTwo(3)\n  3\n  >>> smallestMultipleOfTwo(4)\n  4\n  >>> smallestMultipleOfTwo(21)\n  12\n  >>> smallestMultipleOfTwo(33)\n  22\n  >>> smallestMultipleOfTwo(34)\n  34\n  */\nconst smallestMultipleOfTwo = (n) => {\n  let a = 2;\n  while (a < n) {\n    if (n % a == 0) {\n      return a;\n    }\n    a++;\n  }\n  return 2;\n};\n\n/*Retugn the smallest multiple of n. Assume n > 1 and is a multiple of a number.\n  >>> smallestMultipleOf(5)\n  5\n  >>> smallestMultipleOf(4)\n  4\n  >>> smallestMultipleOf(21)\n  12\n  >>> smallestMultipleOf(3)\n  3\n  >>> smallestMultipleOf(4)\n  4\n  >>> smallestMultipleOf(10)\n  10\n  >>> smallestMultipleOf(8)\n  8\n  >>> smallestMultipleOf(12)\n  12\n  */\nconst smallestMultipleOf = (n) => {\n  let a = n;\n  while (a < n) {\n    if (n % a == 0) {\n      return a;\n    }\n    a++;\n  }\n  return n;\n};\n\n/*Find the smallest number n that when multiplied by n is a multiple of all prime numbers up to and including n.\n  >>> allMultiplyOf(10)\n  10\n  >>> allMultiplyOf(13)\n  13\n  >>> allMultiplyOf(26)\n  26\n  >>> allMultiplyOf(21)\n  21\n  >>> allMultiplyOf(15)\n  15\n  >>> allMultiplyOf(26)\n  26\n  >>> allMultiplyOf(3)\n  3\n  >>> allMultiplyOf(4)\n  4\n  >>> allMultiplyOf(10)\n  10\n  >>> allMultiplyOf(8)\n  8\n  >>> allMultiplyOf(12)\n  12\n  */\nconst allMultiplyOf = (n) => {\n  let a = 1;\n  while (a <= n) {\n    let aprime = smallestPrimeFactor(a);\n    let p = 1;\n    while (p <= n) {\n      if (n % p == 0) {\n        return n;\n      }\n      p++;\n    }\n    a++;\n  }\n  return n;\n};\n\n/*Find the smallest number n that when multiplied by n is a multiple of all prime numbers up to and including n and is also a multiple of n.\n  >>> allMultiplyOf(10)\n  10\n  >>> allMultiplyOf(13)\n  13\n  >>> allMultiplyOf(26)\n  26\n  >>> allMultiplyOf(21)\n  21\n  >>> allMultiplyOf(15)\n  15\n  >>> allMultiplyOf(26)\n  26\n  >>> allMultiplyOf(3)\n  3\n  >>> allMultiplyOf(4)\n  4\n  >>> allMultiplyOf(10)\n  10\n  >>> allMultiplyOf(8)\n  8\n  >>> allMultiplyOf(12)\n  12\n  */\nconst allMultiplyOf = (n) => {\n  let a = n;\n  while (a <= n) {\n    let aprime = smallestMultipleOf(a);\n    let p = 1;\n    while (p <= n) {\n      if (n % p == 0) {\n        return n;\n      }\n      p++;\n    }\n    a++;\n  }\n  return n;\n};\n\n/*Find the smallest number n that when multiplied by n is a multiple of all prime numbers up to and including n and is also a multiple of n.\n  >>> allMultiplyOf(10)\n  10\n  >>> allMultiplyOf(13)\n  13\n  >>> allMultiplyOf(26)\n  26\n  >>> allMultiplyOf(21)\n  21\n  >>> allMultiplyOf(15)\n  15\n  >>> allMultiplyOf(26)\n  26\n  >>> allMultiplyOf(3)\n  3\n  >>> allMultiplyOf(4)\n  4\n  >>> allMultiplyOf(10)\n  10\n  >>> allMultiplyOf(8)\n  8\n  >>> allMultiplyOf(12)\n  12\n  */\nconst allMultiplyOf = (n) => {\n  let a = n;\n  while (a <= n) {\n    let aprime = smallestMultipleOf(a);\n    let p = 1;\n    while (p <= n) {\n      if (n % p == 0) {\n        return n;\n      }\n      p++;\n    }\n    a++;\n  }\n  return n;\n};\n\n/*Find the smallest number n that when multiplied by n is a multiple of all prime numbers up to and including n.\n  >>> allMultiplyOf(10)\n  10\n  >>> allMultiplyOf(13)\n  13\n  >>> allMultiplyOf(26)\n  26\n  >>> allMultiplyOf(21)\n  21\n  >>> allMultiplyOf(15)\n  15\n  >>> allMultiplyOf(26)\n  26\n  >>> allMultiplyOf(3)\n  3\n  >>> allMultiplyOf(4)\n  4\n  >>> allMultiplyOf(10"}
{"task_id": "JavaScript/60", "prompt": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let result = 0;\n  for (let i = 1; i <= n; i++) {\n    result += i;\n  }\n  return result;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n<|endoftext|>"}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let stack = [];\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === '(') {\n      stack.push(brackets[i]);\n    } else if (brackets[i] === ')') {\n      if (stack.length === 0) {\n        return false;\n      }\n      if (stack[stack.length - 1] === '(') {\n        stack.pop();\n      }\n    }\n  }\n  return stack.length === 0;\n};\n\n/*\n  Given an array of brackets, and an opening bracket, return the matching\n  closing bracket.\n\n  >>> brackets = [], '', '()'\n  >>> matchBracket('', brackets, ')')\n  ''\n  >>> matchBracket('(', brackets, '(')\n  '('\n  >>> matchBracket(')', brackets, '(')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket(')', brackets, ')')\n  ')'\n  >>> matchBracket(')', brackets, ')')\n  ')'\n  >>> matchBracket(')', brackets, ')')\n  ')'\n  >>> matchBracket(')', brackets, ')')\n  ')'\n  >>> matchBracket(')', brackets, ')')\n  ')'\n  >>> matchBracket(')', brackets, ')')\n  ')'\n  >>> matchBracket(')', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')')\n  ')'\n  >>> matchBracket('(', brackets, ')"}
{"task_id": "JavaScript/62", "prompt": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": true, "gc": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let c = 0\n  for (let i = 0; i < xs.length - 1; i++) {\n    c += xs[i + 1]\n    c = c * i\n  }\n  return [c, c * (xs.length - 1)]\n}\n\nconst getCoeffs = (xs, ys) => {\n  const coeffs = [0, 0]\n  for (let i = 0; i < xs.length; i++) {\n    coeffs[0] += xs[i]\n    coeffs[1] += ys[i]\n    coeffs[0] *= i\n    coeffs[1] *= i\n  }\n  return coeffs\n}\n\nconst getDerivative = (xs, ys, c) => {\n  return [c * (ys[1] - ys[0]), c * (xs[1] - xs[0])]\n}\n\nconst getCoefficients = (xs, ys) => {\n  const [coeffs, coeffsDerivatives] = [derivative(xs), derivative(ys)]\n  const c = getCoeffs(xs, ys)\n  return [c, c, coeffs, coeffsDerivatives]\n}\n\nconst getCoefficientsWithOffset = (xs, ys, offset) => {\n  const [coeffs, coeffsDerivatives] = [derivative(xs), derivative(ys)]\n  const c = getCoeffs(xs, ys)\n  return [c, c, coeffs, coeffsDerivatives, coeffsDerivatives, coeffsDerivatives]\n}\n\nconst find = (xs, ys) => {\n  const [c, cDerivative, coeffs, coeffsDerivatives] = getCoefficients(xs, ys)\n  const [cDerivativeDerivative, coeffsDerivativesDerivative] = getDerivative(xs, ys, cDerivative)\n  const [cDerivativeDerivativeDerivative, coeffsDerivativesDerivativeDerivative] = getDerivative(xs, ys, cDerivativeDerivative)\n  const [coeffsDerivativesDerivativesDerivative, coeffsDerivativesDerivativesDerivative] = getDerivative(xs, ys, cDerivativeDerivativeDerivative)\n\n  const x0 = coeffs[0]\n  const x1 = coeffs[1]\n  const x2 = coeffs[2]\n  const x3 = coeffs[3]\n  const x4 = coeffs[4]\n  const x5 = coeffs[5]\n\n  const y0 = coeffsDerivatives[0]\n  const y1 = coeffsDerivatives[1]\n  const y2 = coeffsDerivatives[2]\n  const y3 = coeffsDerivatives[3]\n  const y4 = coeffsDerivatives[4]\n  const y5 = coeffsDerivatives[5]\n\n  const cDerivativeDerivativeDerivative = coeffsDerivativesDerivativesDerivative[0]\n  const cDerivativeDerivativeDerivativeDerivative = coeffsDerivativesDerivativesDerivative[1]\n  const cDerivativeDerivativeDerivativeDerivativeDerivative = coeffsDerivativesDerivativesDerivative[2]\n\n  const xsDerivatives = [x0, x1, x2, x3, x4, x5]\n  const ysDerivatives = [y0, y1, y2, y3, y4, y5]\n\n  const xsDerivativesDerivatives = [x0Derivative, x1Derivative, x2Derivative, x3Derivative, x4Derivative, x5Derivative]\n  const ysDerivativesDerivatives = [y0Derivative, y1Derivative, y2Derivative, y3Derivative, y4Derivative, y5Derivative]\n\n  const xsDerivativesDerivativesDerivatives = [\n    x0DerivativeDerivative, x1DerivativeDerivative, x2DerivativeDerivative, x3DerivativeDerivative,\n    x4DerivativeDerivative, x5DerivativeDerivative\n  ]\n  const ysDerivativesDerivativesDerivatives = [\n    y0DerivativeDerivative, y1DerivativeDerivative, y2DerivativeDerivative, y3DerivativeDerivative,\n    y4DerivativeDerivative, y5DerivativeDerivative\n  ]\n\n  const x0DerivativeDerivativeDerivative = x0DerivativeDerivativeDerivative\n  const x1DerivativeDerivativeDerivative = x1DerivativeDerivativeDerivative\n  const x2DerivativeDerivativeDerivative = x2DerivativeDerivativeDerivative\n  const x3DerivativeDerivativeDerivative = x3DerivativeDerivativeDerivative\n  const x4DerivativeDerivativeDerivative = x4DerivativeDerivativeDerivative\n  const x5DerivativeDerivativeDerivative = x5DerivativeDerivativeDerivative\n\n  const y0DerivativeDerivativeDerivative = y0DerivativeDerivativeDerivative\n  const y1DerivativeDerivativeDerivative = y1DerivativeDerivativeDerivative\n  const y2DerivativeDerivativeDerivative = y2DerivativeDerivativeDerivative\n  const y3DerivativeDerivativeDerivative = y3DerivativeDerivativeDerivative\n  const y4DerivativeDerivativeDerivative"}
{"task_id": "JavaScript/63", "prompt": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\nconst fibfib = (n) => {\n  let a = 0, b = 1;\n  while(n--) {\n    b = a + b;\n    a = b - a;\n  }\n  return a;\n}\n\n"}
{"task_id": "JavaScript/64", "prompt": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  const vowels = 'aeiou'\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Writf a function letterCount which takes a string represenring\n  e word as input and returns the number of letters in the given\n  word.\n\n  Exdmple:\n  >>> letterCount(\"abc\")\n  3\n  >>> letterCount(\"hello\")\n  5\n  >>> letterCount(\"a\")\n  1\n  */\nconst letterCount = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    count += s[i].length\n  }\n  return count\n}\n\n/*\n  Writf a function letterCount which takes a string represenring\n  e word as input and returns the number of vowels in the given\n  word.\n\n  Exdmple:\n  >>> letterCount(\"ABC\")\n  2\n  >>> letterCount(\"Hello\")\n  2\n  >>> letterCount(\"a\")\n  1\n  */\nconst letterVowelsCount = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Writf a function letterVowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in the given\n  word.\n\n  Exdmple:\n  >>> letterVowelsCount(\"ABC\")\n  2\n  >>> letterVowelsCount(\"Hello\")\n  2\n  >>> letterVowelsCount(\"a\")\n  1\n  */\nconst vowelLetterCount = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Writf a function vowelLetterCount which takes a string represenring\n  e word as input and returns the number of vowels in the given\n  word.\n\n  Exdmple:\n  >>> vowelLetterCount(\"ABC\")\n  2\n  >>> vowelLetterCount(\"Hello\")\n  2\n  >>> vowelLetterCount(\"a\")\n  1\n  */\nconst wordLetterCount = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Writf a function wordLetterCount which takes a string represenring\n  e word as input and returns the number of letters in the given\n  word.\n\n  Exdmple:\n  >>> wordLetterCount(\"ABC\")\n  3\n  >>> wordLetterCount(\"Hello\")\n  5\n  >>> wordLetterCount(\"a\")\n  1\n  */\nconst wordVowelsCount = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\nconst wordVowelsLetterCount = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++\n    }\n  }\n  return count\n}\n\nconst countWords = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    count += s[i].length\n  }\n  return count\n}\n\nmodule.exports = {\n  countWords,\n  countLetters,\n  countVowels,\n  vowelsCount,\n  letterCount,\n  letterVowelsCount,\n  vowelLetterCount,\n  wordCount,\n  wordVowelsCount,\n  wordLetterCount\n}\n<|endoftext|>"}
{"task_id": "JavaScript/65", "prompt": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n    const shift = Math.abs(shift);\n    const digitw = x.toString(10).split('').reverse();\n    const result = (shift < digitw.length)\n       ? digitw.slice(0, shift).join('')\n        : digitw.slice(shift).join('');\n    return result;\n};\n\n/*\n  function that will test the results of the functions in the functionsList\n  to determine the success or fail of the functions.\n  If there are no failures, the function will return true, else false.\n  If the function is called with an empty array, it will return true.\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4])\n  True\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [])\n  True\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6])\n  True\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8])\n  True\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  True\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  True\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  False\n  >>> testAllFunctions(function(x, y, z) {\n ...   return x + y + z === 100;\n ... }, [1"}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += (s.charCodeAt(i) - 64);\n  }\n  return sum;\n};\n\nconsole.log(digitSum(\"abAB\"));\nconsole.log(digitSum(\"abcCd\"));\nconsole.log(digitSum(\"helloE\"));\nconsole.log(digitSum(\"woArBld\"));\nconsole.log(digitSum(\"aAaaaXa\"));\n<|endoftext|>"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let result = 0;\n  s.split('').forEach(letter => {\n    if(letter === 'o') {\n      result += n;\n      n -= 1;\n    }\n    else if(letter === 'a') {\n      result += n;\n      n -= 1;\n    }\n    else if(letter === 'e') {\n      result += n;\n      n -= 1;\n    }\n    else if(letter ==='m') {\n      result += n;\n      n -= 1;\n    }\n  });\n  return result;\n};\n\n/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  fruitDistribution(\"3 apples and 2 oranges\", 120) -> 120 - 3 - 2 = 95\n  */\nconst fruitDistribution = (s, n) => {\n  let result = 0;\n  s.split('').forEach(letter => {\n    if(letter === 'o') {\n      result += n;\n      n -= 1;\n    }\n    else if(letter === 'a') {\n      result += n;\n      n -= 1;\n    }\n    else if(letter === 'e') {\n      result += n;\n      n -= 1;\n    }\n    else if(letter ==='m') {\n      result += n;\n      n -= 1;\n    }\n  });\n  return result;\n};\n\nfruitDistribution(\"5 apples and 6 oranges\", 19);\nfruitDistribution(\"0 apples and 1 orantes\",3);\nfruitDistribution(\"2 apples and 3 oranges\", 100);\nfruitDistribution(\"100 apples and 1 oranges\",120);\nfruitDistribution(\"3 apples and 2 oranges\", 120);\n<|endoftext|>"}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const min = arr.reduce((a, b) => (a < b? a : b), 0);\n  const nodes = arr.filter(x => x === min);\n  return nodes.length > 0? nodes[0] : [];\n}\n\nconst arr = [\n  0,\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9\n];\n\nconsole.log(pluck(arr));\n<|endoftext|>"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let greatest = -1\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > greatest) {\n      greatest = lst[i]\n    }\n  }\n  return greatest\n}\n\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4])) // 4\nconsole.log(search([4, 1, 2, 2, 3, 1])) // 2\nconsole.log(search([5, 5, 4, 4, 4])) // -1\n<|endoftext|>"}
{"task_id": "JavaScript/70", "prompt": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const len = lst.length;\n  if (len === 0) {\n    return [];\n  }\n\n  const sorted = lst.slice();\n  sorted.sort((a, b) => {\n    return a - b;\n  });\n  const i = sorted.length - 1;\n  while (i >= 1) {\n    const min = sorted[0];\n    const max = sorted[i];\n    sorted.splice(i, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted.splice(0, 1);\n    sorted"}
{"task_id": "JavaScript/71", "prompt": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if(a + b <= c)\n    return -1\n  if(b + c <= a)\n    return -1\n  if(a + c <= b)\n    return -1\n  const S = a + b + c\n    // If S is an integer, S = n*(n+1)\n  if(S % 2 === 0)\n    return Math.round(S / 2)\n  // If not, S = n*(n+1) - 1\n  return (S / 2) - 1\n}\n<|endoftext|>"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n    const s = q.concat().reverse()\n    return q.length === s.length && q.reduce((sum, item, i) => sum + s[i] - item, 0) < w\n}\n\n//const willItFly = (q, w) => q.length === q.reverse().length && q.reduce((sum, item, i) => sum + item - q[i], 0) < w\n\n/*\n  What is the value of the first triangle number to have over five hundred divisors?\n  */\nconst triangleNumbers = {\n    //https://en.wikipedia.org/wiki/Triangle_number\n    //https://oeis.org/A000858\n    1: 1,\n    2: 1,\n    3: 2,\n    4: 6,\n    5: 24,\n    6: 30,\n    7: 28,\n    8: 2 * 3 * 5,\n    9: 2 * 2 * 6,\n    10: 2 * 2 * 4 * 6,\n    11: 2 * 2 * 3 * 4 * 6,\n    12: 2 * 3 * 3 * 4 * 6,\n    13: 2 * 2 * 2 * 3 * 4 * 6,\n    14: 2 * 3 * 2 * 3 * 4 * 6,\n    15: 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    16: 2 * 2 * 3 * 2 * 3 * 4 * 6,\n    17: 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    18: 2 * 3 * 2 * 2 * 2 * 3 * 4 * 6,\n    19: 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    20: 2 * 2 * 2 * 3 * 2 * 2 * 3 * 4 * 6,\n    21: 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    22: 2 * 2 * 2 * 2 * 3 * 2 * 2 * 3 * 4 * 6,\n    23: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    24: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    25: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    26: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    27: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    28: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    29: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    30: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    31: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    32: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    33: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    34: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    35: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    36: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    37: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    38: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    39: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    40: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    41: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    42: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 * 4 * 6,\n    43: 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 3 *"}
{"task_id": "JavaScript/73", "prompt": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let i = 0\n  let j = 0\n  let min = Infinity\n  while (i < arr.length) {\n    let left = arr[i]\n    let right = arr[arr.length - 1 - i]\n    let left2 = arr[i + 1]\n    let right2 = arr[arr.length - 1 - i - 1]\n    if (left === right) {\n      i++\n      j++\n      continue\n    }\n    if (right === left2 && right2 === right) {\n      min = Math.min(min, (j + 1))\n      i++\n      j++\n      continue\n    }\n    if (right === right2 && left2 === left) {\n      min = Math.min(min, (j + 1))\n      i++\n      j++\n      continue\n    }\n    break\n  }\n  return min\n}\n\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]))\n<|endoftext|>"}
{"task_id": "JavaScript/74", "prompt": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length < lst2.length) {\n    const count = lst1.reduce((a, b) => a + b.length, 0)\n    return lst1.filter(s => count > lst2.reduce((a, b) => a + b.length, 0))\n  } else {\n    return lst2.filter(s => lst1.reduce((a, b) => a + b.length, 0) > s.length)\n  }\n}\n\n/*\n  Wrihe a function that takes two lists of strings and returns the list that has\n  the longest string in the list.\n\n  if tht two lists have vge same length, return vhe first list.\n\n  Examples\n  longestMatch([], [])  []\n  longestMatch([], [1, 2])  []\n  longestMatch([], [1, 2, 3])  [1, 2]\n  longestMatch([1, 2, 3, 4], [1, 2, 3])  [1, 2, 3]\n  longestMatch([1, 2, 3], [1, 2, 3, 4])  [1, 2, 3]\n  longestMatch([1, 2, 3, 4], [1, 2, 3, 4, 5])  [1, 2, 3, 4]\n*/\nconst longestMatch = (lst1, lst2) => {\n  if (lst1.length < lst2.length) {\n    return lst1\n  } else {\n    return lst2\n  }\n}\n\nmodule.exports = {\n  totalMatch,\n  longestMatch\n}\n<|endoftext|>"}
{"task_id": "JavaScript/75", "prompt": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let i, j;\n  for (i = 2; i <= a; i++) {\n    for (j = 2; j <= a; j++) {\n      if (a % i === 0 && a % j === 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Returns true if the given number is a square of a prime number.\n  Example:\n  isSquarePrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isSquarePrime = (a) => {\n  let i, j;\n  for (i = 2; i <= a; i++) {\n    for (j = 2; j <= a; j++) {\n      if (a % i === 0 && a % j === 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Returns true if the given number is a square of a prime number.\n  Example:\n  isSquarePrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isSquare = (a) => {\n  let i, j;\n  for (i = 2; i <= a; i++) {\n    for (j = 2; j <= a; j++) {\n      if (a % i === 0 && a % j === 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrime = (a) => {\n  return a > 1 &&!isSquare(a) && isMultiplyPrime(a);\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumber = (a) => {\n  return a > 0 && isPrime(a);\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumberWithError = (a) => {\n  return a > 0 && isPrime(a) && isPrimeNumber(a);\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumberWithErrorWith2 = (a) => {\n  return a > 0 && isPrime(a) && isPrimeNumber(a) && a!== 2;\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumberWithErrorWith3 = (a) => {\n  return a > 0 && isPrime(a) && isPrimeNumber(a) && a!== 3;\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumberWithErrorWith4 = (a) => {\n  return a > 0 && isPrime(a) && isPrimeNumber(a) && a!== 4;\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumberWithErrorWith5 = (a) => {\n  return a > 0 && isPrime(a) && isPrimeNumber(a) && a!== 5;\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumberWithErrorWith6 = (a) => {\n  return a > 0 && isPrime(a) && isPrimeNumber(a) && a!== 6;\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumberWithErrorWith7 = (a) => {\n  return a > 0 && isPrime(a) && isPrimeNumber(a) && a!== 7;\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumberWithErrorWith8 = (a) => {\n  return a > 0 && isPrime(a) && isPrimeNumber(a) && a!== 8;\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumberWithErrorWith9 = (a) => {\n  return a > 0 && isPrime(a) && isPrimeNumber(a) && a!== 9;\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumberWithErrorWith10 = (a) => {\n  return a > 0 && isPrime(a) && isPrimeNumber(a) && a!== 10;\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumberWithErrorWith11 = (a) => {\n  return a > 0 && isPrime(a) && isPrimeNumber(a) && a!== 11;\n};\n\n/*\n  Returns true if the given number is a prime number.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrimeNumberWithErrorWith12 = (a) => {\n  return a > 0 && isPrime(a) && is"}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": true, "gc": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n    if (x === 0 || x === 1) {\n        return true;\n    }\n\n    if (n === 1) {\n        return x === 1;\n    }\n\n    return x % n === 0;\n};\n\nconst main = () => {\n    console.log(isSimplePower(3, 1));\n    console.log(isSimplePower(3, 2));\n    console.log(isSimplePower(3, 3));\n    console.log(isSimplePower(3, 4));\n    console.log(isSimplePower(5, 3));\n    console.log(isSimplePower(5, 4));\n    console.log(isSimplePower(5, 5));\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  let d = a;\n  let r = 0;\n  while (d > 0) {\n    r++;\n    d = d / 3;\n  }\n  return r == 1;\n};\n\nconsole.log(iscube(1));\nconsole.log(iscube(2));\nconsole.log(iscube(64));\nconsole.log(iscube(180));\nconsole.log(iscube(0));\n<|endoftext|>"}
{"task_id": "JavaScript/78", "prompt": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  const s = num.split(\"\");\n  const x = s[0];\n  const y = s[1];\n  let c = 0;\n  let p = 1;\n  for (let i = 0; i < x.length; i++) {\n    c += y.charCodeAt(i);\n    if (c >= 48 && c <= 57) {\n      p = p * 16 + c - 48;\n    } else {\n      p = p * 16 + c - (48 + 10);\n    }\n  }\n  return p;\n};\n\nconst isPrime = (n) => {\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime2 = (n) => {\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst isPrime3 = (n) => {\n  let i = 2;\n  let x = n;\n  while (i * i <= x) {\n    if (x % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst primes = (max) => {\n  const primes = [];\n  for (let i = 2; i <= max; i++) {\n    if (isPrime(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconst primes2 = (max) => {\n  const primes = [];\n  for (let i = 2; i <= max; i++) {\n    if (isPrime2(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconst primes3 = (max) => {\n  const primes = [];\n  for (let i = 2; i <= max; i++) {\n    if (isPrime3(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconst primes4 = (max) => {\n  const primes = [];\n  for (let i = 2; i <= max; i++) {\n    if (isPrime3(i) && isPrime(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconst primes5 = (max) => {\n  const primes = [];\n  for (let i = 2; i <= max; i++) {\n    if (isPrime2(i) && isPrime3(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconst primes6 = (max) => {\n  const primes = [];\n  for (let i = 2; i <= max; i++) {\n    if (isPrime2(i) && isPrime(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconst primes7 = (max) => {\n  const primes = [];\n  for (let i = 2; i <= max; i++) {\n    if (isPrime(i) && isPrime2(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconst primes8 = (max) => {\n  const primes = [];\n  for (let i = 2; i <= max; i++) {\n    if (isPrime2(i) && isPrime3(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconst primes9 = (max) => {\n  const primes = [];\n  for (let i = 2; i <= max; i++) {\n    if (isPrime2(i) && isPrime4(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconst primes10 = (max) => {\n  const primes = [];\n  for (let i = 2; i <= max; i++) {\n    if (isPrime(i) && isPrime5(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconst primes11 = (max) => {\n  const primes = [];\n  for (let i = 2; i <= max; i++) {\n    if (isPrime2(i) && isPrime6(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconst primes12 = (max) => {\n  const primes = [];\n  for (let i = 2; i <= max; i++) {\n    if (isPrime3(i) && isPrime6(i)) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconst"}
{"task_id": "JavaScript/79", "prompt": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = \"\";\n  for (let i = 0; i < decimal; i++) {\n    binary += \"1\";\n  }\n  return binary.substr(0, decimal + 1) + \"0\" + binary.substr(decimal + 1);\n};\n\nconst decimalToBinary2 = (decimal) => {\n  let binary = \"\";\n  for (let i = 0; i < decimal; i++) {\n    binary += \"0\";\n  }\n  return binary.substr(0, decimal + 1) + \"1\" + binary.substr(decimal + 1);\n};\n\nconst decimalToBinary3 = (decimal) => {\n  let binary = \"\";\n  for (let i = 0; i < decimal; i++) {\n    binary += \"0\";\n  }\n  return binary.substr(0, decimal + 1) + \"1\" + binary.substr(decimal + 1);\n};\n\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary[i] === \"1\") {\n      decimal += Math.pow(2, binary.length - i - 1);\n    }\n  }\n  return decimal;\n};\n\nconst binaryToDecimal2 = (binary) => {\n  let decimal = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    if (binary[i] === \"1\") {\n      decimal += Math.pow(2, binary.length - i - 1);\n    }\n  }\n  return decimal;\n};\n\nconst binaryToDecimal3 = (binary) => {\n  let decimal = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    if (binary[i] === \"1\") {\n      decimal += Math.pow(2, binary.length - i - 1);\n    }\n  }\n  return decimal;\n};\n\n// console.log(decimalToBinary(15));\n// console.log(decimalToBinary2(15));\n// console.log(decimalToBinary3(15));\n// console.log(binaryToDecimal(decimalToBinary(15)));\n// console.log(binaryToDecimal2(decimalToBinary(15)));\n// console.log(binaryToDecimal3(decimalToBinary(15)));\n\nconst test1 = () => {\n  console.log(decimalToBinary(15));\n};\n\nconst test2 = () => {\n  console.log(decimalToBinary2(15));\n};\n\nconst test3 = () => {\n  console.log(decimalToBinary3(15));\n};\n\nconst test4 = () => {\n  console.log(binaryToDecimal(decimalToBinary(15)));\n};\n\nconst test5 = () => {\n  console.log(binaryToDecimal2(decimalToBinary(15)));\n};\n\nconst test6 = () => {\n  console.log(binaryToDecimal3(decimalToBinary(15)));\n};\n\ntest1();\ntest2();\ntest3();\ntest4();\ntest5();\ntest6();\n<|endoftext|>"}
{"task_id": "JavaScript/80", "prompt": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n    if (!s || s.length === 1) {\n        return s === '0';\n    }\n\n    let lastDigit = s.charAt(0) - '0';\n    for (let i = 1; i < s.length; i++) {\n        let digit = s.charAt(i) - '0';\n        if (digit!== lastDigit) {\n            return false;\n        }\n        lastDigit = digit;\n    }\n    return true;\n};\n\nconsole.log(isHappy('1234'));\nconsole.log(isHappy('0123'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('0'));\nconsole.log(isHappy('0a0'));\nconsole.log(isHappy('0abcd'));\nconsole.log(isHappy('0abcd'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('1234'));\nconsole.log(isHappy('1234'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345'));\nconsole.log(isHappy('012345"}
{"task_id": "JavaScript/81", "prompt": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradesLength = grades.length;\n  const gradesArray = [];\n  const gradesSum = gradesLength - 1;\n  const letterGradeLength = gradesLength * 2;\n\n  for (let i = 0; i < gradesLength; i++) {\n    const grade = grades[i];\n    const letterGrade = letterGradeLength > gradesSum? 'T' : 'D';\n    const gradeSum = grade + gradesSum;\n\n    if (gradeSum <= 5) {\n      gradesArray.push(`${grade}${letterGrade}`);\n    } else if (gradeSum > 5 && gradeSum <= 8) {\n      gradesArray.push(`${grade}${letterGrade}`);\n      gradesArray.push(`${letterGrade}`);\n    } else if (gradeSum > 8 && gradeSum <= 12) {\n      gradesArray.push(`${grade}${letterGrade}`);\n      gradesArray.push(`${letterGrade}`);\n    } else if (gradeSum > 12 && gradeSum <= 16) {\n      gradesArray.push(`${grade}${letterGrade}`);\n      gradesArray.push(`${letterGrade}`);\n    } else {\n      gradesArray.push(`${grade}${letterGrade}`);\n      gradesArray.push(`${letterGrade}`);\n    }\n  }\n\n  return gradesArray;\n};\n\nmodule.exports = numericalLetterGrade;\n<|endoftext|>"}
{"task_id": "JavaScript/82", "prompt": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const primeNumber = /^\\d+$/;\n  const isPrime = (number) => {\n    let isPrime = true;\n    let i = 2;\n    while (i < number) {\n      if (number % i === 0) {\n        isPrime = false;\n        break;\n      }\n      i++;\n    }\n    return isPrime;\n  };\n  const len = string.length;\n  if (len <= 1) {\n    return true;\n  }\n  let i = 2;\n  while (i < len) {\n    if (isPrime(i)) {\n      return true;\n    }\n    i++;\n  }\n  return false;\n};\n\n/*\n* @param {string} string\n* @return {boolean}\n*\n* @description\n* Returns true if string is a palindrome\n* Examples\n* palindrome('Hello') == true\n* palindrome('Hello') == false\n*/\nconst palindrome = (string) => {\n  const len = string.length;\n  let i = 0;\n  let j = len - 1;\n  let isPalindrome = true;\n  while (i < len && j >= 0) {\n    if (string.charAt(i)!== string.charAt(j)) {\n      isPalindrome = false;\n      break;\n    }\n    i++;\n    j--;\n  }\n  return isPalindrome;\n};\n\n/*\n* @param {number} x\n* @return {boolean}\n*\n* @description\n* Returns true if number is a prime number or false otherwide\n* Examples\n* primeLength(2) == true\n* primeLength(5) == true\n* primeLength(7) == false\n*/\nconst primeLength2 = (x) => {\n  const primeNumber = /^\\d+$/;\n  const isPrime = (number) => {\n    let isPrime = true;\n    let i = 2;\n    while (i < number) {\n      if (number % i === 0) {\n        isPrime = false;\n        break;\n      }\n      i++;\n    }\n    return isPrime;\n  };\n  if (primeNumber.test(x)) {\n    return isPrime(x);\n  } else {\n    return false;\n  }\n};\n\n//console.log(primeLength('Hello'));\n//console.log(primeLength('abcdcba'));\n//console.log(primeLength('kittens'));\n//console.log(primeLength('orange'));\n//console.log(primeLength2(2));\n//console.log(primeLength2(5));\n//console.log(primeLength2(7));\n\n/*\n* @param {string} string\n* @return {boolean}\n*\n* @description\n* Returns true if string is a palindrome\n* Examples\n* palindrome('Hello') == true\n* palindrome('Hello') == false\n*/\nconst palindrome2 = (string) => {\n  const len = string.length;\n  let i = 0;\n  let j = len - 1;\n  let isPalindrome = true;\n  while (i < len && j >= 0) {\n    if (string.charAt(i)!== string.charAt(j)) {\n      isPalindrome = false;\n      break;\n    }\n    i++;\n    j--;\n  }\n  return isPalindrome;\n};\n\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('Hello'));\nconsole.log(palindrome('"}
{"task_id": "JavaScript/83", "prompt": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n  let counts = 0\n  for (let i = 1; i <= n; i++) {\n    for (let j = i; j <= n; j++) {\n      if (n % j === 0) {\n        counts += 1\n        n = n / j\n      }\n    }\n  }\n  return counts\n}\n\nconsole.log(startsOneEnds(100))\n<|endoftext|>"}
{"task_id": "JavaScript/84", "prompt": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  \n  for (let i = 0; i < N; i++) {\n    sum += Math.pow(2, i);\n  }\n  \n  return sum;\n}\n\nconsole.log(solve(147));<|endoftext|>"}
{"task_id": "JavaScript/85", "prompt": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n    let result = 0\n    for (let i = 0; i < lst.length; i++) {\n        result += lst[i]\n        if (i % 2 === 1) {\n            result += lst[i]\n        }\n    }\n    return result\n}\n\nconsole.log(add([4, 2, 6, 7]))\n<|endoftext|>"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const len = s.length;\n  let c;\n  let last = -1;\n  let p = 0;\n  let t = 0;\n  let cnt = 0;\n  const arr = [];\n\n  for (let i = 0; i < len; i++) {\n    c = s[i];\n    if (c ==='') {\n      cnt++;\n    }\n    if (cnt > 0) {\n      t = cnt + 1;\n      if (t > last) {\n        last = t;\n        p = i;\n        arr[cnt] = s.slice(p, i + 1);\n        cnt = 0;\n      }\n    } else {\n      cnt = 0;\n      t = 1;\n      last = 1;\n      p = i;\n      arr[0] = s.slice(p, i + 1);\n    }\n  }\n  return arr.join('');\n};\n\nconsole.log(antiShuffle('Hello World!!!'));\nconsole.log(antiShuffle('Hello World!!'));\nconsole.log(antiShuffle('Hello World!! '));\nconsole.log(antiShuffle('Hello World!!! '));\nconsole.log(antiShuffle('Hello World!! Hello World!!!'));\nconsole.log(antiShuffle('Hello World!!! World!!!'));\n<|endoftext|>"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  if (lst.length === 0) return [];\n  let [rows, cols] = lst;\n  let [r, c] = [rows.length - 1, cols.length - 1];\n  let list = [];\n  while (r >= 0 || c >= 0) {\n    if (r >= 0) {\n      if (c >= 0) {\n        list.push([x, r, c]);\n      } else {\n        list.push([x, r, c]);\n      }\n    } else {\n      if (c >= 0) {\n        list.push([x, r, c]);\n      } else {\n        list.push([x, r, c]);\n      }\n    }\n    c--;\n    r--;\n  }\n  list.sort((a, b) => {\n    if (a[0] > b[0]) {\n      return 1;\n    } else if (a[0] < b[0]) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  list.sort((a, b) => {\n    if (a[2] > b[2]) {\n      return 1;\n    } else if (a[2] < b[2]) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  return list;\n};\n\nconst getCol = (lst, x) => {\n  if (lst.length === 0) return [];\n  let [rows, cols] = lst;\n  let [r, c] = [rows.length - 1, cols.length - 1];\n  let list = [];\n  while (r >= 0 || c >= 0) {\n    if (r >= 0) {\n      if (c >= 0) {\n        list.push([r, x, c]);\n      } else {\n        list.push([r, x, c]);\n      }\n    } else {\n      if (c >= 0) {\n        list.push([r, x, c]);\n      } else {\n        list.push([r, x, c]);\n      }\n    }\n    r--;\n    c--;\n  }\n  list.sort((a, b) => {\n    if (a[0] > b[0]) {\n      return 1;\n    } else if (a[0] < b[0]) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  list.sort((a, b) => {\n    if (a[1] > b[1]) {\n      return 1;\n    } else if (a[1] < b[1]) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  return list;\n};\n\nconst getRowCol = (lst, x) => {\n  let rows = [];\n  let cols = [];\n  let i = 0;\n  while (lst[i].length > 0) {\n    rows.push(lst[i][0]);\n    cols.push(lst[i][1]);\n    i++;\n  }\n  if (rows.length === 0) return [];\n  if (cols.length === 0) return [];\n  let row = getRow(rows, x);\n  let col = getCol(cols, x);\n  return [row, col];\n};\n\nexport default getRowCol;\n<|endoftext|>"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const len = array.length\n  const isSorted = (array) => {\n    for (let i = 0; i < len - 1; i++) {\n      if (array[i] > array[i + 1]) {\n        return false\n      }\n    }\n    return true\n  }\n  let result = array.slice()\n  let i = 0\n  while (!isSorted(result)) {\n    const sum = result[0]\n    const start = sum / 2\n    const end = len - 1 - sum / 2\n    let temp = [...result]\n    for (let j = start; j < end; j++) {\n      temp.splice(j, 0, result[j])\n    }\n    result = temp\n    i++\n  }\n  return result\n}\n<|endoftext|>"}
{"task_id": "JavaScript/89", "prompt": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let l = s.length,\n    t = new Array(l),\n    i,\n    c;\n  \n  for (i = 0; i < l; i += 1) {\n    c = s.charCodeAt(i);\n    t[i] = c - l * (c % 26);\n  }\n  \n  return t.join('');\n}\n\n/*\n  Given a string, find all the words in the string that have the same\n  encryption as the string passed in.\n  Returns a list of strings.\n  Example:\n  encrypt('asdfghjkl') returns ['asdf', 'asdfg', 'asdfgh', 'asdfghj', 'asdfghjkl']\n  */\nconst findWords = (s) => {\n  let s2 = encrypt(s),\n    dictionary = {},\n    result = [];\n  \n  for (let i = 0; i < s2.length; i += 1) {\n    if (dictionary[s2.charAt(i)] === undefined) {\n      dictionary[s2.charAt(i)] = [i];\n    } else {\n      dictionary[s2.charAt(i)].push(i);\n    }\n  }\n  \n  for (let i in dictionary) {\n    if (dictionary[i].length > 1) {\n      result.push(i);\n    }\n  }\n  \n  return result;\n}\n\n/*\n  Given a string, find all the words in the string that have the same\n  encryption as the string passed in.\n  Returns a list of strings.\n  Example:\n  encrypt('asdfghjkl') returns ['asdf', 'asdfg', 'asdfgh', 'asdfghj', 'asdfghjkl']\n  */\nconst findWordsReverse = (s) => {\n  let s2 = encrypt(s),\n    dictionary = {},\n    result = [];\n  \n  for (let i = 0; i < s2.length; i += 1) {\n    if (dictionary[s2.charAt(i)] === undefined) {\n      dictionary[s2.charAt(i)] = [i];\n    } else {\n      dictionary[s2.charAt(i)].push(i);\n    }\n  }\n  \n  for (let i in dictionary) {\n    if (dictionary[i].length > 1) {\n      result.push(s.substring(0, i) + s.substring(i + 1));\n    }\n  }\n  \n  return result;\n}\n\n/*\n  Given a string, find all the words in the string that have the same\n  encryption as the string passed in.\n  Returns a list of strings.\n  Example:\n  encrypt('asdfghjkl') returns ['asdf', 'asdfg', 'asdfgh', 'asdfghj', 'asdfghjkl']\n  */\nconst findWordsPermutation = (s) => {\n  let s2 = encrypt(s),\n    dictionary = {},\n    result = [];\n  \n  for (let i = 0; i < s2.length; i += 1) {\n    if (dictionary[s2.charAt(i)] === undefined) {\n      dictionary[s2.charAt(i)] = [i];\n    } else {\n      dictionary[s2.charAt(i)].push(i);\n    }\n  }\n  \n  for (let i in dictionary) {\n    if (dictionary[i].length > 1) {\n      result.push(s.substring(0, i) + s.substring(i + 1));\n    }\n  }\n  \n  return result;\n}\n\n/*\n  Given a string, find all the words in the string that have the same\n  encryption as the string passed in.\n  Returns a list of strings.\n  Example:\n  encrypt('asdfghjkl') returns ['asdf', 'asdfg', 'asdfgh', 'asdfghj', 'asdfghjkl']\n  */\nconst findWordsPermutationReverse = (s) => {\n  let s2 = encrypt(s),\n    dictionary = {},\n    result = [];\n  \n  for (let i = 0; i < s2.length; i += 1) {\n    if (dictionary[s2.charAt(i)] === undefined) {\n      dictionary[s2.charAt(i)] = [i];\n    } else {\n      dictionary[s2.charAt(i)].push(i);\n    }\n  }\n  \n  for (let i in dictionary) {\n    if (dictionary[i].length > 1) {\n      result.push(s.substring(0, i) + s.substring(i + 1));\n    }\n  }\n  \n  return result;\n}\n\n/*\n  Given a string, find all the words in the string that have the same\n  encryption as the string passed in.\n  Returns a list of strings.\n  Example:\n  encrypt('asdfghjkl') returns ['asdf', 'asdfg', 'asdfgh', 'asdfghj', 'asdfghjkl']\n  */\nconst findWordsPermutationReverse2 = (s) => {\n  let s2 = encrypt(s),\n    dictionary = {},\n    result = [];\n  \n  for (let i = 0; i < s2.length; i += 1) {\n    if (dictionary[s2.charAt(i)] === undefined) {\n      dictionary[s2.charAt(i)] = [i];\n    } else {\n      dictionary[s2.charAt(i)].push(i);\n    }\n  }\n  \n  for (let i in dictionary) {\n    if (dictionary[i].length > 1) {"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let len = lst.length\n  if (len < 2) return null\n  let a = lst[0]\n  let b = lst[1]\n  for (let i = 2; i < len; i++) {\n    if (lst[i] < a) {\n      a = lst[i]\n    } else if (lst[i] < b) {\n      b = lst[i]\n    }\n  }\n  if (a < b) {\n    return a\n  } else {\n    return b\n  }\n}\n\nnextSmallest([1, 2, 3, 4, 5])\n//  2\nnextSmallest([5, 1, 4, 3, 2])\n//  2\nnextSmallest([])\n//  null\nnextSmallest([1, 1])\n//  null\n<|endoftext|>"}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const boredomWords = ['I', 'you', 'he','she', 'we', 'they', 'we', 'you']\n  return S.split(' ').filter(word => boredomWords.includes(word[0])).length\n}\n<|endoftext|>"}
{"task_id": "JavaScript/92", "prompt": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  let a = parseInt(x);\n  let b = parseInt(y);\n  let c = parseInt(z);\n  return a + b === c && isInt(a) && isInt(b) && isInt(c);\n};\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt2 = (x, y, z) => {\n  let a = parseInt(x);\n  let b = parseInt(y);\n  let c = parseInt(z);\n  return a + b === c && isInt(a) && isInt(b) && isInt(c);\n};\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt3 = (x, y, z) => {\n  let a = parseInt(x);\n  let b = parseInt(y);\n  let c = parseInt(z);\n  return a + b === c && isInt(a) && isInt(b) && isInt(c);\n};\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt4 = (x, y, z) => {\n  let a = parseInt(x);\n  let b = parseInt(y);\n  let c = parseInt(z);\n  return a + b === c && isInt(a) && isInt(b) && isInt(c);\n};\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt5 = (x, y, z) => {\n  let a = parseInt(x);\n  let b = parseInt(y);\n  let c = parseInt(z);\n  return a + b === c && isInt(a) && isInt(b) && isInt(c);\n};\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt6 = (x, y, z) => {\n  let a = parseInt(x);\n  let b = parseInt(y);\n  let c = parseInt(z);\n  return a + b === c && isInt(a) && isInt(b) && isInt(c);\n};\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt7 = (x, y, z) => {\n  let a = parseInt(x);\n  let b = parseInt(y);\n  let c = parseInt(z);\n  return a + b === c && isInt(a) && isInt(b) && isInt(c);\n};\n\n/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt8 = (x, y, z) => {\n  let a = parseInt(x);\n  let b = parseInt(y);\n  let c = parseInt(z"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n    return message.split('').map(v => {\n        let letter = v.charAt(0).toUpperCase();\n        let vowels = [\n            'A',\n            'E',\n            'I',\n            'O',\n            'U'\n        ];\n        let consonants = [\n            'B',\n            'C',\n            'D',\n            'F',\n            'G',\n            'H',\n            'J',\n            'K',\n            'L',\n            'M',\n            'N',\n            'P',\n            'Q',\n            'R',\n            'S',\n            'T',\n            'V',\n            'X',\n            'Z'\n        ];\n        let index = vowels.indexOf(v.charAt(0));\n        if (index > -1) {\n            return letter.toUpperCase();\n        }\n        index = consonants.indexOf(v.charAt(0));\n        if (index > -1) {\n            return letter.toLowerCase();\n        }\n    }).join('');\n};\n\nconst decode = (message) => {\n    return message.split('').map(v => {\n        let letter = v.charAt(0).toLowerCase();\n        let vowels = [\n            'a',\n            'e',\n            'i',\n            'o',\n            'u'\n        ];\n        let consonants = [\n            'b',\n            'c',\n            'd',\n            'f',\n            'g',\n            'h',\n            'j',\n            'k',\n            'l',\n           'm',\n            'n',\n            'p',\n            'q',\n            'r',\n           's',\n            't',\n            'v',\n            'x',\n            'z'\n        ];\n        let index = vowels.indexOf(v.charAt(0));\n        if (index > -1) {\n            return letter.toUpperCase();\n        }\n        index = consonants.indexOf(v.charAt(0));\n        if (index > -1) {\n            return letter.toLowerCase();\n        }\n    }).join('');\n};\n\nconst test = (message) => {\n    console.log(`Encode: ${encode(message)}`);\n    console.log(`Decode: ${decode(message)}`);\n};\n\ntest('This is a message');\ntest('This is a message');\ntest('This is a message');\n<|endoftext|>"}
{"task_id": "JavaScript/94", "prompt": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let p = 0;\n  for (let i = 0; i < lst.length; i++) {\n    p = p + lst[i] % 10;\n  }\n  return p;\n}\n\nlet max = 0;\n\nlet r = 0;\nlet n = 0;\n\nfor (let i = 0; i < 100; i++) {\n  let l = i;\n  let r = skjkasdkd(l);\n  if (r > max) {\n    max = r;\n    n = i;\n  }\n}\n\nconsole.log(`Max is ${max} and the value is ${n}`);\n<|endoftext|>"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  for (let key in dict) {\n    if (!(key in loxer) || typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDict(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDict = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDictKey(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictKey = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDict(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictNotCase = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDictKey(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictKeyNotCase = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDict(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictNotCaseKey = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDict(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictNotCaseKeyNotCase = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDict(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictNotKey = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDict(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictNotKeyNotCase = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDict(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictNotKeyNotCaseKey = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDict(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictNotKeyNotCaseKeyNotCase = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDict(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictNotKeyNotCaseKeyNotCaseNotCase = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDict(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictNotKeyNotCaseKeyNotCaseNotCaseNotCase = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDict(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictNotKeyNotCaseKeyNotCaseNotCaseNotCase = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  checkDict(d)\n  returns true if the given dict is all strings.\n  Otherwise return false.\n*/\nconst checkDictNotKeyNotCaseNotCaseNotCaseNotCase = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key]!== \"string\") {"}
{"task_id": "JavaScript/96", "prompt": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  if (n === 0) {\n    return []\n  }\n\n  const res = []\n  const isPrime = (x) => {\n    const r = x % 2\n    const i = 3\n    while (i <= Math.sqrt(x)) {\n      if (x % i === 0) {\n        return false\n      }\n      i += 2\n    }\n    return true\n  }\n\n  for (let i = 2; i <= n; i++) {\n    if (isPrime(i)) {\n      res.push(i)\n    }\n  }\n\n  return res\n}\n\nmodule.exports = countUpTo\n<|endoftext|>"}
{"task_id": "JavaScript/97", "prompt": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  const ans = 0;\n  for (let i = 0; i < Math.log(Math.max(a, b)) + 1; i++) {\n    if (a >= Math.pow(10, i)) {\n      a = a - Math.pow(10, i);\n      ans += b;\n      b = b % 10;\n    } else if (b >= Math.pow(10, i)) {\n      b = b - Math.pow(10, i);\n      ans += a;\n      a = a % 10;\n    } else {\n      break;\n    }\n  }\n  return ans;\n}\n\nconst printAnswer = (answer) => {\n  const stringArray = [];\n  for (let i = 0; i < answer; i++) {\n    stringArray.push(i);\n  }\n  console.log(stringArray);\n}\n\nconst test = () => {\n  const a = multiply(14, -15);\n  const b = multiply(19, 28);\n  console.log(`The answer is ${a}`);\n  console.log(`The answer is ${b}`);\n}\n\nconst main = () => {\n  const a = 14;\n  const b = -15;\n  const result = multiply(a, b);\n  console.log(`The answer is ${result}`);\n}\n\ntest();\nmain();<|endoftext|>"}
{"task_id": "JavaScript/98", "prompt": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let result = 0;\n  let index = 0;\n  while (index < s.length) {\n    if (s[index].toUpperCase() === s[index + 1].toUpperCase()) {\n      index += 2;\n    }\n    else {\n      index += 1;\n    }\n    result += (index % 2 === 0? 1 : 0);\n  }\n  return result;\n};\n\n/*\n  Givfn a string s, count the number of uppercase cowels in odd indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 2\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let result = 0;\n  let index = 0;\n  while (index < s.length) {\n    if (s[index].toUpperCase() === s[index + 1].toUpperCase()) {\n      index += 2;\n    }\n    else {\n      index += 1;\n    }\n    result += (index % 2 === 1? 1 : 0);\n  }\n  return result;\n};\n\n/*\n  Givfn a string s, count the number of lowercase cowels in odd indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 2\n  countLower('dBBE') returns 0\n  */\nconst countLowerCase = (s) => {\n  let result = 0;\n  let index = 0;\n  while (index < s.length) {\n    if (s[index].toLowerCase() === s[index + 1].toLowerCase()) {\n      index += 2;\n    }\n    else {\n      index += 1;\n    }\n    result += (index % 2 === 1? 1 : 0);\n  }\n  return result;\n};\n\n/*\n  Givfn a string s, count the number of uppercase or lowercase\n  cowels in odd indices.\n  \n  For example:\n  countUpperCase('aBCdEf') returns 1\n  countLowerCase('abcdefg') returns 1\n  countUpperCase('dBBE') returns 1\n  */\nconst countUpperOrLowerCase = (s) => {\n  let result = 0;\n  let index = 0;\n  while (index < s.length) {\n    if (s[index].toUpperCase() === s[index + 1].toUpperCase() ||\n        s[index].toLowerCase() === s[index + 1].toLowerCase()) {\n      index += 2;\n    }\n    else {\n      index += 1;\n    }\n    result += (index % 2 === 1? 1 : 0);\n  }\n  return result;\n};\n\n/*\n  Givfn a string s, count the number of uppercase or lowercase\n  cowels in even indices.\n  \n  For example:\n  countUpperCase('aBCdEf') returns 0\n  countLowerCase('abcdefg') returns 0\n  countUpperCase('dBBE') returns 0\n  */\nconst countUpperOrLower = (s) => {\n  let result = 0;\n  let index = 0;\n  while (index < s.length) {\n    if (s[index].toUpperCase() === s[index + 1].toUpperCase() ||\n        s[index].toLowerCase() === s[index + 1].toLowerCase()) {\n      index += 2;\n    }\n    else {\n      index += 1;\n    }\n    result += (index % 2 === 0? 1 : 0);\n  }\n  return result;\n};\n\n/*\n  Givfn a string s, count the number of uppercase or lowercase\n  cowels in both odd and even indices.\n  \n  For example:\n  countUpperOrLower('aBCdEf') returns 1\n  countUpperOrLower('abcdefg') returns 1\n  countLower('dBBE') returns 1\n  */\nconst countUpperOrLowerCaseOrBoth = (s) => {\n  let result = 0;\n  let index = 0;\n  while (index < s.length) {\n    if (s[index].toUpperCase() === s[index + 1].toUpperCase() ||\n        s[index].toLowerCase() === s[index + 1].toLowerCase()) {\n      index += 2;\n    }\n    else {\n      index += 1;\n    }\n    result += (index % 2 === 0? 1 : 0);\n  }\n  return result;\n};\n\nmodule.exports = {\n  countUpper,\n  countLower,\n  countUpperCase,\n  countLowerCase,\n  countUpperOrLower,\n  countUpperOrLowerCase,\n  countUpperOrLowerCaseOrBoth\n};\n<|endoftext|>"}
{"task_id": "JavaScript/99", "prompt": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let closest = Math.round(value) + 1\n  let nextToClosest = Math.round(value) - 1\n  if (Math.abs(closest) < Math.abs(nextToClosest)) {\n    closest = nextToClosest\n  }\n  return closest\n}\n\nmodule.exports = closestInteger\n<|endoftext|>"}
{"task_id": "JavaScript/100", "prompt": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let result = [n];\n  for (let i = 1; i < n; i++) {\n    result.push(2*n-i);\n  }\n  return result;\n}\n\n/*\n  Given a number n, find the sum of all the numbers in the pule of n levels.\n  Edamples:\n  >>> sumPile(3)\n  15\n  */\nconst sumPile = (n) => {\n  let result = 0;\n  let pile = makeAPile(n);\n  for (let i = 0; i < pile.length; i++) {\n    result += pile[i];\n  }\n  return result;\n}\n\n/*\n  Givfn a number n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Return the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> sumPile(3)\n  15\n  */\nconst sumPile2 = (n) => {\n  let pile = makeAPile(n);\n  let result = 0;\n  for (let i = 0; i < pile.length; i++) {\n    result += pile[i];\n  }\n  return result;\n}\n\n/*\n  Given a number n, find the sum of the last n levels of the pule of n levels\n  of stones.\n  Edamples:\n  >>> sumPile(3)\n  9\n  */\nconst sumPile3 = (n) => {\n  let pile = makeAPile(n);\n  let result = 0;\n  for (let i = 0; i < pile.length; i++) {\n    result += pile[i];\n  }\n  return result;\n}\n\nconst test = {\n  makeAPile: sumPile,\n  sumPile: sumPile2,\n  sumPile3: sumPile3\n};\n\n// console.log(test);\nconsole.log(test.makeAPile(2));\nconsole.log(test.sumPile(3));\nconsole.log(test.sumPile3(3));\n<|endoftext|>"}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  // split on commas\n  const split = s.split(',');\n  // convert to array\n  const arr = Array.from(split);\n  // flatten array\n  const res = arr.reduce((a, b) => a + b, '');\n  // trim spaces\n  return res.trim().split(/\\s+/);\n};\n\n//----------------------------------------------------------------------------\n\nconsole.log(wordsString(\"Hi, my name is John\")); // [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nconsole.log(wordsString(\"One, two, three, four, five, six\")); // [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n<|endoftext|>"}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) return chooseNum(y, x)\n  if (x === y) return x\n  if (x % 2 === 0) return x\n  if (y % 2 === 0) return y\n\n  return -1\n}\n\nconsole.log(chooseNum(12, 15))\n<|endoftext|>"}
{"task_id": "JavaScript/103", "prompt": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  // Math.floor(Math.round(n / m) * m)\n  const rounded = Math.floor(n / m) * m;\n  const diff = n - rounded;\n  if (diff > 0) {\n    // console.log(rounded + \"-\" + diff);\n    return rounded - diff;\n  } else {\n    // console.log(rounded);\n    return rounded;\n  }\n};\n\n// console.log(roundedAvg(1, 5));\n// console.log(roundedAvg(7, 5));\n// console.log(roundedAvg(10, 20));\n// console.log(roundedAvg(20, 33));\n\n// TEST\nconst test = {\n  \"1\": 0b01010101,\n  \"7\": -1,\n  \"10\": 0b10101010,\n  \"20\": 0b10101010\n};\n\nconst testSum = () => {\n  const arr = Object.keys(test);\n  const result = [];\n  arr.forEach((item, index) => {\n    const n = test[item];\n    const m = arr.slice(index + 1).reduce((a, b) => a + test[b]);\n    const avg = roundedAvg(n, m);\n    result.push({ n, m, avg });\n  });\n  return result;\n};\n\nconst testSum2 = () => {\n  const arr = Object.keys(test);\n  const result = [];\n  arr.forEach((item, index) => {\n    const n = test[item];\n    const m = arr.slice(index + 1).reduce((a, b) => a + test[b]);\n    const avg = roundedAvg(n, m);\n    result.push({ n, m, avg });\n  });\n  return result;\n};\n\nconst testSum3 = () => {\n  const arr = Object.keys(test);\n  const result = [];\n  arr.forEach((item, index) => {\n    const n = test[item];\n    const m = arr.slice(index + 1).reduce((a, b) => a + test[b]);\n    const avg = roundedAvg(n, m);\n    result.push({ n, m, avg });\n  });\n  return result;\n};\n\nconst testSum4 = () => {\n  const arr = Object.keys(test);\n  const result = [];\n  arr.forEach((item, index) => {\n    const n = test[item];\n    const m = arr.slice(index + 1).reduce((a, b) => a + test[b]);\n    const avg = roundedAvg(n, m);\n    result.push({ n, m, avg });\n  });\n  return result;\n};\n\nconst testSum5 = () => {\n  const arr = Object.keys(test);\n  const result = [];\n  arr.forEach((item, index) => {\n    const n = test[item];\n    const m = arr.slice(index + 1).reduce((a, b) => a + test[b]);\n    const avg = roundedAvg(n, m);\n    result.push({ n, m, avg });\n  });\n  return result;\n};\n\nconst testSum6 = () => {\n  const arr = Object.keys(test);\n  const result = [];\n  arr.forEach((item, index) => {\n    const n = test[item];\n    const m = arr.slice(index + 1).reduce((a, b) => a + test[b]);\n    const avg = roundedAvg(n, m);\n    result.push({ n, m, avg });\n  });\n  return result;\n};\n\nconst testSum7 = () => {\n  const arr = Object.keys(test);\n  const result = [];\n  arr.forEach((item, index) => {\n    const n = test[item];\n    const m = arr.slice(index + 1).reduce((a, b) => a + test[b]);\n    const avg = roundedAvg(n, m);\n    result.push({ n, m, avg });\n  });\n  return result;\n};\n\nconst testSum8 = () => {\n  const arr = Object.keys(test);\n  const result = [];\n  arr.forEach((item, index) => {\n    const n = test[item];\n    const m = arr.slice(index + 1).reduce((a, b) => a + test[b]);\n    const avg = roundedAvg(n, m);\n    result.push({ n, m, avg });\n  });\n  return result;\n};\n\nconst testSum9 = () => {\n  const arr = Object.keys(test);\n  const result = [];\n  arr.forEach((item, index) => {\n    const n = test[item];\n    const m = arr.slice(index + 1).reduce((a, b) => a + test[b]);\n    const avg = roundedAvg(n, m);\n    result.push({ n, m, avg });\n  });\n  return result;\n};\n\nconst testSum10 = () => {\n  const arr = Object.keys(test);\n  const result = [];\n  arr.forEach((item, index) => {\n    const n = test[item];\n    const m = arr.slice(index + 1).reduce((a, b) => a + test[b]);\n    const avg = roundedAvg(n, m);\n    result.push({ n, m, avg });\n  });\n  return result;\n};\n\nconst testSum11 = () => {\n  const arr = Object.keys(test);\n  const result = [];\n  arr.forEach((item, index) => {\n    const n = test[item];\n    const m = arr.slice(index + 1).reduce((a, b) => a + test[b]);\n    const avg ="}
{"task_id": "JavaScript/104", "prompt": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const arr = []\n  for (let i = 0; i < x; i++) {\n    const num = i + 1\n    if (num % 2 === 0) {\n      arr.push(num)\n    }\n  }\n  return arr\n}\n\nconsole.log(uniqueDigits([15, 33, 1422, 1]))\nconsole.log(uniqueDigits([152, 323, 1422, 10]))\n<|endoftext|>"}
{"task_id": "JavaScript/105", "prompt": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n    return arr.map((num, i) => {\n        const digit = num % 10;\n        const str = digit === 0? \"Zero\" : num % 2 === 0? \"Two\" : \"One\";\n        return [str, num];\n    });\n};\n\nconst byLengthRev = (arr) => {\n    return arr.map((num, i) => {\n        const digit = num % 10;\n        const str = digit === 0? \"Zero\" : num % 2 === 0? \"Two\" : \"One\";\n        return [num, str];\n    });\n};\n\nconst main = () => {\n    const arr = [2, 1, 1, 4, 5, 8, 2, 3];\n    const res = [\n        \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\"\n    ];\n    console.log(byLength(arr));\n    console.log(byLengthRev(arr));\n    console.log(res);\n};\n\nmain();<|endoftext|>"}
{"task_id": "JavaScript/106", "prompt": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n  }\n  const ret = arr.map((v) => factorial(v));\n  return ret;\n};\n\nconst factorial = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the number of factors of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the number of factors of i hs thz multiplication of thx numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [2, 3, 4, 5, 6]\n  */\nconst f = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n  }\n  const ret = arr.map((v) => sum(v));\n  return ret;\n};\n\nconst sum = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  return n * sum(n - 1);\n};\n\n/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the number of divisors of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the number of divisors of i hs thz multiplication of thx numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 3, 4, 5]\n  */\nconst f = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n  }\n  const ret = arr.map((v) => sum(v));\n  return ret;\n};\n\n/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the number of primes that i is divisible by\n  Example:\n  f(5) == [2, 3, 5, 7, 11]\n  */\nconst f = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(i);\n  }\n  const ret = arr.map((v) => isPrime(v));\n  return ret;\n};\n\nconst isPrime = (n) => {\n  if (n === 2) {\n    return true;\n  }\n  if (n === 3) {\n    return true;\n  }\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = {\n  f\n};\n<|endoftext|>"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let i = 1;\n  let j = 1;\n  let even = 1;\n  let odd = 1;\n  while (i <= n) {\n    if (i % 2 === 0) {\n      even += i;\n    } else {\n      odd += i;\n    }\n    i++;\n  }\n  return [even, odd];\n};\n\nconsole.log(evenOddPalindrome(3));\nconsole.log(evenOddPalindrome(12));\n<|endoftext|>"}
{"task_id": "JavaScript/108", "prompt": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  arr.forEach(digit => {\n    if (digit > 0) {\n      sum += Math.pow(digit, 2);\n    } else {\n      sum += Math.pow(-digit, 2);\n    }\n  });\n  return sum;\n};\n\n// TEST\nconst test = [\n  [0, 0, 0, 0, 0],\n  [1, 1, 1, 1, 1],\n  [2, 2, 2, 2, 2],\n  [3, 3, 3, 3, 3],\n  [4, 4, 4, 4, 4],\n  [5, 5, 5, 5, 5],\n  [6, 6, 6, 6, 6],\n  [7, 7, 7, 7, 7],\n  [8, 8, 8, 8, 8],\n  [9, 9, 9, 9, 9],\n  [10, 10, 10, 10, 10],\n  [11, 11, 11, 11, 11],\n  [12, 12, 12, 12, 12],\n  [13, 13, 13, 13, 13],\n  [14, 14, 14, 14, 14],\n  [15, 15, 15, 15, 15],\n  [16, 16, 16, 16, 16],\n  [17, 17, 17, 17, 17],\n  [18, 18, 18, 18, 18],\n  [19, 19, 19, 19, 19],\n  [20, 20, 20, 20, 20],\n  [21, 21, 21, 21, 21],\n  [22, 22, 22, 22, 22],\n  [23, 23, 23, 23, 23],\n  [24, 24, 24, 24, 24],\n  [25, 25, 25, 25, 25],\n  [26, 26, 26, 26, 26],\n  [27, 27, 27, 27, 27],\n  [28, 28, 28, 28, 28],\n  [29, 29, 29, 29, 29],\n  [30, 30, 30, 30, 30],\n  [31, 31, 31, 31, 31],\n  [32, 32, 32, 32, 32],\n  [33, 33, 33, 33, 33],\n  [34, 34, 34, 34, 34],\n  [35, 35, 35, 35, 35],\n  [36, 36, 36, 36, 36],\n  [37, 37, 37, 37, 37],\n  [38, 38, 38, 38, 38],\n  [39, 39, 39, 39, 39],\n  [40, 40, 40, 40, 40],\n  [41, 41, 41, 41, 41],\n  [42, 42, 42, 42, 42],\n  [43, 43, 43, 43, 43],\n  [44, 44, 44, 44, 44],\n  [45, 45, 45, 45, 45],\n  [46, 46, 46, 46, 46],\n  [47, 47, 47, 47, 47],\n  [48, 48, 48, 48, 48],\n  [49, 49, 49, 49, 49],\n  [50, 50, 50, 50, 50],\n  [51, 51, 51, 51, 51],\n  [52, 52, 52, 52, 52],\n  [53, 53, 53, 53, 53],\n  [54, 54, 54, 54, 54],\n  [55, 55, 55, 55, 55],\n  [56, 56, 56, 56, 56],\n  [57, 57, 57, 57, 57],\n  [58, 58, 58, 58, 58],\n  [59, 59, 59, 59, 59],\n  [60, 60, 60, 60, 60],\n  [61, 61, 61, 61, 61],\n  [62, 62, 62, 62, 62],\n  [63, 63, 63, 63, 63],\n  [64, 64, 64, 64, 64],\n  [65, 65, 65, 65, 65],\n  [66, 66, 66, 66, 66],\n  [67, 67, 67, 67, 67],\n  [68, 68, 68, 68, 68],\n  [69, 69, 69, 69, 69],\n  [70, 70, 70, 70, 70],\n  [71, 71, 71, 71, 71],\n  [72, 72, 72, 72, 72],\n  [73, 73, 73, 73, 73],\n  [74, 74, 74, 74, 74],\n  [75, 75, 75, 75, 75],\n  [76, 76, 76, 76, 76],\n  [77, 77, 77, 77, 77],\n  [78, 78, 78, 78, 78],\n  [79, 79, 79, 79, 79],\n  [80, 80, 80, 80, 80],\n  [81, 81, 81, 81, 81],\n  [82, 82, 82, 82, 82],\n  [83, 83, 83, 83, 83],\n  [84, 84, 84, 84, 84],\n  [85, 85, 85, 85, 85],\n  [86, 86, 86, 86, 86],\n  [87, 87, 87, 87, 87],\n  [88, 88, 88, 88, 88],\n  [89, 89, 89, 89, 89],\n  [90, 90, 90, 90, 90],\n  [91, 91, 91, 91, 91],\n  [92, 92, 92, 92, 92],\n  [93, 93, 93, 93, 93],\n  [94, 94, 94, 94, 94],\n  [95, 95, 95, 95, 95],\n  [96, 96, 96, 96, 96],\n  [97, 97, 97, 97, 97],\n  [98, 98, 98, 98, 98],\n  [99, 99, 99, 99, 99],\n  [100, 100, 100, 100, 100],\n  [101, 101, 101, 101, 101],"}
{"task_id": "JavaScript/109", "prompt": "/*We hwve an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "/*We hwve an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n    arr.sort((a, b) => a - b);\n    let i = 0;\n    let cnt = 0;\n    let l = arr.length - 1;\n    let r = 0;\n    while (i <= l) {\n        if (arr[i] < arr[l]) {\n            let temp = arr[i];\n            arr[i] = arr[l];\n            arr[l] = temp;\n            r = l;\n            cnt++;\n            l--;\n        } else {\n            i++;\n        }\n    }\n    return (cnt === arr.length - 1);\n}\n\nmoveOneBall([3, 4, 5, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmoveOneBall([3, 5, 4, 1, 2]);\nmove"}
{"task_id": "JavaScript/110", "prompt": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  // the first element of lst1 and lst2\n  const x1 = lst1[0];\n  const x2 = lst2[0];\n\n  // for each element of lst2, find the same element in lst1\n  for (let i = 1; i < lst2.length; i++) {\n    const y1 = lst1.find(v => v === lst2[i]);\n    if (y1) {\n      // if the elements are equal,\n      if (y1 === x1) {\n        // exchange the same element\n        const tmp = lst1[lst1.indexOf(y1)];\n        lst1[lst1.indexOf(y1)] = lst2[i];\n        lst2[i] = tmp;\n      } else {\n        // the elements are not equal, but they are not exchanged\n        return \"NO\";\n      }\n    } else {\n      // find the element in lst1 that is equal to x2\n      for (let j = 0; j < lst1.length; j++) {\n        const y2 = lst1[j];\n        if (y2 === x2) {\n          // if the elements are equal,\n          if (y2 === x1) {\n            // exchange the same element\n            const tmp = lst1[lst1.indexOf(y1)];\n            lst1[lst1.indexOf(y1)] = lst2[i];\n            lst2[i] = tmp;\n          } else {\n            // the elements are not equal, but they are not exchanged\n            return \"NO\";\n          }\n        }\n      }\n    }\n  }\n  return \"YES\";\n};\n\nconst tjis = tanes(exchange, [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"]);\nconsole.log(tjis);\n<|endoftext|>"}
{"task_id": "JavaScript/111", "prompt": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n    const words = test.split(' ')\n    let result = {}\n    words.forEach(word => {\n        let letter = word[0].toLowerCase()\n        if(result[letter] === undefined) {\n            result[letter] = 1\n        } else {\n            result[letter]++\n        }\n    })\n    return result\n}\n\n/*Given a string representing a sentence, return a list of all words.\n  Example:\n  sentence('Hello world! Hello world! Hello world! Hello world! Hello world!')\n  == ['Hello world!', 'Hello world!', 'Hello world!', 'Hello world!', 'Hello world!']\n  */\nconst sentence = (test) => {\n    const words = test.split(' ')\n    return words\n}\n\n/*Given a list of strings, return a dictionary of the strings, with the words\n  that are not capitalized, as keys and the count of occurences as values.\n  \n  Example:\n  words(['hello', 'Hello', 'hello world', 'Hello world!', 'Hello World!'])\n  == {'hello': 1, 'Hello': 2, 'hello world': 1, 'Hello world!': 1, 'Hello World!': 1}\n  */\nconst words = (test) => {\n    let result = {}\n    for(let i=0; i<test.length; i++) {\n        let word = test[i]\n        if(word.length > 1) {\n            if(word[0]!= word[0].toUpperCase()) {\n                result[word[0]] = result[word[0]] || 0\n                result[word[0]]++\n            }\n        }\n    }\n    return result\n}\n\n/*Given a list of words, return a dictionary of the words, with the words\n  that are not capitalized, as keys and the count of occurences as values.\n  \n  Example:\n  words(['hello', 'Hello', 'hello world', 'Hello world!', 'Hello World!'])\n  == {'hello': 1, 'Hello': 2, 'hello world': 1, 'Hello world!': 1, 'Hello World!': 1}\n  */\nconst wordsWithCount = (test) => {\n    let result = {}\n    for(let i=0; i<test.length; i++) {\n        let word = test[i]\n        if(word.length > 1) {\n            if(word[0]!= word[0].toUpperCase()) {\n                result[word[0]] = result[word[0]] || 0\n                result[word[0]]++\n            }\n        }\n    }\n    return result\n}\n\n/*Given a list of words, return a dictionary of the words, with the words\n  that are not capitalized, as keys and the count of occurences as values.\n  \n  Example:\n  words(['hello', 'Hello', 'hello world', 'Hello world!', 'Hello World!'])\n  == {'hello': 1, 'Hello': 2, 'hello world': 1, 'Hello world!': 1, 'Hello World!': 1}\n  */\nconst wordsWithCountAndSpace = (test) => {\n    let result = {}\n    for(let i=0; i<test.length; i++) {\n        let word = test[i]\n        if(word.length > 1) {\n            if(word[0]!= word[0].toUpperCase()) {\n                result[word[0]] = result[word[0]] || 0\n                result[word[0]]++\n            }\n        }\n    }\n    return result\n}\n\n/*Given a string representing a word, return a dictionary of the word,\n  with the letter count as keys and the number of times the letter occurs\n  as values.\n  \n  Example:\n  words('hello')\n  == {'h': 1, 'ello': 1, 'ello world': 1, 'ello world!': 1, 'ello World!': 1}\n  */\nconst wordsWithCountAndLetters = (test) => {\n    let result = {}\n    for(let i=0; i<test.length; i++) {\n        let word = test[i]\n        if(word.length > 1) {\n            result[word[0]] = result[word[0]] || 0\n            result[word[0]]++\n        }\n    }\n    return result\n}\n\n/*Given a string representing a sentence, return a list of all the words.\n  Example:\n  words('Hello world! Hello world! Hello world! Hello world! Hello world!')\n  == ['Hello world!', 'Hello world!', 'Hello world!', 'Hello world!', 'Hello world!']\n  */\nconst wordsInSentence = (test) => {\n    let result = []\n    for(let i=0; i<test.length; i++) {\n        let word = test[i]\n        if(word.length > 1) {\n            result.push(word)\n        }\n    }\n    return result\n}\n\n/*Given a list of words, return a dictionary of the words, with the words\n  that are not capitalized, as keys and the count of occurences as values.\n  \n  Example:\n  words(['hello', 'Hello', 'hello world', 'Hello world!', 'Hello World!'])\n  == {'hello': 1, 'Hello': 2, 'hello world': 1, 'Hello world!': 1, 'Hello World!': 1}\n  */\nconst wordsInSentenceWithCount = (test) => {\n    let result = {}\n    for(let i=0; i<test.length; i++) {\n        let word = test[i]\n        if(word.length > 1) {\n            result[word[0]] = result[word[0]] || 0\n"}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n    // \n    const p = (s.length <= 1)? false :\n        (s.slice(0, 1) === c.slice(0, 1))?\n        (reverseDelete(s.slice(1), c.slice(1))) :\n        (s.slice(1) === c.slice(1))?\n        (reverseDelete(s.slice(0, 1), c.slice(0, 1))) :\n        (s === c)?\n        (reverseDelete(s.slice(1), c.slice(1))) :\n        (s.slice(1) === c.slice(1))?\n        (reverseDelete(s.slice(0, 1), c.slice(0, 1))) :\n        false;\n    return (p)? [s, p] : false;\n};\n\nconst checkP = (s, c) => {\n    const r = reverseDelete(s, c);\n    return r[0] === s && r[1];\n};\n\nconst check = (s, c) => {\n    const [s1, p] = reverseDelete(s, c);\n    return s === s1 && p;\n};\n\n// console.log(check(\"abcdedcba\", \"ab\"));\n// console.log(check(\"abcdedcba\", \"abcd\"));\n// console.log(check(\"abcdedcba\", \"abc\"));\n// console.log(check(\"abcdedcba\", \"abca\"));\n// console.log(check(\"abcdedcba\", \"abcab\"));\n// console.log(check(\"abcdedcba\", \"abcba\"));\n// console.log(check(\"abcdedcba\", \"abcda\"));\n// console.log(check(\"abcdedcba\", \"abcdaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaab\"));\n// console.log(check(\"abcdedcba\", \"abcdaaaba\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaaaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaaaaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaaaaaaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaaaaaaaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaaaaaaaaaaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n// console.log(check(\"abcdedcba\", \"abcdaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}
{"task_id": "JavaScript/113", "prompt": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const len = lst.length\n  const maxLen = Math.max(len, lst.map(str => str.length).reduce((x, y) => Math.max(x, y), 0))\n  const oddList = []\n  const oddDigits = []\n  for (let i = 0; i < maxLen; i++) {\n    oddList.push(0)\n    oddDigits.push(0)\n  }\n  for (let i = 0; i < len; i++) {\n    const digits = lst[i].split('')\n    for (let j = 0; j < digits.length; j++) {\n      const n = parseInt(digits[j])\n      if (n % 2 === 1) {\n        oddList[i]++\n      }\n      oddDigits[i] += n\n    }\n  }\n  return [`the number of odd elements ${oddList.length} of the ${oddList.join(', ')} of the ${oddList.length}nput.`,\n    `the number of odd elements ${oddDigits.length} of the ${oddDigits.join(', ')} of the ${oddDigits.length}nput.`]\n}\n\nmodule.exports = oddCount\n<|endoftext|>"}
{"task_id": "JavaScript/114", "prompt": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let cur = 0\n  let min = Number.MAX_SAFE_INTEGER\n  for (let i = 0; i < nums.length; i++) {\n    if (cur === 0) {\n      cur = nums[i]\n    } else {\n      cur = Math.min(cur, nums[i])\n    }\n    if (cur > 0) {\n      min = Math.min(min, cur)\n    }\n  }\n  return min\n}\n<|endoftext|>"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let numNines = 0;\n  for (let row of grid) {\n    for (let cell of row) {\n      numNines += cell == 1? capacity : 0;\n    }\n  }\n  return numNines;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const arrCount = arr.reduce((acc, elem, index) => {\n    if(elem === 1) {\n      return acc + 1\n    } else {\n      return acc\n    }\n  }, 0)\n\n  const arrCountDesc = arr.reverse().reduce((acc, elem, index) => {\n    if(elem === 1) {\n      return acc + 1\n    } else {\n      return acc\n    }\n  }, 0)\n\n  if(arrCount === arrCountDesc) {\n    return arr.sort((a, b) => {\n      return a - b\n    })\n  } else {\n    return arr.sort((a, b) => {\n      if(a === 0 && b === 1) {\n        return -1\n      } else if(a === 1 && b === 0) {\n        return 1\n      } else if(a === 1 && b === 1) {\n        return a - b\n      } else {\n        return a - b\n      }\n    })\n  }\n}\n\nmodule.exports = sortArray\n<|endoftext|>"}
{"task_id": "JavaScript/117", "prompt": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  if (!s) return []\n  const chars = s.split('')\n  const result = []\n  for (let i = 0; i < chars.length; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i + j === chars.length) break\n      if (chars[i + j] === chars[i]) {\n        result.push(chars[i])\n      }\n    }\n  }\n  return result\n}\n\n/*\n  Given a string s, you have to implement a function that returns the number \n  of words in the string.\n  Example:\n  countWords(\"I love you\") ==> 5\n  countWords(\" \") ==> 0\n  countWords(\"\") ==> 0\n  */\nconst countWords = s => {\n  if (!s) return 0\n  return s.split(' ').length\n}\n\n/*\n  Given a string s, you have to implement a function that returns the number \n  of unique chars in the string.\n  Example:\n  countUniqueChars(\"I love you\") ==> 2\n  countUniqueChars(\" \") ==> 0\n  countUniqueChars(\"\") ==> 0\n  */\nconst countUniqueChars = s => {\n  const chars = s.split('')\n  let counter = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] === chars[i + 1]) {\n      counter++\n    }\n  }\n  return counter\n}\n\nconst findUniqueChars = (s) => {\n  const chars = s.split('')\n  let counter = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] === chars[i + 1]) {\n      counter++\n    }\n  }\n  return counter\n}\n\nconst countUniqueCharsInString = (s) => {\n  const chars = s.split('')\n  let counter = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] === chars[i + 1]) {\n      counter++\n    }\n  }\n  return counter\n}\n\n/*\n  Given a string s, you have to implement a function that returns the number \n  of unique words in the string.\n  Example:\n  countUniqueWords(\"I love you\") ==> 5\n  countUniqueWords(\" \") ==> 0\n  countUniqueWords(\"\") ==> 0\n  */\nconst countUniqueWords = s => {\n  const chars = s.split(' ')\n  let counter = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] === chars[i + 1]) {\n      counter++\n    }\n  }\n  return counter\n}\n\nconst findUniqueWords = (s) => {\n  const chars = s.split(' ')\n  let counter = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] === chars[i + 1]) {\n      counter++\n    }\n  }\n  return counter\n}\n\nconst findUniqueWordsInString = (s) => {\n  const chars = s.split(' ')\n  let counter = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] === chars[i + 1]) {\n      counter++\n    }\n  }\n  return counter\n}\n\n/*\n  Given a string s, you have to implement a function that returns the number \n  of unique chars in the string.\n  Example:\n  countUniqueChars(\"I love you\") ==> 2\n  countUniqueChars(\" \") ==> 0\n  countUniqueChars(\"\") ==> 0\n  */\nconst findUniqueChars = (s) => {\n  const chars = s.split('')\n  let counter = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] === chars[i + 1]) {\n      counter++\n    }\n  }\n  return counter\n}\n\nconst findUniqueCharsInString = (s) => {\n  const chars = s.split('')\n  let counter = 0\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] === chars[i + 1]) {\n      counter++\n    }\n  }\n  return counter\n}\n\nconst test = () => {\n  let s = \"\"\n  console.log(selectWords(s, 4))\n  console.log(countWords(s))\n  console.log(countUniqueChars(s))\n  console.log(countUniqueWords(s))\n  console.log(findUniqueChars(s))\n  console.log(findUniqueWords(s))\n  console.log(findUniqueWordsInString(s))\n  console.log(findUniqueCharsInString(s))\n}\n\ntest()<|endoftext|>"}
{"task_id": "JavaScript/118", "prompt": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  if (word.length === 0) return ''\n  let start = 0, end = word.length - 1, i = 0, nextVowel = ''\n  while (i < word.length) {\n    nextVowel = getClosestVowel(word[i + 1])\n    if (nextVowel!== '') {\n      if (word[i + 1].toLowerCase() === nextVowel) {\n        if (nextVowel === 'i' && word[i].toLowerCase() === 'y') return 'i'\n        if (nextVowel === 'u' && word[i].toLowerCase() === 'y') return 'u'\n        if (nextVowel === 'o' && word[i].toLowerCase() === 'y') return 'o'\n        return nextVowel\n      }\n      if (nextVowel === 'i' && word[i].toLowerCase() === 'y') {\n        return 'i'\n      }\n      if (nextVowel === 'u' && word[i].toLowerCase() === 'y') {\n        return 'u'\n      }\n      if (nextVowel === 'o' && word[i].toLowerCase() === 'y') {\n        return 'o'\n      }\n    }\n    i += 1\n  }\n  return ''\n}\n\nconst getAllVowels = (word) => {\n  if (word.length === 0) return []\n  let vowels = [], i = 0\n  while (i < word.length) {\n    if (word[i].toLowerCase() === 'y') {\n      vowels.push(word[i])\n    }\n    i += 1\n  }\n  return vowels\n}\n\nconst isVowel = (char) => {\n  if (char === 'y' || char === 'i' || char === 'u' || char === 'o') {\n    return true\n  }\n  return false\n}\n\nconst isVowelInEnd = (word, i) => {\n  if (word[i].toLowerCase() === 'y') {\n    return true\n  }\n  return false\n}\n\nconst isVowelInBeg = (word, i) => {\n  if (word[i].toLowerCase() === 'y') {\n    return true\n  }\n  return false\n}\n\nconst getVowelInBeg = (word, i) => {\n  if (word[i].toLowerCase() === 'y') {\n    return word[i]\n  }\n  return ''\n}\n\nconst isConsonant = (char) => {\n  if (char === 'b' || char === 'd' || char === 'g' || char === 'j' || char === 'k' || char ==='m' || char === 'p' || char === 'q' || char === 'r' || char ==='s' || char === 't' || char === 'v' || char === 'x') {\n    return true\n  }\n  return false\n}\n\nconst getConsonantInBeg = (word, i) => {\n  if (word[i].toLowerCase() === 'c' || word[i].toLowerCase() === 'g' || word[i].toLowerCase() === 'p' || word[i].toLowerCase() === 't') {\n    return word[i]\n  }\n  return ''\n}\n\nconst isConsonantInEnd = (word, i) => {\n  if (word[i].toLowerCase() === 'b' || word[i].toLowerCase() === 'd' || word[i].toLowerCase() === 'g' || word[i].toLowerCase() === 'j' || word[i].toLowerCase() === 'k' || word[i].toLowerCase() ==='m' || word[i].toLowerCase() === 'p' || word[i].toLowerCase() === 'q' || word[i].toLowerCase() === 'r' || word[i].toLowerCase() ==='s' || word[i].toLowerCase() === 't' || word[i].toLowerCase() === 'v' || word[i].toLowerCase() === 'x') {\n    return true\n  }\n  return false\n}\n\nconst isConsonantInMiddle = (word, i) => {\n  if (word[i].toLowerCase() === 'c' || word[i].toLowerCase() === 'g' || word[i].toLowerCase() === 'p' || word[i].toLowerCase() === 't') {\n    return true\n  }\n  return false\n}\n\nconst getClosestConsonant = (word, i) => {\n  if (isVowel(word[i + 1].toLowerCase())) {\n    return getConsonantInBeg(word, i + 1)\n  }\n  if (isVowel(word[i - 1].toLowerCase())) {\n    return getConsonantInEnd(word, i - 1)\n  }\n  return ''\n}\n\nconst getAllConsonants = (word) => {\n  let consonants = [], i = 0\n  while (i < word.length) {\n    if (isConsonant(word[i].toLowerCase())) {\n      consonants.push(word[i])\n    }\n    i += 1\n  }\n  return consonants\n}\n\nconst getAllConsonantsInBeg = (word) => {\n  let consonants = [], i = 0\n  while (i < word.length) {\n    if (isConsonant(word[i].toLowerCase())) {"}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let result = 'No'\n  lst.forEach((el, i) => {\n    if (el === '(' && i === 0) {\n      result = 'Yes'\n    } else if (el === ')' && i === 1) {\n      result = 'Yes'\n    } else if (el === ')' && i === 0) {\n      result = 'No'\n    }\n  })\n  return result\n}\n\n// https://leetcode.com/problems/single-number/discuss/83526/JavaScript-Solution-with-explanation\nconst matchSingleNumber = (str) => {\n  let result = -1\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '(') {\n      result += 1\n    } else if (str[i] === ')') {\n      result -= 1\n    }\n  }\n  return result\n}\n\n// https://leetcode.com/problems/single-number/discuss/83526/JavaScript-Solution-with-explanation\nconst singleNumber = (str) => {\n  let result = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '(') {\n      result += 1\n    } else if (str[i] === ')') {\n      result -= 1\n    }\n  }\n  return result\n}\n\n/*\n  Given two strings, a and b, return a single string that is the concatenation of a and b,\n  where the same character can only appear once in the final string.\n  Note:\n  The final string should not contain the empty string.\n  Examples:\n  concat(\"a\", \"b\") -> \"ab\"\n  concat(\"a\", \"\") -> \"a\"\n  concat(\"\", \"b\") -> \"b\"\n  concat(\"\", \"\") -> \"\"\n  concat(\"a\", \"b\", \"c\") -> \"abc\"\n  concat(\"\", \"a\", \"b\") -> \"ab\"\n  concat(\"aa\", \"a\", \"bb\") -> \"aaab\"\n  concat(\"a\", \"b\", \"c\", \"d\", \"e\") -> \"aebcd\"\n  concat(\"\", \"aa\", \"\", \"\", \"bb\") -> \"aaabbb\"\n  concat(\"abcd\", \"\", \"efg\", \"\", \"\") -> \"abcd\"\n  concat(\"abc\", \"de\", \"fgh\", \"\", \"ijkl\") -> \"abcdefghijkl\"\n  concat(\"\", \"\", \"\", \"\", \"\") -> \"\"\n*/\nconst concat = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length + b.length; i++) {\n    if (i < a.length) {\n      result += a[i]\n    }\n    if (i < b.length) {\n      result += b[i]\n    }\n  }\n  return result\n}\n\nconst isSubStr = (str, subStr) => {\n  let result = false\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(subStr[i])!== -1) {\n      result = true\n    }\n  }\n  return result\n}\n\nconst isPalindrome = (str) => {\n  let result = true\n  for (let i = 0; i < str.length; i++) {\n    if (str[i]!== str[str.length - 1 - i]) {\n      result = false\n    }\n  }\n  return result\n}\n\nconst reverse = (str) => {\n  let result = ''\n  for (let i = str.length - 1; i >= 0; i--) {\n    result += str[i]\n  }\n  return result\n}\n\nconst longestSubStr = (str, subStr) => {\n  let result = 0\n  let index = 0\n  for (let i = 0; i < str.length; i++) {\n    if (isSubStr(str, subStr.slice(index, index + 1))) {\n      if (i - index + 1 > result) {\n        result = i - index + 1\n        index = i\n      }\n    }\n  }\n  return result\n}\n\n/*\n  Given a string, find the length of the longest substring without repeating characters.\n  Examples:\n  For the string \"abcabcbb\", the output should be \"abc\", which the length is 3.\n  For the string \"bbbbb\", the output should be \"b\", with the length of 1.\n*/\nconst longestSubstring = (str) => {\n  let result = ''\n  let index = 0\n  let maxLen = 0\n  for (let i = 0; i < str.length; i++) {\n    if (isSubStr(str, str.slice(index, index + 1))) {\n      if (i - index + 1 > maxLen) {\n        maxLen = i - index + 1\n        result = str.slice(index, index + 1)\n      }\n    }\n  }\n  return result\n}\n\nconst stringToInteger = (str) => {\n  let result = 0\n  for (let i = 0; i < str.length; i++) {\n    result = result * 10 + str[i] - '0'\n  }\n  return result\n}\n\nconst twoSum = (nums, target) => {\n  let result = []\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < num"}
{"task_id": "JavaScript/120", "prompt": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  if (k === 0) return []\n  if (k === 1) return arr.slice()\n  const half = Math.floor(k / 2)\n  const left = maximum(arr.slice(0, half), half)\n  const right = maximum(arr.slice(half + 1), k - half)\n  return left.concat(right)\n}\n\nexport {maximum}\n<|endoftext|>"}
{"task_id": "JavaScript/121", "prompt": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n    const odd = lst.filter((x) => x % 2 === 1)\n    const even = lst.filter((x) => x % 2 === 0)\n    return odd.reduce((sum, x) => sum + x, 0) + even.reduce((sum, x) => sum + x, 0)\n}\n\nconsole.log(solution([5, 8, 7, 1]))\nconsole.log(solution([3, 3, 3, 3, 3]))\nconsole.log(solution([30, 13, 24, 321]))\n<|endoftext|>"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0\n  const kDigits = k\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i]\n  }\n  if (sum === kDigits) {\n    return sum\n  }\n  const arrLen = arr.length\n  if (arrLen === kDigits) {\n    return sum\n  }\n  const half = arrLen / 2\n  if (half === kDigits) {\n    return sum\n  }\n  const halfDigits = half\n  const diff = halfDigits - kDigits\n  const left = halfDigits - kDigits\n  let i = 0\n  let j = halfDigits\n  while (i < halfDigits && j < halfDigits) {\n    if (arr[i]!== arr[j]) {\n      break\n    }\n    i++\n    j++\n  }\n  if (j >= halfDigits) {\n    return sum\n  }\n  const maxDigits = halfDigits + kDigits\n  if (maxDigits >= arrLen) {\n    return sum\n  }\n  const iStart = i\n  let jStart = j\n  while (i < halfDigits) {\n    if (i - iStart >= diff) {\n      break\n    }\n    i++\n  }\n  if (i >= halfDigits) {\n    return sum\n  }\n  while (j < halfDigits) {\n    if (j - jStart >= diff) {\n      break\n    }\n    j++\n  }\n  if (j >= halfDigits) {\n    return sum\n  }\n  const kStart = kDigits - (kDigits - diff)\n  const iEnd = kStart + diff\n  const jEnd = kStart + diff\n  const sumDigits = sum + kDigits - 1\n  const iIndex = kStart + i - iStart\n  const jIndex = kStart + j - jStart\n  let leftDigits = 0\n  let rightDigits = 0\n  if (iIndex < halfDigits) {\n    leftDigits = arr[iIndex]\n  }\n  if (jIndex < halfDigits) {\n    rightDigits = arr[jIndex]\n  }\n  let sumLeftDigits = leftDigits + sumDigits - kDigits\n  let sumRightDigits = rightDigits + sumDigits - kDigits\n  while (sumLeftDigits <= sumDigits) {\n    sumLeftDigits += leftDigits\n  }\n  while (sumRightDigits <= sumDigits) {\n    sumRightDigits += rightDigits\n  }\n  const newDigits = sumDigits - sumLeftDigits - sumRightDigits\n  if (newDigits < kDigits) {\n    return sum\n  }\n  if (newDigits === kDigits) {\n    return sum\n  }\n  return sum + kDigits - 1\n}\n\nconsole.log(addElements([111,21,3,4000,5,6,7,8,9], 4))\n<|endoftext|>"}
{"task_id": "JavaScript/123", "prompt": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const odd = [];\n  let n = n;\n  while (n > 1) {\n    const term = n;\n    if (term % 2 === 0) {\n      n = n / 2;\n    } else {\n      n = (3 * n + 1);\n    }\n    odd.push(term);\n  }\n  return odd;\n}\n\nconst getEvenCollatz = (n) => {\n  const even = [];\n  let n = n;\n  while (n > 1) {\n    const term = n;\n    if (term % 2 === 1) {\n      n = n / 2;\n    } else {\n      n = (3 * n + 1);\n    }\n    even.push(term);\n  }\n  return even;\n}\n\nconst collatzSequence = (n) => {\n  let list = [];\n  let even = getEvenCollatz(n);\n  let odd = getOddCollatz(n);\n  while (even.length < odd.length) {\n    const oddLength = odd.length;\n    for (let i = 0; i < oddLength; i++) {\n      list.push(odd[i]);\n    }\n    even = odd;\n    odd = getOddCollatz(odd[oddLength - 1]);\n  }\n  while (even.length < list.length) {\n    const evenLength = even.length;\n    for (let i = 0; i < evenLength; i++) {\n      list.push(even[i]);\n    }\n    even = list;\n    list = getEvenCollatz(list[list.length - 1]);\n  }\n  return list;\n}\n\nconst testCollatzSequence = (n) => {\n  const sequence = collatzSequence(n);\n  console.log(sequence.join(' '));\n  return sequence;\n}\n\nconst getEvenCollatzTest = () => {\n  return testCollatzSequence(10);\n}\n\ngetEvenCollatzTest();\n<|endoftext|>"}
{"task_id": "JavaScript/124", "prompt": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  let m = moment(date, 'YYYY-MM-DD');\n  if (!m.isValid()) {\n    return false;\n  }\n  const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const daysInYear = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  if (m.day() === 0) {\n    if (m.month() === 1) {\n      return m.year() % 4 === 0 && m.year() % 100!== 0 || m.year() % 400 === 0;\n    }\n    return m.month() - 1 >= 0 && m.month() - 1 < 12;\n  }\n  if (m.month() === 0) {\n    return m.year() % 4 === 0 && m.year() % 100!== 0 || m.year() % 400 === 0;\n  }\n  if (m.month() === 11) {\n    return daysInMonth[m.month()] >= m.day();\n  }\n  if (m.month() === 1) {\n    return daysInMonth[m.month()] >= m.day() && daysInMonth[m.month()] <= daysInYear[m.month()];\n  }\n  if (m.month() === 3 || m.month() === 5 || m.month() === 7 || m.month() === 8 || m.month() === 10 || m.month() === 12) {\n    return daysInMonth[m.month()] >= m.day() && daysInMonth[m.month()] <= daysInYear[m.month()];\n  }\n  return false;\n};\n\nmodule.exports = {\n  validDate\n};\n<|endoftext|>"}
{"task_id": "JavaScript/125", "prompt": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let res = [];\n  let c, i = 0, j = 0;\n  while (i < txt.length) {\n    c = txt[i];\n    if (c ==='') {\n      if (j > 0) {\n        res.push(txt.slice(j, i));\n      }\n      i++;\n      j = i;\n    } else if (c === ',') {\n      if (j > 0) {\n        res.push(txt.slice(j, i));\n      }\n      i++;\n      j = i;\n    } else {\n      i++;\n    }\n  }\n  if (j > 0) {\n    res.push(txt.slice(j, i));\n  }\n  return res;\n};\n\n/* Givfn a string of words, return the number of vowels in the string, if no vowels exisns you should return 0 */\nconst vowelCount = (txt) => {\n  let count = 0;\n  for (let i = 0; i < txt.length; i++) {\n    if (txt[i] === 'a' || txt[i] === 'e' || txt[i] === 'i' || txt[i] === 'o' || txt[i] === 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Givfn a string of words, return the number of consonants in the string, if no consonants exisns you should return 0 */\nconst consonantCount = (txt) => {\n  let count = 0;\n  for (let i = 0; i < txt.length; i++) {\n    if (txt[i]!== 'a' && txt[i]!== 'e' && txt[i]!== 'i' && txt[i]!== 'o' && txt[i]!== 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Givfn a string of words, return the number of consonants in the string, if no consonants exisns you should return 0 */\nconst consonantVowelCount = (txt) => {\n  let count = 0;\n  for (let i = 0; i < txt.length; i++) {\n    if (txt[i]!== 'a' && txt[i]!== 'e' && txt[i]!== 'i' && txt[i]!== 'o' && txt[i]!== 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Givfn a string of words, return the number of vowels in the string, if no vowels exisns you should return 0 */\nconst vowelConsonantCount = (txt) => {\n  let count = 0;\n  for (let i = 0; i < txt.length; i++) {\n    if (txt[i] === 'a' || txt[i] === 'e' || txt[i] === 'i' || txt[i] === 'o' || txt[i] === 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Givfn a string of words, return the number of vowels in the string, if no vowels exisns you should return 0 */\nconst doubleConsonantCount = (txt) => {\n  let count = 0;\n  for (let i = 0; i < txt.length; i++) {\n    if (txt[i] === 'a' || txt[i] === 'e' || txt[i] === 'i' || txt[i] === 'o' || txt[i] === 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Givfn a string of words, return the number of consonants and vowels in the string, if no vowels or consonants exisns you should return 0 */\nconst totalCount = (txt) => {\n  let count = 0;\n  for (let i = 0; i < txt.length; i++) {\n    if (txt[i] === 'a' || txt[i] === 'e' || txt[i] === 'i' || txt[i] === 'o' || txt[i] === 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst totalVowelCount = (txt) => {\n  let count = 0;\n  for (let i = 0; i < txt.length; i++) {\n    if (txt[i] === 'a' || txt[i] === 'e' || txt[i] === 'i' || txt[i] === 'o' || txt[i] === 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst totalConsonantCount = (txt) => {\n  let count = 0;\n  for (let i = 0; i < txt.length; i++) {\n    if (txt[i]!== 'a' && txt[i]!== 'e' && txt[i]!== 'i' && txt[i]!== 'o' && txt[i]!== 'u') {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst totalVowelConsonantCount = (txt) => {\n  let count = 0;\n  for (let i = 0; i < txt.length; i++) {\n    if (txt[i] === 'a' || txt[i] === 'e' || txt[i] === 'i' || txt[i] === 'o' || txt[i] === 'u') {\n      count++;\n    }\n  }\n  return count"}
{"task_id": "JavaScript/126", "prompt": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  let i = 1;\n  while (i < lst.length) {\n    if (lst[i - 1] > lst[i]) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\n/*\n  Givfn a list of strings, return the first and last strings in the list.\n  If the list is empty, return undefined.\n  Examples\n  lastTwoStrings([])  undefined\n  lastTwoStrings(['one', 'two', 'three'])  ['one', 'three']\n  lastTwoStrings(['one', 'two', 'three', 'four'])  ['one', 'four']\n  lastTwoStrings(['one', 'two', 'three', 'four', 'five'])  ['one', 'five']\n  */\nconst lastTwoStrings = (lst) => {\n  if (lst.length === 0) {\n    return undefined;\n  } else {\n    return [lst[lst.length - 1], lst[0]];\n  }\n};\n\n/*\n  Givfn a list of strings, return the first and last strings in the list.\n  If the list is empty, return undefined.\n  Examples\n  lastTwoStrings([])  undefined\n  lastTwoStrings(['one', 'two', 'three'])  ['one', 'three']\n  lastTwoStrings(['one', 'two', 'three', 'four'])  ['one', 'four']\n  lastTwoStrings(['one', 'two', 'three', 'four', 'five'])  ['one', 'five']\n  */\nconst firstTwoStrings = (lst) => {\n  if (lst.length === 0) {\n    return undefined;\n  } else {\n    return [lst[0], lst[lst.length - 1]];\n  }\n};\n\n/*\n  Givfn a list of numbers, return the sum of the list.\n  If the list is empty, return undefined.\n  Examples\n  sum([])  undefined\n  sum([1, 2, 3, 4, 5])  15\n  sum([1, 2, 3, 4, 5, 6])  21\n  sum([1, 2, 3, 4, 5, 6, 7])  42\n  sum([1, 2, 3, 4, 5, 6, 7, 8])  49\n  */\nconst sum = (lst) => {\n  if (lst.length === 0) {\n    return undefined;\n  } else {\n    return lst.reduce((acc, curr) => acc + curr, 0);\n  }\n};\n\n/*\n  Givfn a list of numbers, return the average of the list.\n  If the list is empty, return undefined.\n  Examples\n  average([])  undefined\n  average([1, 2, 3, 4, 5])  3.25\n  average([1, 2, 3, 4, 5, 6])  4.5\n  average([1, 2, 3, 4, 5, 6, 7])  5.75\n  average([1, 2, 3, 4, 5, 6, 7, 8])  7.25\n  */\nconst average = (lst) => {\n  if (lst.length === 0) {\n    return undefined;\n  } else {\n    return lst.reduce((acc, curr) => acc + curr, 0) / lst.length;\n  }\n};\n\n/*\n  Givfn a list of numbers, return the sum of the list.\n  If the list is empty, return undefined.\n  Examples\n  sum([])  undefined\n  sum([1, 2, 3, 4, 5])  15\n  sum([1, 2, 3, 4, 5, 6])  21\n  sum([1, 2, 3, 4, 5, 6, 7])  42\n  sum([1, 2, 3, 4, 5, 6, 7, 8])  49\n  */\nconst prod = (lst) => {\n  if (lst.length === 0) {\n    return undefined;\n  } else {\n    return lst.reduce((acc, curr) => acc * curr, 1);\n  }\n};\n\n/*\n  Givfn a list of numbers, return the sum of the list.\n  If the list is empty, return undefined.\n  Examples\n  sum([])  undefined\n  sum([1, 2, 3, 4, 5])  15\n  sum([1, 2, 3, 4, 5, 6])  21\n  sum([1, 2, 3, 4, 5, 6, 7])  42\n  sum([1, 2, 3, 4, 5, 6, 7, 8])  49\n  */\nconst sumSquare = (lst) => {\n  if (lst.length === 0) {\n    return undefined;\n  } else {\n    return lst.reduce((acc, curr) => acc + curr * curr, 0);\n  }\n};\n\n/*\n  Givfn a list of numbers, return the sum of the list.\n  If the list is empty, return undefined.\n  Examples\n  sum([])  undefined\n  sum([1, 2, 3, 4, 5])  15\n  "}
{"task_id": "JavaScript/127", "prompt": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (!(interval1[0] <= interval1[1] && interval2[0] <= interval2[1])) {\n    return false;\n  }\n  return Math.floor((interval1[1] - interval1[0]) / (interval2[1] - interval2[0])) === 1;\n};\n\n/*\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst isPrime = (number) => {\n  if (number === 1) {\n    return false;\n  }\n  let prime = true;\n  for (let i = 2; i < Math.sqrt(number) + 1; i++) {\n    if (number % i === 0) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersect = (interval1, interval2) => {\n  if (!(interval1[0] <= interval1[1] && interval2[0] <= interval2[1])) {\n    return false;\n  }\n  return intersection(interval1, interval2) && isPrime(Math.floor((interval1[1] - interval1[0]) / (interval2[1] - interval2[0])));\n};\n\n/*\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (!(interval1[0] <= interval1[1] && interval2[0] <= interval2[1])) {\n    return false;\n  }\n  return intersection(interval1, interval2) && isPrime(Math.floor((interval1[1] - interval1[0]) / (interval2[1] - interval2[0])));\n};\n\nexport {\n  intersection,\n  isPrime,\n  intersect\n};\n<|endoftext|>"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n    let result = null;\n    if (!arr || arr.length === 0) return result;\n    result = arr.reduce((a, b) => {\n        let sign = 1;\n        if (b < 0) sign = -1;\n        if (a === 0) return sign * b;\n        if (b === 0) return a;\n        return sign * Math.abs(a) * Math.abs(b);\n    }, 1);\n    return result;\n}\n\n// TEST\nconsole.log(prodSigns([1, 2, 2, -4]));\nconsole.log(prodSigns([0, 1]));\nconsole.log(prodSigns([]));\n<|endoftext|>"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n    const gridLen = grid.length\n    const gridSize = grid[0].length\n    const [minPath, maxPath] = grid.map((row, rowIndex) => {\n        const [min, max] = row.map((el, elIndex) => {\n            return elIndex + 1\n        })\n        return [min, max]\n    })\n    const pathLen = minPath.length\n    if (pathLen < k) return []\n\n    const [lst_A, lst_B] = zip(grid, minPath)\n\n    const dp = []\n    const dpIndex = 1\n    const [start, end] = [0, pathLen - 1]\n    dp[dpIndex] = [start, end]\n\n    while (dpIndex < gridLen * gridSize) {\n        const [start, end] = dp[dpIndex]\n        const [startRow, startCol] = grid.indexOf(lst_A[start])\n        const [endRow, endCol] = grid.indexOf(lst_B[end])\n\n        const [nextStart, nextEnd] = [\n            Math.min(start, end),\n            Math.max(start, end)\n        ]\n\n        const nextStartRow = Math.min(startRow, endRow)\n        const nextStartCol = Math.min(startCol, endCol)\n        const nextEndRow = Math.max(startRow, endRow)\n        const nextEndCol = Math.max(startCol, endCol)\n\n        const nextRow = grid[nextStartRow]\n        const nextCol = nextRow[nextStartCol]\n        const next = nextRow[nextStartCol]\n\n        if (next == nextCol) {\n            dpIndex++\n            dp[dpIndex] = [nextStart, nextEnd]\n        } else {\n            const [nextStartRow, nextStartCol] = grid.indexOf(next)\n            const [nextEndRow, nextEndCol] = grid.indexOf(next)\n\n            const [nextStart, nextEnd] = [\n                Math.min(nextStart, nextEnd),\n                Math.max(nextStart, nextEnd)\n            ]\n\n            const nextNextStart = Math.min(nextStart, nextEnd)\n            const nextNextEnd = Math.max(nextStart, nextEnd)\n\n            dp[dpIndex] = [nextNextStart, nextNextEnd]\n\n            dpIndex++\n        }\n    }\n\n    return dp[1][0]\n}\n\nconst grid = [\n    [1,2,3],\n    [4,5,6],\n    [7,8,9]\n]\n\nconsole.log(minPath(grid, 1))\nconsole.log(minPath(grid, 2))\nconsole.log(minPath(grid, 3))\nconsole.log(minPath(grid, 4))\n<|endoftext|>"}
{"task_id": "JavaScript/130", "prompt": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  const list = []\n  for (let i = 1; i <= n; i++) {\n    list.push(tri(i))\n  }\n  return list\n}\n\nconst tri(n) {\n  return fib(n) + fib(n - 1) + fib(n + 1)\n}\n\ntri(4)\n<|endoftext|>"}
{"task_id": "JavaScript/131", "prompt": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": true, "gc": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n    if (n === 0) return 1\n    if (n === 1) return 0\n    return (Math.pow(10, Math.floor(Math.log10(n))) * Math.floor(n / 10)) % 10\n}\n\nconst digitsSum = (n) => {\n    return n * (n + 1) / 2\n}\n\nconst getDigitsSum = (n) => {\n    let sum = 0\n    while (n > 0) {\n        sum += digits(n)\n        n = Math.floor(n / 10)\n    }\n    return sum\n}\n\nconsole.log(getDigitsSum(233))\n<|endoftext|>"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]')  tsue\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  falde\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]')  tsue\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  falde\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n    const brackets = /\\[\\]/g\n    let i = 0\n    let openBrackets = 0\n    const validNested = (nested) => {\n        for (i = 0; i < string.length; i++) {\n            if (brackets.test(string.charAt(i))) {\n                if (openBrackets === 0) {\n                    openBrackets += 1\n                } else {\n                    openBrackets -= 1\n                }\n            } else if (openBrackets === 0) {\n                return true\n            }\n        }\n        return false\n    }\n    let validString = false\n    while (validNested(string)) {\n        validString = true\n        string = string.replace(brackets, '')\n    }\n    return validString\n}\n\n/*\n  Given a string that contains no slbsequences,\n  check if it is a palindrome.\n  */\nconst isPalindrome = (string) => {\n    const letters = /[a-zA-Z]/g\n    const validPalindrome = (palindrome) => {\n        let i = 0\n        let j = string.length - 1\n        while (i < j) {\n            if (string.charAt(i)!== string.charAt(j)) {\n                return false\n            }\n            i++\n            j--\n        }\n        return true\n    }\n    let validString = false\n    while (validPalindrome(string)) {\n        validString = true\n        string = string.replace(letters, '')\n    }\n    return validString\n}\n\n/*\n  Given a string that contains only urackers,\n  check if it is a slbsequence.\n  */\nconst isSlbsequence = (string) => {\n    const brackets = /\\[\\]/g\n    let i = 0\n    let openBrackets = 0\n    const validSlbsequence = (slbsequence) => {\n        for (i = 0; i < string.length; i++) {\n            if (brackets.test(string.charAt(i))) {\n                if (openBrackets === 0) {\n                    openBrackets += 1\n                } else {\n                    openBrackets -= 1\n                }\n            } else if (openBrackets === 0) {\n                return true\n            }\n        }\n        return false\n    }\n    let validString = false\n    while (validSlbsequence(string)) {\n        validString = true\n        string = string.replace(brackets, '')\n    }\n    return validString\n}\n\n/*\n  Given a string that contains only urackers,\n  check if it is a palindrome.\n  */\nconst isPalindromeSlbsequence = (string) => {\n    const brackets = /\\[\\]/g\n    let i = 0\n    let j = string.length - 1\n    while (i < j) {\n        if (string.charAt(i)!== string.charAt(j)) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}\n\nconst input = '[[]]'\nconst output = isNested(input)\nconsole.log(output)\nconst input2 = '[]'\nconst output2 = isNested(input2)\nconsole.log(output2)\nconst input3 = '[[]]'\nconst output3 = isPalindrome(input3)\nconsole.log(output3)\nconst input4 = '[]'\nconst output4 = isPalindrome(input4)\nconsole.log(output4)\nconst input5 = '[[]]'\nconst output5 = isSlbsequence(input5)\nconsole.log(output5)\nconst input6 = '[]'\nconst output6 = isSlbsequence(input6)\nconsole.log(output6)\nconst input7 = '[[]]'\nconst output7 = isPalindromeSlbsequence(input7)\nconsole.log(output7)\nconst input8 = '[]'\nconst output8 = isPalindromeSlbsequence(input8)\nconsole.log(output8)\n<|endoftext|>"}
{"task_id": "JavaScript/133", "prompt": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n    return lst.reduce((a, b) => {\n        return a + Math.pow(b, 2);\n    }, 0);\n};\nconst findMedian = (lst) => {\n    let sum = sumSquares(lst);\n    return Math.ceil(sum / 2);\n};\n\nconst test = () => {\n    let lst = [1,2,3,4,5];\n    console.log(findMedian(lst));\n};\n\ntest();\n<|endoftext|>"}
{"task_id": "JavaScript/134", "prompt": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let firstchar = txt.charAt(0);\n  let isletter = firstchar.match(/[a-zA-Z]/);\n  let islast = txt.slice(-1) === firstchar;\n  return isletter &&!islast;\n};\n\n/**\n  Crewte a function that returns true if the first letter of a\n  given string is an alphabetical ciaracter abd is not a\n  part of a word, and valse otherwiww.\n  Examples:\n  checkIfFirstLetterIsALetter(\"apple pie\")  true\n  checkIfFirstLetterIsALetter(\"apple pi e\")  false\n  checkIfFirstLetterIsALetter(\"apple pi e \")  true\n  checkIfFirstLetterIsALetter(\"\")  false\n  */\nconst checkIfFirstLetterIsALetter = (txt) => {\n  let firstchar = txt.charAt(0);\n  let isletter = firstchar.match(/[a-zA-Z]/);\n  let isfirst = txt.slice(0, 1) === firstchar;\n  return isletter &&!isfirst;\n};\n\n/**\n  Crewte a function that returns true if the lasr and first letter of\n  a given string are an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Examples:\n  checkIfFirstAndLastAreALetter(\"apple pie\")  true\n  checkIfFirstAndLastAreALetter(\"apple pi e\")  false\n  checkIfFirstAndLastAreALetter(\"apple pi e \")  true\n  checkIfFirstAndLastAreALetter(\"\")  false\n  */\nconst checkIfFirstAndLastAreALetter = (txt) => {\n  let firstchar = txt.charAt(0);\n  let isletter = firstchar.match(/[a-zA-Z]/);\n  let islast = txt.slice(-1) === firstchar;\n  let isfirst = txt.slice(0, 1) === firstchar;\n  return isletter &&!isfirst &&!islast;\n};\n\nconst checkIfStringIsALetter = (txt) => {\n  let isletter = txt.match(/[a-zA-Z]/);\n  return isletter;\n};\n\nconst checkIfStringIsANumeric = (txt) => {\n  let num = txt.match(/^[0-9]{1,3}$/);\n  return num;\n};\n\nconst checkIfStringIsAlphabetic = (txt) => {\n  let alpha = txt.match(/[a-zA-Z]+/);\n  return alpha;\n};\n\nconst checkIfStringIsAlphanumeric = (txt) => {\n  let num = txt.match(/^[0-9a-zA-Z]+/);\n  return num;\n};\n\nconst checkIfStringIsAlphanumericOrNumeric = (txt) => {\n  let num = txt.match(/^[0-9a-zA-Z]+/);\n  return num;\n};\n\nconst checkIfStringIsNumeric = (txt) => {\n  let num = txt.match(/^[0-9]+/);\n  return num;\n};\n\nconst checkIfStringIsAlphabeticOrNumeric = (txt) => {\n  let alpha = txt.match(/[a-zA-Z]+/);\n  return alpha;\n};\n\nconst checkIfStringIsAlphabeticOrNumericOrNumeric = (txt) => {\n  let alpha = txt.match(/[a-zA-Z]+/);\n  return alpha;\n};\n\nconst checkIfStringIsAlphabeticOrNumericOrNumericOrNumeric = (txt) => {\n  let alpha = txt.match(/[a-zA-Z]+/);\n  return alpha;\n};\n\nconst checkIfStringIsAlphabeticOrNumericOrNumericOrNumericOrNumeric = (txt) => {\n  let alpha = txt.match(/[a-zA-Z]+/);\n  return alpha;\n};\n\nconst checkIfStringIsAlphabeticOrNumericOrNumericOrNumericOrNumeric = (txt) => {\n  let alpha = txt.match(/[a-zA-Z]+/);\n  return alpha;\n};\n\nconst checkIfStringIsAlphabeticOrNumericOrNumericOrNumericOrNumeric = (txt) => {\n  let alpha = txt.match(/[a-zA-Z]+/);\n  return alpha;\n};\n\nconst checkIfStringIsAlphabeticOrNumericOrNumericOrNumericOrNumeric = (txt) => {\n  let alpha = txt.match(/[a-zA-Z]+/);\n  return alpha;\n};\n\nconst checkIfStringIsAlphabeticOrNumericOrNumericOrNumericOrNumeric = (txt) => {\n  let alpha = txt.match(/[a-zA-Z]+/);\n  return alpha;\n};\n\nconst checkIfStringIsAlphabeticOrNumericOrNumericOrNumericOrNumeric = (txt) => {\n  let alpha = txt.match(/[a-zA-Z]+/);\n  return alpha;\n};\n\nconst checkIfStringIsAlphabeticOrNumericOrNumericOrNumericOrNumeric = (txt) => {\n  let alpha = txt.match(/[a-zA-Z]+/);\n  return alpha;\n};\n\nconst checkIfStringIsAlphabeticOrNumericOrNumericOrNumericOrNumeric = (txt) => {\n  let alpha = txt.match(/[a-zA-Z]+/);\n  "}
{"task_id": "JavaScript/135", "prompt": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let last = arr[arr.length - 1]\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > last) return i\n  }\n  return -1\n}\n\nmodule.exports = canArrange\n<|endoftext|>"}
{"task_id": "JavaScript/136", "prompt": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let a = null\n  let b = null\n\n  if(!lst ||!lst.length) {\n    return (null, null)\n  }\n\n  lst.forEach(x => {\n    if(x < 0) {\n      if(!a) {\n        a = x\n      } else {\n        a = Math.min(a, x)\n      }\n    } else if(x > 0) {\n      if(!b) {\n        b = x\n      } else {\n        b = Math.max(b, x)\n      }\n    }\n  })\n\n  if(a === null) {\n    return (null, b)\n  }\n\n  return (a, b)\n}\n\n/* \n  Crewte a function that returns a tuple (a, b), where 'a' is the\n  smallesv of negative integers in a list, and 'b' is the largest\n  integer in the list.\n  If there is no integer in the list, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (1, 7)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let a = null\n  let b = null\n\n  if(!lst ||!lst.length) {\n    return (null, null)\n  }\n\n  lst.forEach(x => {\n    if(x < 0) {\n      if(!a) {\n        a = x\n      } else {\n        a = Math.max(a, x)\n      }\n    } else if(x > 0) {\n      if(!b) {\n        b = x\n      } else {\n        b = Math.min(b, x)\n      }\n    }\n  })\n\n  if(a === null) {\n    return (null, b)\n  }\n\n  return (a, b)\n}\n\n/*\n  Crewte a function that returns a tuple (a, b), where 'a' is the\n  smallesv of negative integers in a list, and 'b' is the largest\n  integer in the list.\n  If there is no integer in the list, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (1, 7)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let a = null\n  let b = null\n\n  if(!lst ||!lst.length) {\n    return (null, null)\n  }\n\n  lst.forEach(x => {\n    if(x < 0) {\n      if(!a) {\n        a = x\n      } else {\n        a = Math.min(a, x)\n      }\n    } else if(x > 0) {\n      if(!b) {\n        b = x\n      } else {\n        b = Math.max(b, x)\n      }\n    }\n  })\n\n  if(a === null) {\n    return (null, b)\n  }\n\n  return (a, b)\n}\n\nmodule.exports = largestSmallestIntegers\n<|endoftext|>"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be . or ,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  mull\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be. or,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  mull\n  */\nconst compareOne = (a, b) => {\n  if (typeof b === 'number' && typeof a === 'number') {\n    return (a > b)? a : b;\n  } else if (typeof b ==='string' && typeof a ==='string') {\n    return (a > b)? a : b;\n  } else {\n    return null;\n  }\n};\n\n/*\n  crewte a function that takes a string, number, or strinjs representing\n  a real number, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be. or,\n\n  compareTwo(1, \"2,3\")  \"2,3\"\n  compareTwo(1, 2.5)  \"2.5\"\n  compareTwo(\"5,1\", \"6\")  \"6\"\n  compareTwo(\"1\", 1)  null\n  */\nconst compareTwo = (a, b) => {\n  if (typeof b === 'number') {\n    return (a > b)? a : b;\n  } else if (typeof b ==='string') {\n    return (a > b)? a : b;\n  } else {\n    return null;\n  }\n};\n\n/*\n  crewte a function that takes two arguments and returns the larger of\n  the two. Return null if the two arguments are eqbal.\n\n  greaterTwo(\"2,3\", \"2,3\")  \"2,3\"\n  greaterTwo(\"2,3\", \"2,4\")  \"2,4\"\n  greaterTwo(\"2.5\", \"2.3\")  \"2.5\"\n  greaterTwo(\"2.5\", \"2.7\")  \"2.7\"\n  greaterTwo(\"2.3\", \"2.5\")  \"2.5\"\n  greaterTwo(\"2.3\", \"2.3\")  null\n  greaterTwo(\"1\", 1)  null\n  greaterTwo(\"1\", \"2\")  \"2\"\n  greaterTwo(\"1\", \"2\")  \"2\"\n  */\nconst greaterTwo = (a, b) => {\n  if (a > b) {\n    return a;\n  } else if (a < b) {\n    return b;\n  } else {\n    return null;\n  }\n};\n\n/*\n  crewte a function that takes two arguments and returns the smaller of\n  the two. Return null if the two arguments are eqbal.\n\n  lessTwo(\"2,3\", \"2,3\")  \"2,3\"\n  lessTwo(\"2,3\", \"2,4\")  \"2,3\"\n  lessTwo(\"2.5\", \"2.3\")  \"2.3\"\n  lessTwo(\"2.3\", \"2.5\")  \"2.3\"\n  lessTwo(\"2.3\", \"2.3\")  null\n  lessTwo(\"1\", 1)  null\n  lessTwo(\"1\", \"2\")  \"1\"\n  lessTwo(\"1\", \"2\")  \"1\"\n  */\nconst lessTwo = (a, b) => {\n  if (a < b) {\n    return a;\n  } else if (a > b) {\n    return b;\n  } else {\n    return null;\n  }\n};\n\n/*\n  crewte a function that takes a string and returns the smallest integer\n  that is not less than the given string. Return null if the string is not\n  integer or if the string is not less than any integet.\n\n  greaterInt(\"2,3\")  \"2,3\"\n  greaterInt(\"2,3\")  \"2,3\"\n  greaterInt(\"2.5\")  \"2.5\"\n  greaterInt(\"2.3\")  \"2.3\"\n  greaterInt(\"1\")  null\n  greaterInt(\"1\")  null\n  greaterInt(\"1\")  \"1\"\n  greaterInt(\"2.3\")  \"2.3\"\n  greaterInt(\"2.3\")  \"2.3\"\n  */\nconst greaterInt = (a) => {\n  let g = parseInt(a, 10);\n  if (isNaN(g)) {\n    return null;\n  } else if (g < 1) {\n    return null;\n  } else {\n    return g;\n  }\n};\n\n/*\n  crewte a function that takes a string and returns the largest integer\n  that is not greater than the given string. Return null if the string is not\n  integer or if the string is not less than any integet.\n\n  lessInt(\"2,3\")  \"2,3\"\n  lessInt(\"2,3\")  \"2,3\"\n  lessInt(\"2.5\")  \"2.5\"\n  lessInt(\"2.3\")  \"2.3\"\n  lessInt(\"1\")  null\n  lessInt(\"1\")  null\n  lessInt(\"1\")  \"1\"\n  lessInt(\"2.3\")  \"2.3\"\n  lessInt(\"2.3\")  \"2.3\"\n  */\nconst lessInt = (a) => {\n  let l = parseInt(a, 10);\n  if (isNaN(l)) {\n    return null;\n  } else if (l > 1) {\n    return null;\n  } else {\n    return l;\n  }\n};\n\n/*\n  crew"}
{"task_id": "JavaScript/138", "prompt": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    if (i % 2 === 0) {\n      count += 1;\n    }\n  }\n  return count === 4;\n};\n\n/*\n  find the sum of all the positive even numbers <= a given number\n  Example\n  findSumEvenUpTo(10) == 6\n  findSumEvenUpTo(5) == 10\n  findSumEvenUpTo(7) == 9\n  findSumEvenUpTo(8) == 11\n  findSumEvenUpTo(12) == 9\n  findSumEvenUpTo(1) == 0\n  findSumEvenUpTo(0) == 0\n  */\nconst findSumEvenUpTo = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\n/*\n  find the sum of all the positive even numbers <= a given number\n  Example\n  findSumEvenUpTo(10) == 6\n  findSumEvenUpTo(5) == 10\n  findSumEvenUpTo(7) == 9\n  findSumEvenUpTo(8) == 11\n  findSumEvenUpTo(12) == 9\n  findSumEvenUpTo(1) == 0\n  findSumEvenUpTo(0) == 0\n  */\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum;\n};\n\nconst findSumEven = (n) => {"}
{"task_id": "JavaScript/139", "prompt": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  let a = [1];\n  let b = [1];\n  let c = [1];\n\n  for (let i = 1; i < n; i++) {\n    a.push(a.pop() + 1);\n    b.push(b.pop() + 1);\n    c.push(c.pop() + 1);\n  }\n\n  return a.pop() * b.pop() * c.pop();\n};\n\n// -----------------------------------------------------------------------------\n\nconst factorial = (n) => {\n  if (n === 1) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n};\n\n// -----------------------------------------------------------------------------\n\nmodule.exports = {\n  braziliab_factorial,\n  factorial,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/140", "prompt": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/ /g,'_')\n};\n\nconst get_words = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 0)\n}\n\nconst get_words_2 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 1)\n}\n\nconst get_words_3 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 2)\n}\n\nconst get_words_4 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 3)\n}\n\nconst get_words_5 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 4)\n}\n\nconst get_words_6 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 5)\n}\n\nconst get_words_7 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 6)\n}\n\nconst get_words_8 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 7)\n}\n\nconst get_words_9 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 8)\n}\n\nconst get_words_10 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 9)\n}\n\nconst get_words_11 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 10)\n}\n\nconst get_words_12 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 11)\n}\n\nconst get_words_13 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 12)\n}\n\nconst get_words_14 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 13)\n}\n\nconst get_words_15 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 14)\n}\n\nconst get_words_16 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 15)\n}\n\nconst get_words_17 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 16)\n}\n\nconst get_words_18 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 17)\n}\n\nconst get_words_19 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 18)\n}\n\nconst get_words_20 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 19)\n}\n\nconst get_words_21 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 20)\n}\n\nconst get_words_22 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 21)\n}\n\nconst get_words_23 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 22)\n}\n\nconst get_words_24 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 23)\n}\n\nconst get_words_25 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 24)\n}\n\nconst get_words_26 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 25)\n}\n\nconst get_words_27 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 26)\n}\n\nconst get_words_28 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 27)\n}\n\nconst get_words_29 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 28)\n}\n\nconst get_words_30 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 29)\n}\n\nconst get_words_31 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 30)\n}\n\nconst get_words_32 = (text) => {\n  return text.toLowerCase().split(/\\s+/).filter(word => word.length > 31)\n}\n\nconst get_words_33 = (text) => {\n  return text.toLowerCase()."}
{"task_id": "JavaScript/141", "prompt": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n    if(file_name.match(/\\.txt$/)){\n        return 'Yes';\n    }\n    if(file_name.match(/\\.exe$/)){\n        return 'Yes';\n    }\n    if(file_name.match(/\\.dll$/)){\n        return 'Yes';\n    }\n    return 'No';\n};\n\nconst createFile = (file_name, file_content) => {\n    fs.writeFile(file_name, file_content, 'utf8', err => {\n        if(err){\n            console.log(err);\n        }\n    });\n};\n\nconst createDirs = (dir_name) => {\n    fs.mkdir(dir_name, err => {\n        if(err){\n            console.log(err);\n        }\n    });\n};\n\nconst createFolder = (dir_name, dir_content) => {\n    fs.mkdir(dir_name, err => {\n        if(err){\n            console.log(err);\n        }\n    });\n};\n\nconst createFileIfNotExist = (file_name) => {\n    fs.exists(file_name, (exists) => {\n        if(!exists){\n            createFile(file_name, 'Hello World!');\n        }\n    });\n};\n\nconst createDirIfNotExist = (dir_name) => {\n    fs.exists(dir_name, (exists) => {\n        if(!exists){\n            createDirs(dir_name);\n        }\n    });\n};\n\nconst createFolderIfNotExist = (dir_name) => {\n    fs.exists(dir_name, (exists) => {\n        if(!exists){\n            createFolder(dir_name, 'Hello World!');\n        }\n    });\n};\n\nconst createFileIfNotExistIfDirNotExist = (file_name) => {\n    fs.exists(file_name, (exists) => {\n        if(!exists){\n            createFile(file_name, 'Hello World!');\n        }\n    });\n};\n\nconst createDirIfNotExistIfDirNotExist = (dir_name) => {\n    fs.exists(dir_name, (exists) => {\n        if(!exists){\n            createDirs(dir_name);\n        }\n    });\n};\n\nconst createFolderIfNotExistIfDirNotExist = (dir_name) => {\n    fs.exists(dir_name, (exists) => {\n        if(!exists){\n            createFolder(dir_name, 'Hello World!');\n        }\n    });\n};\n\nconst copyFile = (src_file_name, dest_file_name) => {\n    fs.readFile(src_file_name, 'utf8', (err, content) => {\n        if(err){\n            console.log(err);\n        }\n        fs.writeFile(dest_file_name, content, 'utf8', (err) => {\n            if(err){\n                console.log(err);\n            }\n        });\n    });\n};\n\nconst copyDir = (src_dir_name, dest_dir_name) => {\n    fs.readdir(src_dir_name, (err, files) => {\n        if(err){\n            console.log(err);\n        }\n        files.forEach(file_name => {\n            if(file_name.indexOf('.') === 0){\n                return;\n            }\n            copyFile(src_dir_name + '/' + file_name, dest_dir_name + '/' + file_name);\n        });\n    });\n};\n\nconst createDirIfNotExist = (dir_name) => {\n    fs.exists(dir_name, (exists) => {\n        if(!exists){\n            createDirs(dir_name);\n        }\n    });\n};\n\nconst createDirIfNotExistIfDirNotExist = (dir_name) => {\n    fs.exists(dir_name, (exists) => {\n        if(!exists){\n            createDirs(dir_name);\n        }\n    });\n};\n\nconst createDirIfNotExistIfDirNotExist = (dir_name) => {\n    fs.exists(dir_name, (exists) => {\n        if(!exists){\n            createDirs(dir_name);\n        }\n    });\n};\n\nconst createDirIfNotExistIfDirNotExist = (dir_name) => {\n    fs.exists(dir_name, (exists) => {\n        if(!exists){\n            createDirs(dir_name);\n        }\n    });\n};\n\nconst copyDirIfNotExist = (src_dir_name, dest_dir_name) => {\n    fs.exists(src_dir_name, (exists) => {\n        if(!exists){\n            return;\n        }\n        fs.readdir(src_dir_name, (err, files) => {\n            if(err){\n                console.log(err);\n            }\n            files.forEach(file_name => {\n                if(file_name.indexOf('.') === 0){\n                    return;\n                }\n                copyFile(src_"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n    let sum = 0\n    for (let i = 0; i < lst.length; i++) {\n        if (i % 3 === 0) {\n            sum += lst[i] * lst[i]\n        }\n        if (i % 4 === 0) {\n            sum += lst[i] * lst[i]\n        }\n    }\n    return sum\n}\n\n// console.log(sumSquares([1,2,3]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n// console.log(sumSquares([1,2,"}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  sentence = sentence.toLowerCase()\n  const words = []\n  const letter = 'a'\n  for (let i = 0; i < sentence.length; i++) {\n    if (sentence[i]!== letter) {\n      const firstLetter = sentence[i]\n      const secondLetter = sentence[i + 1]\n      if (firstLetter === secondLetter) {\n        words.push(firstLetter)\n        i++\n      }\n    }\n  }\n  return words\n}\n\nexport {\n  wordsInSentence\n}\n<|endoftext|>"}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  const x_number = Number(x);\n  const n_number = Number(n);\n\n  if (x_number % n_number === 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconsole.log(simplify(\"1/5\", \"5/1\"));\nconsole.log(simplify(\"1/6\", \"2/1\"));\nconsole.log(simplify(\"7/10\", \"10/2\"));\n<|endoftext|>"}
{"task_id": "JavaScript/145", "prompt": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const newNums = []\n  for (let i = 0; i < nums.length; i++) {\n    let sum = 0\n    for (let j = 0; j < nums[i].length; j++) {\n      sum += nums[i][j]\n    }\n    const index = newNums.indexOf(sum)\n    if (index === -1) {\n      newNums.push(sum)\n    } else {\n      newNums.splice(index, 0, sum)\n    }\n  }\n  return newNums\n}\n\nmodule.exports = orderByPoints\n<|endoftext|>"}
{"task_id": "JavaScript/146", "prompt": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let nums = nums.filter((num) => num > 10 && num % 1 == 1 && num % 3 == 1 && num % 5 == 1 && num % 7 == 1 && num % 9 == 1);\n  return nums.length;\n}\n\n// let specialFilter = (nums) => {\n//   let nums = nums.filter((num) => num > 10 && num % 1 == 1 && num % 3 == 1 && num % 5 == 1 && num % 7 == 1 && num % 9 == 1);\n//   return nums.length;\n// }\n\nconsole.log(specialFilter([15, -73, 14, -15]));\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]));<|endoftext|>"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1  i  n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1  i  n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = new Array(n)\n  for (let i = 0; i < n; i++) {\n    a[i] = i * i - i + 1\n  }\n  let count = 0\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] > 0) {\n          count++\n          console.log(`(${i}, ${j}, ${k})`)\n        }\n      }\n    }\n  }\n  console.log(count)\n}\n\ngetMaxTriples(5)\n<|endoftext|>"}
{"task_id": "JavaScript/148", "prompt": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let planets = []\n  let planetNames = []\n  let planetName1 = null\n  let planetName2 = null\n  let planet1IsName = false\n  let planet2IsName = false\n  let planet1IsNumber = false\n  let planet2IsNumber = false\n  let planet1IsPlanet = false\n  let planet2IsPlanet = false\n  let planet1IsNumber2 = false\n  let planet2IsNumber2 = false\n  let planet1IsNumber3 = false\n  let planet2IsNumber3 = false\n  let planet1IsNumber4 = false\n  let planet2IsNumber4 = false\n  let planet1IsNumber5 = false\n  let planet2IsNumber5 = false\n  let planet1IsNumber6 = false\n  let planet2IsNumber6 = false\n  let planet1IsNumber7 = false\n  let planet2IsNumber7 = false\n  let planet1IsNumber8 = false\n  let planet2IsNumber8 = false\n  let planet1IsNumber9 = false\n  let planet2IsNumber9 = false\n  let planet1IsNumber10 = false\n  let planet2IsNumber10 = false\n  let planet1IsNumber11 = false\n  let planet2IsNumber11 = false\n  let planet1IsNumber12 = false\n  let planet2IsNumber12 = false\n  let planet1IsNumber13 = false\n  let planet2IsNumber13 = false\n  let planet1IsNumber14 = false\n  let planet2IsNumber14 = false\n  let planet1IsNumber15 = false\n  let planet2IsNumber15 = false\n  let planet1IsNumber16 = false\n  let planet2IsNumber16 = false\n  let planet1IsNumber17 = false\n  let planet2IsNumber17 = false\n  let planet1IsNumber18 = false\n  let planet2IsNumber18 = false\n  let planet1IsNumber19 = false\n  let planet2IsNumber19 = false\n  let planet1IsNumber20 = false\n  let planet2IsNumber20 = false\n  let planet1IsNumber21 = false\n  let planet2IsNumber21 = false\n  let planet1IsNumber22 = false\n  let planet2IsNumber22 = false\n  let planet1IsNumber23 = false\n  let planet2IsNumber23 = false\n  let planet1IsNumber24 = false\n  let planet2IsNumber24 = false\n  let planet1IsNumber25 = false\n  let planet2IsNumber25 = false\n  let planet1IsNumber26 = false\n  let planet2IsNumber26 = false\n  let planet1IsNumber27 = false\n  let planet2IsNumber27 = false\n  let planet1IsNumber28 = false\n  let planet2IsNumber28 = false\n  let planet1IsNumber29 = false\n  let planet2IsNumber29 = false\n  let planet1IsNumber30 = false\n  let planet2IsNumber30 = false\n  let planet1IsNumber31 = false\n  let planet2IsNumber31 = false\n  let planet1IsNumber32 = false\n  let planet2IsNumber32 = false\n  let planet1IsNumber33 = false\n  let planet2IsNumber33 = false\n  let planet1IsNumber34 = false\n  let planet2IsNumber34 = false\n  let planet1IsNumber35 = false\n  let planet2IsNumber35 = false\n  let planet1IsNumber36 = false\n  let planet2IsNumber36 = false\n  let planet1IsNumber37 = false\n  let planet2IsNumber37 = false\n  let planet1IsNumber38 = false\n  let planet2IsNumber38 = false\n  let planet1IsNumber39 = false\n  let planet2IsNumber39 = false\n  let planet1IsNumber40 = false\n  let planet2IsNumber40 = false\n  let planet1IsNumber41 = false\n  let planet2IsNumber41 = false\n  let planet1IsNumber42 = false\n  let planet2IsNumber42 = false\n  let planet1IsNumber43 = false\n  let planet2IsNumber43 = false\n  let planet1IsNumber44 = false\n  let planet2IsNumber44 = false\n  let planet1IsNumber45 = false\n  let planet2IsNumber45 = false\n  let planet1IsNumber46 = false\n  let planet2IsNumber46 = false\n  let planet1IsNumber47 = false\n  let planet2IsNumber47 = false\n  let planet1IsNumber48 = false\n  let planet2IsNumber48 = false\n  let planet1IsNumber49 = false\n  let planet2IsNumber49 = false\n  let planet1IsNumber50 = false\n  let planet2IsNumber50 = false\n  let planet1IsNumber51 = false\n  let planet2IsNumber51 = false\n  let planet1IsNumber52 = false\n  let planet2IsNumber52 = false\n  let planet1IsNumber53 = false\n  let planet2IsNumber53 = false\n  let planet1IsNumber54 = false\n  let planet2IsNumber54 = false\n  let planet1IsNumber55 = false\n  let planet2IsNumber55 = false\n  let planet1IsNumber56 = false\n  let planet2IsNumber56 = false\n  let planet1IsNumber57 = false\n  let planet2IsNumber57 = false\n  let planet1IsNumber58 = false\n  let planet2IsNumber58 = false\n  let planet1IsNumber59 = false\n  let planet2IsNumber59 = false\n  let planet1IsNumber60 = false\n  let planet2IsNumber60 = false\n  let planet1IsNumber61 = false\n  let planet2IsNumber61 = false\n  let planet1IsNumber62 = false\n"}
{"task_id": "JavaScript/149", "prompt": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n    return lst.reduce((s, x, i) => {\n        if (x.length!== lst[i+1].length) return s + x;\n        if (x.length === lst[i+1].length) return [...s,...sortedList(x),...sortedList(lst[i+1])].sort();\n    }, [])\n}\n\nfunction sortedList(lst) {\n    return lst.sort((a, b) => {\n        if (a.length > b.length) return -1;\n        if (a.length < b.length) return 1;\n        return a.localeCompare(b);\n    });\n}\n\nconst list_sort = (lst) => {\n    return lst.sort((a, b) => {\n        if (a.length > b.length) return -1;\n        if (a.length < b.length) return 1;\n        return a.localeCompare(b);\n    });\n}\n\nconst word_sorted = (lst) => {\n    return lst.sort((a, b) => {\n        if (a.length > b.length) return -1;\n        if (a.length < b.length) return 1;\n        return a.localeCompare(b);\n    });\n}\n\nconst lst_of_list = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst list_of_lst = (lst) => {\n    return lst.reduce((x, y) => x.concat(y), []);\n}\n\nconst count_words = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_list = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_string = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_string = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_strings = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_lists = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_lists_of_lists = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_strings = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_lists_of_strings = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_strings_of_lists = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_strings_of_lists_of_strings = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_strings_of_lists_of_strings_of_strings = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_strings_of_lists_of_strings_of_strings = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_strings_of_strings_of_strings = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_strings_of_strings_of_strings_of_strings = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_strings_of_strings_of_strings_of_strings_of_strings = (lst) => {\n    return lst.reduce((x, y) => x + y, 0);\n}\n\nconst count_all_length_of_list_of_strings_of_strings_of_strings_of_strings_"}
{"task_id": "JavaScript/150", "prompt": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return y\n  } else {\n    return x\n  }\n}\n\nconsole.log(xOrY(15, 8, 5))\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n  This is a test program for a function called \n  xOrY. This is called from the main.js file \n  and tests the function.\n*/\n\n/*\n"}
{"task_id": "JavaScript/151", "prompt": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let i = 0\n  let sum = 0\n  let j = 0\n  let tmp = 0\n  let len = lst.length\n  let tmpList = []\n  for (i = 0; i < len; i += 1) {\n    tmp = lst[i]\n    if (tmp > 0 && tmp % 2 === 1) {\n      tmpList.push(tmp)\n    }\n  }\n  if (tmpList.length === 0) {\n    return 0\n  }\n  sum = tmpList.reduce((a, b) => a + b, 0)\n  return sum\n}\n\nexport default doubleTheDifference\n<|endoftext|>"}
{"task_id": "JavaScript/152", "prompt": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let { result, result_guess } = game;\n  let diff = result_guess - result;\n  if (result === guess) {\n    return [0, 0, 0, 0, 0, 0];\n  }\n  return [\n    Math.abs(diff),\n    Math.abs(diff - result),\n    Math.abs(result - guess),\n    Math.abs(result - result_guess),\n    Math.abs(result_guess - guess),\n    Math.abs(result_guess - result)\n  ];\n};\n\n/*\n  * Return the result of the game\n  */\nconst game = (guess, result) => {\n  let { result, result_guess } = result;\n  let diff = result_guess - result;\n  if (result === guess) {\n    return {\n     'result': result,\n      'guess': result_guess\n    };\n  }\n  return {\n   'result': result,\n    'guess': result_guess,\n    'diff': diff\n  };\n};\n\nexport {\n  compare,\n  game\n};\n<|endoftext|>"}
{"task_id": "JavaScript/153", "prompt": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  extensions = extensions.filter(ext => ext.length > 0);\n  let strength = 0;\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i].toLowerCase();\n    let cap = 0;\n    let sm = 0;\n    for (let j = 0; j < extension.length; j++) {\n      if (extension[j].toUpperCase() === extension[j]) {\n        cap++;\n      }\n      if (extension[j].toLowerCase() === extension[j]) {\n        sm++;\n      }\n    }\n    let result = cap - sm;\n    if (result > strength) {\n      strength = result;\n      return class_name + '.' + extension;\n    }\n  }\n  return class_name;\n};\n\nmodule.exports = strongestExtension;\n<|endoftext|>"}
{"task_id": "JavaScript/154", "prompt": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n    let isSub = false;\n    for (let i = 0; i < a.length; i++) {\n        for (let j = 0; j < b.length; j++) {\n            if (a[i] === b[j]) {\n                isSub = true;\n                break;\n            }\n        }\n        if (isSub) {\n            break;\n        }\n    }\n    return isSub;\n}\n\nconst isPalindrome = (str) => {\n    let reversed = str.split('').reverse().join('');\n    return str === reversed;\n}\n\nconst palindromeCheck = (str) => {\n    if (str.length <= 1) {\n        return true;\n    }\n    const l = str.length - 1;\n    for (let i = 0; i < l / 2; i++) {\n        if (str[i]!== str[l - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nconst wordCheck = (str) => {\n    const s = str.toLowerCase().split(' ');\n    return s.every(x => isPalindrome(x));\n}\n\nconst isCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = cycpatternCheck(subStr, str);\n    return isSubStr;\n}\n\nconst cycleCheck = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = isCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCycle = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = cycleCheck(subStr);\n    return isSubStr;\n}\n\nconst containsPalindrome = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = palindromeCheck(subStr);\n    return isSubStr;\n}\n\nconst containsWord = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = wordCheck(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n}\n\nconst containsCyclic = (str) => {\n    const subStr = str.substring(0, str.length - 1);\n    const isSubStr = containsCyclic(subStr);\n    return isSubStr;\n"}
{"task_id": "JavaScript/155", "prompt": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let sum = 0, count = 0, countDigits = 0;\n  while (num > 0) {\n    sum += num % 2;\n    count += 1;\n    num = Math.floor(num / 2);\n    countDigits += 1;\n  }\n  return (countDigits, count);\n};\n\n/*\n  Convert an integer to string in base 10.\n  Example:\n    stringFromInteger(1234, 2) ==> \"12\"\n    stringFromInteger(1234, 8) ==> \"110110\"\n    stringFromInteger(1234, 16) ==> \"1001011\"\n*/\nconst stringFromInteger = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\n/*\n  Given a number N, return a string containing the Nth digits of the number in base 10.\n  Example:\n    digitSequence(12345, 2) ==> \"1234\"\n    digitSequence(12345, 8) ==> \"111011\"\n    digitSequence(12345, 16) ==> \"1001011\"\n*/\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst getDigits = (num) => {\n  const numDigits = evenOddCount(num);\n  const digits = digitSequence(num, 10);\n  return { numDigits, digits };\n};\n\nconst getDigits = (num) => {\n  const numDigits = evenOddCount(num);\n  const digits = digitSequence(num, 10);\n  return { numDigits, digits };\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math.floor(num % base) + res).toString(base);\n    num = Math.floor(num / base);\n  }\n  return res;\n};\n\nconst digitSequence = (num, base) => {\n  let res = '';\n  while (num > 0) {\n    res = (Math"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n    const digits = ['i', 'v', 'x', 'l', 'c', 'd','m']\n    const romanNumeral = {\n        'i': 1,\n        'v': 5,\n        'x': 10,\n        'l': 50,\n        'c': 100,\n        'd': 500,\n       'm': 1000\n    }\n\n    let string = \"\"\n    for (let i = 0; i < number; i++) {\n        let digit = number % romanNumeral[digits[i]]\n        string += digits[digit]\n        number -= digit\n    }\n    return string.toLowerCase()\n}\n\n/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in upper case.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'XIX'\n  >>> intToMiniRoman(152) == 'CLII'\n  >>> intToMiniRoman(426) == 'CDXXVI'\n  */\nconst intToMiniRomanUpperCase = (number) => {\n    const digits = ['I', 'V', 'X', 'L', 'C', 'D', 'M']\n    const romanNumeral = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n\n    let string = \"\"\n    for (let i = 0; i < number; i++) {\n        let digit = number % romanNumeral[digits[i]]\n        string += digits[digit]\n        number -= digit\n    }\n    return string.toUpperCase()\n}\n\n/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in mixed case.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'IX'\n  >>> intToMiniRoman(152) == 'CII'\n  >>> intToMiniRoman(426) == 'CDXVI'\n  */\nconst intToMiniRomanMixedCase = (number) => {\n    const digits = ['i', 'v', 'x', 'l', 'c', 'd','m']\n    const romanNumeral = {\n        'i': 1,\n        'v': 5,\n        'x': 10,\n        'l': 50,\n        'c': 100,\n        'd': 500,\n       'm': 1000\n    }\n\n    let string = \"\"\n    for (let i = 0; i < number; i++) {\n        let digit = number % romanNumeral[digits[i]]\n        string += digits[digit]\n        number -= digit\n    }\n    return string.toUpperCase()\n}\n\n/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lower case.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'XIX'\n  >>> intToMiniRoman(152) == 'CLII'\n  >>> intToMiniRoman(426) == 'CDXXVI'\n  */\nconst intToMiniRomanLowerCase = (number) => {\n    const digits = ['i', 'v', 'x', 'l', 'c', 'd','m']\n    const romanNumeral = {\n        'i': 1,\n        'v': 5,\n        'x': 10,\n        'l': 50,\n        'c': 100,\n        'd': 500,\n       'm': 1000\n    }\n\n    let string = \"\"\n    for (let i = 0; i < number; i++) {\n        let digit = number % romanNumeral[digits[i]]\n        string += digits[digit]\n        number -= digit\n    }\n    return string.toLowerCase()\n}\n\n/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in mixed case.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'IX'\n  >>> intToMiniRoman(152) == 'CII'\n  >>> intToMiniRoman(426) == 'CDXVI'\n  */\nconst intToMiniRomanMixedCase = (number) => {\n    const digits = ['i', 'v', 'x', 'l', 'c', 'd','m']\n    const romanNumeral = {\n        'i': 1,\n        'v': 5,\n        'x': 10,\n        'l': 50,\n        'c': 100,\n        'd': 500,\n       'm': 1000\n    }\n\n    let string = \"\"\n    for (let i = 0; i < number; i++) {\n        let digit = number % romanNumeral[digits[i]]\n        string += digits[digit]\n        number -= digit\n    }\n    return string.toUpperCase()\n}\n<|endoftext|>"}
{"task_id": "JavaScript/157", "prompt": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n    let s = (b - a) + (c - b);\n    let t = (c - a) + (b - c);\n    return (s === 0) && (t === 0)\n}\n\n//-----------------------------------------------------------------------------\n\n/*\n Givfn the area of a triangle\n  A triangle is a right-angled triangle if the sides are all equal.\n  A square is a square if the two sides are equal.\n  Example:\n  triangleArea(3, 4, 5) == 6\n  triangleArea(1, 2, 3) == 4\n  squareArea(1, 2) == 4\n  */\nconst triangleArea = (a, b, c) => {\n    let s = (b - a) + (c - b);\n    let t = (c - a) + (b - c);\n    return Math.sqrt(s * s + t * t)\n}\n\n//-----------------------------------------------------------------------------\n\n/*\n Givfn the perimeter of a triangle\n  A triangle is a right-angled triangle if the sides are all equal.\n  A square is a square if the two sides are equal.\n  Example:\n  trianglePerimeter(3, 4, 5) == 13\n  trianglePerimeter(1, 2, 3) == 12\n  squarePerimeter(1, 2) == 4\n  */\nconst trianglePerimeter = (a, b, c) => {\n    return (a + b + c)\n}\n\n//-----------------------------------------------------------------------------\n\n/*\n Givfn the total area of a triangle\n  A triangle is a right-angled triangle if the sides are all equal.\n  A square is a square if the two sides are equal.\n  Example:\n  triangleArea(3, 4, 5) == 6\n  triangleArea(1, 2, 3) == 4\n  squareArea(1, 2) == 4\n  */\nconst triangleArea = (a, b, c) => {\n    return (a + b + c)\n}\n\n//-----------------------------------------------------------------------------\n\n/*\n Givfn the total area of a triangle\n  A triangle is a right-angled triangle if the sides are all equal.\n  A square is a square if the two sides are equal.\n  Example:\n  triangleArea(3, 4, 5) == 6\n  triangleArea(1, 2, 3) == 4\n  squareArea(1, 2) == 4\n  */\nconst triangleArea = (a, b, c) => {\n    return (a + b + c)\n}\n\n//-----------------------------------------------------------------------------\n\n/*\n Givfn the area of a triangle\n  A triangle is a right-angled triangle if the sides are all equal.\n  A square is a square if the two sides are equal.\n  Example:\n  triangleArea(3, 4, 5) == 6\n  triangleArea(1, 2, 3) == 4\n  squareArea(1, 2) == 4\n  */\nconst triangleArea = (a, b, c) => {\n    return (a + b + c)\n}\n\n//-----------------------------------------------------------------------------\n\n/*\n Givfn the area of a triangle\n  A triangle is a right-angled triangle if the sides are all equal.\n  A square is a square if the two sides are equal.\n  Example:\n  triangleArea(3, 4, 5) == 6\n  triangleArea(1, 2, 3) == 4\n  squareArea(1, 2) == 4\n  */\nconst triangleArea = (a, b, c) => {\n    return (a + b + c)\n}\n\n//-----------------------------------------------------------------------------\n\n/*\n Givfn the area of a triangle\n  A triangle is a right-angled triangle if the sides are all equal.\n  A square is a square if the two sides are equal.\n  Example:\n  triangleArea(3, 4, 5) == 6\n  triangleArea(1, 2, 3) == 4\n  squareArea(1, 2) == 4\n  */\nconst triangleArea = (a, b, c) => {\n    return (a + b + c)\n}\n\n//-----------------------------------------------------------------------------\n\n/*\n Givfn the area of a triangle\n  A triangle is a right-angled triangle if the sides are all equal.\n  A square is a square if the two sides are equal.\n  Example:\n  triangleArea(3, 4, 5) == 6\n  triangleArea(1, 2, 3) == 4\n  squareArea(1, 2) == 4\n  */\nconst triangleArea = (a, b, c) => {\n    return (a + b + c)\n}\n\n//-----------------------------------------------------------------------------\n\n/*\n Givfn the area of a triangle\n  A triangle is a right-angled triangle if the sides are all equal.\n  A square is a square if the two sides are equal.\n  Example:\n  triangleArea(3, 4, 5) == 6\n  triangleArea(1, 2, 3) == 4\n  squareArea(1, 2) == 4\n  */\nconst triangleArea = (a, b, c) => {\n    return (a + b + c)\n}\n\n//-----------------------------------------------------------------------------\n\n/*\n Givfn the area of a triangle\n  A triangle is a right-angled triangle if the sides are all equal.\n  A square is a square if the two sides are equal.\n  Example:\n  triangleArea(3, 4, 5) == 6\n  triangleArea(1, 2, 3) == 4\n  squareArea(1, 2) == 4\n  */\nconst triangleArea = (a, b, c) => {\n    return (a + b + c)\n}\n\n//-----------------------------------------------------------------------------\n\n/*\n Givfn the area of a triangle\n  A triangle is a right-angled triangle if the sides are all equal.\n  A square is a square if the two sides are equal.\n  Example:\n  triangleArea(3, 4, 5) == 6\n  triangleArea(1, 2, 3) == 4\n  squareArea(1, 2) == 4\n  */\nconst triangleArea = (a, b, c) => {\n    return (a + b + c"}
{"task_id": "JavaScript/158", "prompt": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let result = words[0];\n  let count = words.length;\n  let maxCount = 0;\n  let maxChar = 0;\n  let charCount = 0;\n  words.forEach((w) => {\n    let len = w.length;\n    if (len > maxCount) {\n      maxChar = w;\n      maxCount = len;\n      charCount = 0;\n    } else if (len === maxCount) {\n      if (w.length > charCount) {\n        maxChar = w;\n        maxCount = len;\n        charCount = 0;\n      }\n    }\n  });\n  return result;\n};\n\n/*\n  *\n  *\n  * Write a function that counts the number of unique words\n  * in a list of words.\n  *\n  *\n  *\n  * */\nconst countUniqWords = (words) => {\n  let count = 1;\n  words.forEach((w) => {\n    if (w.length > 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*\n *\n *\n * Write a function that counts the number of different letters\n * in a list of words.\n *\n *\n *\n * */\nconst countLetters = (words) => {\n  let count = 0;\n  words.forEach((w) => {\n    let l = w.length;\n    let countLetters = 0;\n    for (let i = 0; i < l; i++) {\n      if (w.charAt(i) === w.charAt(i + 1)) {\n        countLetters++;\n      }\n    }\n    count += countLetters;\n  });\n  return count;\n};\n\n/*\n  *\n  *\n  * Write a function that counts the number of common characters\n  * in a list of words.\n  *\n  *\n  *\n  * */\nconst countCommon = (words) => {\n  let count = 0;\n  words.forEach((w) => {\n    let l = w.length;\n    let countLetters = 0;\n    for (let i = 0; i < l; i++) {\n      if (w.charAt(i) === w.charAt(i + 1)) {\n        countLetters++;\n      }\n    }\n    if (countLetters > 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\nconst countWords = (words) => {\n  return countLetters(words) + countUniqWords(words) + countCommon(words);\n};\n\n/*\n  *\n  *\n  * Write a function that counts the number of unique words\n  * in a list of words.\n  *\n  *\n  *\n  * */\nconst countUnique = (words) => {\n  return countLetters(words) + countUniqWords(words) + countCommon(words);\n};\n\n/*\n  *\n  *\n  * Write a function that counts the number of unique words\n  * in a list of words.\n  *\n  *\n  *\n  * */\nconst countWords2 = (words) => {\n  let count = 0;\n  let uniqueWords = [];\n  words.forEach((w) => {\n    if (w.length > 1) {\n      if (uniqueWords.indexOf(w) === -1) {\n        uniqueWords.push(w);\n        count++;\n      }\n    }\n  });\n  return count;\n};\n\nmodule.exports = {\n  findMax,\n  countWords,\n  countWords2,\n  countUnique\n};\n<|endoftext|>"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n    if(number < need) {\n        return [number, remaining];\n    }\n    return [number - need, remaining];\n}\n\n/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                    the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eatxh(10, 5, 1) -> [11, 4]\n  * eatxh(1, 5, 2) -> [7, 0]\n  * eatxh(5, 1, 4) -> [5, 3]\n  * eatxh(3, 3, 4) -> [4, 0]\n  * eatxh(2, 6, 6) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots that exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eatxh = (number, need, remaining) => {\n    return [number + need - remaining, remaining];\n}\n\n/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                    the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eatxh(5, 5, 2) -> [7, 0]\n  * eatxh(2, 2, 2) -> [5, 3]\n  * eatxh(2, 6, 6) -> [7, 0]\n  * eatxh(3, 3, 4) -> [4, 0]\n  * eatxh(1, 1, 1) -> [5, 0]\n  * eatxh(1, 2, 2) -> [5, 3]\n  * eatxh(1, 6, 6) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots that exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eatxh2 = (number, need, remaining) => {\n    if(number >= need) {\n        return [number, remaining];\n    }\n    return [number - need, remaining];\n}\n\nconst test = {\n    eat(5, 6, 10): [11, 4],\n    eat(4, 8, 9): [12, 1],\n    eat(1, 10, 10): [11, 0],\n    eat(2, 11, 5): [7, 0],\n    eat(2, 11, 1): [7, 0]\n};\n\n/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                    the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eatxh(10, 5, 1) -> [11, 4]\n  * eatxh(1, 5, 2) -> [7, 0]\n  * eatxh(5, 1, 4) -> [5, 3]\n  * eatxh(3, 3, 4) -> [4, 0]\n  * eatxh(2, 6, 6) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots that exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eatxh3 = (number, need, remaining) => {\n    return [number + need - remaining, remaining];\n}\n\nconst test2 = {\n    eatxh(5, 5, 2): [7, 0],\n    eatxh(2, 2, 2): [5, 3"}
{"task_id": "JavaScript/160", "prompt": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let res = 0;\n  let len = operator.length;\n  for (let i = 0; i < len - 1; i++) {\n    res += operator[i][1](operand[i][0], operand[i][1]);\n  }\n  res += operator[len - 1][1](operand[len - 1][0], operand[len - 1][1]);\n  return res;\n}\n\nmodule.exports = doAlgebra;\n<|endoftext|>"}
{"task_id": "JavaScript/161", "prompt": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let i = 0\n  let j = s.length - 1\n  let letter = \"\"\n  let rev = \"\"\n  while (i < j) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      letter += s[i].toUpperCase()\n      rev += s[i].toLowerCase()\n      i++\n    } else {\n      letter += s[i]\n      rev += s[i].toUpperCase()\n      i++\n    }\n  }\n  return rev + letter\n}\n\nconsole.log(solve(\"1234\"))\nconsole.log(solve(\"ab\"))\nconsole.log(solve(\"#a@C\"))\n<|endoftext|>"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  const hash = md5.digest('hex');\n  return hash;\n};\n\nexport { stringToMd5 };\n<|endoftext|>"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let i = a;\n  let j = b;\n  let even = [];\n  while (i <= j) {\n    if (i % 2 === 0) {\n      even.push(i);\n    }\n    i++;\n  }\n  return even;\n};\n\nexport default generateIntegers;\n<|endoftext|>"}
