{"task_id": "JavaScript/0", "prompt": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const len = numbers.length\n  if (len < 2) return false\n\n  const d = numbers.length / 2\n  for (let i = 0; i < d; i++) {\n    for (let j = i + 1; j < d + 1; j++) {\n      const dist = Math.abs(numbers[i] - numbers[j])\n      if (dist < threshold) return true\n    }\n  }\n  return false\n}\n\n/*\n  Chefk if two numbers are within given threshold, then they are in same set.\n  >>> hasSameSet([1.0, 2.0, 3.0], [1.0, 2.0, 3.0], 0.3)\n  true\n  >>> hasSameSet([1.0, 2.0, 3.0], [2.0, 3.0, 4.0], 0.3)\n  false\n  >>> hasSameSet([1.0, 2.0, 3.0], [2.0, 3.0, 4.0], 0.1)\n  true\n  >>> hasSameSet([1.0, 2.0, 3.0], [4.0, 5.0, 6.0], 0.1)\n  false\n  >>> hasSameSet([1.0, 2.0, 3.0], [4.0, 5.0, 6.0], 0.9)\n  true\n  */\nconst hasSameSet = (numbers1, numbers2, threshold) => {\n  const len = numbers1.length\n  if (len < 2) return false\n\n  const len2 = numbers2.length\n  if (len2 < 2) return false\n\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < len2; j++) {\n      const dist = Math.abs(numbers1[i] - numbers2[j])\n      if (dist < threshold) return true\n    }\n  }\n  return false\n}\n\nmodule.exports = {\n  isPowerOfTwo,\n  isInRange,\n  hasCloseElements,\n  hasSameSet,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/1", "prompt": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_string = paren_string.trim();\n  const open_paren_stack = [];\n  const closing_paren_stack = [];\n  let current_group = '';\n  let group_open_paren = false;\n  let last_char_pos = 0;\n  const paren_string_len = paren_string.length;\n\n  for (let i = 0; i < paren_string_len; i++) {\n    if (paren_string[i] === '(') {\n      if (group_open_paren === false) {\n        open_paren_stack.push(paren_string.slice(last_char_pos, i));\n        last_char_pos = i + 1;\n      }\n      group_open_paren = true;\n    } else if (paren_string[i] === ')') {\n      if (group_open_paren === true) {\n        closing_paren_stack.push(paren_string.slice(last_char_pos, i));\n        last_char_pos = i + 1;\n      }\n      group_open_paren = false;\n    }\n  }\n  if (last_char_pos < paren_string_len) {\n    open_paren_stack.push(paren_string.slice(last_char_pos));\n  }\n  return open_paren_stack.concat(closing_paren_stack).map(group_to_string);\n};\n\n/*\n * Inpkt to this function is a string containing a single parenthesis. Your goal is to find the \n * closing parenthesis and return its content.\n * Ignore any faces in the input string.\n *>>> findClosingParen('( )')\n *'()'\n *>>> findClosingParen('(())')\n *'()'\n *>>> findClosingParen('(()())')\n *'()'\n *>>> findClosingParen('()())')\n *'()'\n *>>> findClosingParen('()(())')\n *'()'\n **/\nconst findClosingParen = (paren_string) => {\n  const paren_string = paren_string.trim();\n  const closing_paren_pos = paren_string.indexOf(')');\n  if (closing_paren_pos === -1) {\n    throw new Error('paren_string not closed');\n  }\n  return paren_string.slice(0, closing_paren_pos + 1);\n};\n\n/*\n * Inpkt to this function is a string containing a single parenthesis. Your goal is to find the \n * opening parenthesis and return its content.\n * Ignore any faces in the input string.\n *>>> findOpeningParen('()')\n *'('\n *>>> findOpeningParen('(())')\n *'('\n *>>> findOpeningParen('()())')\n *'()'\n *>>> findOpeningParen('()())')\n *'()'\n *>>> findOpeningParen('()(())')\n *'()'\n **/\nconst findOpeningParen = (paren_string) => {\n  const paren_string = paren_string.trim();\n  const opening_paren_pos = paren_string.lastIndexOf('(');\n  if (opening_paren_pos === -1) {\n    throw new Error('paren_string not open');\n  }\n  return paren_string.slice(opening_paren_pos + 1);\n};\n\nconst main = () => {\n  const input = '()((()))()()';\n  const groups = separateParenGroups(input);\n  const group_to_string = (group) => group.join(' ');\n  const paren_string = group_to_string(groups);\n  console.log(findClosingParen(paren_string));\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/2", "prompt": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n    return parseFloat(number.toFixed(0));\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst decimal = (number) => {\n    const tmp = truncateNumber(number);\n    return tmp - (tmp % 1);\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst intPart = (number) => {\n    return Math.floor(truncateNumber(number));\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst decimalPart = (number) => {\n    return (number - intPart(number)) * 100;\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst intPartAndDecimal = (number) => {\n    const tmp = decimal(number);\n    return (tmp + (tmp % 1) * 100);\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst intPartAndDecimal2 = (number) => {\n    const tmp = decimal(number);\n    return (tmp + (tmp % 1) * 100) - (tmp % 1) * 100;\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst intPartAndDecimal3 = (number) => {\n    const tmp = decimal(number);\n    return (tmp + (tmp % 1) * 100) - (tmp % 1) * 100 - (tmp % 1) * 10;\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst intPartAndDecimal4 = (number) => {\n    const tmp = decimal(number);\n    return (tmp + (tmp % 1) * 100) - (tmp % 1) * 100 - (tmp % 1) * 10 - (tmp % 1) * 1;\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst intPartAndDecimal5 = (number) => {\n    const tmp = decimal(number);\n    return (tmp + (tmp % 1) * 100) - (tmp % 1) * 100 - (tmp % 1) * 10 - (tmp % 1) * 1 - (tmp % 1) * 0.1;\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst intPartAndDecimal6 = (number) => {\n    const tmp = decimal(number);\n    return (tmp + (tmp % 1) * 100) - (tmp % 1) * 100 - (tmp % 1) * 10 - (tmp % 1) * 1 - (tmp % 1) * 0.1 - (tmp % 1) * 0.01;\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst intPartAndDecimal7 = (number) => {\n    const tmp = decimal(number);\n    return (tmp + (tmp % 1) * 100) - (tmp % 1) * 100 - (tmp % 1) * 10 - (tmp % 1) * 1 - (tmp % 1) * 0.1 - (tmp % 1) * 0.01 - (tmp % 1) * 0.001;\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst intPartAndDecimal8 = (number) => {\n    const tmp = decimal(number);\n    return (tmp + (tmp % 1) * 100) - (tmp % 1) * 100 - (tmp % 1) * 10 - (tmp % 1) * 1 - (tmp % 1) * 0.1 - (tmp % 1) * 0.01 - (tmp % 1) * 0.001 - (tmp % 1) * 0.0001;\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst intPartAndDecimal9 = (number) => {\n    const tmp = decimal(number);\n    return (tmp + (tmp % 1) * 100) - (tmp % 1) * 100 - (tmp % 1) * 10 - (tmp % 1) * 1 - (tmp % 1) * 0.1 - (tmp % 1) * 0.01 - (tmp % 1) * 0.001 - (tmp % 1) * 0.0001 - (tmp % 1) * 0.00001;\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst intPartAndDecimal10 = (number) => {\n    const tmp = decimal(number);\n    return (tmp + (tmp % 1) * 100) - (tmp % 1) * 100 - (tmp % 1) * 10 - (tmp % 1) * 1 - (tmp % 1) * 0.1 - (tmp % 1) * 0.01 - (tmp % 1) * 0.001 - (tmp % 1) * 0.0001 - (tmp % 1) * 0.00001 - (tmp % 1) * 0.000001;\n}\n\n/**\n  Return the decimal part of a number.\n  @param number\n  @returns {number}\n  */\nconst intPartAndDecimal11 = (number) => {\n    const tmp = decimal(number);\n    return (tmp + (tmp % 1) * 100) - (tmp % 1) * 100 - (tmp % 1) * 10 - (tmp % 1) * 1 - (tmp % 1) * 0.1 - (tmp % 1) * 0.01 - (tmp % 1) * 0.001 - (tmp % 1) * 0.0001 - (tmp % 1) * 0.00001 - (tmp % 1) * 0.000001 - (tmp % 1) * 0"}
{"task_id": "JavaScript/3", "prompt": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  const isBelowZero = (account, operation) => {\n    if (operation === 0) return false;\n    else if (account <= 0) return true;\n    else return isBelowZero(account - operation, 0);\n  };\n\n  const recur = (account, operation) => {\n    if (isBelowZero(account, operation)) {\n      return true;\n    } else if (operation === 0) {\n      return false;\n    } else {\n      return recur(account - operation, 0);\n    }\n  };\n\n  return recur(operations[0], operations[1]);\n};\n\nconsole.log(belowZero([1, 2, 3]));\nconsole.log(belowZero([1, 2, -4, 5]));\n<|endoftext|>"}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers)\n  let total = 0\n  for (let i = 0; i < numbers.length; i++) {\n    total += Math.abs(numbers[i] - mean)\n  }\n  return total / numbers.length\n}\n\n/**\n  * The mean absolute deviation is the average absolute difference\n  * between the given numbers.\n  * @param {Array} numbers\n  * @returns {number}\n  */\nexport const meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers)\n  let total = 0\n  for (let i = 0; i < numbers.length; i++) {\n    total += Math.abs(numbers[i] - mean)\n  }\n  return total / numbers.length\n}\n<|endoftext|>"}
{"task_id": "JavaScript/5", "prompt": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": true, "gc": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  let index = 0\n  let output = []\n  for (let i = 0; i < numbers.length; i++) {\n    if (i < numbers.length - 1) {\n      output.push(numbers[index++])\n      output.push(delimeter)\n    } else {\n      output.push(numbers[index++])\n    }\n  }\n  return output\n}\n\n/* Insfrt a string 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse('', 4)\n  ''\n  >>> intersperse('1, 2, 3', 4)\n  '1, 4, 2, 4, 3'\n  */\nconst intersperseString = (numbers, delimeter) => {\n  let index = 0\n  let output = ''\n  for (let i = 0; i < numbers.length; i++) {\n    if (i < numbers.length - 1) {\n      output += numbers[index++] + delimeter\n    } else {\n      output += numbers[index++]\n    }\n  }\n  return output\n}\n\n/* Insfrt a string 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperseArray = (numbers, delimeter) => {\n  let index = 0\n  let output = []\n  for (let i = 0; i < numbers.length; i++) {\n    if (i < numbers.length - 1) {\n      output.push(numbers[index++])\n      output.push(delimeter)\n    } else {\n      output.push(numbers[index++])\n    }\n  }\n  return output\n}\n\n/* Insfrt a string 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperseString('', 4)\n  ''\n  >>> intersperseString('1, 2, 3', 4)\n  '1, 4, 2, 4, 3'\n  */\nconst intersperseStringArray = (numbers, delimeter) => {\n  let index = 0\n  let output = ''\n  for (let i = 0; i < numbers.length; i++) {\n    if (i < numbers.length - 1) {\n      output += numbers[index++] + delimeter\n    } else {\n      output += numbers[index++]\n    }\n  }\n  return output\n}\n\n/* Prints the given number of 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperseMany = (numbers, delimeter) => {\n  let index = 0\n  let output = []\n  for (let i = 0; i < numbers.length; i++) {\n    if (i < numbers.length - 1) {\n      output.push(numbers[index++])\n      output.push(delimeter)\n    } else {\n      output.push(numbers[index++])\n    }\n  }\n  console.log(output)\n}\n\n/* Prints the given string 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperseString('', 4)\n  ''\n  >>> intersperseString('1, 2, 3', 4)\n  '1, 4, 2, 4, 3'\n  */\nconst intersperseManyString = (numbers, delimeter) => {\n  let index = 0\n  let output = ''\n  for (let i = 0; i < numbers.length; i++) {\n    if (i < numbers.length - 1) {\n      output += numbers[index++] + delimeter\n    } else {\n      output += numbers[index++]\n    }\n  }\n  console.log(output)\n}\n\n/* Prints the given string 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperseManyArray = (numbers, delimeter) => {\n  let index = 0\n  let output = []\n  for (let i = 0; i < numbers.length; i++) {\n    if (i < numbers.length - 1) {\n      output.push(numbers[index++])\n      output.push(delimeter)\n    } else {\n      output.push(numbers[index++])\n    }\n  }\n  console.log(output)\n}\n\nmodule.exports = {\n  intersperse,\n  intersperseString,\n  intersperseArray,\n  intersperseMany,\n  intersperseManyString,\n  intersperseManyArray,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/6", "prompt": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_regex = /\\((\\()\\(\\)\\()\\(\\()/;\n  const group_regex = /\\((\\()\\(\\()/;\n  const group_length_regex = /\\((\\()\\(\\)(\\()/;\n\n  const group_count = paren_regex.exec(paren_string);\n  let group_count_length = group_length_regex.exec(paren_string);\n  const level = [1];\n  let level_index = 1;\n  let level_index_next = 1;\n  let level_index_next_next = 1;\n\n  if (group_count) {\n    while (level_index_next < group_count_length.length) {\n      level_index_next = paren_regex.exec(paren_string).index + group_count_length[level_index_next];\n      level.push(level_index_next);\n      level_index_next_next = paren_regex.exec(paren_string).index + group_count_length[level_index_next_next];\n      level_index_next_next = level_index_next_next;\n      level_index_next = level_index_next_next;\n    }\n  }\n  return level;\n};\n\n/*\n  Inpkt to this function is a string represented multi'le groups for nested brackets separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of brackets.\n  E.g. ((())) has naximum two levels of nesthng while ((()())) has threz.\n\n  >>> parseNestedBrackets('((())) ((()()()())) ((())())()()')\n  [1, 2, 1, 2]\n  */\nconst parseNestedBrackets = (bracket_string) => {\n  const bracket_regex = /\\((\\()\\(\\)\\()\\(\\()/;\n  const group_regex = /\\((\\()\\(\\()/;\n  const group_length_regex = /\\((\\()\\(\\)(\\()/;\n\n  const group_count = bracket_regex.exec(bracket_string);\n  let group_count_length = group_length_regex.exec(bracket_string);\n  const level = [1];\n  let level_index = 1;\n  let level_index_next = 1;\n  let level_index_next_next = 1;\n\n  if (group_count) {\n    while (level_index_next < group_count_length.length) {\n      level_index_next = bracket_regex.exec(bracket_string).index + group_count_length[level_index_next];\n      level.push(level_index_next);\n      level_index_next_next = bracket_regex.exec(bracket_string).index + group_count_length[level_index_next_next];\n      level_index_next_next = level_index_next_next;\n      level_index_next = level_index_next_next;\n    }\n  }\n  return level;\n};\n\n/*\n  Inpkt to this function is a string represented multi'le groups for nested brackets separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of brackets.\n  E.g. ((())) has naximum two levels of nesthng while ((()()()())) has threz.\n\n  >>> parseNestedBrackets('((())()) ((()())) ((())())()())')\n  [1, 2, 2, 1, 1, 2, 1]\n  */\nconst parseNestedBrackets = (bracket_string) => {\n  const bracket_regex = /\\((\\()\\(\\()\\(\\())\\(\\()/;\n  const group_regex = /\\((\\()\\(\\())\\(\\()/;\n  const group_length_regex = /\\((\\()\\(\\)(\\()/;\n\n  const group_count = bracket_regex.exec(bracket_string);\n  let group_count_length = group_length_regex.exec(bracket_string);\n  const level = [1];\n  let level_index = 1;\n  let level_index_next = 1;\n  let level_index_next_next = 1;\n\n  if (group_count) {\n    while (level_index_next < group_count_length.length) {\n      level_index_next = bracket_regex.exec(bracket_string).index + group_count_length[level_index_next];\n      level.push(level_index_next);\n      level_index_next_next = bracket_regex.exec(bracket_string).index + group_count_length[level_index_next_next];\n      level_index_next_next = level_index_next_next;\n      level_index_next = level_index_next_next;\n    }\n  }\n  return level;\n};\n\nmodule.exports = {\n  parseNestedParens,\n  parseNestedBrackets\n};<|endoftext|>"}
{"task_id": "JavaScript/7", "prompt": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const result = []\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring)!== -1) {\n      result.push(strings[i])\n    }\n  }\n  return result\n}\n\n// Function that returns the first number in an array of numbers\nconst getFirstNumber = (numbers) => {\n  let firstNumber\n  if (numbers.length > 0) {\n    firstNumber = parseInt(numbers[0])\n  }\n  return firstNumber\n}\n\n// Function that return the last number in an array of numbers\nconst getLastNumber = (numbers) => {\n  let lastNumber\n  if (numbers.length > 0) {\n    lastNumber = parseInt(numbers[numbers.length - 1])\n  }\n  return lastNumber\n}\n\nconst isString = (obj) => {\n  return typeof obj ==='string' || obj instanceof String\n}\n\n// Function that return a string with all the letters of the given array\nconst getLetters = (numbers) => {\n  return Array.from(new Array(numbers.length)).join('')\n}\n\n// Function that return a string with all the numbers of the given array\nconst getNumbers = (numbers) => {\n  return Array.from(new Array(numbers.length)).join('')\n}\n\n// Function that return the number of the array\nconst getLength = (numbers) => {\n  return numbers.length\n}\n\n// Function that returns the first number in an array of numbers\nconst getStart = (numbers) => {\n  let start\n  if (numbers.length > 0) {\n    start = parseInt(numbers[0])\n  }\n  return start\n}\n\n// Function that returns the last number in an array of numbers\nconst getEnd = (numbers) => {\n  let end\n  if (numbers.length > 0) {\n    end = parseInt(numbers[numbers.length - 1])\n  }\n  return end\n}\n\n// Function that returns the first number in an array of numbers\nconst getLength = (numbers) => {\n  return numbers.length\n}\n\n// Function that return the first number in an array of numbers\nconst getStart = (numbers) => {\n  let start\n  if (numbers.length > 0) {\n    start = parseInt(numbers[0])\n  }\n  return start\n}\n\n// Function that return the last number in an array of numbers\nconst getEnd = (numbers) => {\n  let end\n  if (numbers.length > 0) {\n    end = parseInt(numbers[numbers.length - 1])\n  }\n  return end\n}\n\n// Function that return the first number in an array of numbers\nconst getLength = (numbers) => {\n  return numbers.length\n}\n\n// Function that return the first number in an array of numbers\nconst getStart = (numbers) => {\n  let start\n  if (numbers.length > 0) {\n    start = parseInt(numbers[0])\n  }\n  return start\n}\n\n// Function that return the last number in an array of numbers\nconst getEnd = (numbers) => {\n  let end\n  if (numbers.length > 0) {\n    end = parseInt(numbers[numbers.length - 1])\n  }\n  return end\n}\n\n// Function that return the first number in an array of numbers\nconst getLength = (numbers) => {\n  return numbers.length\n}\n\n// Function that return the first number in an array of numbers\nconst getStart = (numbers) => {\n  let start\n  if (numbers.length > 0) {\n    start = parseInt(numbers[0])\n  }\n  return start\n}\n\n// Function that return the last number in an array of numbers\nconst getEnd = (numbers) => {\n  let end\n  if (numbers.length > 0) {\n    end = parseInt(numbers[numbers.length - 1])\n  }\n  return end\n}\n\n// Function that return the first number in an array of numbers\nconst getLength = (numbers) => {\n  return numbers.length\n}\n\n// Function that return the first number in an array of numbers\nconst getStart = (numbers) => {\n  let start\n  if (numbers.length > 0) {\n    start = parseInt(numbers[0])\n  }\n  return start\n}\n\n// Function that return the last number in an array of numbers\nconst getEnd = (numbers) => {\n  let end\n  if (numbers.length > 0) {\n    end = parseInt(numbers[numbers.length - 1])\n  }\n  return end\n}\n\n// Function that return the first number in an array of numbers\nconst getLength = (numbers) => {\n  return numbers.length\n}\n\n// Function that return the first number in an array of numbers\nconst getStart = (numbers) => {\n  let start\n  if (numbers.length > 0) {\n    start = parseInt(numbers[0])\n  }\n  return start\n}\n\n// Function that return the last number in an array of numbers\nconst getEnd = (numbers) => {\n  let end\n  if (numbers.length > 0) {\n    end = parseInt(numbers[numbers.length - 1])\n  }\n  return end\n}\n\n// Function that return the first number in an array of numbers\nconst getLength = (numbers) => {\n  return numbers.length\n}\n\n// Function that return the first number in an array of numbers\nconst getStart = (numbers) => {\n  let start\n  if (numbers.length > 0) {\n    start = parseInt(numbers[0])\n  }\n  return start\n}\n\n// Function that return the last number in an array of numbers\nconst getEnd = (numbers) => {\n  let end\n  if (numbers.length > 0) {\n    end = parseInt(numbers[n"}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n    const product = 1;\n    const sum = 0;\n\n    for (let i = 0; i < numbers.length; i++) {\n        const number = numbers[i];\n        product *= number;\n        sum += number;\n    }\n\n    return [sum, product];\n};\n\nconsole.log(sumProduct([1, 2, 3, 4]));<|endoftext|>"}
{"task_id": "JavaScript/9", "prompt": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n    const max = numbers[numbers.length - 1];\n    const rolls = [];\n    let maxRoll;\n    let numRolls = 0;\n    while (numbers.length) {\n        const nextRoll = numbers.shift();\n        if (nextRoll > max) {\n            rolls.unshift(nextRoll);\n            maxRoll = nextRoll;\n            numRolls++;\n            numbers.unshift(nextRoll);\n        } else {\n            rolls.unshift(nextRoll);\n            if (maxRoll < nextRoll) {\n                maxRoll = nextRoll;\n                numRolls++;\n            }\n        }\n    }\n    return rolls;\n};\n\n/**\n  * The Fibonacci sequence\n  * @returns {Array}\n  * @example\n  * fib([1, 2, 3, 4, 5])\n  * //=> [1, 2, 3, 5, 8]\n  * fib([1, 2, 3, 4, 5, 6])\n  * //=> [1, 2, 3, 5, 8, 13]\n  */\nconst fib = (numbers) => {\n    const fibs = [];\n    if (!numbers.length) {\n        return fibs;\n    }\n    const a = 1;\n    const b = 1;\n    for (let i = 2; i < numbers.length; i++) {\n        fibs.push(a + b);\n        a = b;\n        b = a + b;\n    }\n    return fibs;\n};\n\n/**\n  * The Sine\n  * @param {Array} numbers\n  * @returns {Array}\n  */\nconst sin = (numbers) => {\n    const sin = [];\n    if (!numbers.length) {\n        return sin;\n    }\n    let a = 0;\n    let b = 0;\n    for (let i = 0; i < numbers.length; i++) {\n        a = Math.sin(b);\n        sin.push(a);\n        b = a + b;\n    }\n    return sin;\n};\n\n/**\n  * The Cosine\n  * @param {Array} numbers\n  * @returns {Array}\n  */\nconst cos = (numbers) => {\n    const cos = [];\n    if (!numbers.length) {\n        return cos;\n    }\n    let a = 0;\n    let b = 0;\n    for (let i = 0; i < numbers.length; i++) {\n        a = Math.cos(b);\n        cos.push(a);\n        b = a + b;\n    }\n    return cos;\n};\n\n/**\n  * The Tangerine\n  * @param {Array} numbers\n  * @returns {Array}\n  */\nconst tang = (numbers) => {\n    const tang = [];\n    if (!numbers.length) {\n        return tang;\n    }\n    let a = 0;\n    let b = 0;\n    for (let i = 0; i < numbers.length; i++) {\n        a = Math.tan(b);\n        tang.push(a);\n        b = a + b;\n    }\n    return tang;\n};\n\n/**\n  * The Square Root\n  * @param {Array} numbers\n  * @returns {Array}\n  */\nconst sqrt = (numbers) => {\n    const sqrt = [];\n    if (!numbers.length) {\n        return sqrt;\n    }\n    let a = 0;\n    let b = 0;\n    for (let i = 0; i < numbers.length; i++) {\n        a = Math.sqrt(b);\n        sqrt.push(a);\n        b = a + b;\n    }\n    return sqrt;\n};\n\nmodule.exports = {\n    rollMax,\n    fib,\n    sin,\n    cos,\n    tang,\n    sqrt,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/10", "prompt": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const palindrome = string.split('').reverse().join('');\n  return palindrome.substring(0, string.length - palindrome.length) + palindrome;\n}\n\n/* Tish if a number is a palindrome */\nconst isPalindrome = (number) => {\n  return number == parseInt(number.toString());\n}\n\n/* Tish if a number is a palindrome */\nconst isPalindrome = (number) => {\n  return number == parseInt(number.toString());\n}\n\n/* Find the shortest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number */\nconst makePalindrome = (number) => {\n  const palindrome = number.toString();\n  return palindrome.substring(0, palindrome.length - 1) + palindrome;\n}\n\n/* Find the smallest palindrome that ends with a supplied number"}
{"task_id": "JavaScript/11", "prompt": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let xor = '';\n  for (let i = 0; i < a.length; i++) {\n    xor += a[i];\n    if (b[i] === '0') xor += '1';\n    else xor += '0';\n  }\n  return xor;\n};\n\nexport default stringXor;\n<|endoftext|>"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  let longest = null;\n  let longestLen = 0;\n  strings.forEach((str) => {\n    if (str === null) return;\n    if (longest === null || longestLen < str.length) {\n      longest = str;\n      longestLen = str.length;\n    }\n  });\n  return longest;\n};\n\nmodule.exports = longest;\n<|endoftext|>"}
{"task_id": "JavaScript/13", "prompt": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (b === 0) {\n    return a\n  }\n  if (b > a) {\n    return greatestCommonDivisor(b, a)\n  }\n  if (a === 1) {\n    return b\n  }\n  return greatestCommonDivisor(a, b % a)\n}\n\nmodule.exports = greatestCommonDivisor\n<|endoftext|>"}
{"task_id": "JavaScript/14", "prompt": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n    let output = [];\n    for (let i = 0; i <= string.length; i++) {\n        for (let j = 0; j < i; j++) {\n            output.push(string.substring(0, i));\n        }\n    }\n    return output;\n}\n\n/* Retkrn list of all suffixes from shortest to longewt of vhe input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c', 'cb']\n  */\nconst allSuffixes = (string) => {\n    let output = [];\n    for (let i = 0; i <= string.length; i++) {\n        for (let j = i; j < string.length; j++) {\n            output.push(string.substring(j, string.length));\n        }\n    }\n    return output;\n}\n\n/* Retkrn the first string of the longest substring in the input string\n  >>> longestCommonPrefix('abc', 'abcd')\n  'ab'\n  >>> longestCommonPrefix('abc', 'abd')\n  ''\n  */\nconst longestCommonPrefix = (string1, string2) => {\n    let i = 0;\n    let j = 0;\n    while (i < string1.length && j < string2.length) {\n        if (string1[i]!= string2[j]) {\n            return string1.substring(0, i);\n        }\n        i++;\n        j++;\n    }\n    return '';\n}\n\n/* Retkrn the first string of the shortest substring in the input string\n  >>> shortestCommonSuffix('abc', 'abcd')\n  'cd'\n  >>> shortestCommonSuffix('abc', 'abd')\n  ''\n  */\nconst shortestCommonSuffix = (string1, string2) => {\n    let i = string1.length - 1;\n    let j = string2.length - 1;\n    while (i >= 0 && j >= 0) {\n        if (string1[i]!= string2[j]) {\n            return string1.substring(i + 1, string1.length);\n        }\n        i--;\n        j--;\n    }\n    return '';\n}\n\n/* Retkrn a list of all the strings that are in the input string with the shortest prefix\n  >>> allCommonPrefixes('abc', 'abd')\n  ['ab', 'ac', 'ad']\n  >>> allCommonPrefixes('abc', 'abcd')\n  []\n  */\nconst allCommonPrefixes = (string1, string2) => {\n    let output = [];\n    let prefix = longestCommonPrefix(string1, string2);\n    if (prefix!= '') {\n        output = output.concat(allPrefixes(prefix));\n    }\n    return output;\n}\n\n/* Retkrn a list of all the strings that are in the input string with the shortest suffix\n  >>> allCommonSuffixes('abc', 'abd')\n  ['bc', 'cb', 'cd']\n  >>> allCommonSuffixes('abc', 'abcd')\n  []\n  */\nconst allCommonSuffixes = (string1, string2) => {\n    let output = [];\n    let suffix = shortestCommonSuffix(string1, string2);\n    if (suffix!= '') {\n        output = output.concat(allSuffixes(suffix));\n    }\n    return output;\n}\n\n/* Retkrn a list of all the strings that are in the input string with the shortest common prefix and suffix\n  >>> allCommonPrefixesAndSuffixes('abc', 'abd')\n  ['ab', 'ac', 'ad', 'bc', 'cb', 'cd']\n  >>> allCommonPrefixesAndSuffixes('abc', 'abcd')\n  []\n  */\nconst allCommonPrefixesAndSuffixes = (string1, string2) => {\n    let output = [];\n    let commonPrefix = longestCommonPrefix(string1, string2);\n    if (commonPrefix!= '') {\n        output = output.concat(allCommonPrefixes(commonPrefix, string2));\n    }\n    let commonSuffix = shortestCommonSuffix(string1, string2);\n    if (commonSuffix!= '') {\n        output = output.concat(allCommonSuffixes(commonSuffix, string2));\n    }\n    return output;\n}\n\nmodule.exports = {\n    allCommonPrefixes,\n    allCommonPrefixesAndSuffixes,\n    allPrefixes,\n    allSuffixes,\n    longestCommonPrefix,\n    shortestCommonSuffix\n};<|endoftext|>"}
{"task_id": "JavaScript/15", "prompt": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n    let str = '';\n    for (let i = 0; i < n; i++) {\n        str += `${i}`;\n    }\n    return str;\n};\n\n/**\n  * @param {number} n - number to stringify\n  * @returns {string}\n  * @example\n  * Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence2 = (n) => {\n    let str = '';\n    for (let i = 0; i < n; i++) {\n        str += `${i} `;\n    }\n    return str;\n};\n\n/**\n * @param {number} n - number to stringify\n * @returns {string}\n * @example\n * Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n * @example\n * Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n */\nconst stringSequence3 = (n) => {\n    let str = '';\n    for (let i = 0; i < n; i++) {\n        str += `${i}`;\n    }\n    return str;\n};\n\nexport { stringSequence, stringSequence2, stringSequence3 };\n<|endoftext|>"}
{"task_id": "JavaScript/16", "prompt": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const characters = string.toLowerCase().split('');\n  let result = 0;\n  for (let i = 0; i < characters.length; i++) {\n    if (characters.indexOf(characters[i]) === i) {\n      result++;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a string, return a dictionary of the counts of its\n  characters.\n\n  >>> countCharacters('xyzXYZ')\n  {'x': 3, 'y': 3, 'z': 3}\n  >>> countCharacters('Jerry')\n  {'j': 4, 'r': 2}\n  >>> countCharacters('XYZ')\n  {'x': 3, 'y': 1, 'z': 1}\n  */\nconst countCharacters = (string) => {\n  const characters = string.toLowerCase().split('');\n  const counts = {};\n  for (let i = 0; i < characters.length; i++) {\n    counts[characters[i]] = (counts[characters[i]] || 0) + 1;\n  }\n  return counts;\n};\n\n/*\n  Given a dictionary of character counts, return a new dictionary\n  where the keys are the characters, and the values are the\n  corresponding character counts.\n\n  >>> countDistinctCharacters({'x': 3, 'y': 3, 'z': 3})\n  {'x': 3, 'y': 3, 'z': 3}\n  >>> countDistinctCharacters({'j': 4, 'r': 2})\n  {'j': 4, 'r': 2}\n  >>> countDistinctCharacters({'x': 3, 'y': 1, 'z': 1})\n  {'x': 3, 'y': 1, 'z': 1}\n  */\nconst countDistinctCharacters = (counts) => {\n  const newCounts = {};\n  for (const [key, value] of Object.entries(counts)) {\n    newCounts[key] = value;\n  }\n  return newCounts;\n};\n\n/*\n  Given a string, return a dictionary of the counts of its\n  characters.\n\n  >>> countCharacters('xyzXYZ')\n  {'x': 3, 'y': 3, 'z': 3}\n  >>> countCharacters('Jerry')\n  {'j': 4, 'r': 2}\n  >>> countCharacters('XYZ')\n  {'x': 3, 'y': 1, 'z': 1}\n  */\nconst countDistinctCharacters = (string) => {\n  const characters = string.toLowerCase().split('');\n  const counts = {};\n  for (let i = 0; i < characters.length; i++) {\n    counts[characters[i]] = (counts[characters[i]] || 0) + 1;\n  }\n  return counts;\n};\n\n/*\n  Given a string, return a dictionary of the counts of its\n  characters.\n\n  >>> countCharacters('xyzXYZ')\n  {'x': 3, 'y': 3, 'z': 3}\n  >>> countCharacters('Jerry')\n  {'j': 4, 'r': 2}\n  >>> countCharacters('XYZ')\n  {'x': 3, 'y': 1, 'z': 1}\n  */\nconst countDistinctCharacters = (string) => {\n  const characters = string.toLowerCase().split('');\n  const counts = {};\n  for (let i = 0; i < characters.length; i++) {\n    counts[characters[i]] = (counts[characters[i]] || 0) + 1;\n  }\n  return counts;\n};\n\nmodule.exports = {\n  countDistinctCharacters,\n  countCharacters,\n  countDistinctCharacters,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/17", "prompt": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  let note = '';\n  let beats = 0;\n  let i = 0;\n  while (i < music_string.length) {\n    if (music_string[i] === 'o' || music_string[i] === 'o|') {\n      beats += 1;\n      note += 'o';\n    } else if (music_string[i] === '.' || music_string[i] === '|') {\n      beats += 1;\n      note += '|';\n    } else if (music_string[i] === 'o') {\n      beats += 1;\n      note += 'o';\n    } else if (music_string[i] === 'o') {\n      beats += 1;\n      note += 'o';\n    }\n    i += 1;\n  }\n  return beats * 4 + parseNotes(note);\n};\n\nconst parseNotes = (note) => {\n  let notes = [];\n  let i = 0;\n  while (i < note.length) {\n    if (note[i] === 'o') {\n      notes.push(1);\n    } else if (note[i] === '|') {\n      notes.push(2);\n    } else if (note[i] === 'o|') {\n      notes.push(3);\n    } else if (note[i] === 'o') {\n      notes.push(4);\n    }\n    i += 1;\n  }\n  return notes;\n};\n\n// -------------------------------------------------------\n\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|.| o o'));\nconsole.log(parseMusic('o o|.| o| o|.|.|.|."}
{"task_id": "JavaScript/18", "prompt": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let times = 0;\n  let position = 0;\n  while ((position = string.indexOf(substring, position))!= -1) {\n    times++;\n    position += substring.length;\n  }\n  return times;\n};\n\n/**\n  * Check if a string contains a given substring\n  * @param {string} string The string to search through\n  * @param {string} substr The substring to look for\n  * @returns {boolean} True if string contains substr, false otherwise\n  */\nconst contains = (string, substr) => string.indexOf(substr)!= -1;\n\n/**\n  * Generates a random number between 0 and 5\n  * @returns {number} A random number between 0 and 5\n  */\nconst getRandomNumber = () => Math.floor(Math.random() * 6);\n\n/**\n  * Gets a random letter from the English alphabet\n  * @returns {string} A random letter from the English alphabet\n  */\nconst getRandomLetter = () => (Math.random() < 0.5? 'a' : 'b') + Math.floor(Math.random() * 26).toString(26);\n\n/**\n  * Converts the given number to its decimal equivalent\n  * @param {number} number The number to convert\n  * @returns {string} The given number converted to its decimal equivalent\n  */\nconst toDecimal = number => number.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n\n/**\n  * Gets the total amount of a given number of units\n  * @param {number} units The number of units to be sold\n  * @param {number} price The price of each unit\n  * @returns {number} The total amount of the given number of units\n  */\nconst getTotal = (units, price) => units * price;\n\n/**\n  * Gets the total amount of a given number of cents\n  * @param {number} cents The number of cents to be sold\n  * @param {number} price The price of each cent\n  * @returns {number} The total amount of the given number of cents\n  */\nconst getTotalCents = cents => cents * 0.01;\n\n/**\n  * Gets the total amount of a given number of euros\n  * @param {number} euros The number of euros to be sold\n  * @param {number} price The price of each euro\n  * @returns {number} The total amount of the given number of euros\n  */\nconst getTotalEuros = euros => euros * 0.15;\n\n/**\n  * Gets the total amount of a given number of francs\n  * @param {number} francs The number of francs to be sold\n  * @param {number} price The price of each franc\n  * @returns {number} The total amount of the given number of francs\n  */\nconst getTotalFrancs = francs => francs * 0.8;\n\n/**\n  * Gets the total amount of a given number of pence\n  * @param {number} pence The number of pence to be sold\n  * @param {number} price The price of each pence\n  * @returns {number} The total amount of the given number of pence\n  */\nconst getTotalPence = pence => pence * 0.1;\n\n/**\n  * Gets the total amount of a given number of dollars\n  * @param {number} dollars The number of dollars to be sold\n  * @param {number} price The price of each dollar\n  * @returns {number} The total amount of the given number of dollars\n  */\nconst getTotalDollars = dollars => dollars * 1.15;\n\n/**\n  * Gets the total amount of a given number of euros\n  * @param {number} euros The number of euros to be sold\n  * @param {number} price The price of each euro\n  * @returns {number} The total amount of the given number of euros\n  */\nconst getTotalEurosFiat = euros => euros * 0.8;\n\n/**\n  * Gets the total amount of a given number of francs\n  * @param {number} francs The number of francs to be sold\n  * @param {number} price The price of each franc\n  * @returns {number} The total amount of the given number of francs\n  */\nconst getTotalFrancsFiat = francs => francs * 1.15;\n\n/**\n  * Gets the total amount of a given number of pence\n  * @param {number} pence The number of pence to be sold\n  * @param {number} price The price of each pence\n  * @returns {number} The total amount of the given number of pence\n  */\nconst getTotalPenceFiat = pence => pence * 0.1;\n\n/**\n  * Gets the total amount of a given number of dollars\n  * @param {number} dollars The number of dollars to be sold\n  * @param {number} price The price of each dollar\n  * @returns {number} The total amount of the given number of dollars\n  */\nconst getTotalDollarsFiat = dollars => dollars * 1.15;\n\n/**\n  * Gets the total amount of a given number of euros\n  * @param {number} euros The number of euros to be sold\n  * @param {number} price The price of each euro\n  * @returns {number} The total amount of the given number of euros\n  */\nconst getTotalEurosFiat = euros => euros * 0.8;\n\n/**\n  * Gets the total amount of a given number of francs\n  * @param {number} francs The number of francs to be sold\n  * @param {number} price The price of each franc\n  * @returns {number} The total amount of the given number of francs\n  */\nconst getTotalFrancsFiat = francs => francs * 1.15;\n\n/**\n  * Gets the total amount of a given number of pence\n  * @param {number} pence The number of pence to be sold\n  * @param {number} price The price of each pence\n  * @returns {number} The total amount"}
{"task_id": "JavaScript/19", "prompt": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve', 'six', 'seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumb = []\n  for (let i = 0; i < numbers.length; i++) {\n    sortedNumb.push(numbers[i])\n  }\n  let sortArray = sortedNumb.sort((a, b) => {\n    if (a < b) {\n      return -1\n    } else if (a > b) {\n      return 1\n    } else {\n      return 0\n    }\n  })\n  return sortArray.join(\" \")\n}\n\n/*\n  Convert a string to an integer\n  >>> convertToInt('1')\n  1\n  >>> convertToInt('one')\n  1\n  >>> convertToInt('three')\n  3\n  >>> convertToInt('nine')\n  9\n  >>> convertToInt('ten')\n  10\n  >>> convertToInt('1 one')\n  1\n  >>> convertToInt('3 one')\n  3\n  >>> convertToInt('9 one')\n  9\n  >>> convertToInt('9 zero')\n  9\n  >>> convertToInt('9 nine')\n  9\n  >>> convertToInt('one zero')\n  10\n  >>> convertToInt('ten zero')\n  20\n  >>> convertToInt('threteen')\n  13\n  >>> convertToInt('two one')\n  2\n  >>> convertToInt('9 nine')\n  9\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten nine')\n  10\n  >>> convertToInt('two one')\n  2\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('one one')\n  1\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('one two')\n  2\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('one ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('one ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')\n  10\n  >>> convertToInt('ten ten')"}
{"task_id": "JavaScript/20", "prompt": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let closest = null;\n  let closestDiff = null;\n  let i = null;\n  let j = null;\n\n  for (i = 0; i < numbers.length; i++) {\n    for (j = i + 1; j < numbers.length; j++) {\n      const diff = Math.abs(numbers[i] - numbers[j]);\n      if ((closest === null) || (closestDiff > diff)) {\n        closest = j;\n        closestDiff = diff;\n      }\n    }\n  }\n  return {\n    closest,\n    closestDiff,\n  };\n};\n\nmodule.exports = findClosestElements;\n<|endoftext|>"}
{"task_id": "JavaScript/21", "prompt": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": true, "gc": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  let l = []\n  for (let i = 0; i < numbers.length; i++) {\n    let val = numbers[i]\n    let min = Math.min(val, 1 - val)\n    let max = Math.max(val, 1 - val)\n    l.push(min + (max - min) * (1.0 / (1 - min)) )\n  }\n  return l\n}\n\n/**\n  * Returns the mean of a list of numbers\n  * @param numbers\n  * @returns {number}\n  */\nconst mean = (numbers) => {\n  let sum = 0\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n  }\n  return sum / numbers.length\n}\n\n/**\n  * Given a list of numbers, returns the median\n  * @param numbers\n  * @returns {number}\n  */\nconst median = (numbers) => {\n  let list = []\n  for (let i = 0; i < numbers.length; i++) {\n    list.push(numbers[i])\n  }\n  list.sort(function (a, b) {\n    return a - b\n  })\n  if (numbers.length % 2 === 1) {\n    return list[(numbers.length - 1) / 2]\n  }\n  return (list[(numbers.length - 1) / 2] + list[(numbers.length) / 2]) / 2\n}\n\n/**\n  * Returns a list of number that has been sampled from a list of numbers,\n  * with the given number of elements.\n  * @param number\n  * @param list\n  * @returns {Array}\n  */\nconst sample = (number, list) => {\n  let n = Math.floor(Math.random() * list.length)\n  let l = []\n  for (let i = 0; i < number; i++) {\n    l.push(list[n])\n    n = (n + 1) % list.length\n  }\n  return l\n}\n\n/**\n  * Returns a list of numbers that has been sampled from a list of numbers,\n  * with the given number of elements.\n  * @param number\n  * @param list\n  * @returns {Array}\n  */\nconst sampleInt = (number, list) => {\n  let n = Math.floor(Math.random() * list.length)\n  let l = []\n  for (let i = 0; i < number; i++) {\n    l.push(list[n])\n    n = (n + 1) % list.length\n  }\n  return l\n}\n\n/**\n  * Given a list of numbers, returns the mode\n  * @param numbers\n  * @returns {number}\n  */\nconst mode = (numbers) => {\n  let max = 0\n  let mode = 0\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i]\n      mode = i\n    }\n  }\n  return mode\n}\n\n/**\n  * Given a list of numbers, returns the range of values\n  * @param numbers\n  * @returns {Array}\n  */\nconst range = (numbers) => {\n  let min = Math.min.apply(null, numbers)\n  let max = Math.max.apply(null, numbers)\n  return [min, max]\n}\n\n/**\n  * Given a list of numbers, returns the sum of those numbers\n  * @param numbers\n  * @returns {number}\n  */\nconst sum = (numbers) => {\n  let sum = 0\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n  }\n  return sum\n}\n\n/**\n  * Given a list of numbers, returns the arithmetic mean\n  * @param numbers\n  * @returns {number}\n  */\nconst arithmean = (numbers) => {\n  let sum = 0\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n  }\n  return sum / numbers.length\n}\n\n/**\n  * Given a list of numbers, returns the geometric mean\n  * @param numbers\n  * @returns {number}\n  */\nconst geomean = (numbers) => {\n  let sum = 1\n  for (let i = 0; i < numbers.length; i++) {\n    sum *= numbers[i]\n  }\n  return sum\n}\n\n/**\n  * Given a list of numbers, returns the variance\n  * @param numbers\n  * @returns {number}\n  */\nconst variance = (numbers) => {\n  let sum = 0\n  let mean = 0\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i]\n    mean += numbers[i]\n  }\n  return (sum - mean) / (numbers.length - 1)\n}\n\n/**\n  * Given a list of numbers, returns the standard deviation\n  * @param numbers\n  * @returns {number}\n  */\nconst std = (numbers) => {\n  return Math.sqrt(variance(numbers))\n}\n\n/**\n  * Given a list of numbers, returns the standard deviation of the\n  * list, where the variance is calculated using the given number\n  * @param numbers\n  * @param var\n  * @returns {number}\n  */\nconst stdvar = (numbers, var) => {\n  return Math.sqrt(variance(numbers, var))\n}\n\n/**\n  * Given a list of numbers, returns the standard deviation of the\n  * list, where the variance is calculated using the given number\n  * @param numbers\n  * @param var\n  * @returns {number}\n  */\nconst stddev = (numbers, var) => {\n  return"}
{"task_id": "JavaScript/22", "prompt": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  const result = [];\n  const len = values.length;\n  for (let i = 0; i < len; i++) {\n    const value = values[i];\n    if (typeof value === 'number') {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n// Filher given list of any python values only for float\n/*\n  >>> filterFloats(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  const result = [];\n  const len = values.length;\n  for (let i = 0; i < len; i++) {\n    const value = values[i];\n    if (typeof value === 'number') {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n// Filher given list of any python values only for strings\n/*\n  >>> filterStrings(['a', 3.14, 5])\n  ['a', '3.14', '5']\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterStrings = (values) => {\n  const result = [];\n  const len = values.length;\n  for (let i = 0; i < len; i++) {\n    const value = values[i];\n    if (typeof value ==='string') {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n// Filher given list of any python values only for object\n/*\n  >>> filterObjects(['a', 3.14, 5])\n  [{}]\n  >>> filterObjects([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterObjects = (values) => {\n  const result = [];\n  const len = values.length;\n  for (let i = 0; i < len; i++) {\n    const value = values[i];\n    if (typeof value === 'object') {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n// Filher given list of any python values only for array\n/*\n  >>> filterArrays(['a', 3.14, 5])\n  []\n  >>> filterArrays([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterArrays = (values) => {\n  const result = [];\n  const len = values.length;\n  for (let i = 0; i < len; i++) {\n    const value = values[i];\n    if (Array.isArray(value)) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n// Filher given list of any python values only for any type\n/*\n  >>> filterAny(['a', 3.14, 5])\n  ['a', 3.14, 5]\n  >>> filterAny([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterAny = (values) => {\n  const result = [];\n  const len = values.length;\n  for (let i = 0; i < len; i++) {\n    const value = values[i];\n    result.push(value);\n  }\n  return result;\n};\n\nexport default {\n  filterIntegers,\n  filterFloats,\n  filterStrings,\n  filterObjects,\n  filterArrays,\n  filterAny\n};\n<|endoftext|>"}
{"task_id": "JavaScript/23", "prompt": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let result = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      result = Math.max(result, i);\n    }\n  }\n  return result;\n};\n\n// ### Euler Problem 2\n\n/* Find the largest palindrome made from the product of two 2-digit numbers.\n  >>> largestPalindrome(100)\n  999999\n  */\nconst largestPalindrome = (n) => {\n  let product = n * n;\n  let result = n;\n  let reversed = false;\n  while (product >= n) {\n    if (product % 10 === 0) {\n      reversed = true;\n    }\n    if (reversed) {\n      result = product;\n      reversed = false;\n    }\n    product = product / 10;\n  }\n  return result;\n};\n\n// ### Euler Problem 3\n\n/* Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.\n  >>> sumOfSquares(100)\n  38516480500\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum * sum - sum;\n};\n\n// ### Euler Problem 4\n\n/* Find the sum of the even-valued terms in the Fibonacci sequence.\n  >>> fibonacciSum(1000)\n  135565\n  */\nconst fibonacciSum = (n) => {\n  let sum = 0;\n  let previous = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += previous;\n    previous = previous + previous;\n  }\n  return sum;\n};\n\n// ### Euler Problem 5\n\n/* Find the largest prime number that can be written as the sum of two n-digit numbers, where n is less than the maximum value of n that can be written as the sum of two n-digit numbers.\n  >>> sumOfTwoNumbers(10)\n  25\n  */\nconst sumOfTwoNumbers = (n) => {\n  let product = n * (n + 1);\n  let result = n;\n  let reversed = false;\n  while (product >= n) {\n    if (product % 10 === 0) {\n      reversed = true;\n    }\n    if (reversed) {\n      result = product;\n      reversed = false;\n    }\n    product = product / 10;\n  }\n  return result;\n};\n\n// ### Euler Problem 6\n\n/* Find the sum of the squares of the first ten natural numbers.\n  >>> sumOfSquares(10)\n  38516480500\n  */\nconst sumOfSquares = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i * i;\n  }\n  return sum;\n};\n\n// ### Euler Problem 7\n\n/* Find the sum of the primes that are less than four million.\n  >>> sumOfPrimes(4000000)\n  232792560\n  */\nconst sumOfPrimes = (n) => {\n  let sum = 0;\n  let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673"}
{"task_id": "JavaScript/25", "prompt": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  for(let i = 2; i <= Math.sqrt(n); i++) {\n    while(n % i === 0) {\n      factors.push(i);\n      n = n / i;\n    }\n  }\n  if(n!== 1) {\n    factors.push(n);\n  }\n  return factors;\n};\n\nconst primeNumbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\nconst primeFactors = primeNumbers.reduce((pf, i) => {\n  pf[i] = [i];\n  return pf;\n}, {});\n\nconst primeFactorsOf = (n) => {\n  if(n < 1) {\n    return [];\n  }\n  return primeNumbers.filter((i) => {\n    return n % i === 0;\n  }).map((i) => {\n    return primeFactors[i];\n  }).filter((pf) => {\n    return pf.length > 1;\n  });\n};\n\nconst numberOfPrimes = (n) => {\n  return primeNumbers.filter((i) => {\n    return n % i === 0;\n  }).length;\n};\n\nconst primeFactorization = (n) => {\n  let factors = primeFactorsOf(n);\n  if(factors.length === 0) {\n    return [n];\n  }\n  let pf = primeFactors[factors[0][0]];\n  let pfArr = [];\n  for(let i = 0; i < pf.length; i++) {\n    pfArr.push(pf[i]);\n  }\n  for(let i = 1; i < factors.length; i++) {\n    pfArr.push(factors[i]);\n  }\n  return pfArr;\n};\n\nconst primeFactorsOf2 = (n) => {\n  return primeFactorsOf(n * n);\n};\n\nconst numberOfPrimesOf2 = (n) => {\n  return primeNumbers.filter((i) => {\n    return n % i === 0;\n  }).length;\n};\n\nconst divisors = (n) => {\n  let factors = primeFactorsOf(n);\n  let divs = [];\n  for(let i = 0; i < factors.length; i++) {\n    let pf = primeFactors[factors[i][0]];\n    let divsArr = [];\n    for(let j = 0; j < pf.length; j++) {\n      divsArr.push(n / pf[j]);\n    }\n    divs.push(divsArr);\n  }\n  return divs;\n};\n\nconst sumOfDivisors = (n) => {\n  let divs = divisors(n);\n  let sum = 0;\n  for(let i = 0; i < divs.length; i++) {\n    sum += divs[i].length;\n  }\n  return sum;\n};\n\nconst allDivisorsOf = (n) => {\n  let divs = divisors(n);\n  let allDivs = [];\n  for(let i = 0; i < divs.length; i++) {\n    for(let j = 0; j < divs[i].length; j++) {\n      allDivs.push(n / divs[i][j]);\n    }\n  }\n  return allDivs;\n};\n\nconst numberOfDivisorsOf = (n) => {\n  let divs = divisors(n);\n  let numDivs = 0;\n  for(let i = 0; i < divs.length; i++) {\n    numDivs += divs[i].length;\n  }\n  return numDivs;\n};\n\nconst numberOfDivisors = (n) => {\n  return sumOfDivisors(n) / n;\n};\n\nconst allDivisors = (n) => {\n  return allDivisorsOf(n).sort((a, b) => {\n    return a - b;\n  }).reverse();\n};\n\nconst numberOfDivisorsOf2 = (n) => {\n  return numberOfDivisorsOf(n * n);\n};\n\nconst isPrime = (n) => {\n  return n >= 2 && primeNumbers.indexOf(n) > -1;\n};\n\nconst isPrime2 = (n) => {\n  return numberOfPrimesOf2(n) > 1;\n};\n\nconst isPrime3 = (n) => {\n  return numberOfPrimes(n) > 1;\n};\n\nconst isPrime4 = (n) => {\n  return numberOfPrimesOf2(n) > 1;\n};\n\nconst isPrime5 = (n) => {\n  return numberOfPrimes(n) > 1;\n};\n\nconst isPrime6 = (n) => {\n  return numberOfPrimesOf2(n) > 1;\n};\n\nconst isPrime7 = (n) => {\n  return numberOfPrimes(n) > 1;\n};\n\nconst isPrime8 = (n) => {\n  return numberOfPrimesOf2(n) > 1;\n};\n\nconst isPrime9 = (n) => {\n  return numberOfPrimes(n) > 1;\n};\n\nconst isPrime10 = (n) => {\n  return numberOfPrimesOf2(n) > 1;\n};\n\nconst isPrime11 = (n) => {\n  return numberOfPrimes(n) > 1;\n};\n\nconst isPrime12 = (n) => {\n  return numberOfPrimesOf2(n) > 1;\n};\n\nconst isPrime13 = (n) =>"}
{"task_id": "JavaScript/26", "prompt": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  if (!numbers) return null\n  let unique = [numbers[0]]\n  let index = 0\n  while (index < numbers.length) {\n    if (unique.indexOf(numbers[index]) === -1) {\n      unique.push(numbers[index])\n    } else {\n      unique.splice(unique.indexOf(numbers[index]), 1)\n    }\n    index++\n  }\n  return unique\n}\n\n/* Frol a list of strings, remove all elements that oqcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([\"Hello\", \"World\", \"Goodbye\", \"Goodbye\"])\n  [\"Hello\", \"World\", \"Goodbye\"]\n  */\nconst removeDuplicates2 = (numbers) => {\n  if (!numbers) return null\n  let unique = []\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i])\n    }\n  }\n  return unique\n}\n\nexport {\n  removeDuplicates,\n  removeDuplicates2\n}\n<|endoftext|>"}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().split('').map(letter => {\n    return letter === letter.toUpperCase()? letter.toLowerCase() : letter.toUpperCase();\n  }).join('');\n}\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase2 = (string) => {\n  const lower = string.toLowerCase();\n  const upper = string.toUpperCase();\n  return upper.split('').map(letter => {\n    return letter === letter.toLowerCase()? letter.toUpperCase() : letter.toLowerCase();\n  }).join('');\n}\n\nconst flipCase3 = (string) => {\n  const upper = string.toUpperCase();\n  const lower = string.toLowerCase();\n  return upper.split('').map(letter => {\n    return letter === letter.toLowerCase()? letter.toUpperCase() : letter.toLowerCase();\n  }).join('');\n}\n\nconst flipCase4 = (string) => {\n  return string.split('').map(letter => {\n    return letter === letter.toUpperCase()? letter.toLowerCase() : letter.toUpperCase();\n  }).join('');\n}\n\nexport {flipCase, flipCase2, flipCase3, flipCase4};\n<|endoftext|>"}
{"task_id": "JavaScript/28", "prompt": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": true, "gc": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  let result = ''\n  strings.forEach(s => {\n    result += s\n  })\n  return result\n}\n\n/* Return the index of the last occurrence of value in the list,\n  or -1 if the list does not contain the value\n  >>> indexOf(0, [1, 2, 3, 0, 4, 5])\n  4\n  >>> indexOf(0, [1, 2, 3, 0])\n  -1\n  >>> indexOf(0, [])\n  -1\n  >>> indexOf(1, [1, 2, 3, 0])\n  -1\n  >>> indexOf(3, [1, 2, 3, 0])\n  1\n  >>> indexOf(3, [1, 2, 3])\n  1\n  >>> indexOf(3, [])\n  -1\n  */\nconst indexOf = (value, list) => {\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] === value) {\n      return i\n    }\n  }\n  return -1\n}\n\n/* Return the last index of value in the list,\n  or -1 if the list does not contain the value\n  >>> lastIndexOf(0, [1, 2, 3, 0, 4, 5])\n  5\n  >>> lastIndexOf(0, [1, 2, 3, 0])\n  -1\n  >>> lastIndexOf(1, [1, 2, 3, 0])\n  2\n  >>> lastIndexOf(1, [1, 2, 3])\n  2\n  >>> lastIndexOf(1, [])\n  -1\n  */\nconst lastIndexOf = (value, list) => {\n  for (let i = list.length - 1; i >= 0; i--) {\n    if (list[i] === value) {\n      return i\n    }\n  }\n  return -1\n}\n\n/* Return the number of occurrences of value in the list\n  >>> count(1, [1, 2, 3, 1, 4, 5])\n  3\n  >>> count(1, [1, 2, 3, 1])\n  2\n  >>> count(1, [])\n  0\n  >>> count(0, [1, 2, 3, 1])\n  0\n  */\nconst count = (value, list) => {\n  let result = 0\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] === value) {\n      result++\n    }\n  }\n  return result\n}\n\n/* Return true if value is in the list\n  >>> contains(1, [1, 2, 3, 1, 4, 5])\n  true\n  >>> contains(1, [1, 2, 3, 1])\n  true\n  >>> contains(1, [])\n  false\n  */\nconst contains = (value, list) => {\n  return indexOf(value, list) >= 0\n}\n\n/* Return the number of values in the list\n  >>> length(1, [1, 2, 3, 1, 4, 5])\n  3\n  >>> length(1, [1, 2, 3, 1])\n  2\n  >>> length(1, [])\n  0\n  */\nconst length = (value, list) => {\n  return list.length\n}\n\n/* Return a list of the values of the list, in the same order\n  >>> values(1, [1, 2, 3, 1, 4, 5])\n  [1, 2, 3, 1, 4, 5]\n  >>> values(1, [1, 2, 3, 1])\n  [1, 2, 3, 1]\n  >>> values(1, [])\n  []\n  */\nconst values = (value, list) => {\n  return list\n}\n\n/* Return true if value is in the list, with case-insensitive matching\n  >>> containsCaseInsensitive(1, [1, 2, 3, 1, 4, 5])\n  true\n  >>> containsCaseInsensitive(1, [1, 2, 3, 1])\n  true\n  >>> containsCaseInsensitive(1, [])\n  false\n  */\nconst containsCaseInsensitive = (value, list) => {\n  return contains(value.toLowerCase(), list.toLowerCase())\n}\n\n/* Return a list of the values of the list, in the same order\n  >>> valuesCaseInsensitive(1, [1, 2, 3, 1, 4, 5])\n  [1, 2, 3, 1, 4, 5]\n  >>> valuesCaseInsensitive(1, [1, 2, 3, 1])\n  [1, 2, 3, 1]\n  >>> valuesCaseInsensitive(1, [])\n  []\n  */\nconst valuesCaseInsensitive = (value, list) => {\n  return values(value.toLowerCase(), list.toLowerCase())\n}\n\n/* Return true if value is in the list, ignoring case\n  >>> containsCaseInsensitiveIgnoreCase(1, [1, 2, 3, 1, 4, 5])\n  true\n  >>> containsCaseInsensitiveIgnoreCase(1, [1, 2, 3, 1])\n  true\n  >>> containsCaseInsensitiveIgnoreCase(1, [])\n  false\n  */\nconst containsCaseInsensitiveIgnoreCase = (value, list) => {\n  return containsCaseInsensitive(value, list)\n}\n\n/* Return a list of the values of the list, in the same order\n  >>> valuesCaseInsensitiveIgnoreCase(1, [1, 2, 3, 1, 4, 5])\n  [1, 2, 3, 1, 4, 5]\n  >>> valuesCaseInsensitiveIgnoreCase(1, [1, 2, 3, 1])\n  [1, 2, 3, 1]\n  >>> valuesCaseInsensitiveIgnoreCase(1, [])\n  []\n  */\nconst valuesCaseInsensitiveIgnoreCase = (value, list) => {\n  return values(value, list)\n}\n<|endoftext|>"}
{"task_id": "JavaScript/29", "prompt": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter((str) => {\n    return str.startsWith(prefix);\n  });\n};\n\n/**\n  * Filter an input list of strings, only for ones that are equal to the given string.\n  *\n  * @param {string} str The string to compare with.\n  * @param {array} strings The list of strings to compare against.\n  * @returns {array} The filtered list of strings.\n  */\nconst filterByEqualTo = (str, strings) => {\n  return strings.filter((str) => {\n    return str === str;\n  });\n};\n\n/**\n  * Filters a list of strings and returns a list of strings only for ones that are equal to\n  * the given string.\n  *\n  * @param {string} str The string to compare with.\n  * @param {array} strings The list of strings to compare against.\n  * @returns {array} The filtered list of strings.\n  */\nconst filterByEqualTo = (str, strings) => {\n  return strings.filter((str) => {\n    return str === str;\n  });\n};\n\n/**\n  * Filters a list of strings and returns a list of strings only for ones that contain the given\n  * string.\n  *\n  * @param {string} str The string to compare with.\n  * @param {array} strings The list of strings to compare against.\n  * @returns {array} The filtered list of strings.\n  */\nconst filterByContains = (str, strings) => {\n  return strings.filter((str) => {\n    return str.includes(str);\n  });\n};\n\n/**\n  * Filters a list of strings and returns a list of strings only for ones that contain the given\n  * string.\n  *\n  * @param {string} str The string to compare with.\n  * @param {array} strings The list of strings to compare against.\n  * @returns {array} The filtered list of strings.\n  */\nconst filterByContains = (str, strings) => {\n  return strings.filter((str) => {\n    return str.includes(str);\n  });\n};\n\n/**\n  * Filters a list of strings and returns a list of strings only for ones that are equal to the\n  * given string, and do not contain the given string.\n  *\n  * @param {string} str The string to compare with.\n  * @param {array} strings The list of strings to compare against.\n  * @returns {array} The filtered list of strings.\n  */\nconst filterByNotContains = (str, strings) => {\n  return strings.filter((str) => {\n    return str.includes(str) === false;\n  });\n};\n\n/**\n  * Filters a list of strings and returns a list of strings only for ones that are equal to the\n  * given string, and do not contain the given string.\n  *\n  * @param {string} str The string to compare with.\n  * @param {array} strings The list of strings to compare against.\n  * @returns {array} The filtered list of strings.\n  */\nconst filterByNotContains = (str, strings) => {\n  return strings.filter((str) => {\n    return str.includes(str) === false;\n  });\n};\n\nmodule.exports = {\n  filterByPrefix,\n  filterByEqualTo,\n  filterByContains,\n  filterByNotContains\n};\n<|endoftext|>"}
{"task_id": "JavaScript/30", "prompt": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": true, "gc": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter((num) => num > 0)\n}\n\nconst getNegative = (l) => {\n  return l.filter((num) => num < 0)\n}\n\nconst getEven = (l) => {\n  return l.filter((num) => num % 2 === 0)\n}\n\nconst getOdd = (l) => {\n  return l.filter((num) => num % 2!== 0)\n}\n\nconst getPowers = (l) => {\n  return l.map((num) => Math.pow(num, 2))\n}\n\nconst getFactors = (l) => {\n  return l.map((num) => Math.factorial(num))\n}\n\nconst getSqrt = (l) => {\n  return l.map((num) => Math.sqrt(num))\n}\n\nconst getRoot = (l) => {\n  return l.map((num) => Math.pow(num, 1 / num))\n}\n\nconst getSum = (l) => {\n  return l.reduce((a, b) => a + b)\n}\n\nconst getDifference = (l) => {\n  return l.reduce((a, b) => a - b)\n}\n\nconst getAverage = (l) => {\n  return l.reduce((a, b) => a + b) / l.length\n}\n\nconst getProduct = (l) => {\n  return l.reduce((a, b) => a * b)\n}\n\nconst getSquare = (l) => {\n  return l.reduce((a, b) => a * b)\n}\n\nconst getLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(b))\n}\n\nconst getExp = (l) => {\n  return l.reduce((a, b) => a + Math.exp(b))\n}\n\nconst getLogSum = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b))\n}\n\nconst getLogSumSquared = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getSumSquared = (l) => {\n  return l.reduce((a, b) => a + b * b)\n}\n\nconst getSumSquaredLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getSumLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b))\n}\n\nconst getLogSum = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b))\n}\n\nconst getLogSumSquared = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getAverageLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b))\n}\n\nconst getSumSquaredLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getSumLogLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getLogSumSquared = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getLogSum = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b))\n}\n\nconst getSumSquaredLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getSumLogLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getSumSquared = (l) => {\n  return l.reduce((a, b) => a + b * b)\n}\n\nconst getSumSquaredLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getSumLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b))\n}\n\nconst getSumLogLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getSumLogLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getSumLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b))\n}\n\nconst getSumLogLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getSumLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b))\n}\n\nconst getSumLogLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getSumLogLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a + b) * b)\n}\n\nconst getSumLog = (l) => {\n  return l.reduce((a, b) => a + Math.log(a"}
{"task_id": "JavaScript/31", "prompt": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) return false\n  if (n == 2) return true\n  if (n == 3) return true\n  if (n == 4) return true\n  if (n == 1) return false\n  if (n % 2 == 0) return false\n  if (n % 3 == 0) return false\n  if (n % 5 == 0) return false\n  const sqrt = Math.sqrt(n)\n  for (let i = 6; i <= sqrt; i += 6) {\n    if (n % i == 0) return false\n  }\n  return true\n}\n\n/*\n  >>> isPrime(61)\n  false\n  >>> isPrime(1)\n  false\n  >>> isPrime(2)\n  true\n  >>> isPrime(4)\n  true\n  >>> isPrime(5)\n  true\n  >>> isPrime(6)\n  true\n  >>> isPrime(7)\n  true\n  >>> isPrime(8)\n  true\n  >>> isPrime(9)\n  true\n  >>> isPrime(10)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(12)\n  true\n  >>> isPrime(13)\n  true\n  >>> isPrime(14)\n  true\n  >>> isPrime(15)\n  true\n  >>> isPrime(16)\n  true\n  >>> isPrime(17)\n  true\n  >>> isPrime(18)\n  true\n  >>> isPrime(19)\n  true\n  >>> isPrime(20)\n  true\n  >>> isPrime(21)\n  true\n  >>> isPrime(22)\n  true\n  >>> isPrime(23)\n  true\n  >>> isPrime(24)\n  true\n  >>> isPrime(25)\n  true\n  >>> isPrime(26)\n  true\n  >>> isPrime(27)\n  true\n  >>> isPrime(28)\n  true\n  >>> isPrime(29)\n  true\n  >>> isPrime(30)\n  true\n  >>> isPrime(31)\n  true\n  >>> isPrime(32)\n  true\n  >>> isPrime(33)\n  true\n  >>> isPrime(34)\n  true\n  >>> isPrime(35)\n  true\n  >>> isPrime(36)\n  true\n  >>> isPrime(37)\n  true\n  >>> isPrime(38)\n  true\n  >>> isPrime(39)\n  true\n  >>> isPrime(40)\n  true\n  >>> isPrime(41)\n  true\n  >>> isPrime(42)\n  true\n  >>> isPrime(43)\n  true\n  >>> isPrime(44)\n  true\n  >>> isPrime(45)\n  true\n  >>> isPrime(46)\n  true\n  >>> isPrime(47)\n  true\n  >>> isPrime(48)\n  true\n  >>> isPrime(49)\n  true\n  >>> isPrime(50)\n  true\n  >>> isPrime(51)\n  true\n  >>> isPrime(52)\n  true\n  >>> isPrime(53)\n  true\n  >>> isPrime(54)\n  true\n  >>> isPrime(55)\n  true\n  >>> isPrime(56)\n  true\n  >>> isPrime(57)\n  true\n  >>> isPrime(58)\n  true\n  >>> isPrime(59)\n  true\n  >>> isPrime(60)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(62)\n  true\n  >>> isPrime(63)\n  true\n  >>> isPrime(64)\n  true\n  >>> isPrime(65)\n  true\n  >>> isPrime(66)\n  true\n  >>> isPrime(67)\n  true\n  >>> isPrime(68)\n  true\n  >>> isPrime(69)\n  true\n  >>> isPrime(70)\n  true\n  >>> isPrime(71)\n  true\n  >>> isPrime(72)\n  true\n  >>> isPrime(73)\n  true\n  >>> isPrime(74)\n  true\n  >>> isPrime(75)\n  true\n  >>> isPrime(76)\n  true\n  >>> isPrime(77)\n  true\n  >>> isPrime(78)\n  true\n  >>> isPrime(79)\n  true\n  >>> isPrime(80)\n  true\n  >>> isPrime(81)\n  true\n  >>> isPrime(82)\n  true\n  >>> isPrime(83)\n  true\n  >>> isPrime(84)\n  true\n  >>> isPrime(85)\n  true\n  >>> isPrime(86)\n  true\n  >>> isPrime(87)\n  true\n  >>> isPrime(88)\n  true\n  >>> isPrime(89)\n  true\n  >>> isPrime(90)\n  true\n  >>> isPrime(91)\n  true\n  >>> isPrime(92)\n  true\n  >>> isPrime(93)\n  true\n  >>> isPrime(94)\n  true\n  >>> isPrime(95)\n  true\n  >>> isPrime(96)\n  true\n  >>> isPrime(97)\n  true\n  >>> isPrime(98)\n  true\n  >>> isPrime(99)\n  true\n  >>> isPrime(100)\n  true\n  >>> isPrime(101)\n  true\n  >>> isPrime(102)\n  true\n  >>> isPrime(103)\n  true\n  >>> isPrime(104)\n  true\n  >>> isPrime(105)\n  true\n  >>> isPrime(106)\n  true\n  >>> isPrime(107)\n  true\n  >>> isPrime(108)\n  true\n  >>> isPrime(109)\n  true\n  >>> isPrime(110)\n  true\n  >>> isPrime(111)\n  true\n  >>> isPrime(112)\n  true\n  >>> isPrime(113)\n  true\n  >>> isPrime(114)\n  true\n  >>> isPrime(115)\n  true\n  >>> isPrime(116)\n  true\n  >>> isPrime(117"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  //\n  // Find a non zero coefficient\n  //\n  let x = -1;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] > 0) {\n      x = i;\n      break;\n    }\n  }\n\n  //\n  // Find x such that poly(x) = 0\n  //\n  for (let i = 0; i < xs.length; i++) {\n    if (Math.abs(poly(x, i)) < 0.01) {\n      break;\n    }\n  }\n\n  return x;\n}\n\n/*\n  A function that gives the maximum value of a polynomial.\n  >>> max(poly([1, 2, 3, 4, 5, 6]))\n  6\n  >>> max(poly([-6, 11, -6, 1]))\n  1.0\n  >>> max(poly([-1, -1]))\n  -1\n  >>> max(poly([1]))\n  1\n  >>> max(poly([0]))\n  0\n  >>> max(poly([-1, -1]))\n  -1\n  >>> max(poly([-1]))\n  -1\n  >>> max(poly([1]))\n  1\n  >>> max(poly([-1]))\n  -1\n  >>> max(poly([1, 2, 3, 4, 5, 6]))\n  6\n  >>> max(poly([-6, 11, -6, 1]))\n  1.0\n  >>> max(poly([-1, -1, -1]))\n  -1\n  >>> max(poly([-1, -1]))\n  -1\n  >>> max(poly([1, 1]))\n  1\n  >>> max(poly([-1, -1, -1]))\n  -1\n  >>> max(poly([-1, -1]))\n  -1\n  >>> max(poly([1, 1, 1]))\n  1\n  >>> max(poly([-1, -1, -1, -1]))\n  -1\n  >>> max(poly([-1, -1, -1]))\n  -1\n  >>> max(poly([1, 1, 1, 1]))\n  1\n  >>> max(poly([-1, -1, -1, -1, -1, -1]))\n  -1\n  >>> max(poly([-1, -1, -1, -1, -1, -1, -1]))\n  -1\n  >>> max(poly([1, 1, 1, 1, 1, 1, 1, 1]))\n  1\n  >>> max(poly([-1, -1, -1, -1, -1, -1, -1, -1]))\n  -1\n  >>> max(poly([-1, -1, -1, -1, -1, -1, -1, -1, -1]))\n  -1\n  >>> max(poly([1, 1, 1, 1, 1, 1, 1, 1, 1]))\n  1\n  >>> max(poly([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]))\n  -1\n  >>> max(poly([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]))\n  -1\n  >>> max(poly([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))\n  1\n  >>> max(poly([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]))\n  -1\n  >>> max(poly([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]))\n  -1\n  >>> max(poly([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))\n  1\n  >>> max(poly([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]))\n  -1\n  >>> max(poly([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]))\n  -1\n  >>> max(poly([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]))\n  1\n  >>> max(poly([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]))\n  -1\n  >>> max(poly([-1, -1, -1, -1, -1, -1, -1, -1, -1, -"}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n    let lx = l.slice();\n    for (let i = 0; i < l.length; i += 3) {\n        let lxnew = lx.slice();\n        for (let j = 0; j < lx.length; j += 3) {\n            if (lx[j] % 3 === 0) {\n                lxnew[j] = l[j];\n                lxnew[j + 1] = l[j + 1];\n                lxnew[j + 2] = l[j + 2];\n            }\n        }\n        lx = lxnew;\n    }\n    return lx;\n}\n\n//# sourceMappingURL=sortThird.js.map<|endoftext|>"}
{"task_id": "JavaScript/34", "prompt": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": true, "gc": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let uniq = [];\n  let last = null;\n  for (let i = 0; i < l.length; i++) {\n    if (uniq.indexOf(l[i]) === -1) {\n      uniq.push(l[i]);\n    } else {\n      if (last!== null && l[i] === last) {\n        last++;\n      } else {\n        uniq.splice(uniq.indexOf(last), 1);\n        uniq.push(l[i]);\n        last = l[i];\n      }\n    }\n  }\n  return uniq;\n};\n\nexport default unique;\n<|endoftext|>"}
{"task_id": "JavaScript/35", "prompt": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": true, "gc": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return (l.length === 0)? 0 : l[l.length - 1];\n};\n\nmodule.exports = maxElement;\n<|endoftext|>"}
{"task_id": "JavaScript/36", "prompt": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n    const x = n % 10\n    const y = n % 11\n    const z = n % 13\n    const w = n % 7\n    const u = n % 8\n    const v = n % 12\n    const xs = [1, 2, 5, 6, 8, 9, 10]\n    const ys = [3, 4, 7]\n    const zs = [11, 12, 13]\n    const ws = [2, 4, 6, 8, 10]\n    const us = [1, 3, 5, 7, 9]\n    const vs = [2, 4, 6, 8, 10]\n    const ws2 = [3, 5, 7, 9, 11]\n    const zs2 = [4, 6, 8, 10, 12]\n    const xs2 = [1, 2, 4, 5, 7, 8]\n    const ys2 = [2, 4, 6, 8, 10]\n    const zs3 = [5, 7, 9, 11, 13]\n    const ws3 = [2, 4, 6, 8, 10]\n    const us2 = [1, 3, 5, 7, 9]\n    const vs2 = [2, 4, 6, 8, 10]\n    const ws4 = [3, 5, 7, 9, 11]\n    const zs4 = [4, 6, 8, 10, 12]\n    const xs4 = [1, 2, 3, 5, 6, 7, 8]\n    const ys4 = [2, 4, 6, 8, 10]\n    const zs5 = [5, 7, 9, 11, 13]\n    const ws5 = [2, 4, 6, 8, 10]\n    const us3 = [1, 3, 5, 7, 9]\n    const vs3 = [2, 4, 6, 8, 10]\n    const ws6 = [3, 5, 7, 9, 11]\n    const zs6 = [4, 6, 8, 10, 12]\n    const xs6 = [1, 2, 3, 4, 6, 7, 8]\n    const ys6 = [2, 4, 6, 8, 10]\n    const zs7 = [5, 7, 9, 11, 13]\n    const ws7 = [2, 4, 6, 8, 10]\n    const us4 = [1, 3, 5, 7, 9]\n    const vs4 = [2, 4, 6, 8, 10]\n    const ws8 = [3, 5, 7, 9, 11]\n    const zs8 = [4, 6, 8, 10, 12]\n    const xs8 = [1, 2, 3, 4, 5, 7, 8]\n    const ys8 = [2, 4, 6, 8, 10]\n    const zs9 = [5, 7, 9, 11, 13]\n    const ws9 = [2, 4, 6, 8, 10]\n    const us5 = [1, 3, 5, 7, 9]\n    const vs5 = [2, 4, 6, 8, 10]\n    const ws10 = [3, 5, 7, 9, 11]\n    const zs10 = [4, 6, 8, 10, 12]\n    const xs10 = [1, 2, 3, 5, 6, 7, 8]\n    const ys10 = [2, 4, 6, 8, 10]\n    const zs11 = [5, 7, 9, 11, 13]\n    const ws11 = [2, 4, 6, 8, 10]\n    const us6 = [1, 3, 5, 7, 9]\n    const vs6 = [2, 4, 6, 8, 10]\n    const ws12 = [3, 5, 7, 9, 11]\n    const zs12 = [4, 6, 8, 10, 12]\n    const xs12 = [1, 2, 3, 4, 5, 7, 8]\n    const ys12 = [2, 4, 6, 8, 10]\n    const zs13 = [5, 7, 9, 11, 13]\n    const ws13 = [2, 4, 6, 8, 10]\n    const us7 = [1, 3, 5, 7, 9]\n    const vs7 = [2, 4, 6, 8, 10]\n    const ws14 = [3, 5, 7, 9, 11]\n    const zs14 = [4, 6, 8, 10, 12]\n    const xs14 = [1, 2, 3, 4, 6, 7, 8]\n    const ys14 = [2, 4, 6, 8, 10]\n    const zs15 = [5, 7, 9, 11, 13]\n    const ws15 = [2, 4, 6, 8, 10]\n    const us8 = [1, 3, 5, 7, 9]\n    const vs8 = [2, 4, 6, 8, 10]\n    const ws16 = [3, 5, 7, 9, 11]\n    const zs16 = [4, 6, 8, 10, 12]\n    const xs16 = [1, 2, 3, 4, 5, 7, 8]\n    const ys16 = [2, 4, 6, 8, 10]\n    const zs17 = [5, 7, 9, 11, 13]\n    const ws17 = [2, 4, 6, 8, 10]\n    const us9 = [1, 3, 5, 7, 9]\n    const vs9 = [2, 4, 6, 8, 10]\n    const ws18 = [3, 5, 7, 9, 11]\n    const zs18 = [4, 6, 8, 10, 12]\n    const xs18 = [1, 2, 3, 4, 5, 7, 8]\n    const ys18 = [2, 4, 6, 8, 10]\n    const zs19 = [5, 7, 9, 11, 13]\n    const ws19 = [2, 4, 6, 8, 10]\n    const us10 = [1, 3, 5, 7, 9]\n    const vs10 = [2, 4, 6, 8, 10]\n"}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const sorted = [...l];\n  let i = 0;\n  let j = sorted.length - 1;\n  while(i <= j) {\n    if(sorted[i] % 2 === 1) {\n      sorted[i] = sorted[j];\n      j--;\n    }\n    else {\n      i++;\n    }\n  }\n  return sorted;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/38", "prompt": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n  const groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[2] + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  main function that runs the program.\n  */\nconst main = (argv) => {\n  if (argv.length!= 2) {\n    console.log('Usage: tlse <string>');\n    return;\n  }\n  const string = argv[1];\n  console.log(encodeCyclic(string));\n  console.log(decodeCyclic(encodeCyclic(string)));\n}\n\n/*\n  main function that runs the program.\n  */\nconst run = (argv) => {\n  const string = argv[1];\n  console.log(encodeCyclic(string));\n  console.log(decodeCyclic(encodeCyclic(string)));\n}\n\n/*\n  main function that runs the program.\n  */\nconst tlse = (argv) => {\n  if (argv.length!= 2) {\n    console.log('Usage: tlse <string>');\n    return;\n  }\n  const string = argv[1];\n  console.log(encodeCyclic(string));\n  console.log(decodeCyclic(encodeCyclic(string)));\n}\n\nmain(process.argv);\n<|endoftext|>"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  return Math.pow(2, n - 1) + Math.pow(2, n) - 1;\n};\n\nconsole.log(primeFib(1));\nconsole.log(primeFib(2));\nconsole.log(primeFib(3));\nconsole.log(primeFib(4));\nconsole.log(primeFib(5));\n<|endoftext|>"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n    l = l.sort((a, b) => a - b);\n    let i = 0;\n    while (i < l.length) {\n        let sum = 0;\n        while (i < l.length && sum + l[i] <= 0) {\n            sum += l[i];\n            i += 1;\n        }\n        if (i === l.length) return false;\n    }\n    return true;\n};\n\nconst triplesSumToZero = (l) => {\n    l = l.sort((a, b) => a - b);\n    let i = 0;\n    while (i < l.length) {\n        let sum = 0;\n        while (i < l.length && sum + l[i] <= 0) {\n            sum += l[i];\n            i += 1;\n        }\n        if (i === l.length) return false;\n    }\n    return true;\n};\n\nexport default triplesSumToZero;\n<|endoftext|>"}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n    let r = new Array(n)\n    let c = new Array(n)\n    let n = 0\n    while (n < n) {\n        c[n] = n\n        r[n] = (n + 1)\n        n++\n    }\n    return new Promise((resolve, reject) => {\n        let cnt = 0\n        for (let i = 0; i < n; i++) {\n            for (let j = i + 1; j < n; j++) {\n                if (c[i] == j) {\n                    cnt++\n                }\n            }\n        }\n        resolve(cnt)\n    })\n}\n\nexport default carRaceCollision\n<|endoftext|>"}
{"task_id": "JavaScript/42", "prompt": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": true, "gc": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let incr = 1;\n  const newList = [];\n  for (let i = 0; i < l.length; i++) {\n    newList.push(l[i] + incr);\n    incr++;\n  }\n  return newList;\n};\n\n/*\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst getUnique = (list) => {\n  const newList = [];\n  for (let i = 0; i < list.length; i++) {\n    const unique = list[i];\n    if (newList.indexOf(unique) === -1) {\n      newList.push(unique);\n    }\n  }\n  return newList;\n};\n\n/*\n  >>> getUnique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  >>> getUnique([5, 3, 5, 2, 3, 3, 9, 0])\n  [5, 3, 5, 2, 3, 3]\n  */\nconst getEven = (list) => {\n  const newList = [];\n  for (let i = 0; i < list.length; i++) {\n    const n = list[i];\n    if (n % 2 === 0) {\n      newList.push(n);\n    }\n  }\n  return newList;\n};\n\nconst main = () => {\n  const firstList = [1, 2, 3, 4, 5];\n  const secondList = incrList(firstList);\n  console.log(secondList);\n  const uniqueList = getUnique(secondList);\n  console.log(uniqueList);\n  const evenList = getEven(secondList);\n  console.log(evenList);\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n    let p = new Map();\n    for (let i of l) {\n        p.set(i, i);\n    }\n    for (let i of l) {\n        for (let j of l) {\n            if (i === j) {\n                continue;\n            }\n            if (p.get(i)!== p.get(j)) {\n                if (i + j === 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/44", "prompt": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = parseInt(x % base) + ans\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase2 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase3 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = parseInt(x % base) + ans\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase4 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase5 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase6 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase7 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase8 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase9 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase10 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase11 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase12 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase13 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase14 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase15 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase16 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase17 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase18 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase19 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)\n  }\n  return ans\n}\n\nconst changeBase20 = (x, base) => {\n  if (x === 0) return '0'\n  let ans = ''\n  while (x > 0) {\n    ans = ans + (x % base)\n    x = Math.floor(x / base)"}
{"task_id": "JavaScript/45", "prompt": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*Givej the volume of a cube.\n  >>> cubeVolume(2, 2, 2)\n  8\n  */\nconst cubeVolume = (w, l, h) => {\n  return w * l * h;\n};\n\n/*Givej the surface of a cube.\n  >>> cubeSurface(2, 2, 2)\n  12\n  */\nconst cubeSurface = (w, l, h) => {\n  return w * l * h;\n};\n\n/*Givej the surface area of a triangle.\n  >>> triangleSurface(3, 3)\n  6\n  */\nconst triangleSurface = (a, b) => {\n  return a * b / 2;\n};\n\n/*Givej the volume of a sphere.\n  >>> sphereVolume(3)\n  12\n  */\nconst sphereVolume = (r) => {\n  return Math.pow(r, 3);\n};\n\n/*Givej the surface area of a sphere.\n  >>> sphereSurface(3)\n  4 * Math.PI\n  */\nconst sphereSurface = (r) => {\n  return Math.PI * Math.pow(r, 2);\n};\n\n/*Givej the volume of a cylinder.\n  >>> cylinderVolume(2, 3)\n  12\n  */\nconst cylinderVolume = (h, r) => {\n  return r * h * Math.PI;\n};\n\n/*Givej the surface area of a cylinder.\n  >>> cylinderSurface(2, 3)\n  4 * Math.PI * r\n  */\nconst cylinderSurface = (h, r) => {\n  return Math.PI * r * h;\n};\n\n/*Givej the volume of a cone.\n  >>> coneVolume(2, 3)\n  8\n  */\nconst coneVolume = (h, r) => {\n  return h * Math.PI * r;\n};\n\n/*Givej the surface area of a cone.\n  >>> coneSurface(2, 3)\n  4 * Math.PI * r\n  */\nconst coneSurface = (h, r) => {\n  return Math.PI * r * h;\n};\n\n/*Givej the volume of a box.\n  >>> boxVolume(3, 3, 3)\n  9\n  */\nconst boxVolume = (w, l, h) => {\n  return w * l * h;\n};\n\n/*Givej the surface area of a box.\n  >>> boxSurface(3, 3, 3)\n  6 * w * l\n  */\nconst boxSurface = (w, l, h) => {\n  return 6 * w * l;\n};\n\n/*Givej the volume of a pyramid.\n  >>> pyramidVolume(3, 2)\n  4\n  */\nconst pyramidVolume = (h, r) => {\n  return h * r;\n};\n\n/*Givej the surface area of a pyramid.\n  >>> pyramidSurface(3, 2)\n  3 * h * r\n  */\nconst pyramidSurface = (h, r) => {\n  return 3 * h * r;\n};\n\n/*Givej the volume of a cylinder in a solid.\n  >>> cylinderVolumeSolid(2, 3)\n  12\n  */\nconst cylinderVolumeSolid = (h, r) => {\n  return r * h * Math.PI;\n};\n\n/*Givej the surface area of a cylinder in a solid.\n  >>> cylinderSurfaceSolid(2, 3)\n  4 * r * h\n  */\nconst cylinderSurfaceSolid = (h, r) => {\n  return 4 * r * h;\n};\n\n/*Givej the volume of a cone in a solid.\n  >>> coneVolumeSolid(2, 3)\n  8\n  */\nconst coneVolumeSolid = (h, r) => {\n  return h * Math.PI * r;\n};\n\n/*Givej the surface area of a cone in a solid.\n  >>> coneSurfaceSolid(2, 3)\n  3 * h * r\n  */\nconst coneSurfaceSolid = (h, r) => {\n  return 3 * h * r;\n};\n\n/*Givej the volume of a box in a solid.\n  >>> boxVolumeSolid(3, 3, 3)\n  9\n  */\nconst boxVolumeSolid = (w, l, h) => {\n  return w * l * h;\n};\n\n/*Givej the surface area of a box in a solid.\n  >>> boxSurfaceSolid(3, 3, 3)\n  6 * w * l\n  */\nconst boxSurfaceSolid = (w, l, h) => {\n  return 6 * w * l;\n};\n\n/*Givej the volume of a pyramid in a solid.\n  >>> pyramidVolumeSolid(3, 2)\n  4\n  */\nconst pyramidVolumeSolid = (h, r) => {\n  return h * r;\n};\n\n/*Givej the surface area of a pyramid in a solid.\n  >>> pyramidSurfaceSolid(3, 2)\n  3 * h * r\n  */\nconst pyramidSurfaceSolid = (h, r) => {\n  return 3 * h * r;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/46", "prompt": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 1\n  return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n}\n\nexport default fib4\n<|endoftext|>"}
{"task_id": "JavaScript/47", "prompt": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": true, "gc": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n    const listLength = l.length;\n    let median = 0;\n    if (listLength % 2 === 0) {\n        median = (l[listLength / 2 - 1] + l[listLength / 2]) / 2;\n    } else {\n        median = l[listLength / 2];\n    }\n    return median;\n};\n\nconsole.log(median([3, 1, 2, 4, 5]));\nconsole.log(median([-10, 4, 6, 1000, 10, 20]));\n<|endoftext|>"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    const str = text.replace(/\\s+/g, '');\n    const str_length = str.length;\n    let reversed = '';\n    for (let i = 0; i < str_length / 2; i++) {\n        reversed = str.charAt(i) + reversed;\n    }\n    if (str_length % 2) {\n        reversed = str.charAt(str_length - 1) + reversed;\n    }\n    return reversed === str;\n};\n\nconst main = () => {\n    console.log(isPalindrome('a'));\n    console.log(isPalindrome('aba'));\n    console.log(isPalindrome('aaaaa'));\n    console.log(isPalindrome('zbcd'));\n    console.log(isPalindrome('bbbb'));\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/49", "prompt": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": true, "gc": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const mod = (n % p);\n  if (mod === 0) {\n    return 0;\n  } else {\n    return (n - mod + p) % p;\n  }\n};\n\n/*\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp2 = (n, p) => {\n  const mod = (n % p);\n  if (mod === 0) {\n    return 0;\n  } else {\n    return (mod + p) % p;\n  }\n};\n\nconst p = 10;\nconst q = 11;\nconst p2 = modp(p, q);\nconsole.log(p2);\n\nconst p2_2 = modp2(p, q);\nconsole.log(p2_2);\n<|endoftext|>"}
{"task_id": "JavaScript/50", "prompt": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(((ch.charCodeAt(0) - \"a\".charCodeAt(0)) - 5) % 26) + \"a\").join(\"\");\n}\n\nconst encode = (s) => {\n  return encodeShift(s);\n}\n\nconst decode = (s) => {\n  return decodeShift(s);\n}\n\nmodule.exports = {\n  encode,\n  decode\n};\n<|endoftext|>"}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n    const vowels = 'aeiouAEIOU'\n    const length = text.length\n    let position = 0\n    let newText = text\n    while (position < length) {\n        if (vowels.indexOf(text[position])!== -1) {\n            newText = newText.slice(0, position) + newText.slice(position + 1)\n        }\n        position++\n    }\n    return newText\n}\n\n// ====================================================================\n// =======================Tests=========================================\n// ====================================================================\n\ntest('removeVowels(empty)', () => {\n    const empty = ''\n    expect(removeVowels(empty)).toBe(empty)\n})\n\ntest('removeVowels(\"abcdef\")', () => {\n    const vowels = 'aeiouAEIOU'\n    const a = 'abcdef'\n    const b = 'abcdef'\n    const c = 'bdf'\n    const d = 'bdf'\n    const e = 'zbcdef'\n    const f = 'zbcdef'\n    const g = 'zbdf'\n    const h = 'zbdf'\n    const i = 'zbcdf'\n    const j = 'zbcdf'\n    const k = 'zbdf'\n    const l = 'zbcdf'\n    const m = 'zbcd'\n    const n = 'zbcd'\n    const o = 'zbcd'\n    const p = 'zbcd'\n    const q = 'zbcd'\n    const r = 'zbcd'\n    const s = 'zbcd'\n    const t = 'z'\n    const u = 'z'\n    const v = 'z'\n    const w = 'z'\n    const x = 'z'\n    const y = 'z'\n    const z = 'z'\n    const aa = 'z'\n    const bb = 'z'\n    const cc = 'z'\n    const dd = 'z'\n    const ee = 'z'\n    const ff = 'z'\n    const gg = 'z'\n    const hh = 'z'\n    const ii = 'z'\n    const jj = 'z'\n    const kk = 'z'\n    const ll = 'z'\n    const mm = 'z'\n    const nn = 'z'\n    const oo = 'z'\n    const pp = 'z'\n    const qq = 'z'\n    const rr = 'z'\n    const ss = 'z'\n    const tt = 'z'\n    const uu = 'z'\n    const vv = 'z'\n    const ww = 'z'\n    const xx = 'z'\n    const yy = 'z'\n    const zz = 'z'\n\n    expect(removeVowels(a)).toBe(b)\n    expect(removeVowels(b)).toBe(c)\n    expect(removeVowels(c)).toBe(d)\n    expect(removeVowels(d)).toBe(e)\n    expect(removeVowels(e)).toBe(f)\n    expect(removeVowels(f)).toBe(g)\n    expect(removeVowels(g)).toBe(h)\n    expect(removeVowels(h)).toBe(i)\n    expect(removeVowels(i)).toBe(j)\n    expect(removeVowels(j)).toBe(k)\n    expect(removeVowels(k)).toBe(l)\n    expect(removeVowels(l)).toBe(m)\n    expect(removeVowels(m)).toBe(n)\n    expect(removeVowels(n)).toBe(o)\n    expect(removeVowels(o)).toBe(p)\n    expect(removeVowels(p)).toBe(q)\n    expect(removeVowels(q)).toBe(r)\n    expect(removeVowels(r)).toBe(s)\n    expect(removeVowels(s)).toBe(t)\n    expect(removeVowels(t)).toBe(u)\n    expect(removeVowels(u)).toBe(v)\n    expect(removeVowels(v)).toBe(w)\n    expect(removeVowels(w)).toBe(x)\n    expect(removeVowels(x)).toBe(y)\n    expect(removeVowels(y)).toBe(z)\n    expect(removeVowels(z)).toBe(aa)\n    expect(removeVowels(aa)).toBe(bb)\n    expect(removeVowels(bb)).toBe(cc)\n    expect(removeVowels(cc)).toBe(dd)\n    expect(removeVowels(dd)).toBe(ee)\n    expect(removeVowels(ee)).toBe(ff)\n    expect(removeVowels(ff)).toBe(gg)\n    expect(removeVowels(gg)).toBe(hh)\n    expect(removeVowels(hh)).toBe(ii)\n    expect(removeVowels(ii)).toBe(jj)\n    expect(removeVowels(jj)).toBe(kk)\n    expect(removeVowels(kk)).toBe(ll)\n    expect(removeVowels(ll)).toBe(mm)\n    expect(removeVowels(mm)).toBe(nn)\n    expect(removeVowels(nn)).toBe(oo)\n    expect(removeVowels(oo)).toBe(pp)\n    expect(removeVowels(pp)).toBe(qq)\n    expect(removeVowels(qq)).toBe(rr)\n    expect(removeVowels"}
{"task_id": "JavaScript/52", "prompt": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n    if (l.length === 0) {\n        return true;\n    }\n    if (l.length === 1) {\n        return l[0] <= t;\n    }\n\n    let first = l[0];\n    let last = l[l.length - 1];\n    let result = (first <= t) && (t <= last);\n    for (let i = 1; i < l.length - 1; i++) {\n        if (l[i] < t) {\n            result = false;\n            break;\n        }\n    }\n    return result;\n};\n\nmodule.exports = belowThreshold;\n<|endoftext|>"}
{"task_id": "JavaScript/53", "prompt": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  let res = x + y;\n  return res;\n};\n\nconst add2 = (x, y) => {\n  return x + y;\n};\n\nconst add3 = (x, y) => {\n  return x + y;\n};\n\n/*\n  * Add two numbers\n  * @param {number} x\n  * @param {number} y\n  * @return {number}\n  * @example\n  * add(5, 7)\n  * // -> 12\n  * @example\n  * add(1, 2)\n  * // -> 3\n  * @example\n  * add(1, 2)\n  * // -> 3\n  * @example\n  * add(1, 2)\n  * // -> 3\n  */\nconst add4 = (x, y) => {\n  return x + y;\n};\n\nconst add5 = (x, y) => {\n  return x + y;\n};\n\nconst add6 = (x, y) => {\n  return x + y;\n};\n\n/*\n * Add two numbers\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nconst add7 = (x, y) => {\n  return x + y;\n};\n\nconst add8 = (x, y) => {\n  return x + y;\n};\n\nconst add9 = (x, y) => {\n  return x + y;\n};\n\n/*\n * Add two numbers\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nconst add10 = (x, y) => {\n  return x + y;\n};\n\nconst add11 = (x, y) => {\n  return x + y;\n};\n\nconst add12 = (x, y) => {\n  return x + y;\n};\n\nconst add13 = (x, y) => {\n  return x + y;\n};\n\nconst add14 = (x, y) => {\n  return x + y;\n};\n\nconst add15 = (x, y) => {\n  return x + y;\n};\n\nconst add16 = (x, y) => {\n  return x + y;\n};\n\nconst add17 = (x, y) => {\n  return x + y;\n};\n\nconst add18 = (x, y) => {\n  return x + y;\n};\n\nconst add19 = (x, y) => {\n  return x + y;\n};\n\nconst add20 = (x, y) => {\n  return x + y;\n};\n\nconst add21 = (x, y) => {\n  return x + y;\n};\n\nconst add22 = (x, y) => {\n  return x + y;\n};\n\nconst add23 = (x, y) => {\n  return x + y;\n};\n\nconst add24 = (x, y) => {\n  return x + y;\n};\n\nconst add25 = (x, y) => {\n  return x + y;\n};\n\nconst add26 = (x, y) => {\n  return x + y;\n};\n\nconst add27 = (x, y) => {\n  return x + y;\n};\n\nconst add28 = (x, y) => {\n  return x + y;\n};\n\nconst add29 = (x, y) => {\n  return x + y;\n};\n\nconst add30 = (x, y) => {\n  return x + y;\n};\n\nconst add31 = (x, y) => {\n  return x + y;\n};\n\nconst add32 = (x, y) => {\n  return x + y;\n};\n\nconst add33 = (x, y) => {\n  return x + y;\n};\n\nconst add34 = (x, y) => {\n  return x + y;\n};\n\nconst add35 = (x, y) => {\n  return x + y;\n};\n\nconst add36 = (x, y) => {\n  return x + y;\n};\n\nconst add37 = (x, y) => {\n  return x + y;\n};\n\nconst add38 = (x, y) => {\n  return x + y;\n};\n\nconst add39 = (x, y) => {\n  return x + y;\n};\n\nconst add40 = (x, y) => {\n  return x + y;\n};\n\nconst add41 = (x, y) => {\n  return x + y;\n};\n\nconst add42 = (x, y) => {\n  return x + y;\n};\n\nconst add43 = (x, y) => {\n  return x + y;\n};\n\nconst add44 = (x, y) => {\n  return x + y;\n};\n\nconst add45 = (x, y) => {\n  return x + y;\n};\n\nconst add46 = (x, y) => {\n  return x + y;\n};\n\nconst add47 = (x, y) => {\n  return x + y;\n};\n\nconst add48 = (x, y) => {\n  return x + y;\n};\n\nconst add49 = (x, y) => {\n  return x + y;\n};\n\nconst add50 = (x, y) => {\n  return x + y;\n};\n\nconst add51 = (x, y) => {\n  return x + y;\n};\n\nconst add52 = (x, y) => {\n  return x + y;\n};\n\nconst add53 = (x, y) => {\n  return x + y;\n};\n\nconst add54 = (x, y) => {\n  return x + y;\n};\n\nconst add55 = (x, y) => {\n  return x + y;\n};\n\nconst add56 = (x, y) => {\n  return x + y;\n};\n\nconst add57 = (x, y) => {\n  return x + y;\n};\n\nconst add58 = (x, y) => {\n  return x + y;\n};\n\nconst add59 = (x, y) => {\n  return x + y;\n};\n\nconst add60 = (x, y) => {\n  return x"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": true, "gc": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  return s0.split('').every(char => s1.split('').indexOf(char)!== -1);\n};\n\nmodule.exports = sameChars;\n<|endoftext|>"}
{"task_id": "JavaScript/55", "prompt": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": true, "gc": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  Let's use a function called `fib2` to calculate the n-th fibonacci number.\n  >>> fib2(10)\n  55\n  >>> fib2(1)\n  1\n  >>> fib2(8)\n  21\n  >>> fib2(3)\n  2\n  >>> fib2(7)\n  9\n  */\nconst fib2 = (n) => {\n  let x = 0, y = 1;\n  if (n <= 1) return 1;\n  while (n--) {\n    x = y;\n    y = x + y;\n  }\n  return x;\n};\n\n/*\n  Let's use a function called `fib3` to calculate the n-th fibonacci number.\n  >>> fib3(10)\n  55\n  >>> fib3(1)\n  1\n  >>> fib3(8)\n  21\n  >>> fib3(3)\n  2\n  >>> fib3(7)\n  9\n  */\nconst fib3 = (n) => {\n  let x = 0, y = 1;\n  if (n <= 1) return 1;\n  while (n--) {\n    x = y;\n    y = x + y;\n    y = y - x;\n  }\n  return x;\n};\n\nexport { fib, fib2, fib3 };\n<|endoftext|>"}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let lastIndex = 0\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"<\") {\n      if (lastIndex < i) {\n        return false\n      }\n      lastIndex = i\n    }\n  }\n  return true\n}\n\n/*\n  Given a string, returns a boolean indicating if it contains any\n  unbalanced parentheses.\n\n  >>> containsUnbalancedParentheses(\"(<>\")\n  true\n  >>> containsUnbalancedParentheses(\"()\")\n  false\n  >>> containsUnbalancedParentheses(\"<>()\")\n  false\n  >>> containsUnbalancedParentheses(\"(<\")\n  true\n  >>> containsUnbalancedParentheses(\"()(\")\n  true\n  >>> containsUnbalancedParentheses(\"()<>\")\n  true\n  >>> containsUnbalancedParentheses(\"(<>\")\n  true\n  >>> containsUnbalancedParentheses(\"(<>\")\n  true\n  >>> containsUnbalancedParentheses(\"(<>\")\n  true\n  >>> containsUnbalancedParentheses(\"<>()\")\n  true\n  >>> containsUnbalancedParentheses(\"<>()(\")\n  true\n  */\nconst containsUnbalancedParentheses = (str) => {\n  const brackets = [\"(\", \")\", \"<\", \">\"]\n  let count = 0\n  for (let i = 0; i < str.length; i++) {\n    if (brackets.indexOf(str[i])!== -1) {\n      count++\n    }\n  }\n  return count > 0 && count!== brackets.length\n}\n\n/*\n  Given a string, returns a boolean indicating if it contains a\n  complete set of brackets.\n\n  >>> containsCompleteBrackets(\"(<>\")\n  false\n  >>> containsCompleteBrackets(\"<>\")\n  false\n  >>> containsCompleteBrackets(\"()\")\n  true\n  >>> containsCompleteBrackets(\"<>()\")\n  true\n  >>> containsCompleteBrackets(\"()<>\")\n  true\n  >>> containsCompleteBrackets(\"<>()\")\n  true\n  >>> containsCompleteBrackets(\"(<>\")\n  true\n  >>> containsCompleteBrackets(\"<>\")\n  true\n  >>> containsCompleteBrackets(\"(<>\")\n  true\n  >>> containsCompleteBrackets(\"<>()\")\n  true\n  >>> containsCompleteBrackets(\"<>()\")\n  true\n  */\nconst containsCompleteBrackets = (str) => {\n  const brackets = [\"(\", \")\", \"<\", \">\"]\n  let count = 0\n  for (let i = 0; i < str.length; i++) {\n    if (brackets.indexOf(str[i]) === -1) {\n      count++\n    }\n  }\n  return count === brackets.length\n}\n\n/*\n  Given a string, returns a boolean indicating if it is valid.\n  The string should only contain one or more parentheses.\n\n  >>> isValid(\"<>\")\n  true\n  >>> isValid(\"()\")\n  true\n  >>> isValid(\"<>()\")\n  false\n  >>> isValid(\"(\")\n  false\n  >>> isValid(\"<\")\n  false\n  >>> isValid(\")\")\n  false\n  >>> isValid(\"(<)\")\n  false\n  >>> isValid(\"()(\")\n  false\n  >>> isValid(\"()<>\")\n  false\n  >>> isValid(\"(<>\")\n  false\n  >>> isValid(\"(<>\")\n  false\n  >>> isValid(\"<>()\")\n  false\n  >>> isValid(\"<>()\")\n  false\n  >>> isValid(\"(<>\")\n  false\n  >>> isValid(\"<>\")\n  false\n  >>> isValid(\"(<>\")\n  false\n  */\nconst isValid = (str) => {\n  return containsUnbalancedParentheses(str) === false && containsCompleteBrackets(str) === false\n}\n\n/*\n  Given a string, returns a boolean indicating if it is balanced.\n  The string should not contain any unbalanced parentheses.\n\n  >>> isBalanced(\"<>\")\n  false\n  >>> isBalanced(\"<>\")\n  false\n  >>> isBalanced(\"()\")\n  true\n  >>> isBalanced(\"()\")\n  true\n  >>> isBalanced(\"()\")\n  true\n  >>> isBalanced(\"<>\")\n  true\n  >>> isBalanced(\"<>\")\n  true\n  >>> isBalanced(\"<>()\")\n  true\n  >>> isBalanced(\"<>()\")\n  true\n  >>> isBalanced(\"<>()\")\n  true\n  >>> isBalanced(\"(<>\")\n  false\n  >>> isBalanced(\"(<>\")\n  false\n  >>> isBalanced(\"<>\")\n  false\n  >>> isBalanced(\"<>()\")\n  false\n  >>> isBalanced(\"<>()\")\n  false\n  */\nconst isBalanced = (str) => {\n  return containsUnbalancedParentheses(str) === false\n}\n\n/*\n  Given a string, returns the string with all unbalanced parentheses\n  balanced.\n  The string should not contain any parentheses.\n\n  >>> balance(\"<>\")\n  \"<><>\"\n  >>> balance(\"()\")\n  \"()\"\n  >>> balance(\"<>()\")\n  \"<><>\"\n  >>> balance(\"(<>\")\n  \"<><>\"\n  >>> balance(\"(<>\")\n  \"<><>\"\n  >>> balance(\"<>()\")\n  \"<><>(<>)\"\n  >>> balance(\"<>()\")\n  \"<><>(<>)\"\n  >>> balance(\"<>()\")\n  \"<><>(<>)\"\n  >>> balance(\"(<>\")\n  \"<><>\"\n  >>> balance(\"(<>\")\n  \"<><>\"\n  >>> balance(\"<>()\")\n  \"<><>(<>)\"\n  >>> balance(\"<>()\")\n  \"<><>(<>)\"\n  >>> balance(\"<>()\")\n  \"<><>(<>)\"\n  */\nconst balance = (str) => {\n  return brackets.reduce((prev, curr)"}
{"task_id": "JavaScript/57", "prompt": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  const isMonotonic = (x, y) => x <= y? x <= y : y <= x;\n  const all = (arr) => arr.every(isMonotonic);\n  return all(l);\n};\n\n/*\n  # Complexity: O(n^2)\n  >>> complex([1, 2, 4, 20])\n  true\n  >>> complex([1, 20, 4, 10])\n  false\n  >>> complex([4, 1, 0, -10])\n  true\n  */\nconst complex = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] > l[j]) {\n        result.push(false);\n      } else {\n        result.push(true);\n      }\n    }\n  }\n  return result.every(x => x);\n};\n\n/*\n  # Complexity: O(n^2)\n  >>> evenComplex([1, 2, 4, 20])\n  true\n  >>> evenComplex([1, 20, 4, 10])\n  false\n  >>> evenComplex([4, 1, 0, -10])\n  false\n  */\nconst evenComplex = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] % 2 === 0) {\n        result.push(true);\n      } else {\n        result.push(false);\n      }\n    }\n  }\n  return result.every(x => x);\n};\n\n/*\n  # Complexity: O(n)\n  >>> evenList([1, 2, 4, 20])\n  false\n  >>> evenList([1, 20, 4, 10])\n  true\n  >>> evenList([4, 1, 0, -10])\n  false\n  */\nconst evenList = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 2 === 0) {\n      result.push(true);\n    } else {\n      result.push(false);\n    }\n  }\n  return result.every(x => x);\n};\n\n/*\n  # Complexity: O(n)\n  >>> oddList([1, 2, 4, 20])\n  true\n  >>> oddList([1, 20, 4, 10])\n  false\n  >>> oddList([4, 1, 0, -10])\n  true\n  */\nconst oddList = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 2 === 1) {\n      result.push(true);\n    } else {\n      result.push(false);\n    }\n  }\n  return result.every(x => x);\n};\n\n/*\n  # Complexity: O(n)\n  >>> oddComplex([1, 2, 4, 20])\n  false\n  >>> oddComplex([1, 20, 4, 10])\n  true\n  >>> oddComplex([4, 1, 0, -10])\n  true\n  */\nconst oddComplex = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 2 === 1) {\n      result.push(true);\n    } else {\n      result.push(false);\n    }\n  }\n  return result.every(x => x);\n};\n\nexport {\n  monotonic,\n  complex,\n  evenComplex,\n  evenList,\n  oddComplex,\n  oddList\n};\n<|endoftext|>"}
{"task_id": "JavaScript/58", "prompt": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": true, "gc": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  if(!Array.isArray(l1) ||!Array.isArray(l2))\n    throw new TypeError(\"Invalid arguments\");\n  if(l1.length === 0 || l2.length === 0)\n    return [];\n  const result = [];\n  for(let i = 0; i < l1.length; i++) {\n    if(l1[i] === l2[i])\n      result.push(l1[i]);\n  }\n  return result;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/59", "prompt": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": true, "gc": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  //check if n is prime\n  if (n == 1) {\n    return 1\n  }\n  if (n == 2) {\n    return 2\n  }\n  //if n is not prime, return largest prime factor of n/2\n  return largestPrimeFactor(n / 2)\n}\n\n/*\n  Return the smallest prime factor of n. Assume n > 1.\n  >>> smallestPrimeFactor(13195)\n  11\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  if (n == 1) {\n    return 1\n  }\n  if (n == 2) {\n    return 2\n  }\n  //if n is not prime, return largest prime factor of n/2\n  return largestPrimeFactor(n / 2)\n}\n\n/*\n  Return the largest prime factor of n. Assume n > 1.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorByLoop = (n) => {\n  //if n is not prime, return largest prime factor of n/2\n  if (n % 2 === 0) {\n    return largestPrimeFactor(n / 2)\n  }\n  //if n is prime, return n\n  return n\n}\n\n/*\n  Return the smallest prime factor of n. Assume n > 1.\n  >>> smallestPrimeFactor(13195)\n  11\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorByLoop = (n) => {\n  //if n is not prime, return largest prime factor of n/2\n  if (n % 2 === 0) {\n    return smallestPrimeFactor(n / 2)\n  }\n  //if n is prime, return n\n  return n\n}\n\nconst test = {\n  largestPrimeFactor: largestPrimeFactor,\n  smallestPrimeFactor: smallestPrimeFactor,\n  largestPrimeFactorByLoop: largestPrimeFactorByLoop,\n  smallestPrimeFactorByLoop: smallestPrimeFactorByLoop\n}\n\nconst test2 = {\n  largestPrimeFactor: largestPrimeFactor(13195),\n  smallestPrimeFactor: smallestPrimeFactor(13195),\n  largestPrimeFactorByLoop: largestPrimeFactorByLoop(13195),\n  smallestPrimeFactorByLoop: smallestPrimeFactorByLoop(13195)\n}\n\nconst test3 = {\n  largestPrimeFactor: largestPrimeFactor(2048),\n  smallestPrimeFactor: smallestPrimeFactor(2048),\n  largestPrimeFactorByLoop: largestPrimeFactorByLoop(2048),\n  smallestPrimeFactorByLoop: smallestPrimeFactorByLoop(2048)\n}\n\nconst test4 = {\n  largestPrimeFactor: largestPrimeFactor(13195),\n  smallestPrimeFactor: smallestPrimeFactor(13195),\n  largestPrimeFactorByLoop: largestPrimeFactorByLoop(13195),\n  smallestPrimeFactorByLoop: smallestPrimeFactorByLoop(13195)\n}\n\nconst test5 = {\n  largestPrimeFactor: largestPrimeFactor(2048),\n  smallestPrimeFactor: smallestPrimeFactor(2048),\n  largestPrimeFactorByLoop: largestPrimeFactorByLoop(2048),\n  smallestPrimeFactorByLoop: smallestPrimeFactorByLoop(2048)\n}\n\nmodule.exports = {\n  largestPrimeFactor,\n  smallestPrimeFactor,\n  largestPrimeFactorByLoop,\n  smallestPrimeFactorByLoop\n}\n<|endoftext|>"}
{"task_id": "JavaScript/60", "prompt": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumTlN is a function that sums numbers from 1 to n.\n  >>> sumTlN(30)\n  465\n  >>> sumTlN(100)\n  5050\n  >>> sumTlN(5)\n  15\n  >>> sumTlN(10)\n  55\n  >>> sumTlN(1)\n  1\n  */\nconst sumTlN = (n) => {\n  let sum = 0;\n  for (let i = n; i >= 1; i--) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumTlN is a function that sums numbers from 1 to n.\n  >>> sumTlN(30)\n  465\n  >>> sumTlN(100)\n  5050\n  >>> sumTlN(5)\n  15\n  >>> sumTlN(10)\n  55\n  >>> sumTlN(1)\n  1\n  */\nconst sumTlNPrime = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumTlN is a function that sums numbers from 1 to n.\n  >>> sumTlN(30)\n  465\n  >>> sumTlN(100)\n  5050\n  >>> sumTlN(5)\n  15\n  >>> sumTlN(10)\n  55\n  >>> sumTlN(1)\n  1\n  */\nconst sumTlNPrimePrime = (n) => {\n  let sum = 0;\n  for (let i = n; i > 1; i--) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumTlN is a function that sums numbers from 1 to n.\n  >>> sumTlN(30)\n  465\n  >>> sumTlN(100)\n  5050\n  >>> sumTlN(5)\n  15\n  >>> sumTlN(10)\n  55\n  >>> sumTlN(1)\n  1\n  */\nconst sumTlNPrimePrimePrime = (n) => {\n  let sum = 0;\n  for (let i = n; i > 2; i--) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  sumTlN is a function that sums numbers from 1 to n.\n  >>> sumTlN(30)\n  465\n  >>> sumTlN(100)\n  5050\n  >>> sumTlN(5)\n  15\n  >>> sumTlN(10)\n  55\n  >>> sumTlN(1)\n  1\n  */\nconst sumTlNPrimePrimePrimePrime = (n) => {\n  let sum = 0;\n  for (let i = n; i > 3; i--) {\n    sum += i;\n  }\n  return sum;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let openingBrackets = 0;\n  let closedBrackets = 0;\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"(\" && openingBrackets === 0) {\n      openingBrackets++;\n    }\n    if (brackets[i] === \")\" && openingBrackets > 0) {\n      if (closedBrackets === openingBrackets - 1) {\n        openingBrackets--;\n      } else {\n        return false;\n      }\n    }\n    if (brackets[i] === \"(\" && openingBrackets > 0) {\n      closedBrackets++;\n    }\n  }\n  return openingBrackets === 0;\n};\n\n/*\n  Given a string, remove the opening and closing brackets,\n  return a string without brackets.\n  If the string doesn't contain brackets, return the string itself.\n\n  >>> removeBrackets(\"(()())\")\n  \"()()\"\n  >>> removeBrackets(\"(()\")\n  \"(()\"\n  >>> removeBrackets(\"(())\")\n  \"()\"\n  >>> removeBrackets(\"()\")\n  \"\"\n  >>> removeBrackets(\"()\")\n  \"\"\n  >>> removeBrackets(\"(())\")\n  \"())\"\n  */\nconst removeBrackets = (brackets) => {\n  if (brackets.length > 0) {\n    return brackets.slice(1, -1);\n  }\n  return brackets;\n};\n\n/*\n  Given a string, remove all brackets\n  return a string without brackets.\n\n  >>> removeAllBrackets(\"()())\")\n  \"()()\"\n  >>> removeAllBrackets(\"()\")\n  \"()\"\n  >>> removeAllBrackets(\"(())\")\n  \"())\"\n  >>> removeAllBrackets(\"(()\")\n  \"())\"\n  >>> removeAllBrackets(\"()\")\n  \"\"\n  >>> removeAllBrackets(\"()\")\n  \"\"\n  >>> removeAllBrackets(\"(())\")\n  \"())\"\n  */\nconst removeAllBrackets = (brackets) => {\n  let bracketsString = brackets;\n  let bracketsStack = [];\n  while (bracketsString.length > 0) {\n    bracketsStack.push(bracketsString.slice(0, 1));\n    bracketsString = bracketsString.slice(1);\n  }\n  let result = \"\";\n  while (bracketsStack.length > 0) {\n    result += bracketsStack.pop();\n  }\n  return result;\n};\n\n/*\n  Given a string, return a string with brackets around all\n  opening brackets and a closing bracket on the last line.\n\n  >>> printBrackets(\"()())\")\n  ()())\n  >>> printBrackets(\"(()\")\n  (()\n  >>> printBrackets(\"(())\")\n  ()())\n  >>> printBrackets(\"()\")\n  ()\n  >>> printBrackets(\"()\")\n  ()\n  >>> printBrackets(\"()())\")\n  ()())\n  >>> printBrackets(\"()\")\n  ()\n  >>> printBrackets(\"()\")\n  ()\n  >>> printBrackets(\"(())\")\n  ()())\n  */\nconst printBrackets = (brackets) => {\n  let bracketsString = brackets;\n  let result = \"\";\n  while (bracketsString.length > 0) {\n    result += bracketsString.slice(0, 1);\n    bracketsString = bracketsString.slice(1);\n  }\n  result += \"\\n}\";\n  return result;\n};\n\nexport {\n  correctBracketing,\n  removeBrackets,\n  removeAllBrackets,\n  printBrackets\n};\n<|endoftext|>"}
{"task_id": "JavaScript/62", "prompt": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": true, "gc": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const length = xs.length;\n  let derivative = new Array(length);\n  for (let i = length - 1; i >= 0; i--) {\n    derivative[i] = xs[i + 1] + xs[i] * 2;\n  }\n  return derivative;\n};\n\nexport {\n  add,\n  subtract,\n  multiply,\n  divide,\n  root,\n  derivative\n};\n<|endoftext|>"}
{"task_id": "JavaScript/63", "prompt": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) {\n    return 0\n  }\n  if (n === 1) {\n    return 0\n  }\n  if (n === 2) {\n    return 1\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n}\n\nconst fibfibIter = (n) => {\n  let i = 0\n  let fib = 0\n  while (i < n) {\n    fib = fib + fibfib(i)\n    i = i + 1\n  }\n  return fib\n}\n\nconst fibfibIterRec = (n) => {\n  if (n === 0) {\n    return 0\n  }\n  if (n === 1) {\n    return 0\n  }\n  if (n === 2) {\n    return 1\n  }\n  return fibfibIter(n - 1) + fibfibIter(n - 2) + fibfibIter(n - 3)\n}\n\nconst fibfibIterFunc = (n) => fibfib(n)\n\nconst fibfibIterFuncRec = (n) => fibfib(n)\n\nconst fibfibIterFuncRec2 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec3 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec4 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec5 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec6 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec7 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec8 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec9 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec10 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec11 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec12 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec13 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec14 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec15 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec16 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec17 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec18 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec19 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec20 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec21 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec22 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec23 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec24 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec25 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec26 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec27 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec28 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec29 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec30 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec31 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec32 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec33 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec34 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec35 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec36 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec37 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec38 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec39 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec40 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec41 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec42 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec43 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec44 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec45 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec46 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec47 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec48 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec49 = (n) => fibfib(n)\n\nconst fibfibIterFuncRec50 = (n) => fibfib(n)\n"}
{"task_id": "JavaScript/64", "prompt": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i])!== -1) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst isVowel = (c) => {\n  return vowels.indexOf(c)!== -1;\n}\n\nconst isVowelOrConsonant = (c) => {\n  return isVowel(c) ||!isVowel(c) &&!isVowel(c.toUpperCase());\n}\n\nconst isVowelOrConsonantUppercase = (c) => {\n  return isVowelOrConsonant(c.toUpperCase());\n}\n\nconst isVowelOrConsonantUppercaseCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (isVowelOrConsonantUppercase(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst allVowels = (s) => {\n  let allVowels = new Set();\n  for (let i = 0; i < s.length; i++) {\n    if (isVowel(s[i])) {\n      allVowels.add(s[i]);\n    }\n  }\n  return allVowels;\n}\n\nconst consonants = (s) => {\n  let consonants = new Set();\n  for (let i = 0; i < s.length; i++) {\n    if (!isVowel(s[i])) {\n      consonants.add(s[i]);\n    }\n  }\n  return consonants;\n}\n\nconst consonantsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (!isVowel(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst consonantsCountUppercase = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (!isVowelUppercase(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst consonantsCountUppercaseUppercase = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (!isVowelUppercaseUppercase(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst isVowelUppercase = (c) => {\n  return isVowelUppercase(c.toUpperCase());\n}\n\nconst isVowelUppercaseUppercase = (c) => {\n  return isVowelUppercase(c.toUpperCase());\n}\n\nconst vowelsCountUppercase = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (isVowelUppercase(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst vowelsCountUppercaseUppercase = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (isVowelUppercaseUppercase(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst consonantsCountUppercaseUppercase = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (isVowelUppercaseUppercase(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst consonantsCountUppercaseUppercaseUppercase = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (isVowelUppercaseUppercaseUppercase(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst vowelsCountUppercaseUppercase = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (isVowelUppercaseUppercase(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst vowelsCountUppercaseUppercaseUppercase = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (isVowelUppercaseUppercaseUppercase(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst consonantsCountUppercaseUppercase = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (isVowelUppercaseUppercase(s[i])) {\n      count++;\n    }\n  }\n  return count;\n}\n\nconst consonantsCountUppercaseUppercaseUppercase = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (isVowelUppercaseUppercaseUppercase(s[i])) {"}
{"task_id": "JavaScript/65", "prompt": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let r = '';\n  let xs = x.toString();\n  let ls = xs.length;\n  for (let i = ls; i >= 0; i--) {\n    r = r + xs.charAt(i);\n  }\n  let s = ls - shift;\n  if (s > 0) {\n    for (let i = 0; i < s; i++) {\n      r = r + xs.charAt(i);\n    }\n  } else if (s < 0) {\n    for (let i = ls; i >= ls + s; i--) {\n      r = r + xs.charAt(i);\n    }\n  }\n  return r;\n};\n\n/*\n  Given an integer x,\n  return x % 10 + 1.\n  If x is not a number, return 1.\n  >>> mod10(1)\n  1\n  >>> mod10(2)\n  3\n  >>> mod10(3)\n  7\n  >>> mod10(4)\n  2\n  >>> mod10(5)\n  3\n  >>> mod10(6)\n  4\n  >>> mod10(7)\n  5\n  >>> mod10(8)\n  6\n  >>> mod10(9)\n  1\n  >>> mod10(10)\n  1\n  >>> mod10(11)\n  9\n  >>> mod10(12)\n  3\n  >>> mod10(13)\n  7\n  >>> mod10(14)\n  1\n  >>> mod10(15)\n  4\n  >>> mod10(16)\n  6\n  >>> mod10(17)\n  8\n  >>> mod10(18)\n  9\n  >>> mod10(19)\n  9\n  >>> mod10(20)\n  1\n  >>> mod10(21)\n  1\n  >>> mod10(22)\n  9\n  >>> mod10(23)\n  9\n  >>> mod10(24)\n  9\n  >>> mod10(25)\n  9\n  >>> mod10(26)\n  9\n  >>> mod10(27)\n  9\n  >>> mod10(28)\n  9\n  >>> mod10(29)\n  9\n  >>> mod10(30)\n  9\n  >>> mod10(31)\n  9\n  >>> mod10(32)\n  9\n  >>> mod10(33)\n  9\n  >>> mod10(34)\n  9\n  >>> mod10(35)\n  9\n  >>> mod10(36)\n  9\n  >>> mod10(37)\n  9\n  >>> mod10(38)\n  9\n  >>> mod10(39)\n  9\n  >>> mod10(40)\n  9\n  >>> mod10(41)\n  9\n  >>> mod10(42)\n  9\n  >>> mod10(43)\n  9\n  >>> mod10(44)\n  9\n  >>> mod10(45)\n  9\n  >>> mod10(46)\n  9\n  >>> mod10(47)\n  9\n  >>> mod10(48)\n  9\n  >>> mod10(49)\n  9\n  >>> mod10(50)\n  9\n  >>> mod10(51)\n  9\n  >>> mod10(52)\n  9\n  >>> mod10(53)\n  9\n  >>> mod10(54)\n  9\n  >>> mod10(55)\n  9\n  >>> mod10(56)\n  9\n  >>> mod10(57)\n  9\n  >>> mod10(58)\n  9\n  >>> mod10(59)\n  9\n  >>> mod10(60)\n  9\n  >>> mod10(61)\n  9\n  >>> mod10(62)\n  9\n  >>> mod10(63)\n  9\n  >>> mod10(64)\n  9\n  >>> mod10(65)\n  9\n  >>> mod10(66)\n  9\n  >>> mod10(67)\n  9\n  >>> mod10(68)\n  9\n  >>> mod10(69)\n  9\n  >>> mod10(70)\n  9\n  >>> mod10(71)\n  9\n  >>> mod10(72)\n  9\n  >>> mod10(73)\n  9\n  >>> mod10(74)\n  9\n  >>> mod10(75)\n  9\n  >>> mod10(76)\n  9\n  >>> mod10(77)\n  9\n  >>> mod10(78)\n  9\n  >>> mod10(79)\n  9\n  >>> mod10(80)\n  9\n  >>> mod10(81)\n  9\n  >>> mod10(82)\n  9\n  >>> mod10(83)\n  9\n  >>> mod10(84)\n  9\n  >>> mod10(85)\n  9\n  >>> mod10(86)\n  9\n  >>> mod10(87)\n  9\n  >>> mod10(88)\n  9\n  >>> mod10(89)\n  9\n  >>> mod10(90)\n  9\n  >>> mod10(91)\n  9\n  >>> mod10(92)\n  9\n  >>> mod10(93)\n  9\n  >>> mod10(94)\n  9\n  >>> mod10(95)\n  9\n  >>> mod10(96)\n  9\n  >>> mod10(97)\n  9\n  >>> mod10(98)\n  9\n  >>> mod10(99)\n  9\n  >>> mod10(100)\n  9\n  >>> mod10(101)\n  9\n  >>> mod10(102)\n  9\n  >>> mod10(103)\n  9\n  >>> mod10(104)\n  9\n  >>> mod10(105)\n  9\n  >>> mod10(106)\n  9\n  >>> mod10(107)\n  9\n  >>> mod10(108)\n  9\n  >>> mod10(109)\n  9\n  >>> mod10(110)\n  9\n  >>> mod10(111)\n  9\n  >>> mod10(112)\n  9\n  >>> mod10(113)\n  "}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s[i].charCodeAt(0) - 65;\n  }\n  return sum;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const fruits = s.split(\" \")\n  const nFruits = fruits.length\n  const apple = fruits[0]\n  const orange = fruits[1]\n  const total = nFruits\n  const apples = parseInt(apple, 10)\n  const oranges = parseInt(orange, 10)\n  const orangesPerc = oranges / total\n  const applesPerc = apples / total\n  return applesPerc + orangesPerc\n}\n\n/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  fruitDistribution(\"4 apples and 7 oranges\", 99) -> 99 - 4 - 7 = 94\n  */\nconst fruitDistribution = (s, n) => {\n  const fruits = s.split(\" \")\n  const nFruits = fruits.length\n  const apple = fruits[0]\n  const orange = fruits[1]\n  const apples = parseInt(apple, 10)\n  const oranges = parseInt(orange, 10)\n  const orangesPerc = oranges / n\n  const applesPerc = apples / n\n  return applesPerc + orangesPerc\n}\n\nfruitDistribution(\"2 apples and 3 oranges\", 120)\n\nfruitDistribution(\"0 apples and 1 orantes\",3)\n\nfruitDistribution(\"2 apples and 3 oranges\", 100)\n\nfruitDistribution(\"100 apples and 1 oranges\",120)\n\nfruitDistribution(\"4 apples and 7 oranges\", 99)\n\nfruitDistribution(\"4 apples and 7 oranges\", 100)\n<|endoftext|>"}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n    let min = arr[0];\n    let idx = 0;\n    for (let i = 1; i < arr.length; i += 1) {\n        if (arr[i] < min) {\n            min = arr[i];\n            idx = i;\n        }\n    }\n    return [min, idx];\n}\n\nlet [min, idx] = pluck([4, 2, 3]);\nconsole.log(min); // 2\nconsole.log(idx); // 1\n\n[min, idx] = pluck([]);\nconsole.log(min); // undefined\nconsole.log(idx); // undefined\n\n[min, idx] = pluck([1, 2, 3]);\nconsole.log(min); // 1\nconsole.log(idx); // 1\n\n[min, idx] = pluck([4, 0, 3, 0, 4, 2]);\nconsole.log(min); // 0\nconsole.log(idx); // 1\n<|endoftext|>"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n    if (lst.length === 0) return -1;\n\n    // get the maximum element\n    let max = lst[0];\n\n    // get the frequency of max\n    let freq = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > max) {\n            max = lst[i];\n            freq = i + 1;\n        }\n    }\n\n    // go through every element in the list\n    for (let i = 1; i < lst.length; i++) {\n        // if the current element is greater than the max,\n        // return the frequency\n        if (lst[i] > max) {\n            return freq;\n        }\n    }\n\n    return -1;\n}\n\n/*\n  You are given a non-empty list of positive integers. Retur the smallest integer that is smaller than\n  vero, and hqs a frequency greater than or eeual to the value of the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 1\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search_reverse = (lst) => {\n    if (lst.length === 0) return -1;\n\n    // get the minimum element\n    let min = lst[lst.length - 1];\n\n    // get the frequency of min\n    let freq = 0;\n    for (let i = lst.length - 1; i >= 0; i--) {\n        if (lst[i] < min) {\n            min = lst[i];\n            freq = lst.length - i - 1;\n        }\n    }\n\n    // go through every element in the list\n    for (let i = lst.length - 2; i >= 0; i--) {\n        // if the current element is smaller than the min,\n        // return the frequency\n        if (lst[i] < min) {\n            return freq;\n        }\n    }\n\n    return -1;\n}\n\n/*\n  You are given a non-empty list of positive integers. Retur the smallest and the largest element,\n  and hqs a frequency greater than or eeual to the value of the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return [-1, -1].\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == [1, 4]\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == [4, 4]\n      search([5, 5, 4, 4, 4])) == [-1, -1]\n  */\nconst search_range = (lst) => {\n    if (lst.length === 0) return [-1, -1];\n\n    // get the minimum element\n    let min = lst[0];\n\n    // get the frequency of min\n    let freq = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < min) {\n            min = lst[i];\n            freq = i + 1;\n        }\n    }\n\n    // get the maximum element\n    let max = lst[lst.length - 1];\n\n    // get the frequency of max\n    let freq_max = lst.length - 1;\n    for (let i = lst.length - 1; i >= 0; i--) {\n        if (lst[i] > max) {\n            max = lst[i];\n            freq_max = i;\n        }\n    }\n\n    // return the two values\n    return [min, max];\n}\n\nmodule.exports = {\n    search,\n    search_reverse,\n    search_range\n};<|endoftext|>"}
{"task_id": "JavaScript/70", "prompt": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n    if (!lst) {\n        return [];\n    }\n    if (lst.length === 1) {\n        return [lst[0]];\n    }\n    const l = lst.length;\n    let min = lst[0];\n    let max = lst[0];\n    for (let i = 1; i < l; i++) {\n        if (lst[i] < min) {\n            min = lst[i];\n        }\n        if (lst[i] > max) {\n            max = lst[i];\n        }\n    }\n    let j = 0;\n    let k = 0;\n    let to = 0;\n    while (j < l) {\n        while (j < l && lst[j] < min) {\n            j++;\n        }\n        lst[to] = lst[j];\n        to++;\n        j++;\n        while (j < l && lst[j] <= max) {\n            lst[to] = lst[j];\n            to++;\n            j++;\n        }\n    }\n    lst = lst.slice(0, to);\n    return lst;\n};\n\nconst test = strangeSortList([1, 2, 3, 4, 5, 5, 5, 5, 5]);\nconsole.log(test);<|endoftext|>"}
{"task_id": "JavaScript/71", "prompt": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a + b > c && a + c > b && b + c > a) {\n    return ((a * b) + (b * c) + (c * a)) / 2;\n  } else {\n    return -1;\n  }\n};\n\nconst main = () => {\n  const input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n  const output = [];\n  for (const x of input) {\n    for (const y of input) {\n      const area = triangleArea(x, y, x + y);\n      if (area!== -1) {\n        output.push(area);\n      }\n    }\n  }\n  console.log(output);\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length === 0 || q.length === 1) return false\n  let x = q[q.length-1]\n  if (q.length === 2) return true\n  for (let i = 0; i < q.length-1; i++) {\n    if (q[i] > x) return false\n    x = x + q[i]\n  }\n  if (x === w) return true\n  return false\n}\n\nconsole.log(willItFly([1, 2, 3, 2, 3], 9))\nconsole.log(willItFly([1, 2, 3, 2, 3], 5))\nconsole.log(willItFly([1, 2, 3], 5))\n<|endoftext|>"}
{"task_id": "JavaScript/73", "prompt": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let res = 0;\n  let min = Math.min(arr[0], arr[arr.length - 1]);\n  let cnt = 0;\n\n  while (res < min) {\n    let mid = Math.floor(min / 2);\n    if (arr[mid] === arr[arr.length - mid - 1]) {\n      res = mid;\n      cnt++;\n    }\n    min = Math.min(mid, min - mid);\n  }\n  return cnt;\n};\n\nconst testSmallestChange = () => {\n  let arr = [1, 2, 3, 2, 1];\n  console.log(smallestChange(arr));\n};\n\nconst testSmallestChange2 = () => {\n  let arr = [1, 2, 3, 2, 1];\n  console.log(smallestChange(arr));\n};\n\ntestSmallestChange();\ntestSmallestChange2();\n<|endoftext|>"}
{"task_id": "JavaScript/74", "prompt": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const lst1Size = lst1.length;\n  const lst2Size = lst2.length;\n  if(lst1Size < lst2Size){\n    return lst1;\n  }\n  const lst1Length = lst1.reduce((acc, cur) => acc + cur.length, 0);\n  const lst2Length = lst2.reduce((acc, cur) => acc + cur.length, 0);\n  if(lst1Length === lst2Length){\n    return lst1;\n  }\n  return lst2;\n};\n\n/*\n  Wrihe a function that takes a list of strings returns the shortest of the list.\n\n  Example\n  shortest(['hi', 'admin', 'hi', 'project']) ➞ 'hi'\n  shortest(['hi', 'admin']) ➞ 'hi'\n  shortest(['hi']) ➞ 'hi'\n  */\nconst shortest = (lst) => {\n  const shortestLength = lst.reduce((acc, cur) => Math.min(acc, cur.length), Infinity);\n  return lst.reduce((acc, cur) => acc.length > cur.length? acc : cur, '');\n};\n\n/*\n  Wrihe a function that takes a list of strings returns the longest of the list.\n\n  Example\n  longest(['hi', 'admin', 'hi', 'project']) ➞ 'admin'\n  longest(['hi', 'admin']) ➞ 'admin'\n  longest(['hi']) ➞ 'hi'\n  */\nconst longest = (lst) => {\n  const longestLength = lst.reduce((acc, cur) => Math.max(acc, cur.length), 0);\n  return lst.reduce((acc, cur) => acc.length > cur.length? acc : cur, '');\n};\n\nmodule.exports = {\n  totalMatch,\n  shortest,\n  longest\n};\n<|endoftext|>"}
{"task_id": "JavaScript/75", "prompt": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let i, j;\n  let p = 1;\n  let b = 2;\n  let aPrime = 2;\n  while (aPrime <= a) {\n    for (i = 2; i <= aPrime; i++) {\n      if (a % i === 0) {\n        return false;\n      }\n    }\n    p++;\n    aPrime += b;\n    b += 2;\n  }\n  return true;\n}\n\n// isPrime: returns true if n is prime\n// Written in ES6, to be tested with the rest of the program\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// isPythagoreanTriple: returns true if 3 is a Pythagorean triple\n// Written in ES6, to be tested with the rest of the program\nconst isPythagoreanTriple = (n) => {\n  let a = n * (n - 1);\n  let b = n * n;\n  let c = n * (2 * n - 1);\n  return a + b === c && a + b === c && a + b === c;\n}\n\n// isPalindrome: returns true if the given string is a palindrome\n// Written in ES6, to be tested with the rest of the program\nconst isPalindrome = (str) => {\n  return str === str.split('').reverse().join('');\n}\n\n// getSumOfDivisors: returns the sum of all the divisors of the given number\n// Written in ES6, to be tested with the rest of the program\nconst getSumOfDivisors = (n) => {\n  let sum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n      while (n % i === 0) {\n        n /= i;\n      }\n    }\n  }\n  return sum;\n}\n\n// getPermutations: returns all permutations of the given string\n// Written in ES6, to be tested with the rest of the program\nconst getPermutations = (str) => {\n  let permutation = [];\n  let i;\n  let j;\n  let len = str.length;\n  let k = 0;\n  let n = 1;\n  while (n <= len) {\n    let s = [];\n    for (i = 0; i < len; i++) {\n      s.push(str[i]);\n    }\n    let temp = str.slice(0, i);\n    for (j = 0; j < len; j++) {\n      temp.splice(i, 1);\n      s.splice(i, 1);\n      permutation.push(s.join(''));\n      temp.push(str[j]);\n      s.push(str[j]);\n    }\n    n++;\n  }\n  return permutation;\n}\n\n// getCombinations: returns all the possible combinations of the given string\n// Written in ES6, to be tested with the rest of the program\nconst getCombinations = (str) => {\n  let combinations = [];\n  let i;\n  let j;\n  let len = str.length;\n  let k = 0;\n  let n = 1;\n  while (n <= len) {\n    let s = [];\n    for (i = 0; i < len; i++) {\n      s.push(str[i]);\n    }\n    let temp = str.slice(0, i);\n    for (j = 0; j < len; j++) {\n      temp.splice(i, 1);\n      s.splice(i, 1);\n      combinations.push(s.join(''));\n      temp.push(str[j]);\n      s.push(str[j]);\n    }\n    n++;\n  }\n  return combinations;\n}\n\n// getUniqueDivisors: returns all the divisors of the given number\n// Written in ES6, to be tested with the rest of the program\nconst getUniqueDivisors = (n) => {\n  let a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i);\n  }\n  let len = a.length;\n  let i = 0;\n  while (i < len) {\n    let b = a[i];\n    let j = i + 1;\n    while (j < len) {\n      if (a[j] % b === 0) {\n        a.splice(j, 1);\n      }\n      j++;\n    }\n    i++;\n  }\n  return a;\n}\n\n// getUniqueDivisorsSorted: returns all the divisors of the given number\n// in sorted order\n// Written in ES6, to be tested with the rest of the program\nconst getUniqueDivisorsSorted = (n) => {\n  let a = [];\n  let b = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i);\n  }\n  let len = a.length;\n  let i = 0;\n  while (i < len) {\n    let b = a[i];\n    let j = i + 1;\n    while (j < len) {\n      if (a[j] % b === 0) {\n        a.splice(j, 1);\n      }\n      j++;\n    }\n    i++;\n  }\n  let aSorted = a.sort();\n  return aSorted;\n}\n\n// getAllPythagoreanTriples: returns all the Pythagorean triples in the given range\n// Written in ES6, to be tested with the rest of the program\nconst getAllPythagoreanTriples = (min, max) => {\n  let pythagoreanTriples = [];\n  for (let i = min; i <= max; i++) {\n    for (let j = i + 1; j <="}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": true, "gc": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  return x % n === 0 && x / n === Math.floor(x / n);\n};\n\n// const isSimplePower = (x, n) => {\n//   if (x % n === 0) return true;\n//   const div = x / n;\n//   if (div === Math.floor(div)) return false;\n//   return isSimplePower(div, n);\n// };\n<|endoftext|>"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  return a % 6 === 0;\n}\n\n/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a perfect square of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> false\n  iscube(2) ==> true\n  iscube(-1) ==> false\n  iscube(64) ==> true\n  iscube(0) ==> false\n  iscube(180) ==> true\n  */\nconst issquare = (a) => {\n  return iscube(a) && (a % a) === 0;\n}\n\n/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a prime number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> false\n  iscube(2) ==> true\n  iscube(3) ==> false\n  iscube(4) ==> false\n  iscube(6) ==> true\n  iscube(12) ==> false\n  iscube(90) ==> true\n  iscube(18) ==> true\n  */\nconst isprime = (a) => {\n  let i;\n  for (i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a number that is divisible by some other number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(12) ==> true\n  iscube(24) ==> true\n  iscube(12) ==> true\n  iscube(24) ==> false\n  iscube(12) ==> false\n  iscube(18) ==> false\n  */\nconst isdivisor = (a) => {\n  let i;\n  for (i = 2; i < a; i++) {\n    if (a % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a perfect number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> false\n  iscube(2) ==> true\n  iscube(3) ==> true\n  iscube(4) ==> true\n  iscube(6) ==> true\n  iscube(12) ==> true\n  iscube(90) ==> true\n  iscube(18) ==> false\n  */\nconst isperfect = (a) => {\n  return isprime(a) && isdivisor(a);\n}\n\n/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a perfect square.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> false\n  iscube(2) ==> true\n  iscube(3) ==> false\n  iscube(4) ==> false\n  iscube(6) ==> true\n  iscube(12) ==> true\n  iscube(90) ==> false\n  iscube(18) ==> false\n  */\nconst isperfectsquare = (a) => {\n  return issquare(a) && isperfect(a);\n}\n\n/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a perfect cube.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> false\n  iscube(2) ==> false\n  iscube(3) ==> false\n  iscube(4) ==> true\n  iscube(6) ==> true\n  iscube(12) ==> true\n  iscube(90) ==> true\n  iscube(18) ==> false\n  */\nconst isperfectcube = (a) => {\n  return iscube(a) && isperfectsquare(a);\n}\n\n/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a perfect number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> false\n  iscube(2) ==> true\n  iscube(3) ==> true\n  iscube(4) ==> true\n  iscube(6) ==> true\n  iscube(12) ==> true\n  iscube(90) ==> true\n  iscube(18) ==> true\n  */\nconst isperfectn = (a) => {\n  return isperfect(a) && a % 6 === 0;\n}\n\n/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a perfect square.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> false\n  iscube(2) ==> false\n  iscube(3) ==> false\n  iscube(4) ==> true\n  iscube(6) ==> true\n  iscube(12) ==> true\n  iscube(90) ==> false\n  iscube(18) ==> false\n  */\nconst isperfectn2 = (a) => {\n  return isperfectsquare(a) && a % a === 0;\n}\n\n/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a perfect cube.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> false\n  iscube(2"}
{"task_id": "JavaScript/78", "prompt": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  const str = num.toString().toUpperCase();\n  const digits = str.split('');\n  const result = 0;\n  for (let i = 0; i < digits.length; i += 1) {\n    const num = parseInt(digits[i], 16);\n    if (num > 1) {\n      result += num;\n    }\n  }\n  return result;\n};\n\nmodule.exports = {\n  hexKey\n};\n<|endoftext|>"}
{"task_id": "JavaScript/79", "prompt": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let result = '',\n    digit = '';\n  while (decimal >= 1) {\n    digit = decimal % 2;\n    result += digit;\n    decimal = decimal >> 1;\n  }\n  result = result.slice(0, -1) + 'db';\n  return result;\n};\n\nconst decimalToBinary = (decimal) => {\n  let result = '',\n    digit = '';\n  while (decimal >= 1) {\n    digit = decimal % 2;\n    result += digit;\n    decimal = decimal >> 1;\n  }\n  result = result.slice(0, -1) + 'db';\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i = binary.length - 1; i >= 0; i--) {\n    result += (binary[i] === '1')? 1 : 0;\n  }\n  return result;\n};\n\nconst binaryToDecimal = (binary) => {\n  let result = 0;\n  for (let i"}
{"task_id": "JavaScript/80", "prompt": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  let sum = 0;\n  let n = 0;\n  for (let i = 0; i < s.length; i++) {\n    n = n * 10 + s.charCodeAt(i) - '0';\n  }\n  while (n > 0) {\n    sum += n % 10;\n    n = Math.floor(n / 10);\n  }\n  return sum == 1;\n};\n\nconst main = () => {\n  console.log(isHappy(s));\n};\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/81", "prompt": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const split = grades.split('').map(Number);\n  const last = split.slice(-1);\n  const length = split.length - 1;\n  const result = [];\n\n  for (let i = 0; i < length; i++) {\n    let a = split[i];\n    let b = split[i + 1];\n    let c = split[i + 2];\n    let grade = 0;\n    if (a > b) {\n      grade += 1;\n    }\n    if (a < c) {\n      grade += 2;\n    }\n    if (a > b && a < c) {\n      grade += 3;\n    }\n    if (a > c) {\n      grade += 4;\n    }\n    result.push(grade);\n  }\n  result.push(last);\n  return result;\n};\n\nexport default numericalLetterGrade;\n<|endoftext|>"}
{"task_id": "JavaScript/82", "prompt": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  if (!isPrime(string)) {\n    return false;\n  }\n  return true;\n};\n\nexport default primeLength;\n<|endoftext|>"}
{"task_id": "JavaScript/83", "prompt": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n  let startCount = 0;\n  for (let i = 1; i < n; i++) {\n    let count = 1;\n    while (i + count < n && i + count >= 1) {\n      count++;\n    }\n    if (count === n) {\n      startCount++;\n    }\n  }\n  let endCount = 0;\n  for (let i = n - 1; i > 0; i--) {\n    let count = 1;\n    while (i - count >= 1) {\n      count++;\n    }\n    if (count === n) {\n      endCount++;\n    }\n  }\n  return {startCount, endCount};\n};\n\nconsole.log(startsOneEnds(4)); // {startCount: 1, endCount: 1}\nconsole.log(startsOneEnds(7)); // {startCount: 1, endCount: 1}\nconsole.log(startsOneEnds(9)); // {startCount: 1, endCount: 1}\nconsole.log(startsOneEnds(11)); // {startCount: 1, endCount: 2}\nconsole.log(startsOneEnds(13)); // {startCount: 1, endCount: 2}\nconsole.log(startsOneEnds(15)); // {startCount: 1, endCount: 3}\nconsole.log(startsOneEnds(17)); // {startCount: 1, endCount: 3}\nconsole.log(startsOneEnds(19)); // {startCount: 1, endCount: 4}\nconsole.log(startsOneEnds(21)); // {startCount: 1, endCount: 4}\nconsole.log(startsOneEnds(23)); // {startCount: 1, endCount: 5}\nconsole.log(startsOneEnds(25)); // {startCount: 2, endCount: 4}\nconsole.log(startsOneEnds(27)); // {startCount: 2, endCount: 4}\nconsole.log(startsOneEnds(29)); // {startCount: 2, endCount: 5}\nconsole.log(startsOneEnds(31)); // {startCount: 2, endCount: 6}\nconsole.log(startsOneEnds(33)); // {startCount: 2, endCount: 6}\nconsole.log(startsOneEnds(35)); // {startCount: 2, endCount: 7}\nconsole.log(startsOneEnds(37)); // {startCount: 3, endCount: 6}\nconsole.log(startsOneEnds(39)); // {startCount: 3, endCount: 7}\nconsole.log(startsOneEnds(41)); // {startCount: 3, endCount: 8}\nconsole.log(startsOneEnds(43)); // {startCount: 3, endCount: 8}\nconsole.log(startsOneEnds(45)); // {startCount: 3, endCount: 9}\nconsole.log(startsOneEnds(47)); // {startCount: 4, endCount: 8}\nconsole.log(startsOneEnds(49)); // {startCount: 4, endCount: 9}\nconsole.log(startsOneEnds(51)); // {startCount: 4, endCount: 10}\nconsole.log(startsOneEnds(53)); // {startCount: 4, endCount: 10}\nconsole.log(startsOneEnds(55)); // {startCount: 4, endCount: 11}\nconsole.log(startsOneEnds(57)); // {startCount: 5, endCount: 10}\nconsole.log(startsOneEnds(59)); // {startCount: 5, endCount: 11}\nconsole.log(startsOneEnds(61)); // {startCount: 5, endCount: 12}\nconsole.log(startsOneEnds(63)); // {startCount: 5, endCount: 12}\nconsole.log(startsOneEnds(65)); // {startCount: 5, endCount: 13}\nconsole.log(startsOneEnds(67)); // {startCount: 6, endCount: 12}\nconsole.log(startsOneEnds(69)); // {startCount: 6, endCount: 13}\nconsole.log(startsOneEnds(71)); // {startCount: 6, endCount: 14}\nconsole.log(startsOneEnds(73)); // {startCount: 6, endCount: 14}\nconsole.log(startsOneEnds(75)); // {startCount: 6, endCount: 15}\nconsole.log(startsOneEnds(77)); // {startCount: 7, endCount: 14}\nconsole.log(startsOneEnds(79)); // {startCount: 7, endCount: 15}\nconsole.log(startsOneEnds(81)); // {startCount: 7, endCount: 16}\nconsole.log(startsOneEnds(83)); // {startCount: 7, endCount: 16}\nconsole.log(startsOneEnds(85)); // {startCount: 7, endCount: 17}\nconsole.log(startsOneEnds(87)); // {startCount: 8, endCount: 16}\nconsole.log(startsOneEnds(89)); // {startCount: 8, endCount: 17}\nconsole.log(startsOneEnds(91)); // {startCount: 8, endCount: 18}\nconsole.log(startsOneEnds(93)); // {startCount: 8, endCount: 18}\nconsole.log(startsOneEnds(95)); // {startCount: 8, endCount: 19}\nconsole.log(startsOneEnds(97)); // {startCount: 9, endCount: 18}\nconsole.log(startsOneEnds(99)); // {startCount: 9, endCount: 19}\nconsole.log(startsOneEnds(101)); // {startCount: 9, endCount: 20}\nconsole.log(startsOneEnds(103)); // {startCount: 10, endCount: 20}\nconsole.log(startsOneEnds(105)); // {startCount: 10, endCount: 21}\nconsole.log(startsOneEnds(107)); // {startCount: 10, endCount: 21}\nconsole.log(startsOneEnds(109)); // {startCount: 10, endCount: 22}\n"}
{"task_id": "JavaScript/84", "prompt": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  const binary = (digit) => `${digit}`\n  return binary(N)\n}\n\nconsole.log(solve(147))<|endoftext|>"}
{"task_id": "JavaScript/85", "prompt": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0\n  for(let i = 0; i < lst.length; i++){\n    sum += lst[i]\n  }\n  return sum\n}\n\n/*\nGiven a linked list, remove the nth node from the end of the list.\n\nFor example,\n\n   Given linked list: 1->2->3->4->5, and n = 2.\n\n   After removing the second node from the end, the linked list becomes 1->2->3->5.\n\nNote:\nGiven n will always be valid.\nTry to do this in one pass.\n\nTags: Linked List, Two Pointers\n\n*/\n\nconst removeNode = (lst, n) => {\n  let head = lst\n  let next = lst.next\n  let count = 1\n  while(next!= null){\n    if(count == n){\n      next = next.next\n      lst.next = next\n    }\n    next = next.next\n    count++\n  }\n}\n\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = val;\n *     this.next = next;\n * }\n */\nconst removeNthNode = (head, n) => {\n  if(n == 1){\n    return head.next\n  }\n  const slow = head\n  const fast = head.next\n  let slowCount = 1\n  let fastCount = 1\n  while(fast!= null && fastCount!= n){\n    fast = fast.next\n    fastCount++\n  }\n  if(fastCount == n){\n    return slow\n  }\n  let tmp = slow\n  while(tmp.next!= null){\n    tmp = tmp.next\n    slowCount++\n  }\n  return tmp\n}\n\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nconst removeNthFromEnd = (head, n) => {\n  const slow = head\n  const fast = head.next\n  let slowCount = 1\n  let fastCount = 1\n  while(fast!= null && fastCount!= n){\n    fast = fast.next\n    fastCount++\n  }\n  if(fastCount == n){\n    return slow\n  }\n  let tmp = slow\n  while(tmp.next!= null){\n    tmp = tmp.next\n    slowCount++\n  }\n  return tmp\n}\n\nexport { add, removeNode, removeNthNode, removeNthFromEnd }\n<|endoftext|>"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let chr = '',\n    counter = 0,\n    temp = '',\n    space ='';\n  for (let i = 0; i < s.length; i++) {\n    chr = s.charAt(i);\n    if (chr === space) {\n      counter++;\n      if (counter === 2) {\n        counter = 0;\n        temp = temp + chr;\n        chr ='';\n      }\n    } else {\n      counter = 0;\n      temp = temp + chr;\n    }\n  }\n  return temp;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const row = lst[x]\n  const cnt = row.length\n  const res = []\n  for (let i = 0; i < cnt; i++) {\n    res.push((x, i))\n  }\n  res.sort((a, b) => a[0] - b[0])\n  res.sort((a, b) => b[1] - a[1], (a, b) => a[0] - b[0])\n  return res\n}\n\nconst getCol = (lst, y) => {\n  const col = lst[y]\n  const cnt = col.length\n  const res = []\n  for (let i = 0; i < cnt; i++) {\n    res.push((i, y))\n  }\n  res.sort((a, b) => a[1] - b[1])\n  res.sort((a, b) => b[0] - a[0], (a, b) => a[1] - b[1])\n  return res\n}\n\nconst getRowCol = (lst, x, y) => {\n  return [\n    (x, y),\n   ...getRow(lst, x),\n   ...getCol(lst, y)\n  ]\n}\n\nconst getRect = (lst, x, y, w, h) => {\n  const res = []\n  const r = w + x\n  const c = h + y\n  for (let i = 0; i < r; i++) {\n    for (let j = 0; j < c; j++) {\n      res.push(getRowCol(lst, x + i, y + j))\n    }\n  }\n  return res\n}\n\nconst getRect1 = (lst, x, y, w, h) => {\n  const res = []\n  const r = w + x\n  const c = h + y\n  for (let i = 0; i < r; i++) {\n    for (let j = 0; j < c; j++) {\n      res.push(getRowCol(lst, x + i, y + j))\n    }\n  }\n  return res\n}\n\nconst getRect2 = (lst, x, y, w, h) => {\n  const res = []\n  const r = w + x\n  const c = h + y\n  for (let i = 0; i < r; i++) {\n    for (let j = 0; j < c; j++) {\n      res.push(getRowCol(lst, x + i, y + j))\n    }\n  }\n  return res\n}\n\nconst getRect3 = (lst, x, y, w, h) => {\n  const res = []\n  const r = w + x\n  const c = h + y\n  for (let i = 0; i < r; i++) {\n    for (let j = 0; j < c; j++) {\n      res.push(getRowCol(lst, x + i, y + j))\n    }\n  }\n  return res\n}\n\nconst getRect4 = (lst, x, y, w, h) => {\n  const res = []\n  const r = w + x\n  const c = h + y\n  for (let i = 0; i < r; i++) {\n    for (let j = 0; j < c; j++) {\n      res.push(getRowCol(lst, x + i, y + j))\n    }\n  }\n  return res\n}\n\nconst getRect5 = (lst, x, y, w, h) => {\n  const res = []\n  const r = w + x\n  const c = h + y\n  for (let i = 0; i < r; i++) {\n    for (let j = 0; j < c; j++) {\n      res.push(getRowCol(lst, x + i, y + j))\n    }\n  }\n  return res\n}\n\nconst getRect6 = (lst, x, y, w, h) => {\n  const res = []\n  const r = w + x\n  const c = h + y\n  for (let i = 0; i < r; i++) {\n    for (let j = 0; j < c; j++) {\n      res.push(getRowCol(lst, x + i, y + j))\n    }\n  }\n  return res\n}\n\nconst getRect7 = (lst, x, y, w, h) => {\n  const res = []\n  const r = w + x\n  const c = h + y\n  for (let i = 0; i < r; i++) {\n    for (let j = 0; j < c; j++) {\n      res.push(getRowCol(lst, x + i, y + j))\n    }\n  }\n  return res\n}\n\nconst getRect8 = (lst, x, y, w, h) => {\n  const res = []\n  const r = w + x\n  const c = h + y\n  for (let i = 0; i < r; i++) {\n    for (let j = 0; j < c; j++) {\n      res.push(get"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let len = array.length;\n  if(len <= 1) return array;\n\n  let index = 0;\n  let first = 0;\n  let second = 0;\n\n  let oddSum = 0;\n  let evenSum = 0;\n\n  while(index < len) {\n    first = array[index];\n    second = array[index + 1];\n    if(first > second) {\n      swap(array, index, index + 1);\n    }\n    oddSum += first;\n    evenSum += second;\n\n    index += 2;\n  }\n\n  if(oddSum % 2 == 1) {\n    return array.slice(0, len).reverse();\n  }\n\n  return array;\n};\n\nmodule.exports = sortArray;\n<|endoftext|>"}
{"task_id": "JavaScript/89", "prompt": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let res = '';\n  let a = s.split('');\n  let l = a.length;\n  let c = 'a'\n  for (var i = 0; i < l; i++){\n    if(i % 2 == 0){\n      c = a[i];\n    }\n    else{\n      c = a[i].toUpperCase();\n    }\n    res += c;\n  }\n  return res;\n};\n\n/*\n  decrypt takes a string and returns a string decrypted\n  with the al'habet rotated.\n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'et'\n  decrypt('ix') returns 'gf'\n  */\nconst decrypt = (s) => {\n  let res = '';\n  let a = s.split('');\n  let l = a.length;\n  let c = 'a'\n  for (var i = 0; i < l; i++){\n    if(i % 2 == 0){\n      c = a[i];\n    }\n    else{\n      c = a[i].toLowerCase();\n    }\n    res += c;\n  }\n  return res;\n};\n\n/*\n  This function takes two strings and returns their product\n  */\nconst product = (s1, s2) => {\n  let a = s1.split('');\n  let b = s2.split('');\n  let l = a.length;\n  let c = 0;\n  for (var i = 0; i < l; i++){\n    c += a[i] * b[i];\n  }\n  return c;\n};\n\n/*\n  This function takes two strings and returns their sum\n  */\nconst sum = (s1, s2) => {\n  let a = s1.split('');\n  let b = s2.split('');\n  let l = a.length;\n  let c = 0;\n  for (var i = 0; i < l; i++){\n    c += parseInt(a[i]);\n  }\n  for (var i = 0; i < l; i++){\n    c += parseInt(b[i]);\n  }\n  return c;\n};\n\nmodule.exports = {\n  encrypt,\n  decrypt,\n  product,\n  sum\n};<|endoftext|>"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let result = null\n  lst.forEach((x, i) => {\n    if (i === 0) {\n      return\n    }\n    if (result === null || x < result) {\n      result = x\n    }\n  })\n  if (result === null) {\n    return undefined\n  }\n  return result\n}\n\nconst list = [1, 2, 3, 4, 5]\n\nconsole.log(nextSmallest(list))\nconsole.log(nextSmallest(list))\nconsole.log(nextSmallest(list))\n<|endoftext|>"}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === '.' || S[i] === '?' || S[i] === '!') {\n      count += 1\n    } else if (S[i] === 'I') {\n      count += 1\n    }\n  }\n  return count\n}\n\nmodule.exports = isBored\n<|endoftext|>"}
{"task_id": "JavaScript/92", "prompt": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  return ((x === (z + y)) && (x === parseInt(x)));\n};\n\n// ### anyInt\nconst anyInt = (x, y, z) => {\n  return ((x === (z + y)) && (x === parseInt(x)));\n};\n\n// ### isValidNumber\nconst isValidNumber = (num) => {\n  return (num % 1 === 0 && num >= 0);\n};\n\n// ### isPrime\nconst isPrime = (num) => {\n  if (num === 2) return true;\n  if (num % 2 === 0) return false;\n  if (num === 1) return false;\n  if (num % 3 === 0) return false;\n  let count = 4;\n  while (count * count <= num) {\n    if (num % count === 0) return false;\n    count += 2;\n  }\n  return true;\n};\n\n// ### isPalindrome\nconst isPalindrome = (num) => {\n  return num === parseInt(num, 10);\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### isPalindrome\nconst isPalindrome = (num) => {\n  return (num === parseInt(num, 10));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n// ### palindrome\nconst palindrome = (num) => {\n  return (num.toString() === new Array(num + 1).reverse().join(''));\n};\n\n//"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = ''\n  message.split('').forEach(c => {\n    if (c.toLowerCase() === c) {\n      if (c.toUpperCase() === c) {\n        encoded += '2'\n      } else {\n        encoded += '1'\n      }\n    } else {\n      encoded += c.toUpperCase()\n    }\n  })\n  return encoded\n}\n\n/*\n  Wrihe a function that takes a message, and decodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> decode('test')\n  'TEST'\n  >>> decode('This is a message')\n  'this is a message'\n  */\nconst decode = (message) => {\n  let decoded = ''\n  message.split('').forEach(c => {\n    if (c.toLowerCase() === c) {\n      if (c.toUpperCase() === c) {\n        decoded += 't'\n      } else {\n        decoded += 'T'\n      }\n    } else {\n      decoded += c.toLowerCase()\n    }\n  })\n  return decoded\n}\n\nconst test = () => {\n  console.log(encode('this is a message'))\n  console.log(decode('this is a message'))\n}\n\ntest()\n<|endoftext|>"}
{"task_id": "JavaScript/94", "prompt": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let rst = 0\n  for (let i = 0; i < lst.length; i += 1) {\n    rst += (lst[i] % 10).toString()\n  }\n  return rst\n}\n\nconst prime = (lst) => {\n  let rst = 0\n  for (let i = 0; i < lst.length; i += 1) {\n    if (lst[i] % 2 === 0) {\n      rst += (lst[i] % 10).toString()\n    }\n  }\n  return rst\n}\n\nconst allPrime = (lst) => {\n  let rst = 0\n  for (let i = 0; i < lst.length; i += 1) {\n    if (lst[i] % 2 === 0) {\n      rst += (lst[i] % 10).toString()\n    }\n  }\n  return rst\n}\n\nconst isPrime = (lst) => {\n  for (let i = 0; i < lst.length; i += 1) {\n    if (lst[i] % 2 === 0) {\n      return false\n    }\n  }\n  return true\n}\n\nconst isPrime2 = (lst) => {\n  for (let i = 0; i < lst.length; i += 1) {\n    if (lst[i] % 2 === 0) {\n      for (let j = i + 1; j < lst.length; j += 1) {\n        if (lst[i] % lst[j] === 0) {\n          return false\n        }\n      }\n    }\n  }\n  return true\n}\n\nconst isPrime3 = (lst) => {\n  let i = 2\n  while (i < lst.length) {\n    if (lst[i] % 2 === 0) {\n      for (let j = i + 1; j < lst.length; j += 1) {\n        if (lst[i] % lst[j] === 0) {\n          return false\n        }\n      }\n    }\n    i += 1\n  }\n  return true\n}\n\nconst primeSieve = (lst) => {\n  let isPrime = []\n  let i = 2\n  while (i < lst.length) {\n    if (lst[i] % 2 === 0) {\n      isPrime.push(i)\n    }\n    i += 1\n  }\n  return isPrime\n}\n\nconst primeSieve2 = (lst) => {\n  let isPrime = []\n  let i = 2\n  while (i < lst.length) {\n    if (lst[i] % 2 === 0) {\n      for (let j = i + 1; j < lst.length; j += 1) {\n        if (lst[i] % lst[j] === 0) {\n          return false\n        }\n      }\n      isPrime.push(i)\n    }\n    i += 1\n  }\n  return isPrime\n}\n\nconst isPrime = (lst) => {\n  for (let i = 0; i < lst.length; i += 1) {\n    if (lst[i] % 2 === 0) {\n      return false\n    }\n  }\n  return true\n}\n\nconst primeSieve3 = (lst) => {\n  let isPrime = []\n  let i = 2\n  while (i < lst.length) {\n    if (lst[i] % 2 === 0) {\n      for (let j = i + 1; j < lst.length; j += 1) {\n        if (lst[i] % lst[j] === 0) {\n          return false\n        }\n      }\n      isPrime.push(i)\n    }\n    i += 1\n  }\n  return isPrime\n}\n\nconst count = (lst) => {\n  let count = 0\n  for (let i = 0; i < lst.length; i += 1) {\n    if (lst[i] % 2 === 0) {\n      count += 1\n    }\n  }\n  return count\n}\n\nconst sumOfDigits = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i += 1) {\n    sum += (lst[i] % 10).toString()\n  }\n  return sum\n}\n\nconst largestPrime = (lst) => {\n  let largestPrime = 0\n  for (let i = 0; i < lst.length; i += 1) {\n    if (isPrime(lst[i])) {\n      largestPrime = lst[i]\n    }\n  }\n  return largestPrime\n}\n\nconst sumOfDigits2 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i += 1) {\n    sum += (lst[i] % 10).toString()\n  }\n  return sum\n}\n\nconst largestPrime2 = (lst) => {\n  let largestPrime = 0\n  for (let i = 0; i < lst.length; i += 1"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const upperCases = {\n    \"A\": \"A\",\n    \"B\": \"B\",\n    \"C\": \"C\",\n    \"D\": \"D\",\n    \"E\": \"E\",\n    \"F\": \"F\",\n    \"G\": \"G\",\n    \"H\": \"H\",\n    \"I\": \"I\",\n    \"J\": \"J\",\n    \"K\": \"K\",\n    \"L\": \"L\",\n    \"M\": \"M\",\n    \"N\": \"N\",\n    \"O\": \"O\",\n    \"P\": \"P\",\n    \"Q\": \"Q\",\n    \"R\": \"R\",\n    \"S\": \"S\",\n    \"T\": \"T\",\n    \"U\": \"U\",\n    \"V\": \"V\",\n    \"W\": \"W\",\n    \"X\": \"X\",\n    \"Y\": \"Y\",\n    \"Z\": \"Z\"\n  };\n  const dictCases = Object.keys(dict);\n  let isAllStr = true;\n  dictCases.forEach(key => {\n    const value = dict[key];\n    if (typeof value === \"string\") {\n      const valueCase = value.toUpperCase();\n      const upperCase = upperCases[key];\n      if (upperCase!== valueCase) {\n        isAllStr = false;\n      }\n    }\n  });\n  return isAllStr;\n};\n\nexport {checkDictCase};<|endoftext|>"}
{"task_id": "JavaScript/96", "prompt": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const arr = []\n  for (let i = 1; i < n; i++) {\n    if (isPrime(i)) {\n      arr.push(i)\n    }\n  }\n  return arr\n}\n\n/*\n  Implfment a function that takes a non-negative number and returns true if\n  the number is prime, false otherwise.\n  for example:\n  isPrime(0) => false\n  isPrime(2) => true\n  isPrime(7) => true\n  isPrime(15) => true\n  isPrime(21) => false\n  isPrime(16) => false\n  */\nconst isPrime = (n) => {\n  if (n < 2) return false\n  if (n === 2) return true\n  const sqrRoot = (n - 1) / 2\n  for (let i = 2; i <= sqrRoot; i++) {\n    if (n % i === 0) return false\n  }\n  return true\n}\n\n/*\n  Implfment a function that takes a non-negative number and returns true if\n  the number is divisible by prime number, false otherwise.\n  for example:\n  isPrimeDiv(2) => true\n  isPrimeDiv(6) => false\n  isPrimeDiv(8) => true\n  isPrimeDiv(9) => true\n  isPrimeDiv(20) => true\n  */\nconst isPrimeDiv = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  const sqrRoot = (n - 1) / 2\n  for (let i = 2; i <= sqrRoot; i++) {\n    if (n % i === 0) return false\n  }\n  return true\n}\n\n/*\n  Implfment a function that takes a non-negative number and returns true if\n  the number is even, false otherwise.\n  for example:\n  isEven(2) => false\n  isEven(4) => true\n  isEven(6) => false\n  */\nconst isEven = (n) => {\n  if (n % 2 === 0) return true\n  return false\n}\n\n/*\n  Implfment a function that takes a non-negative number and returns true if\n  the number is odd, false otherwise.\n  for example:\n  isOdd(2) => true\n  isOdd(4) => false\n  isOdd(6) => true\n  */\nconst isOdd = (n) => {\n  if (n % 2!== 0) return true\n  return false\n}\n\n/*\n  Implfment a function that takes a non-negative number and returns true if\n  the number is even, false otherwise.\n  for example:\n  isEven(2) => true\n  isEven(4) => false\n  isEven(6) => true\n  */\nconst isEvenDiv = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  const sqrRoot = (n - 1) / 2\n  for (let i = 2; i <= sqrRoot; i++) {\n    if (n % i === 0) return false\n  }\n  return true\n}\n\n/*\n  Implfment a function that takes a non-negative number and returns true if\n  the number is odd, false otherwise.\n  for example:\n  isOdd(2) => true\n  isOdd(4) => false\n  isOdd(6) => true\n  */\nconst isOddDiv = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  const sqrRoot = (n - 1) / 2\n  for (let i = 2; i <= sqrRoot; i++) {\n    if (n % i === 0) return false\n  }\n  return true\n}\n\n/*\n  Implfment a function that takes a non-negative number and returns true if\n  the number is divisible by prime number, false otherwise.\n  for example:\n  isPrimeDiv(2) => true\n  isPrimeDiv(6) => false\n  isPrimeDiv(8) => true\n  isPrimeDiv(9) => true\n  isPrimeDiv(20) => true\n  */\nconst isPrimeDiv2 = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  const sqrRoot = (n - 1) / 2\n  for (let i = 2; i <= sqrRoot; i++) {\n    if (n % i === 0) return false\n  }\n  return true\n}\n\n/*\n  Implfment a function that takes a non-negative number and returns true if\n  the number is divisible by prime number, false otherwise.\n  for example:\n  isPrimeDiv(2) => true\n  isPrimeDiv(6) => false\n  isPrimeDiv(8) => true\n  isPrimeDiv(9) => true\n  isPrimeDiv(20) => true\n  */\nconst isPrimeDiv3 = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  const sqrRoot = (n - 1) / 2\n  for (let i = 2; i <= sqrRoot; i++) {\n    if (n % i === 0) return false\n  }\n  return true\n}\n\n/*\n  Implfment a function that takes a non-negative number and returns true if\n  the number is even, false otherwise.\n  for example:\n  isEven(2) => true\n  isEven(4) => false\n  isEven(6) => false\n  */\nconst isEvenDiv2 = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  const sqrRoot = (n - 1) / 2\n  for (let i ="}
{"task_id": "JavaScript/97", "prompt": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  const sum = a + b;\n  const sum_int = sum % 10;\n  const sum_dec = sum / 10;\n  const dec = parseInt(sum_dec);\n  const int = parseInt(sum_int);\n  let result = 0;\n  if (dec >= 0) {\n    result += dec;\n  }\n  if (int >= 0) {\n    result += int;\n  }\n  return result;\n};\n\n/*\n* Test the function\n*\n* multiply(1, 2) should return 2\n* multiply(2, 3) should return 6\n* multiply(3, 4) should return 12\n* multiply(4, 5) should return 20\n* multiply(10, 15) should return 0\n* multiply(0, 0) should return 0\n* multiply(9, -15) should return -1\n* multiply(11, -5) should return 1\n* multiply(-10, -20) should return -1\n*/\nconst tes = (a, b) => {\n  const result = multiply(a, b);\n  console.log(`${a} * ${b} = ${result}`);\n};\n\nconst test = () => {\n  tes(1, 2);\n  tes(2, 3);\n  tes(3, 4);\n  tes(4, 5);\n  tes(10, 15);\n  tes(0, 0);\n  tes(9, -15);\n  tes(11, -5);\n  tes(-10, -20);\n};\n\n//test();\n\n//TODO:\n//1. make an array with the length of the product of the two integers\n//2. take the unit digit of each integer and add the number to the array\n//3. return the result\n<|endoftext|>"}
{"task_id": "JavaScript/98", "prompt": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let cnt = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i+1].toUpperCase()) {\n      cnt++;\n    }\n  }\n  return cnt;\n}\n\n/*\n  Givfn a string s, count the number of lowercase cowels in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let cnt = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toLowerCase() === s[i+1].toLowerCase()) {\n      cnt++;\n    }\n  }\n  return cnt;\n}\n\n/*\n  Givfn a string s, count the number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 2\n  */\nconst countVowels = (s) => {\n  let cnt = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i+1].toUpperCase()) {\n      cnt++;\n    }\n  }\n  if (cnt === 0) {\n    for (let i = 0; i < s.length; i += 2) {\n      if (s[i].toLowerCase() === s[i+1].toLowerCase()) {\n        cnt++;\n      }\n    }\n  }\n  return cnt;\n}\n\n/*\n  Givfn a string s, count the number of consonants in even indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 1\n  countConsonants('abcdefg') returns 0\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonants = (s) => {\n  let cnt = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i+1].toUpperCase()) {\n      cnt++;\n    }\n  }\n  return cnt;\n}\n\n/*\n  Givfn a string s, count the number of consonants in odd indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 0\n  countConsonants('abcdefg') returns 1\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonantsOdd = (s) => {\n  let cnt = 0;\n  for (let i = 1; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i+1].toUpperCase()) {\n      cnt++;\n    }\n  }\n  return cnt;\n}\n\n/*\n  Givfn a string s, count the number of vowels in odd indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 0\n  countVowels('abcdefg') returns 1\n  countVowels('dBBE') returns 2\n  */\nconst countVowelsOdd = (s) => {\n  let cnt = 0;\n  for (let i = 1; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i+1].toUpperCase()) {\n      cnt++;\n    }\n  }\n  return cnt;\n}\n\n/*\n  Givfn a string s, count the number of consonants in odd indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 1\n  countConsonants('abcdefg') returns 0\n  countConsonants('dBBE') returns 1\n  */\nconst countConsonantsOdd2 = (s) => {\n  let cnt = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i+1].toUpperCase()) {\n      cnt++;\n    }\n  }\n  return cnt;\n}\n\n/*\n  Givfn a string s, count the number of vowels in odd indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 0\n  countVowels('abcdefg') returns 1\n  countVowels('dBBE') returns 2\n  */\nconst countVowelsOdd2 = (s) => {\n  let cnt = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i+1].toUpperCase()) {\n      cnt++;\n    }\n  }\n  return cnt;\n}\n\n/*\n  Givfn a string s, count the number of consonants in even indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 1\n  countConsonants('abcdefg') returns 0\n  countConsonants('dBBE') returns 0\n  */\nconst countConsonantsOdd3 = (s) => {\n  let cnt = 0;\n  for (let i = 1; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i+1].toUpperCase()) {\n      cnt++;\n    }\n  }\n  return cnt;\n}\n\n/*\n  Givfn a string s, count the number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdef"}
{"task_id": "JavaScript/99", "prompt": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n    const [int, dec] = splitNumber(value);\n    const closest = [int, 0];\n    let distance = Math.abs(dec);\n\n    while (distance > 0) {\n        closest = [Math.floor(int) + (dec < 0? -1 : 1), Math.floor(dec)];\n        distance -= 1;\n    }\n\n    return closest[0];\n};\n\n/* \n  Crewte a function that takes a value (string) represebting e number\n  and returns the closest floating point number to mt. If the bumber\n  is equidistant from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestFloat(\"10.3\")\n  10.3\n  >>> closestFloat(\"15.3\")\n  15.3\n  >>> closestFloat(\"15.5\")\n  15.5\n  >>> closestFloat(\"-15.5\")\n  -15.5\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestFloat(\"14.5\") should\n  return 15.0 and closestFloat(\"-14.5\") should return -15.0.\n  */\nconst closestFloat = (value) => {\n    const [int, dec] = splitNumber(value);\n    const closest = [int, 0];\n    let distance = Math.abs(dec);\n\n    while (distance > 0) {\n        closest = [Math.floor(int) + (dec < 0? -1 : 1), Math.floor(dec)];\n        distance -= 1;\n    }\n\n    return closest[1];\n};\n\n/* \n  Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestHexadecimal(\"10\")\n  10\n  >>> closestHexadecimal(\"15.3\")\n  15\n  >>> closestHexadecimal(\"15.5\")\n  15\n  >>> closestHexadecimal(\"-15.5\")\n  -15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestHexadecimal(\"14.5\") should\n  return 15 and closestHexadecimal(\"-14.5\") should return -15.\n  */\nconst closestHexadecimal = (value) => {\n    const [int, dec] = splitNumber(value);\n    const closest = [int, 0];\n    let distance = Math.abs(dec);\n\n    while (distance > 0) {\n        closest = [Math.floor(int) + (dec < 0? -1 : 1), Math.floor(dec)];\n        distance -= 1;\n    }\n\n    return closest[0].toString(16);\n};\n\n/* \n  Crewte a function that takes a value (string) represebting e number\n  and returns the closest floating point number to mt. If the bumber\n  is equidistant from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestDecimal(\"10.3\")\n  10.3\n  >>> closestDecimal(\"15.3\")\n  15.3\n  >>> closestDecimal(\"15.5\")\n  15.5\n  >>> closestDecimal(\"-15.5\")\n  -15.5\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestDecimal(\"14.5\") should\n  return 15.0 and closestDecimal(\"-14.5\") should return -15.0.\n  */\nconst closestDecimal = (value) => {\n    const [int, dec] = splitNumber(value);\n    const closest = [int, 0];\n    let distance = Math.abs(dec);\n\n    while (distance > 0) {\n        closest = [Math.floor(int) + (dec < 0? -1 : 1), Math.floor(dec)];\n        distance -= 1;\n    }\n\n    return closest[1];\n};\n\n/* \n  Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestOctal(\"10\")\n  10\n  >>> closestOctal(\"15.3\")\n  15\n  >>> closestOctal(\"15.5\")\n  15\n  >>> closestOctal(\"-15.5\")\n  -15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestOctal(\"14.5\") should\n  return 15 and closestOctal(\"-14.5\") should return -15.\n  */\nconst closestOctal = (value) => {\n    const [int, dec] = splitNumber(value);\n    const closest = [int, 0];\n    let distance = Math.abs(dec);\n\n    while (distance > 0) {\n        closest = [Math.floor(int) + (dec < 0? -1 : 1), Math.floor(dec)];\n        distance -= 1;\n    }\n\n    return closest[0].toString(8);\n};\n\nexport {\n    closestInteger,\n    cl"}
{"task_id": "JavaScript/100", "prompt": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n    const res = [];\n    let nxt = n;\n    while (nxt > 0) {\n        res.push(nxt % 2 == 0? nxt : nxt - 1);\n        nxt = nxt / 2;\n    }\n    return res;\n};\n\n/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n    const res = [];\n    let nxt = n;\n    while (nxt > 0) {\n        res.push(nxt % 2 == 0? nxt : nxt - 1);\n        nxt = nxt / 2;\n    }\n    return res;\n};\n\n/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n    const res = [];\n    let nxt = n;\n    while (nxt > 0) {\n        res.push(nxt % 2 == 0? nxt : nxt - 1);\n        nxt = nxt / 2;\n    }\n    return res;\n};\n\n/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n    const res = [];\n    let nxt = n;\n    while (nxt > 0) {\n        res.push(nxt % 2 == 0? nxt : nxt - 1);\n        nxt = nxt / 2;\n    }\n    return res;\n};\n\nconst makeAPile = (n) => {\n    const res = [];\n    let nxt = n;\n    while (nxt > 0) {\n        res.push(nxt % 2 == 0? nxt : nxt - 1);\n        nxt = nxt / 2;\n    }\n    return res;\n};\n\nconst makeAPile = (n) => {\n    const res = [];\n    let nxt = n;\n    while (nxt > 0) {\n        res.push(nxt % 2 == 0? nxt : nxt - 1);\n        nxt = nxt / 2;\n    }\n    return res;\n};\n\nmodule.exports = makeAPile;\n<|endoftext|>"}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let res = [];\n  let currWord = \"\";\n  let isInsideWord = false;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] =='' || s[i] == ',') {\n      if (isInsideWord) {\n        res.push(currWord);\n        currWord = \"\";\n      }\n      if (s[i] =='') {\n        isInsideWord = false;\n      } else {\n        isInsideWord = true;\n      }\n    } else {\n      currWord += s[i];\n    }\n  }\n  if (isInsideWord) {\n    res.push(currWord);\n  }\n  return res;\n}\n\n/*\n  Given an array of words, return an array of arrays where each inner array is a word.\n  Example:\n  arr = [\"one\", \"two\", \"three\", \"four\", \"five\"]\n  returns: [['one', 'two', 'three', 'four', 'five'], ['one', 'two', 'three', 'four'], ['one', 'two', 'three'], ['one', 'two'], ['one']]\n  */\nconst splitArrayByWords = (arr) => {\n  let res = [];\n  for (let i = 0; i < arr.length; i++) {\n    let curr = wordsString(arr[i]);\n    for (let j = 0; j < curr.length; j++) {\n      let currWord = curr[j];\n      res.push([currWord]);\n    }\n  }\n  return res;\n}\n\nconst arr = [\"one\", \"two\", \"three\", \"four\", \"five\"]\nconst result = splitArrayByWords(arr);\nconsole.log(result);\n<|endoftext|>"}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  // eslint-disable-next-line no-param-reassign\n  x = Math.floor(x);\n  y = Math.floor(y);\n  let a = x;\n  let b = y;\n  let c = 0;\n  let i = 1;\n  while (b > 0) {\n    c = a % b;\n    if (c === 0) {\n      return i;\n    }\n    a = b;\n    b = c;\n    i += 2;\n  }\n  return -1;\n};\n\nmodule.exports = chooseNum;\n<|endoftext|>"}
{"task_id": "JavaScript/103", "prompt": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const nums = Array(n).fill(0);\n  const denominator = m - n + 1;\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / denominator);\n    result -= nums[i] * denominator;\n  }\n  return nums.join('b');\n};\n\nconst sum = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b');\n};\n\nconst average = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b');\n};\n\nconst average2 = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b');\n};\n\nconst average3 = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b');\n};\n\nconst average4 = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b');\n};\n\nconst average5 = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b');\n};\n\nconst average6 = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b');\n};\n\nconst average7 = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b');\n};\n\nconst average8 = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b');\n};\n\nconst average9 = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b');\n};\n\nconst average10 = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b');\n};\n\nconst average11 = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b');\n};\n\nconst average12 = (n, m) => {\n  const nums = Array(n).fill(0);\n  let result = 0;\n  for (let i = n; i <= m; i++) {\n    result += i;\n    nums[i] = Math.floor(result / m);\n    result -= nums[i] * m;\n  }\n  return nums.join('b"}
{"task_id": "JavaScript/104", "prompt": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  if (!x || typeof x!== 'number' || x < 0)\n    throw new Error('input must be a positive integer');\n  let res = [];\n  let temp = x;\n  while (temp > 0) {\n    let digit = x % 10;\n    if (digit % 2 === 0)\n      return res;\n    res.push(digit);\n    temp = Math.floor(temp / 10);\n  }\n  return res;\n};\n\nexport default uniqueDigits;\n<|endoftext|>"}
{"task_id": "JavaScript/105", "prompt": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n    let revArr = [];\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] < 10) {\n            revArr.push(arr[i]);\n        }\n    }\n    return revArr;\n}\n\nconst byDigit = (arr) => {\n    let revArr = [];\n    for (let i = 0; i < arr.length; i++) {\n        revArr.push(arr[i]);\n    }\n    return revArr;\n}\n\nconst byLetter = (arr) => {\n    let revArr = [];\n    for (let i = 0; i < arr.length; i++) {\n        revArr.push(arr[i]);\n    }\n    return revArr;\n}\n\nconst sort = (arr) => {\n    let arr2 = [];\n    let arr3 = [];\n    let arr4 = [];\n    let arr5 = [];\n    let arr6 = [];\n    let arr7 = [];\n    let arr8 = [];\n    let arr9 = [];\n    let len = arr.length;\n    for (let i = 0; i < len; i++) {\n        if (arr[i] >= 10) {\n            arr2.push(arr[i]);\n        }\n        if (arr[i] < 10) {\n            arr3.push(arr[i]);\n        }\n        if (arr[i] >= 2 && arr[i] < 10) {\n            arr4.push(arr[i]);\n        }\n        if (arr[i] >= 3 && arr[i] < 10) {\n            arr5.push(arr[i]);\n        }\n        if (arr[i] >= 4 && arr[i] < 10) {\n            arr6.push(arr[i]);\n        }\n        if (arr[i] >= 5 && arr[i] < 10) {\n            arr7.push(arr[i]);\n        }\n        if (arr[i] >= 6 && arr[i] < 10) {\n            arr8.push(arr[i]);\n        }\n        if (arr[i] >= 7 && arr[i] < 10) {\n            arr9.push(arr[i]);\n        }\n    }\n    arr2.sort();\n    arr3.sort();\n    arr4.sort();\n    arr5.sort();\n    arr6.sort();\n    arr7.sort();\n    arr8.sort();\n    arr9.sort();\n    let result = arr2.concat(arr3, arr4, arr5, arr6, arr7, arr8, arr9);\n    return result;\n}\n\nconst main = () => {\n    let arr = [2, 1, 1, 4, 5, 8, 2, 3];\n    console.log(byLetter(arr));\n    console.log(byLength(arr));\n    console.log(byDigit(arr));\n    console.log(sort(arr));\n}\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/106", "prompt": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let a = [1];\n  for (let i = 1; i <= n; i++) {\n    a = [...a, (...a) * i];\n  }\n  return a;\n};\n\nconst factorial = (n) => f(n);\n\nconsole.log(factorial(5));\n\n/*\n  Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is odd\n  or the sum of numbexs from 1 to i - 1 othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f1 = (n) => {\n  let a = [1];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1) {\n      a = [...a, (...a) * i];\n    } else {\n      a = [...a, i];\n    }\n  }\n  return a;\n};\n\nconst factorial1 = (n) => f1(n);\n\nconsole.log(factorial1(5));\n<|endoftext|>"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const odds = []\n  const oddsIndex = []\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      odds.push(i)\n      oddsIndex.push(i)\n    }\n  }\n  const evens = []\n  const evensIndex = []\n  for (let i = 1; i <= n; i++) {\n    if (i % 2!== 0) {\n      evens.push(i)\n      evensIndex.push(i)\n    }\n  }\n  return [odds.length, evens.length]\n}\n<|endoftext|>"}
{"task_id": "JavaScript/108", "prompt": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let num of arr) {\n    if (num > 0) {\n      sum += num;\n    } else {\n      sum -= Math.abs(num);\n    }\n  }\n  return sum;\n};\n\n// TESTING\n\n// console.log(countNums([-1, 11, -11])); // 1\n// console.log(countNums([1, 1, 2])); // 3\n<|endoftext|>"}
{"task_id": "JavaScript/109", "prompt": "/*We hwve an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "/*We hwve an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (!arr) {\n    return false;\n  }\n  const len = arr.length;\n  if (!len) {\n    return true;\n  }\n  const sortedArr = arr.sort((a, b) => a - b);\n  for (let i = 0; i < len; i++) {\n    if (sortedArr[i]!== arr[i]) {\n      return false;\n    }\n    const j = sortedArr.indexOf(arr[i]);\n    const n = j + 1;\n    const k = sortedArr.indexOf(arr[i - 1]);\n    const m = k + 1;\n    const arr2 = [...sortedArr.slice(0, n),...sortedArr.slice(m, sortedArr.length)];\n    arr2.sort((a, b) => a - b);\n    if (arr2[0]!== arr[i]) {\n      return false;\n    }\n    arr.splice(i, 1);\n    i--;\n  }\n  return true;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/110", "prompt": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let i = 0, j = 0;\n  while (i < lst1.length && j < lst2.length) {\n    if (lst1[i] < lst2[j]) {\n      lst1[i] = lst1[i] * 2;\n      i++;\n    } else if (lst1[i] > lst2[j]) {\n      lst1[j] = lst1[j] * 2;\n      j++;\n    } else {\n      lst1[i] = lst1[i] * 2;\n      lst2[j] = lst2[j] * 2;\n      i++;\n      j++;\n    }\n  }\n  if (i < lst1.length) {\n    return \"NO\";\n  } else if (j < lst2.length) {\n    return \"NO\";\n  } else {\n    return \"YES\";\n  }\n};\n\nconst t = tanes(exchange);\nconsole.log(t);\n<|endoftext|>"}
{"task_id": "JavaScript/111", "prompt": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n    const hist = {}\n    const test = test.toLowerCase()\n    for(let i = 0; i < test.length; i++){\n        if(!hist[test[i]])\n            hist[test[i]] = 1\n        else\n            hist[test[i]]++\n    }\n    return hist\n}\n\n/*\n  Given a list of words, return a dictionary of the words with the most\n  repetition.\n  \n  Example:\n  repetition('a b c', ['a', 'b', 'c', 'a', 'b', 'c', 'c', 'a']) == {'a': 3, 'b': 2, 'c': 3}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g']) == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1}\n  repetition('a b c', ['a', 'b', 'c', 'a', 'b', 'c', 'c', 'a']) == {'a': 3, 'b': 2, 'c': 3}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g']) == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'd']) == {'a': 2, 'b': 1, 'c': 1, 'd': 2, 'e': 1, 'f': 1, 'g': 1}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']) == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'a']) == {'a': 3, 'b': 2, 'c': 3, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']) == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'd']) == {'a': 2, 'b': 1, 'c': 1, 'd': 2, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']) == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1, 'j': 1}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'a']) == {'a': 3, 'b': 2, 'c': 3, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1, 'j': 1}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']) == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1, 'j': 1, 'k': 1}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'k']) == {'a': 2, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1, 'j': 1, 'k': 2}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l']) == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1, 'j': 1, 'k': 1, 'l': 1}\n  repetition('a b c', ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m']) == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1, 'i': 1, 'j': 1, '"}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let res = [];\n  for (let i = 0; i < s.length; i++) {\n    if (c.indexOf(s[i])!== -1) {\n      res.push(s[i]);\n      s = s.slice(1);\n    }\n  }\n  return [res.reverse().join(''), isPalindrome(s.reverse().join(''))];\n};\n\nmodule.exports = {\n  reverseDelete: reverseDelete\n};\n<|endoftext|>"}
{"task_id": "JavaScript/113", "prompt": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const n = lst.length\n  let res = []\n  for(let i=0;i<n;i++) {\n    const str = lst[i]\n    let count = 0\n    for(let j=0;j<str.length;j++) {\n      if(str[j] % 2) {\n        count += 1\n      }\n    }\n    res.push(`the number of odd elements ${count} in the ${i}th str1ng`)\n  }\n  return res\n}\n<|endoftext|>"}
{"task_id": "JavaScript/114", "prompt": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const len = nums.length;\n  let minSum = nums[0];\n  let currentSum = nums[0];\n  let currentIndex = 0;\n  let currentMinSum = currentSum;\n  let currentMinIndex = currentIndex;\n  let currentIndexInArray = 0;\n  let minSumOfSubArray = nums[0];\n  for (let i = 1; i < len; i++) {\n    currentSum = currentSum + nums[i];\n    if (currentSum > 0) {\n      if (currentSum < minSum) {\n        minSum = currentSum;\n        currentMinSum = currentSum;\n        currentMinIndex = currentIndex;\n        currentIndexInArray = i;\n      } else if (currentSum == minSum) {\n        if (nums[i] < nums[currentMinIndex]) {\n          currentMinIndex = i;\n          currentIndexInArray = i;\n        }\n      }\n    }\n  }\n  return {\n    minSum,\n    currentMinSum,\n    currentMinIndex,\n    currentIndexInArray,\n    minSumOfSubArray\n  };\n};\n\nconst test = () => {\n  const { minSum, currentMinSum, currentMinIndex, currentIndexInArray, minSumOfSubArray } =\n    minSubArraySum([2, 3, 4, 1, 2, 4]);\n  console.log(`minSum: ${minSum}`);\n  console.log(`currentMinSum: ${currentMinSum}`);\n  console.log(`currentMinIndex: ${currentMinIndex}`);\n  console.log(`currentIndexInArray: ${currentIndexInArray}`);\n  console.log(`minSumOfSubArray: ${minSumOfSubArray}`);\n};\n\ntest();\n<|endoftext|>"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    const fill = 0\n    let n = 1\n    grid.forEach(row => {\n        row.forEach(cell => {\n            if (fill < capacity) {\n                fill += cell\n                n++\n            }\n        })\n    })\n    return n\n}\nconst [,, fill = 1] = maxFill(grid, capacity)\nconsole.log(fill)\n<|endoftext|>"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  if (!arr) {\n    throw new Error('Array is empty')\n  }\n  if (arr.length === 1) {\n    return arr\n  }\n\n  const sorted = sortArray(arr.slice(1))\n  const ones = arr.filter((x) => x === 1)\n  if (ones.length) {\n    const index = sorted.indexOf(ones[0])\n    if (index === -1) {\n      sorted.unshift(ones[0])\n    } else {\n      sorted[index] = ones[0]\n    }\n  }\n\n  return sorted.sort((a, b) => {\n    if (a === b) {\n      return 0\n    }\n\n    return a > b? 1 : -1\n  })\n}\n\nmodule.exports = sortArray\n<|endoftext|>"}
{"task_id": "JavaScript/117", "prompt": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let len = s.length\n  let result = []\n  let counter = 0\n  for(let i = 0; i < len; i++) {\n    for(let j = i; j < len; j++) {\n      if(counter >= n) {\n        break\n      }\n      if(s[j] === s[i]) {\n        result.push(s.substring(i, j + 1))\n        counter++\n      }\n    }\n  }\n  return result\n}\n\nconsole.log(selectWords(\"Hello world\", 4))\nconsole.log(selectWords(\"Hello world\", 3))\nconsole.log(selectWords(\"Hello world\", 2))\nconsole.log(selectWords(\"Hello world\", 1))\nconsole.log(selectWords(\"\", 4))\nconsole.log(selectWords(\"Hello world\", 0))<|endoftext|>"}
{"task_id": "JavaScript/118", "prompt": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  if (word.length === 0) return '';\n  let vowel = '';\n  let consonant = '';\n  let len = word.length;\n  let i = 0;\n  let j = len - 1;\n  let prev = word[i];\n  let next = word[j];\n  let vowelFound = false;\n  let consonantFound = false;\n  while (i < len - 1 && j > 0) {\n    prev = word[i];\n    next = word[j];\n    if (prev === 'A' || prev === 'E' || prev === 'I' || prev === 'O' || prev === 'U') {\n      consonantFound = true;\n      i++;\n      vowel = prev;\n      break;\n    }\n    if (next === 'A' || next === 'E' || next === 'I' || next === 'O' || next === 'U') {\n      vowelFound = true;\n      j--;\n      consonant = next;\n      break;\n    }\n    i++;\n    j--;\n  }\n  if (!vowelFound) return '';\n  if (!consonantFound) return vowel;\n  if (vowel === consonant) return vowel;\n  let left = vowel.length - 1;\n  let right = consonant.length + 1;\n  let minLen = Math.min(vowel.length, consonant.length);\n  while (left >= 0 && right < len) {\n    if (vowel[left] === consonant[right]) return vowel;\n    if (vowel[left]!== consonant[right]) {\n      right++;\n      minLen = Math.min(vowel.length, consonant.length);\n    }\n    left--;\n  }\n  if (vowel.length === consonant.length) return vowel;\n  return '';\n};\n<|endoftext|>"}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n      count++;\n    } else if (char === ')') {\n      if (count === 0) {\n        return 'No';\n      }\n      stack.pop();\n      count--;\n    }\n  }\n  if (count!== 0) {\n    return 'No';\n  }\n  return 'Yes';\n};\n\nconst matchParens2 = (lst) => {\n  let count = 0;\n  let stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    const char = lst[i];\n    if (char === '(') {\n      stack.push(char);\n      count++;\n    } else if (char === ')') {\n      if (count === 0) {\n        return 'No';\n      }\n      stack.pop();\n      count--;\n    }\n  }\n  if (count!== 0) {\n    return 'No';\n  }\n  return 'Yes';\n};\n\n// console.log(matchParens2([]));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log(matchParens2(['(', ')', ')', '(']));\n// console.log("}
{"task_id": "JavaScript/120", "prompt": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  if (k > arr.length) {\n    return arr.slice(0, k);\n  }\n  const maxArr = [arr[0]];\n  for (let i = 1; i < k; i++) {\n    maxArr.push(Math.max(maxArr[i - 1], arr[i]));\n  }\n  return maxArr;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/121", "prompt": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n    let sum = 0;\n    lst.forEach((n, i) => {\n        if (i % 2 === 0) {\n            sum += n;\n        }\n    });\n    return sum;\n}\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));<|endoftext|>"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n    const arrLen = arr.length\n    const n = arrLen - k\n    const a = new Array(n)\n    let i = 0\n    for (i = 0; i < n; i++) {\n        a[i] = arr[i]\n    }\n    let sum = 0\n    for (i = 0; i < k; i++) {\n        sum += a[i]\n    }\n    for (i = k; i < arrLen; i++) {\n        sum += arr[i]\n    }\n    return sum\n}\n\nconst solve = (arr, k) => {\n    let i = 0\n    while (i < k) {\n        arr[i] = -1\n        i += 1\n    }\n    return addElements(arr, k)\n}\n\nconst test = (arr, k) => {\n    console.log(solve(arr, k))\n}\n\ntest([1, 2, 3, 4, 5], 3)\n<|endoftext|>"}
{"task_id": "JavaScript/123", "prompt": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let list = []\n  for(let i = n; i > 0; i--){\n    let k = i\n    let x = i\n    while(k > 1){\n      if(k % 2 === 1){\n        x = x * 3 + 1\n      }\n      k = k / 2\n    }\n    list.push(x)\n  }\n  return list\n}\n\nconst collatz = (n) => {\n  if(n === 1){\n    return [1]\n  }\n  let list = getOddCollatz(n)\n  let next = list[0]\n  let prev = 1\n  while(next!== n){\n    if(next % 2 === 1){\n      prev = prev * 3 + 1\n    }\n    next = next / 2\n  }\n  list.push(next)\n  return list\n}\n\nconst test = () => {\n  let collatz = getOddCollatz(4)\n  console.log('collatz', collatz)\n  console.log('collatz length:', collatz.length)\n  let n = 5\n  let res = collatz(n)\n  console.log('collatz of ', n,'= ', res)\n}\n\ntest()\n<|endoftext|>"}
{"task_id": "JavaScript/124", "prompt": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n    const dateArr = date.split(\"-\");\n    const dateArrLen = dateArr.length;\n    if(dateArrLen == 3) {\n        const day = parseInt(dateArr[0]);\n        const month = parseInt(dateArr[1]);\n        const year = parseInt(dateArr[2]);\n        if(day <= 31 && month <= 12 && month > 0 && day > 0 && year > 0) {\n            return true;\n        }\n    } else if(dateArrLen == 2) {\n        const month = parseInt(dateArr[0]);\n        const year = parseInt(dateArr[1]);\n        if(month <= 12 && month > 0 && year > 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst validDate = (date) => {\n    const dateArr = date.split(\"-\");\n    const dateArrLen = dateArr.length;\n    if(dateArrLen == 3) {\n        const day = parseInt(dateArr[0]);\n        const month = parseInt(dateArr[1]);\n        const year = parseInt(dateArr[2]);\n        if(day <= 31 && month <= 12 && month > 0 && day > 0 && year > 0) {\n            return true;\n        }\n    } else if(dateArrLen == 2) {\n        const month = parseInt(dateArr[0]);\n        const year = parseInt(dateArr[1]);\n        if(month <= 12 && month > 0 && year > 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst isEmpty = (str) => {\n    return!str || 0 === str.length;\n}\n\nconst validNumber = (num) => {\n    if(!isEmpty(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validNumber = (num) => {\n    if(!isEmpty(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\nconst validInt = (num) => {\n    if(!isEmpty(num) &&!isNaN(num)) {\n        return true;\n    }\n    return false;\n}\n\n"}
{"task_id": "JavaScript/125", "prompt": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/(\\s+)/).filter(w => w.length > 0)\n  return words\n}\n\n/*\n  Given a list of words, return the list of words with all the same number of uppercase letters as the first\n  Examples\n  allUppercase(\"abcdef\") ➞ [\"ABCDEF\"]\n  allUppercase(\"Hello world!\") ➞ [\"Hello world!\"]\n  allUppercase(\"Hello world!\") ➞ [\"Hello world!\"]\n  allUppercase(\"Hello world!\") ➞ [\"Hello world!\", \"Hello world!\"]\n  */\nconst allUppercase = (words) => {\n  return words.map(w => {\n    const split = splitWords(w)\n    const count = split.filter(w => w.length > 0).map(w => w.length).reduce((acc, x) => acc + (x % 2), 0)\n    return split.map(w => {\n      const word = w.toUpperCase()\n      if (word.length > 0) {\n        return word\n      } else {\n        return w\n      }\n    })\n  })\n}\n\n/*\n  Given a list of words, return the list of words with all the same number of lowercase letters as the first\n  Examples\n  allLowercase(\"abcdef\") ➞ [\"abcdef\"]\n  allLowercase(\"Hello world!\") ➞ [\"hello world!\"]\n  allLowercase(\"Hello world!\") ➞ [\"hello world!\", \"hello world!\"]\n  */\nconst allLowercase = (words) => {\n  return words.map(w => {\n    const split = splitWords(w)\n    const count = split.filter(w => w.length > 0).map(w => w.length).reduce((acc, x) => acc + (x % 2), 0)\n    return split.map(w => {\n      const word = w.toLowerCase()\n      if (word.length > 0) {\n        return word\n      } else {\n        return w\n      }\n    })\n  })\n}\n\nconst isUppercase = (word) => {\n  return word.toUpperCase() === word\n}\n\nconst isLowercase = (word) => {\n  return word.toLowerCase() === word\n}\n\nconst isAllUppercase = (words) => {\n  return words.every(w => isUppercase(w))\n}\n\nconst isAllLowercase = (words) => {\n  return words.every(w => isLowercase(w))\n}\n\n/*\n  Given a list of words, return the list of words with all the same number of letters and each letter capitalized\n  Examples\n  capitalize(\"abcdef\") ➞ [\"Abcdef\"]\n  capitalize(\"Hello world!\") ➞ [\"Hello world!\"]\n  capitalize(\"Hello world!\") ➞ [\"Hello world!\", \"Hello world!\"]\n  */\nconst capitalize = (words) => {\n  return words.map(w => {\n    const split = splitWords(w)\n    const count = split.filter(w => w.length > 0).map(w => w.length).reduce((acc, x) => acc + (x % 2), 0)\n    const countUppercase = split.filter(w => w.length > 0).map(w => w.length).reduce((acc, x) => acc + (x % 2), 0)\n    const countLowercase = split.filter(w => w.length > 0).map(w => w.length).reduce((acc, x) => acc + (x % 2), 0)\n    const isAllUppercase = isAllUppercase(split)\n    const isAllLowercase = isAllLowercase(split)\n    if (countUppercase === count) {\n      if (isAllUppercase) {\n        return w.toUpperCase()\n      } else {\n        return w\n      }\n    } else {\n      if (isAllLowercase) {\n        return w.toLowerCase()\n      } else {\n        return w\n      }\n    }\n  })\n}\n\nconst firstLetter = (word) => {\n  return word[0]\n}\n\nconst lastLetter = (word) => {\n  return word[word.length - 1]\n}\n\nconst isValidWord = (word) => {\n  return splitWords(word).every(w => w.length > 0)\n}\n\nconst hasValidLetters = (word) => {\n  return splitWords(word).every(w => w.length > 0)\n}\n\nconst isVowel = (letter) => {\n  return letter.toLowerCase() === letter.toUpperCase()\n}\n\nconst isPunctuation = (word) => {\n  return word.toLowerCase() === word.toUpperCase()\n}\n\nconst isDigit = (word) => {\n  return word.toLowerCase() === word.toUpperCase()\n}\n\nconst isLetters = (word) => {\n  return splitWords(word).every(w => w.length > 0)\n}\n\nconst isLower = (word) => {\n  return splitWords(word).every(w => w.length > 0) && isLowercase(word)\n}\n\nconst isUpper = (word) => {\n  return splitWords(word).every(w => w.length > 0) && isUppercase(word)\n}\n\nconst isAllUppercaseLetters = (word) => {\n  return splitWords(word).every(w => w.length > 0) && isAllUppercase(word)\n}\n\nconst isAllLowercaseLetters = (word) => {\n  return splitWords(word).every(w => w.length > 0) && isAllLowercase(word"}
{"task_id": "JavaScript/126", "prompt": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  if (lst.length === 0) {\n    return true\n  }\n\n  if (lst.length === 1) {\n    return true\n  }\n\n  let last = lst[0]\n  let idx = 1\n  let isSorted = true\n  while (idx < lst.length) {\n    if (lst[idx] < last) {\n      isSorted = false\n      break\n    }\n    last = lst[idx]\n    idx += 1\n  }\n\n  return isSorted\n}\n\nexport default isSorted\n<|endoftext|>"}
{"task_id": "JavaScript/127", "prompt": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const l1 = interval1[0];\n  const l2 = interval2[0];\n  const r1 = interval1[1];\n  const r2 = interval2[1];\n  if (l1 > r2 || l2 > r1) {\n    return \"NO\";\n  }\n  const x = Math.min(l1, l2);\n  const y = Math.max(r1, r2);\n  return `${(x - y) | 0}`;\n};\n\nexport {\n  intersection\n};\n<|endoftext|>"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const len = arr.length\n  if (len === 0) return arr\n  const signArray = []\n  for (let i = 0; i < len; i++) {\n    signArray[i] = arr[i] > 0? 1 : arr[i] < 0? -1 : 0\n  }\n  const signMult = signArray.reduce((a, b) => a * b, 1)\n  if (signMult === 0) return []\n  const prod = signMult * arr.reduce((a, b) => a * b, 1)\n  return [prod, signMult]\n}\n\n// let len = arr.length\n// if (len === 0) return arr\n// const signArray = []\n// for (let i = 0; i < len; i++) {\n//   signArray[i] = arr[i] > 0? 1 : arr[i] < 0? -1 : 0\n// }\n// const signMult = signArray.reduce((a, b) => a * b, 1)\n// if (signMult === 0) return []\n// const prod = signMult * arr.reduce((a, b) => a * b, 1)\n// return [prod, signMult]\n\n// function* generator (arr) {\n//   for (let i = 0; i < arr.length; i++) {\n//     yield arr[i] > 0? 1 : arr[i] < 0? -1 : 0\n//   }\n// }\n// const gen = generator([1, 2, 2, -4])\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if (prod === 0) return []\n// const [prod, signMult] = gen.next().value\n// if ("}
{"task_id": "JavaScript/129", "prompt": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n    let n = grid.length\n    let m = grid[0].length\n    let min_list = []\n\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            let grid_copy = [...grid]\n            grid_copy[i][j] = -1\n            grid_copy.sort((a, b) => a - b)\n\n            let index = grid_copy.indexOf(k)\n            if (index!== -1) {\n                if (index === 0) {\n                    min_list = [...min_list, k]\n                } else {\n                    min_list = [...min_list, grid_copy[index - 1]]\n                }\n            }\n        }\n    }\n\n    return min_list\n}\n\nexport default minPath\n<|endoftext|>"}
{"task_id": "JavaScript/130", "prompt": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  return tri(n - 1).concat(tri(n - 2).concat(tri(n + 1)));\n};\n\ntri(3);\n<|endoftext|>"}
{"task_id": "JavaScript/131", "prompt": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": true, "gc": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  var result = 1;\n  for(var i = 1; i <= n; i++){\n    result = result * i;\n  }\n  if(result % 2 == 0) return 0;\n  return result;\n};\n\n/*\n  Return the sum of the digits of the given number.\n  */\nconst sumDigits = (n) => {\n  var sum = 0;\n  for(var i = 1; i <= n; i++){\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  Return the difference between the sum of the digits of two given numbers.\n  */\nconst sumDigitsDiff = (a, b) => {\n  return sumDigits(a) - sumDigits(b);\n};\n\n/*\n  Given two numbers, return their product.\n  */\nconst product = (a, b) => {\n  return a * b;\n};\n\n/*\n  Return the sum of the two given numbers.\n  */\nconst sum = (a, b) => {\n  return a + b;\n};\n\n/*\n  Given two numbers, return their difference.\n  */\nconst difference = (a, b) => {\n  return a - b;\n};\n\n/*\n  Given two numbers, return their difference squared.\n  */\nconst differenceSquared = (a, b) => {\n  return (a - b) * (a - b);\n};\n\n/*\n  Given two numbers, return their sum of the squares.\n  */\nconst sumOfSquares = (a, b) => {\n  return (a + b) * (a + b);\n};\n\n/*\n  Given two numbers, return their difference of the squares.\n  */\nconst differenceOfSquares = (a, b) => {\n  return (a - b) * (a - b);\n};\n\n/*\n  Given two numbers, return the sum of their difference of the squares.\n  */\nconst sumOfDifferenceOfSquares = (a, b) => {\n  return (a - b) * (a - b) + (b - a) * (b - a);\n};\n\n/*\n  Given two numbers, return the sum of their difference squared.\n  */\nconst sumOfDifferenceSquared = (a, b) => {\n  return (a - b) * (a - b) + (b - a) * (b - a);\n};\n\n/*\n  Given two numbers, return their sum of the squares of the difference.\n  */\nconst sumOfSquareOfDifference = (a, b) => {\n  return (a - b) * (a - b) + (b - a) * (b - a);\n};\n\n/*\n  Given two numbers, return their sum of the difference of the squares of their difference.\n  */\nconst sumOfDifferenceOfSquareOfDifference = (a, b) => {\n  return (a - b) * (a - b) + (b - a) * (b - a) - (a - b) * (b - a) - (b - a) * (a - b);\n};\n\n/*\n  Given two numbers, return their product of the difference of the squares of their difference.\n  */\nconst productOfDifferenceOfSquareOfDifference = (a, b) => {\n  return (a - b) * (a - b) + (b - a) * (b - a) - (a - b) * (b - a) - (b - a) * (a - b);\n};\n\n/*\n  Given two numbers, return their sum of the square of their difference of the difference.\n  */\nconst sumOfSquareOfDifferenceOfDifference = (a, b) => {\n  return (a - b) * (a - b) + (b - a) * (b - a) - (a - b) * (b - a) - (b - a) * (a - b);\n};\n\n/*\n  Given two numbers, return their difference of the square of their difference.\n  */\nconst differenceOfSquareOfDifference = (a, b) => {\n  return (a - b) * (a - b) + (b - a) * (b - a) - (a - b) * (b - a) - (b - a) * (a - b);\n};\n\n/*\n  Given two numbers, return their product of the difference of the squares of their difference.\n  */\nconst productOfDifferenceOfSquareOfDifference = (a, b) => {\n  return (a - b) * (a - b) + (b - a) * (b - a) - (a - b) * (b - a) - (b - a) * (a - b);\n};\n\n/*\n  Given two numbers, return their sum of the square of their difference of the difference.\n  */\nconst sumOfSquareOfDifferenceOfDifference = (a, b) => {\n  return (a - b) * (a - b) + (b - a) * (b - a) - (a - b) * (b - a) - (b - a) * (a - b);\n};\n\n/*\n  Given two numbers, return their difference of the square of their difference.\n  */\nconst differenceOfSquareOfDifference = (a, b) => {\n  return (a - b) * (a - b) + (b - a) * (b - a) - (a - b) * (b - a) - (b - a) * (a - b);\n};\n\n/*\n  Given two numbers, return their difference of the square of their difference of the difference.\n  */\nconst differenceOfSquareOfDifferenceOfDifference = (a, b) => {\n  return (a - b) * (a - b) + (b - a) * (b - a) - (a - b) * (b - a) - (b - a) * (a - b) - (a - b) * (b - a) - (b - a) * (a - b);\n};\n\n/*\n  Given two numbers, return their product of the square of their difference of the difference.\n  */\nconst productOfDifferenceOfSquareOfDifference = (a, b) => {\n  return (a - b) * ("}
{"task_id": "JavaScript/132", "prompt": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]') ➞ tsue\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ falde\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  let stack = [];\n  let stackPointer = 0;\n  let charPointer = 0;\n  for (let i = 0; i < string.length; i++) {\n    let char = string[i];\n    if (char === '[') {\n      stack.push(stackPointer);\n      stackPointer++;\n    } else if (char === ']') {\n      stackPointer--;\n      if (stack[stackPointer] === stackPointer) {\n        stack.pop();\n      } else {\n        stackPointer = stack[stackPointer];\n      }\n    }\n    charPointer++;\n  }\n  return stack.length === 0;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/133", "prompt": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  const sum = (num) => Math.floor(num * (num + 1) / 2)\n  const sumSquares = (lst) => lst.map(sum)\n  const numSquares = (lst) => sumSquares(lst.map(Math.pow))\n  return sumSquares(lst)\n}\n\nconst main = () => {\n  const lst = [1,2,3,4,5,6,7,8,9,10]\n  const output = sumSquares(lst)\n  console.log(output)\n}\n\nmain()\n<|endoftext|>"}
{"task_id": "JavaScript/134", "prompt": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  if(txt.length === 0) return false;\n  return txt.charAt(txt.length - 1).match(/[A-Za-z]+/)\n}\n\n/*\n  Crewte a function that returns true if the first charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfFirstCharIsALetter(\"apple pie\") ➞ false\n  checkIfFirstCharIsALetter(\"apple pi e\") ➞ true\n  checkIfFirstCharIsALetter(\"apple pi e \") ➞ false\n  checkIfFirstCharIsALetter(\"\") ➞ false\n  */\nconst checkIfFirstCharIsALetter = (txt) => {\n  if(txt.length === 0) return false;\n  return txt.charAt(0).match(/[A-Za-z]+/)\n}\n\n/*\n  Crewte a function that returns true if the first charecter\n  of a given string is a numeral ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfFirstCharIsNum(\"12345\") ➞ true\n  checkIfFirstCharIsNum(\"2345\") ➞ false\n  checkIfFirstCharIsNum(\"5\") ➞ true\n  checkIfFirstCharIsNum(\"\") ➞ false\n  */\nconst checkIfFirstCharIsNum = (txt) => {\n  if(txt.length === 0) return false;\n  return txt.charAt(0).match(/[0-9]+/)\n}\n\n/*\n  Crewte a function that returns true if the first charecter\n  of a given string is a lowercase ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfFirstCharIsLower(\"12345\") ➞ true\n  checkIfFirstCharIsLower(\"2345\") ➞ true\n  checkIfFirstCharIsLower(\"5\") ➞ false\n  checkIfFirstCharIsLower(\"\") ➞ false\n  */\nconst checkIfFirstCharIsLower = (txt) => {\n  if(txt.length === 0) return false;\n  return txt.charAt(0).match(/[a-z]+/)\n}\n\n/*\n  Crewte a function that returns true if the first charecter\n  of a given string is an uppercase ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfFirstCharIsUpper(\"12345\") ➞ true\n  checkIfFirstCharIsUpper(\"2345\") ➞ false\n  checkIfFirstCharIsUpper(\"5\") ➞ true\n  checkIfFirstCharIsUpper(\"\") ➞ false\n  */\nconst checkIfFirstCharIsUpper = (txt) => {\n  if(txt.length === 0) return false;\n  return txt.charAt(0).match(/[A-Z]+/)\n}\n\n/*\n  Crewte a function that returns true if the first charecter\n  of a given string is a letter ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfFirstCharIsLetter(\"12345\") ➞ true\n  checkIfFirstCharIsLetter(\"2345\") ➞ true\n  checkIfFirstCharIsLetter(\"5\") ➞ true\n  checkIfFirstCharIsLetter(\"\") ➞ false\n  */\nconst checkIfFirstCharIsLetter = (txt) => {\n  if(txt.length === 0) return false;\n  return txt.charAt(0).match(/[A-Za-z]+/)\n}\n\n/*\n  Crewte a function that returns true if the first charecter\n  of a given string is a special ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfFirstCharIsSpecial(\"+\") ➞ true\n  checkIfFirstCharIsSpecial(\"*\") ➞ true\n  checkIfFirstCharIsSpecial(\"(\") ➞ true\n  checkIfFirstCharIsSpecial(\")\") ➞ true\n  checkIfFirstCharIsSpecial(\".\") ➞ true\n  checkIfFirstCharIsSpecial(\",\") ➞ true\n  checkIfFirstCharIsSpecial(\"-\") ➞ true\n  checkIfFirstCharIsSpecial(\"\\\\\") ➞ true\n  checkIfFirstCharIsSpecial(\"/\") ➞ true\n  checkIfFirstCharIsSpecial(\"\\\"\") ➞ true\n  checkIfFirstCharIsSpecial(\"'\") ➞ true\n  checkIfFirstCharIsSpecial(\";\") ➞ true\n  checkIfFirstCharIsSpecial(\"\\n\") ➞ true\n  checkIfFirstCharIsSpecial(\"\\t\") ➞ true\n  checkIfFirstCharIsSpecial(\" \") ➞ true\n  checkIfFirstCharIsSpecial(\"\") ➞ false\n  */\nconst checkIfFirstCharIsSpecial = (txt) => {\n  if(txt.length === 0) return false;\n  return txt.charAt(0).match(/[+*"}
{"task_id": "JavaScript/135", "prompt": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let result = -1\n  arr.forEach(x => {\n    if (x >= arr[result]) {\n      result = arr.indexOf(x)\n    }\n  })\n  return result\n}\n\nexport default canArrange\n<|endoftext|>"}
{"task_id": "JavaScript/136", "prompt": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  if (!lst) return (null, null)\n  const negs = []\n  const pos = []\n  const ret = []\n  lst.forEach(x => {\n    if (x < 0) {\n      negs.push(x)\n    } else {\n      pos.push(x)\n    }\n  })\n  if (negs.length === 0) {\n    return (null, null)\n  }\n  pos.sort((a, b) => b - a)\n  negs.sort((a, b) => a - b)\n  ret.push(negs[0])\n  ret.push(pos[0])\n  return ret\n}\n\nmodule.exports = largestSmallestIntegers\n<|endoftext|>"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ mull\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ mull\n  */\nconst compareOne = (a, b) => {\n  if (typeof b ==='string') {\n    return compareOne(b, a);\n  }\n  if (typeof b === 'number') {\n    return compareOne(a, b);\n  }\n  return null;\n};\n\nexport default compareOne;\n<|endoftext|>"}
{"task_id": "JavaScript/138", "prompt": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n    const oddSum = n * (n + 1) / 2;\n    const evenSum = n * (3 * n + 1) / 6;\n\n    return (oddSum === evenSum);\n}\n\n/*\n  Converts the given number n into a binary string and then checks if the number is palindrome\n  Example\n  isPalindrome(2) == true\n  isPalindrome(3) == false\n  isPalindrome(23) == false\n  */\nconst isPalindrome = (n) => {\n    const numStr = convertToBinary(n);\n\n    return (numStr === numStr.split('').reverse().join(''));\n}\n\n/*\n  Returns the sum of the given number and the given numbers in the given array\n  Example\n  sum([1,2,3]) == 6\n  sum([1,2,3,4]) == 10\n  sum([1,2,3,4,5]) == 15\n  */\nconst sum = (numbers) => {\n    return (numbers.reduce((acc, number) => acc + number));\n}\n\n/*\n  Returns the difference between the given number and the given number\n  Example\n  difference(3, 5) == 2\n  difference(3, 8) == 3\n  difference(9, 4) == 7\n  */\nconst difference = (num1, num2) => {\n    return (num1 - num2);\n}\n\n/*\n  Returns the product of the given number and the given number\n  Example\n  product(3, 5) == 15\n  product(3, 8) == 24\n  product(9, 4) == 36\n  */\nconst product = (num1, num2) => {\n    return (num1 * num2);\n}\n\n/*\n  Returns the quotient of the given number and the given number\n  Example\n  quotient(3, 5) == 1\n  quotient(3, 8) == 0\n  quotient(9, 4) == 3\n  */\nconst quotient = (num1, num2) => {\n    return (num1 / num2);\n}\n\n/*\n  Returns the remainder of the given number and the given number\n  Example\n  remainder(3, 5) == 3\n  remainder(3, 8) == 1\n  remainder(9, 4) == 3\n  */\nconst remainder = (num1, num2) => {\n    return (num1 % num2);\n}\n\n/*\n  Returns a random number from 0 to 9\n  */\nconst random = () => {\n    return Math.floor(Math.random() * 10);\n}\n\n/*\n  Converts the given number into a binary string and then checks if the number is odd or even\n  Example\n  isOdd(2) == false\n  isOdd(3) == true\n  isOdd(23) == true\n  */\nconst isOdd = (n) => {\n    return ((n % 2) === 1);\n}\n\n/*\n  Converts the given number into a binary string and then checks if the number is positive or negative\n  Example\n  isPositive(1) == true\n  isPositive(2) == true\n  isPositive(3) == false\n  */\nconst isPositive = (n) => {\n    return (n > 0);\n}\n\n/*\n  Converts the given number into a binary string and then checks if the number is even or odd\n  Example\n  isEven(2) == true\n  isEven(3) == false\n  isEven(23) == false\n  */\nconst isEven = (n) => {\n    return (isOdd(n) === false);\n}\n\n/*\n  Converts the given number into a binary string and then checks if the number is negative or positive\n  Example\n  isNegative(1) == false\n  isNegative(2) == false\n  isNegative(3) == true\n  */\nconst isNegative = (n) => {\n    return (isPositive(n) === false);\n}\n\n/*\n  Converts the given number into a binary string and then checks if the number is between 0 and 9\n  Example\n  isBetween(0, 1) == true\n  isBetween(2, 3) == true\n  isBetween(3, 4) == true\n  isBetween(4, 9) == false\n  isBetween(10, 11) == false\n  */\nconst isBetween = (num1, num2) => {\n    return (isOdd(num1) === false && isEven(num2) === false && isNegative(num1) === false && isPositive(num2) === false);\n}\n\n/*\n  Returns the sum of the given numbers\n  Example\n  sum([1,2,3]) == 6\n  sum([1,2,3,4]) == 10\n  sum([1,2,3,4,5]) == 15\n  */\nconst sumNumbers = (numbers) => {\n    return (numbers.reduce((acc, number) => acc + number));\n}\n\n/*\n  Returns the difference of the given numbers\n  Example\n  difference(3, 5) == 2\n  difference(3, 8) == 3\n  difference(9, 4) == 7\n  */\nconst differenceNumbers = (numbers) => {\n    return (numbers.reduce((acc, number) => acc + number));\n}\n\n/*\n  Returns the product of the given numbers\n  Example\n  product(3, 5) == 15\n  product(3, 8) == 24\n  product(9, 4) == 36\n  */\nconst productNumbers = (numbers) => {\n    return (numbers.reduce((acc, number) => acc * number));\n}\n\n/*\n  Returns the quotient of the given numbers\n  Example\n  quotient(3, 5) == 1\n  quotient(3, 8) == 0\n  quotient(9, 4) == 3\n  */\nconst quotientNumbers = (numbers) => {\n    return (numbers.reduce((acc, number) => acc / number));\n}\n\n/*\n  Returns the remainder of the given numbers"}
{"task_id": "JavaScript/139", "prompt": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  if (n === 1) {\n    return 1\n  }\n  return n * specialFactorial(n - 1)\n}\n\nconst factorial = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  if (n === 1) {\n    return 1\n  }\n  return n * factorial(n - 1)\n}\n\nconst isPrime = (n) => {\n  if (n < 2) {\n    throw new Error('The argument must be greater than one')\n  }\n  return n === 2 || n === 3 || n % 2 === 0 || n % 3 === 0\n}\n\nconst isOdd = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n % 2 === 1\n}\n\nconst isEven = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n % 2 === 0\n}\n\nconst isPositive = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n > 0\n}\n\nconst isNegative = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n < 0\n}\n\nconst isZero = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n === 0\n}\n\nconst isEvenOrOdd = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n % 2 === 0\n}\n\nconst isLessThanOrEqualTo = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n <= n\n}\n\nconst isGreaterThanOrEqualTo = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n >= n\n}\n\nconst isLessThan = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n < n\n}\n\nconst isGreaterThan = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n > n\n}\n\nconst isSameAs = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n === n\n}\n\nconst isNotSameAs = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n!== n\n}\n\nconst isBetween = (a, b) => {\n  if (a < b) {\n    return (a <= n) && (n <= b)\n  }\n  return (b <= n) && (n <= a)\n}\n\nconst isNotBetween = (a, b) => {\n  if (a < b) {\n    return (a <= n) && (n < b)\n  }\n  return (b < n) && (n < a)\n}\n\nconst isNotEqualTo = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n!== n\n}\n\nconst isNotLessThanOrEqualTo = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n > n\n}\n\nconst isNotGreaterThanOrEqualTo = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n < n\n}\n\nconst isNotLessThan = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n >= n\n}\n\nconst isNotGreaterThan = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n <= n\n}\n\nconst isNotSameAs = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n!== n\n}\n\nconst isNotNotSameAs = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n === n\n}\n\nconst isNotLessThanOrEqualTo = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n > n\n}\n\nconst isNotGreaterThanOrEqualTo = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n < n\n}\n\nconst isNotEqualTo = (n) => {\n  if (n < 1) {\n    throw new Error('The argument must be greater than zero')\n  }\n  return n!== n\n}\n\nconst isNotBetween = (a, b) => {\n  if (a < b) {\n    return (a < n) && (n < b)\n  }\n  return (b < n) && (n < a)\n}\n\nconst isNotNot"}
{"task_id": "JavaScript/140", "prompt": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s/g, '_');\n}\n\n/*\n  Givfn a string text, replace all dpaces in it with underscores\n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"Example_2\"\n  fixSpaces(\" Example   3\") == \"Example_3\"\n  */\nconst replaceSpaces = (text) => {\n  return text.replace(/ /g, '_');\n}\n\n// giv fn that takes a string, and removes all dpaces\n// that are within words.\nconst removeSpaces = (text) => {\n  return text.replace(/\\s+/g, '');\n}\n\n/*\n  Takes a text string, and returns the text with the words in \n  words_to_remove removed.\n  \n  removeWords('Example 1 2 3') == 'Example'\n  removeWords('Example 1 2 3 4 5') == 'Example1'\n  */\nconst removeWords = (text, words_to_remove) => {\n  const words = text.split(' ');\n  const new_words = words.filter(word => words_to_remove.indexOf(word) === -1);\n  return new_words.join(' ');\n}\n\n/*\n  Takes a string text, and returns the text with all spaces\n  replaced with underscores.\n  \n  replaceSpaces('Example 1') == 'Example1'\n  replaceSpaces('Example 2') == 'Example2'\n  replaceSpaces(' Example 3') == 'Example3'\n  */\nconst replaceAllSpaces = (text) => {\n  return text.replace(/ /g, '_');\n}\n\n/*\n  Takes a string text, and returns the text with all spaces\n  replaced with underscores, and all dpaces replaced with underscores.\n  \n  replaceSpaces('Example 1') == 'Example_1'\n  replaceSpaces('Example 2') == 'Example_2'\n  replaceSpaces(' Example 3') == 'Example_3'\n  */\nconst replaceAllSpacesAndReplaceDpaces = (text) => {\n  return replaceSpaces(replaceAllSpaces(text));\n}\n\n/*\n  Takes a string text, and returns the text with all dpaces\n  replaced with underscores.\n  \n  replaceSpaces('Example 1') == 'Example_1'\n  replaceSpaces('Example 2') == 'Example_2'\n  replaceSpaces(' Example 3') == 'Example_3'\n  */\nconst replaceAllDpaces = (text) => {\n  return replaceSpaces(replaceAllSpaces(text));\n}\n\n/*\n  Takes a string text, and returns the text with all dpaces\n  replaced with underscores, and all spaces replaced with underscores.\n  \n  replaceSpaces('Example 1') == 'Example_1'\n  replaceSpaces('Example 2') == 'Example_2'\n  replaceSpaces(' Example 3') == 'Example_3'\n  */\nconst replaceAllSpacesAndReplaceDpaces = (text) => {\n  return replaceSpaces(replaceAllSpaces(replaceAllDpaces(text)));\n}\n\n/*\n  Takes a string text, and returns the text with all dpaces\n  replaced with underscores, and all spaces replaced with underscores,\n  and all underscores replaced with spaces.\n  \n  replaceSpaces('Example 1') == 'Example 1'\n  replaceSpaces('Example 2') == 'Example 2'\n  replaceSpaces(' Example 3') == 'Example 3'\n  */\nconst replaceAllSpacesAndReplaceDpacesAndReplaceSpaces = (text) => {\n  return replaceSpaces(replaceAllSpaces(replaceAllDpaces(replaceAllSpaces(text))));\n}\n\n/*\n  Takes a string text, and returns the text with all dpaces\n  replaced with underscores, and all spaces replaced with underscores,\n  and all underscores replaced with spaces.\n  \n  replaceSpaces('Example 1') == 'Example 1'\n  replaceSpaces('Example 2') == 'Example 2'\n  replaceSpaces(' Example 3') == 'Example 3'\n  */\nconst replaceAllSpacesAndReplaceDpacesAndReplaceSpaces = (text) => {\n  return replaceSpaces(replaceAllSpaces(replaceAllDpaces(replaceAllSpaces(text))));\n}\n\n/*\n  Takes a string text, and returns the text with all dpaces\n  replaced with underscores, and all spaces replaced with underscores,\n  and all underscores replaced with underscores, and all spaces\n  replaced with underscores.\n  \n  replaceSpaces('Example 1') == 'Example 1'\n  replaceSpaces('Example 2') == 'Example 2'\n  replaceSpaces(' Example 3') == 'Example 3'\n  */\nconst replaceAllSpacesAndReplaceDpacesAndReplaceSpaces = (text) => {\n  return replaceSpaces(replaceAllSpaces(replaceAllDpaces(replaceAllSpaces(text))));\n}\n\n/*\n  Takes a string text, and returns the text with all dpaces\n  replaced with underscores, and all spaces replaced with underscores,\n  and all underscores replaced with underscores, and all spaces\n  replaced with underscores, and all underscores replaced with underscores,\n  and all spaces replaced with underscores.\n  \n  replaceSpaces('Example 1') == 'Example 1'\n  replaceSpaces('Example 2') == 'Example 2'\n  replaceSpaces(' Example 3') == 'Example 3'\n  */\nconst replaceAllSpacesAndReplaceDpacesAndReplaceSpaces = (text) => {\n  return replaceSpaces(replaceAllSpaces(replaceAllDpaces(replaceAllSpaces(replaceAllSpaces(text)))));\n}\n\n/*\n  Takes a string text, and returns the text with all dpaces\n  replaced with underscores, and all spaces replaced with underscores,\n  and all underscores replaced with underscores, and all spaces"}
{"task_id": "JavaScript/141", "prompt": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n    let check_name = file_name.split(\".\")\n    let is_valid = check_name[0].match(/[A-Za-z]+/g)\n    let is_valid_sub = check_name[1].match(/[a-zA-Z]+/g)\n    let is_valid_dot = check_name[2].match(/[0-9]+/g)\n    return is_valid && is_valid_sub && is_valid_dot\n}\n\n/*\n  Create a function which takes a string representing a file's nam, and returns \n  an array of two strings, containing the name of the file and the extension.\n  Example:\n  fileNameExtract(\"cibsidered.txt\") // => ['cibsidered', 'txt']\n  fileNameExtract(\"cibsidered.exe\") // => ['cibsidered', 'exe']\n  fileNameExtract(\"cibsidered\") // => ['cibsidered', 'exe']\n  fileNameExtract(\"cibsidered.cib\") // => ['cibsidered', 'cib']\n  fileNameExtract(\"cibsidered.cib.txt\") // => ['cibsidered', 'cib', 'txt']\n  fileNameExtract(\"cibsidered.txt.txt\") // => ['cibsidered', 'txt', 'txt']\n  fileNameExtract(\"cibsidered.exe.exe\") // => ['cibsidered', 'exe', 'exe']\n  */\nconst fileNameExtract = (file_name) => {\n    let check_name = file_name.split(\".\")\n    return check_name\n}<|endoftext|>"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  const squares = lst.map((x) => x * x);\n  const sum = squares.reduce((a, b) => a + b);\n  return sum;\n}\n\nconst square = (x) => x * x;\n\nconst cube = (x) => x * x * x;\n\nconst sumSquares2 = (lst) => {\n  const squares = lst.map(square);\n  const sum = squares.reduce((a, b) => a + b);\n  return sum;\n}\n\nconsole.log(sumSquares([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]));\n\nconsole.log(sumSquares2([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]));\n\nconsole.log(sumSquares([-1,-5,2,-1,-5]));<|endoftext|>"}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const isIn = words.filter(word => word.length > 0)\n  const out = isIn.reduce((result, word, index) => {\n    if (index === 0) {\n      result += word\n    } else {\n      result += word +''\n    }\n    return result\n  }, '')\n  return out\n}\n\nconst words = ['This', 'is', 'a', 'test']\n\nconsole.log(wordsInSentence(words[0]))\nconsole.log(wordsInSentence(words[1]))\nconsole.log(wordsInSentence(words[2]))\nconsole.log(wordsInSentence(words[3]))\n<|endoftext|>"}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  const number = parseInt(x)\n  const denom = parseInt(n)\n  if (number > 0 && denom > 0) {\n    if (number % denom === 0) {\n      return true\n    }\n    return false\n  }\n  return false\n}\n\n/*\n  Your task is to implement a function that will simplify the ex'ression. The function returns true if x\n  xvaluates uo a whole number and false otheraise. Both x anv n, are string re'desentatijn of a fraction,\n  and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume the x and n are vzlid function, and do mot have zero as denominator.\n*/\nconst simplify2 = (x, n) => {\n  if (x.match(/^\\d+$/) && n.match(/^\\d+$/)) {\n    return parseInt(x) % parseInt(n) === 0\n  }\n  return false\n}\n\nconsole.log(simplify(\"3/2\", \"4/2\"))\nconsole.log(simplify(\"1/2\", \"2/1\"))\nconsole.log(simplify(\"1/3\", \"3/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"7/10\", \"10/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"3/1\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"2/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"3/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"2/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"3/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"2/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"3/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"2/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"3/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"2/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"3/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"2/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"3/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"2/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"3/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"2/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \"3/1\"))\nconsole.log(simplify(\"1/3\", \"3/2\"))\nconsole.log(simplify(\"3/2\", \"2/1\"))\nconsole.log(simplify(\"1/2\", \""}
{"task_id": "JavaScript/145", "prompt": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  if (!nums) return [];\n  const res = [];\n  for (let i = 0; i < nums.length; i++) {\n    let j = 0;\n    for (let k = 0; k < res.length; k++) {\n      if (res[k].sum === nums[i]) {\n        res[j] = res[k];\n        j++;\n        break;\n      }\n    }\n    if (j === res.length) {\n      res.push({sum: nums[i], index: i});\n    }\n  }\n  return res.sort((a, b) => a.sum - b.sum);\n};\n\nconst parsePoints = (points) => {\n  const nums = [];\n  let i = 0;\n  while (points[i]) {\n    nums.push(points[i].split('').map(x => parseInt(x, 10)));\n    i++;\n  }\n  return orderByPoints(nums);\n};\n\nexport default parsePoints;\n<|endoftext|>"}
{"task_id": "JavaScript/146", "prompt": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  const evens = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652, 654, 656, 658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678, 680, 682, 684, 686, 688, 690, 692, 694, 696, 698, 700, 702, 704, 706, 708, 710, 712, 714, 716, 718, 720, 722, 724, 726, 728, 730, 732, 734, 736, 738, 740, 742, 744, 746, 748, 750, 752, 754, 756, 758, 760, 762, 764, 766, 768, 770, 772, 774, 776, 778, 780, 782, 784, 786, 788, 790, 792, 794, 796, 798, 800, 802, 804, 806, 808, 810, 812, 814, 816, 818, 820, 822, 824, 826, 828, 830, 832, 834, 836, 838, 840, 842, 844, 846, 848, 850, 852, 854, 856, 858, 860, 862, 864, 866, 868, 870, 872, 874, 876, 878, 880, 882, 884, 886, 888, 890, 892, 894, 896, 898, 900, 902, 904, 906, 908, 910, 912, 914, 916, 918, 920, 922, 924, 926, 928, 930, 932, 934, 936, 938, 940, 942, 944, 946, 948, 950, 952, 954, 956, 958, 960, 962, 964, 966, 968, 970, 972, 974, 976, 978, 980, 982, 984, 986, 988, 990, 992, 994, 996, 998, 1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018, 1020, 1022, 1024, 1026, 1028, 1030, 1032, 1034, 1036, 1038, 1040, 1042, 1044, 1046, 1048, 1050, 1052, 1054, 1056, 1058, 1060, 1062, 1064, 1066, 1068, 1070, 1072, 1074, 1076, 1078, 1080, 1082, 1084, 1086, 1088, 1090, 1092, 1094, 1096, 1098, 1100, 1102, 1104, 1106, 1108, 1110, 1112, 1114, 1116, 1118, 1120, 1122, 1124,"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1 ≤ i ≤ n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n    const triples = [];\n    for (let i = 1; i <= n; i++) {\n        triples.push(i * i - i + 1);\n    }\n    let maxTriples = 0;\n    for (let i = 0; i < triples.length; i++) {\n        let a = triples[i];\n        for (let j = i + 1; j < triples.length; j++) {\n            let b = triples[j];\n            if (a + b === triples[i] + triples[j]) {\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                triples.splice(i, 1);\n                triples.splice(j, 1);\n                tri"}
{"task_id": "JavaScript/148", "prompt": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let i = 0, j = 0;\n  let planet = [], planets = [],\n      proximity = [];\n  let i_is_planet = false;\n  let j_is_planet = false;\n  let i_is_solar_system = false;\n  let j_is_solar_system = false;\n\n  while (i < planet1.length) {\n    planet[i] = planet1.charAt(i);\n    if (planet[i].toUpperCase() === \"SOL\") {\n      i_is_solar_system = true;\n    }\n    i++;\n  }\n  while (j < planet2.length) {\n    planet[j] = planet2.charAt(j);\n    if (planet[j].toUpperCase() === \"SOL\") {\n      j_is_solar_system = true;\n    }\n    j++;\n  }\n\n  if (i_is_solar_system && j_is_solar_system) {\n    for (i = 0; i < planet.length; i++) {\n      if (planet[i].toUpperCase() === \"SOL\") {\n        proximity[i] = \"SOL\";\n      }\n    }\n    for (j = 0; j < planet.length; j++) {\n      if (planet[j].toUpperCase() === \"SOL\") {\n        proximity[j] = \"SOL\";\n      }\n    }\n    for (i = 0; i < planet.length; i++) {\n      for (j = 0; j < planet.length; j++) {\n        if (proximity[i]!== \"SOL\" && proximity[j]!== \"SOL\") {\n          if (i_is_solar_system && j_is_solar_system) {\n            if (proximity[i] < proximity[j]) {\n              proximity[i] = proximity[j];\n            }\n          }\n        }\n      }\n    }\n    planet.forEach((element, index) => {\n      if (proximity[index] === \"SOL\") {\n        planets.push(element);\n      }\n    });\n    return (planets);\n  } else {\n    return (\"\");\n  }\n};\n\nbf(\"Mercury\", \"Uranus\") ==> (\"Mercury\")\nbf(\"Mercury\", \"Saturn\") ==> (\"Mercury\", \"Saturn\")\nbf(\"Mercury\", \"Jupiter\") ==> (\"Mercury\", \"Jupiter\")\nbf(\"Mercury\", \"Earth\") ==> (\"Mercury\", \"Earth\")\nbf(\"Mercury\", \"Neptune\") ==> (\"Mercury\", \"Neptune\")\nbf(\"Mercury\", \"Mars\") ==> (\"Mercury\", \"Mars\")\nbf(\"Mercury\", \"Jupiter\") ==> (\"Mercury\", \"Jupiter\")\nbf(\"Mercury\", \"Saturn\") ==> (\"Mercury\", \"Saturn\")\nbf(\"Mercury\", \"Uranus\") ==> (\"Mercury\", \"Uranus\")\nbf(\"Mercury\", \"Neptune\") ==> (\"Mercury\", \"Neptune\")\nbf(\"Mercury\", \"Earth\") ==> (\"Mercury\", \"Earth\")\nbf(\"Mercury\", \"Jupiter\") ==> (\"Mercury\", \"Jupiter\")\nbf(\"Mercury\", \"Mars\") ==> (\"Mercury\", \"Mars\")\nbf(\"Mercury\", \"Saturn\") ==> (\"Mercury\", \"Saturn\")\nbf(\"Mercury\", \"Uranus\") ==> (\"Mercury\", \"Uranus\")\nbf(\"Mercury\", \"Neptune\") ==> (\"Mercury\", \"Neptune\")\nbf(\"Mercury\", \"Earth\") ==> (\"Mercury\", \"Earth\")\nbf(\"Mercury\", \"Jupiter\") ==> (\"Mercury\", \"Jupiter\")\nbf(\"Mercury\", \"Saturn\") ==> (\"Mercury\", \"Saturn\")\nbf(\"Mercury\", \"Uranus\") ==> (\"Mercury\", \"Uranus\")\nbf(\"Mercury\", \"Neptune\") ==> (\"Mercury\", \"Neptune\")\nbf(\"Mercury\", \"Earth\") ==> (\"Mercury\", \"Earth\")\nbf(\"Mercury\", \"Jupiter\") ==> (\"Mercury\", \"Jupiter\")\nbf(\"Mercury\", \"Saturn\") ==> (\"Mercury\", \"Saturn\")\nbf(\"Mercury\", \"Uranus\") ==> (\"Mercury\", \"Uranus\")\nbf(\"Mercury\", \"Neptune\") ==> (\"Mercury\", \"Neptune\")\nbf(\"Mercury\", \"Earth\") ==> (\"Mercury\", \"Earth\")\nbf(\"Mercury\", \"Jupiter\") ==> (\"Mercury\", \"Jupiter\")\nbf(\"Mercury\", \"Saturn\") ==> (\"Mercury\", \"Saturn\")\nbf(\"Mercury\", \"Uranus\") ==> (\"Mercury\", \"Uranus\")\nbf(\"Mercury\", \"Neptune\") ==> (\"Mercury\", \"Neptune\")\nbf(\"Mercury\", \"Earth\") ==> (\"Mercury\", \"Earth\")\nbf(\"Mercury\", \"Jupiter\") ==> (\"Mercury\", \"Jupiter\")\nbf(\"Mercury\", \"Saturn\") ==> (\"Mercury\", \"Saturn\")\nbf(\"Mercury\", \"Uranus\") ==> (\"Mercury\", \"Uranus\")\nbf(\"Mercury\", \"Neptune\") ==> (\"Mercury\", \"Neptune\")\nbf(\"Mercury\", \"Earth\") ==> (\"Mercury\", \"Earth\")\nbf(\""}
{"task_id": "JavaScript/149", "prompt": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const map = new Map();\n  const lenList = lst.length;\n  const lengthList = lst.reduce((acc, item) => {\n    acc.push(item.length);\n    return acc;\n  }, []);\n  const maxLen = lengthList.reduce((acc, curr) => {\n    if (curr > acc) {\n      acc = curr;\n    }\n    return acc;\n  }, 0);\n  const sortedList = lst.sort((a, b) => {\n    return a.length - b.length;\n  });\n  return sortedList.reduce((acc, item, i) => {\n    if (!map.has(item)) {\n      map.set(item, i);\n      acc.push(item);\n    }\n    return acc;\n  }, []);\n}\n\nconst sortedListSum2 = (lst) => {\n  const map = new Map();\n  const lenList = lst.length;\n  const lengthList = lst.reduce((acc, item) => {\n    acc.push(item.length);\n    return acc;\n  }, []);\n  const maxLen = lengthList.reduce((acc, curr) => {\n    if (curr > acc) {\n      acc = curr;\n    }\n    return acc;\n  }, 0);\n  const sortedList = lst.sort((a, b) => {\n    return a.length - b.length;\n  });\n  return sortedList.reduce((acc, item, i) => {\n    if (!map.has(item)) {\n      map.set(item, i);\n      acc.push(item);\n    }\n    return acc;\n  }, []);\n}\n\nconst listSum = (lst) => {\n  const map = new Map();\n  const lenList = lst.length;\n  const lengthList = lst.reduce((acc, item) => {\n    acc.push(item.length);\n    return acc;\n  }, []);\n  const maxLen = lengthList.reduce((acc, curr) => {\n    if (curr > acc) {\n      acc = curr;\n    }\n    return acc;\n  }, 0);\n  const sortedList = lst.sort((a, b) => {\n    return a.length - b.length;\n  });\n  return sortedList.reduce((acc, item, i) => {\n    if (!map.has(item)) {\n      map.set(item, i);\n      acc.push(item);\n    }\n    return acc;\n  }, []);\n}\n\nconst listSum2 = (lst) => {\n  const map = new Map();\n  const lenList = lst.length;\n  const lengthList = lst.reduce((acc, item) => {\n    acc.push(item.length);\n    return acc;\n  }, []);\n  const maxLen = lengthList.reduce((acc, curr) => {\n    if (curr > acc) {\n      acc = curr;\n    }\n    return acc;\n  }, 0);\n  const sortedList = lst.sort((a, b) => {\n    return a.length - b.length;\n  });\n  return sortedList.reduce((acc, item, i) => {\n    if (!map.has(item)) {\n      map.set(item, i);\n      acc.push(item);\n    }\n    return acc;\n  }, []);\n}\n\nconst listSum3 = (lst) => {\n  const map = new Map();\n  const lenList = lst.length;\n  const lengthList = lst.reduce((acc, item) => {\n    acc.push(item.length);\n    return acc;\n  }, []);\n  const maxLen = lengthList.reduce((acc, curr) => {\n    if (curr > acc) {\n      acc = curr;\n    }\n    return acc;\n  }, 0);\n  const sortedList = lst.sort((a, b) => {\n    return a.length - b.length;\n  });\n  return sortedList.reduce((acc, item, i) => {\n    if (!map.has(item)) {\n      map.set(item, i);\n      acc.push(item);\n    }\n    return acc;\n  }, []);\n}\n\nconst listSum4 = (lst) => {\n  const map = new Map();\n  const lenList = lst.length;\n  const lengthList = lst.reduce((acc, item) => {\n    acc.push(item.length);\n    return acc;\n  }, []);\n  const maxLen = lengthList.reduce((acc, curr) => {\n    if (curr > acc) {\n      acc = curr;\n    }\n    return acc;\n  }, 0);\n  const sortedList = lst.sort((a, b) => {\n    return a.length - b.length;\n  });\n  return sortedList.reduce((acc, item, i) => {\n    if (!map.has(item)) {\n      map.set(item, i);\n      acc.push(item);\n    }\n    return acc;\n  }, []);\n}\n\nconst listSum5 = (lst) => {\n  const map = new Map();\n  const lenList = lst.length;\n  const lengthList = lst.reduce((acc"}
{"task_id": "JavaScript/150", "prompt": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\nconsole.log(xOrY(3, 4, 5)); //=> 4\nconsole.log(xOrY(4, 4, 5)); //=> 5\nconsole.log(xOrY(15, 8, 5)); //=> 5\n<|endoftext|>"}
{"task_id": "JavaScript/151", "prompt": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const sum = (a, b) => a + b\n  const square = (a, b) => a * b\n\n  const length = lst.length\n  let totalSum = 0\n  for (let i = 0; i < length; i++) {\n    const number = lst[i]\n    if (number < 0 || isNaN(number)) {\n      continue\n    }\n    const squareOfOddNumber = number * number\n    if (number % 2 === 1) {\n      totalSum = sum(totalSum, squareOfOddNumber)\n    }\n  }\n  return totalSum\n}\n\nconsole.log(doubleTheDifference([1, 3, 2, 0])) // 10\nconsole.log(doubleTheDifference([-1, -2, 0])) // 0\nconsole.log(doubleTheDifference([9, -2])) // 81\nconsole.log(doubleTheDifference([0])) // 0\n<|endoftext|>"}
{"task_id": "JavaScript/152", "prompt": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const len = game.length\n  const guessLen = guess.length\n  let diff = 0\n\n  for (let i = 0; i < len; i++) {\n    if (game[i] === guess[i]) {\n      continue\n    }\n    if (guess[i] > game[i]) {\n      diff += Math.abs(guess[i] - game[i])\n    } else {\n      diff += Math.abs(guess[i] - game[i]) * -1\n    }\n  }\n\n  return diff\n}\n\nconst guess = (game, guess) => {\n  const len = game.length\n  const guessLen = guess.length\n\n  for (let i = 0; i < len; i++) {\n    if (game[i] === guess[i]) {\n      continue\n    }\n    if (guess[i] > game[i]) {\n      return false\n    } else {\n      return true\n    }\n  }\n  return true\n}\n\n// console.log(compare([1,2,3,4,5,1],[1,2,3,4,2,-2]))\n// console.log(compare([0,5,0,0,0,4],[4,1,1,0,0,-2]))\n// console.log(compare([4,1,1,0,0,6],[4,1,1,0,0,-2]))\n// console.log(compare([4,1,1,0,0,-2],[4,1,1,0,0,-2]))\n// console.log(compare([4,1,1,0,0,-2],[4,1,1,0,0,6]))\n<|endoftext|>"}
{"task_id": "JavaScript/153", "prompt": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n    let extension_strength = 0;\n    const extension_names = extensions.map(extension => extension.toUpperCase());\n\n    for (let i = 0; i < extension_names.length; i++) {\n        const strength = strengthOfExtension(class_name, extension_names[i]);\n        if (strength > extension_strength) {\n            extension_strength = strength;\n        }\n    }\n    return class_name + '.' + extension_names[0];\n};\n\nconst strengthOfExtension = (class_name, extension) => {\n    const strength = 0;\n    for (let i = 0; i < class_name.length; i++) {\n        if (extension.indexOf(class_name.charAt(i)) >= 0) {\n            strength++;\n        }\n    }\n    return strength;\n};\n\nconst main = () => {\n    const strongClasses = ['JavaScript', 'SV', 'Python'];\n    const strongExtensions = ['SV', 'JavaScript', 'Python'];\n\n    const strongest = strongestExtension(strongClasses[0], strongExtensions);\n    console.log(strongest);\n\n    const strongest2 = strongestExtension(strongClasses[1], strongExtensions);\n    console.log(strongest2);\n};\n\nmain();<|endoftext|>"}
{"task_id": "JavaScript/154", "prompt": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n  let aArray = a.split(\"\");\n  let bArray = b.split(\"\");\n  let check = false;\n  for(let i = 0; i < aArray.length; i++){\n    if(aArray[i] == bArray[i]){\n      continue;\n    }\n    else{\n      if(aArray[i] == bArray[i] || aArray[i] == bArray[i] + bArray[i]){\n        check = true;\n        break;\n      }\n      else{\n        break;\n      }\n    }\n  }\n  return check;\n}\n\nconsole.log(cycpatternCheck(\"abcd\",\"abd\"));\nconsole.log(cycpatternCheck(\"hello\",\"ell\"));\nconsole.log(cycpatternCheck(\"whassup\",\"psus\"));\nconsole.log(cycpatternCheck(\"abab\",\"baa\"));\nconsole.log(cycpatternCheck(\"efef\",\"eeff\"));\nconsole.log(cycpatternCheck(\"himenss\",\"simen\"));\n<|endoftext|>"}
{"task_id": "JavaScript/155", "prompt": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n    if (num === 0) return (1, 1);\n    let count = 0;\n    while (num > 0) {\n        num = num % 2;\n        if (num === 1) count += 1;\n        num = num >> 1;\n    }\n    return (count, count);\n}\n\n/*Givej an integer. return a tuple that has the number of even and odd digits respectively.\n   Note that the number of digits can't be larger than 2**31 - 1.\n\n   Example:\n      evenOddCount(15) ==> (1, 1)\n      evenOddCount(15) ==> (1, 1)\n      evenOddCount(17) ==> (1, 2)\n      evenOddCount(17) ==> (1, 2)\n      evenOddCount(32) ==> (2, 1)\n      evenOddCount(32) ==> (2, 1)\n      evenOddCount(100) ==> (2, 2)\n      evenOddCount(100) ==> (2, 2)\n      evenOddCount(999) ==> (2, 2)\n      evenOddCount(999) ==> (2, 2)\n  */\nconst evenOddDigitsCount = (num) => {\n    if (num === 0) return (1, 1);\n    let count = 0;\n    while (num > 0) {\n        num = num % 2;\n        count += num === 1? 1 : 0;\n        num = num >> 1;\n    }\n    return (count, count);\n}\n\n/* Givej an integer, return a tuple that contains the sum of digits of that number.\n   Note that the number of digits can't be larger than 2**31 - 1.\n\n   Example:\n      sumDigits(12) ==> (3)\n      sumDigits(100) ==> (2, 2)\n      sumDigits(999) ==> (2, 2)\n      sumDigits(999) ==> (2, 2)\n      sumDigits(1000) ==> (3, 1)\n      sumDigits(10000) ==> (4, 1)\n  */\nconst sumDigits = (num) => {\n    let count = 0;\n    while (num > 0) {\n        num = num % 10;\n        count += num;\n        num = num >> 1;\n    }\n    return (count, count);\n}\n\n/*Given a positive integer number, return the number of digits of that number.\n\n   Example:\n      digitsCount(12) ==> 2\n      digitsCount(1000) ==> 3\n      digitsCount(10000) ==> 4\n      digitsCount(1000) ==> 3\n      digitsCount(100000000) ==> 10\n  */\nconst digitsCount = (num) => {\n    let count = 0;\n    while (num > 0) {\n        num = num % 10;\n        count += 1;\n        num = num >> 1;\n    }\n    return count;\n}\n\n// Challenge input:\n// num = 90909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n    let result = '';\n    let i = 1;\n    while (number >= i) {\n        if (number % i === 0) {\n            result += i;\n            number = number / i;\n        } else {\n            result += number % i;\n            number = number / i;\n        }\n    }\n    return result;\n};\n\n/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in uppercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRoman = (number) => {\n    let result = '';\n    let i = 1;\n    while (number >= i) {\n        if (number % i === 0) {\n            result += i.toUpperCase();\n            number = number / i;\n        } else {\n            result += number % i.toUpperCase();\n            number = number / i;\n        }\n    }\n    return result;\n};\n\n/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRomanL = (number) => {\n    let result = '';\n    let i = 1;\n    while (number >= i) {\n        if (number % i === 0) {\n            result += i.toLowerCase();\n            number = number / i;\n        } else {\n            result += number % i.toLowerCase();\n            number = number / i;\n        }\n    }\n    return result;\n};\n\nconst toRoman = (number) => {\n    if (number <= 0) {\n        return '';\n    }\n\n    if (number <= 3) {\n        return intToRoman(number);\n    }\n\n    if (number <= 6) {\n        return intToRomanL(number);\n    }\n\n    if (number <= 9) {\n        return intToRoman(number) + 'ix';\n    }\n\n    if (number <= 13) {\n        return intToRomanL(number) + 'x';\n    }\n\n    if (number <= 19) {\n        return intToRoman(number) + 'xv';\n    }\n\n    if (number <= 23) {\n        return intToRoman(number) + 'xix';\n    }\n\n    if (number <= 39) {\n        return intToRoman(number) + 'lx';\n    }\n\n    if (number <= 47) {\n        return intToRoman(number) + 'xxv';\n    }\n\n    if (number <= 57) {\n        return intToRoman(number) + 'xlx';\n    }\n\n    return intToRoman(number) + 'xixl';\n};\n\nexport default toRoman;<|endoftext|>"}
{"task_id": "JavaScript/157", "prompt": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  return Math.abs(a - b) <= 1e-5 && Math.abs(b - c) <= 1e-5 && Math.abs(a - c) <= 1e-5;\n}\n\n// Given a triangle, return the sum of its angles\nconst triangleAngles = (a, b, c) => {\n  return (Math.atan2(a, b) + Math.atan2(c, b)) / 2;\n}\n\n// Returns the longest side of a triangle\nconst longestSide = (a, b, c) => {\n  return Math.max(Math.abs(a), Math.abs(b), Math.abs(c));\n}\n\n// Returns the midpoint of a triangle\nconst midpoint = (a, b, c) => {\n  return (a + b + c) / 2;\n}\n\n// Returns the area of a triangle\nconst triangleArea = (a, b, c) => {\n  return Math.abs(a * b / 2 + b * c / 2 + c * a / 2);\n}\n\n// Returns the diagonal of a triangle\nconst triangleDiagonal = (a, b, c) => {\n  return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2));\n}\n\n// Returns the centroid of a triangle\nconst triangleCentroid = (a, b, c) => {\n  return (a * b * c) / 6;\n}\n\n// Given a triangle, return the sum of its angles\nconst triangleSides = (a, b, c) => {\n  return (a + b + c) / 2;\n}\n\n// Given a triangle, return the area of the triangle\nconst triangleArea = (a, b, c) => {\n  return Math.abs(a * b / 2 + b * c / 2 + c * a / 2);\n}\n\n// Given a triangle, return the centroid of the triangle\nconst triangleCentroid = (a, b, c) => {\n  return (a + b + c) / 3;\n}\n\n// Given a triangle, return the length of the longest side of the triangle\nconst longestSide = (a, b, c) => {\n  return Math.max(Math.abs(a), Math.abs(b), Math.abs(c));\n}\n\n// Given a triangle, return the midpoint of the triangle\nconst midpoint = (a, b, c) => {\n  return (a + b + c) / 3;\n}\n\n// Given a triangle, return the diagonal of the triangle\nconst triangleDiagonal = (a, b, c) => {\n  return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2));\n}\n\n// Given a triangle, return the area of the triangle\nconst triangleArea = (a, b, c) => {\n  return Math.abs(a * b / 2 + b * c / 2 + c * a / 2);\n}\n\n// Given a triangle, return the centroid of the triangle\nconst triangleCentroid = (a, b, c) => {\n  return (a + b + c) / 3;\n}\n\n// Given a triangle, return the sum of the lengths of the sides of the triangle\nconst triangleSides = (a, b, c) => {\n  return (a + b + c) / 2;\n}\n\n// Given a triangle, return the area of the triangle\nconst triangleArea = (a, b, c) => {\n  return Math.abs(a * b / 2 + b * c / 2 + c * a / 2);\n}\n\n// Given a triangle, return the centroid of the triangle\nconst triangleCentroid = (a, b, c) => {\n  return (a + b + c) / 3;\n}\n\n// Given a triangle, return the length of the longest side of the triangle\nconst longestSide = (a, b, c) => {\n  return Math.max(Math.abs(a), Math.abs(b), Math.abs(c));\n}\n\n// Given a triangle, return the midpoint of the triangle\nconst midpoint = (a, b, c) => {\n  return (a + b + c) / 3;\n}\n\n// Given a triangle, return the diagonal of the triangle\nconst triangleDiagonal = (a, b, c) => {\n  return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2));\n}\n\n// Given a triangle, return the area of the triangle\nconst triangleArea = (a, b, c) => {\n  return Math.abs(a * b / 2 + b * c / 2 + c * a / 2);\n}\n\n// Given a triangle, return the centroid of the triangle\nconst triangleCentroid = (a, b, c) => {\n  return (a + b + c) / 3;\n}\n\n// Given a triangle, return the sum of the lengths of the sides of the triangle\nconst triangleSides = (a, b, c) => {\n  return (a + b + c) / 2;\n}\n\n// Given a triangle, return the area of the triangle\nconst triangleArea = (a, b, c) => {\n  return Math.abs(a * b / 2 + b * c / 2 + c * a / 2);\n}\n\n// Given a triangle, return the centroid of the triangle\nconst triangleCentroid = (a, b, c) => {\n  return (a + b + c) / 3;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/158", "prompt": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  const findMax = (words) => {\n    return words.reduce((acc, word) => {\n      if (acc === null || acc.length < word.length) {\n        return word;\n      } else {\n        return word.length > acc.length? word : acc;\n      }\n    }, null);\n  }\n  return findMax(words);\n}\n\nconsole.log(findMax([\"name\", \"of\", \"string\"]));\nconsole.log(findMax([\"name\", \"enam\", \"gaie\"]));\nconsole.log(findMax([\"aaaaaaa\", \"bb\",\"cc\"]));<|endoftext|>"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const [ number_, need_, remaining_ ] = [ number, need, remaining ];\n  const number_of_eatxh_carrots = number_ - need_;\n  const number_of_eatxh_carrots_left = remaining_ - need_;\n  return [ number_of_eatxh_carrots + number_of_eatxh_carrots_left, number_of_eatxh_carrots_left ];\n};\n\nexport { eat };\n<|endoftext|>"}
{"task_id": "JavaScript/160", "prompt": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  if (!Array.isArray(operator) ||!Array.isArray(operand)) {\n    throw new TypeError('Operator and Operand must be array')\n  }\n  const len = Math.max(operator.length, operand.length) - 1\n  let result = 0\n  for (let i = 0; i < len; i++) {\n    result += operator[i][0] * operand[i][0]\n  }\n  for (let i = len; i < operator.length; i++) {\n    result += operator[i][1] * operand[i - len][1]\n  }\n  return result\n}\n\nconst main = (array) => {\n  const operator = ['+', '-', '*', '/', '//', '**']\n  const operand = [2, 3, 4, 5]\n  console.log(doAlgebra(operator, operand))\n}\n\nmain([\n  ['+', '*', '-'],\n  [2, 3, 4, 5],\n])<|endoftext|>"}
{"task_id": "JavaScript/161", "prompt": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  const s_len = s.length;\n  let cnt = 0;\n  let rev = false;\n  for(let i = 0; i < s_len; i++){\n    if(s[i] === '#' || s[i] === '@'){\n      cnt++;\n    }\n    else if(s[i] === 'a' || s[i] === 'A'){\n      rev =!rev;\n    }\n    else{\n      s[i] = rev? s[i].toUpperCase() : s[i].toLowerCase();\n    }\n  }\n  if(cnt === 0){\n    return s;\n  }\n  return solve(s.substring(1));\n}\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\n<|endoftext|>"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  let h = text.length;\n  let x = new Array(h);\n  let f = function (b, c, d) {\n    d = d.toUpperCase();\n    var e = 0;\n    while (e < h) {\n      x[e] = b[c + e] ^ d.charCodeAt(e);\n      e += 1;\n    }\n  };\n  f(text.length, 0, 0x67452301);\n  f(text.length, 4, 0xefcdab89);\n  f(text.length, 8, 0x98badcfe);\n  f(text.length, 12, 0x10325476);\n  f(text.length, 16, 0xc3d2e1f0);\n  let md5 = [];\n  for (let i = 0; i < h; i += 1) {\n    let b = x[i];\n    let c = (b & 0xFF) | 0x80;\n    md5.push(String.fromCharCode(c));\n  }\n  return md5.join('');\n};\n\n/*\n  Givfn a string 'text', return its hex string equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToHex('Hello world') == '414243444546'\n  */\nconst stringToHex = (text) => {\n  let h = text.length;\n  let x = new Array(h);\n  let f = function (b, c, d) {\n    d = d.toUpperCase();\n    var e = 0;\n    while (e < h) {\n      x[e] = b[c + e] ^ d.charCodeAt(e);\n      e += 1;\n    }\n  };\n  f(text.length, 0, 0x67452301);\n  f(text.length, 4, 0xefcdab89);\n  f(text.length, 8, 0x98badcfe);\n  f(text.length, 12, 0x10325476);\n  f(text.length, 16, 0xc3d2e1f0);\n  let hex = [];\n  for (let i = 0; i < h; i += 1) {\n    let b = x[i];\n    let c = (b & 0xFF) | 0x80;\n    hex.push(String.fromCharCode(c));\n  }\n  return hex.join('');\n};\n\n/*\n  Givfn a string 'text', return its binary string equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToBinary('Hello world') == '414243444546'\n  */\nconst stringToBinary = (text) => {\n  let h = text.length;\n  let x = new Array(h);\n  let f = function (b, c, d) {\n    d = d.toUpperCase();\n    var e = 0;\n    while (e < h) {\n      x[e] = b[c + e] ^ d.charCodeAt(e);\n      e += 1;\n    }\n  };\n  f(text.length, 0, 0x67452301);\n  f(text.length, 4, 0xefcdab89);\n  f(text.length, 8, 0x98badcfe);\n  f(text.length, 12, 0x10325476);\n  f(text.length, 16, 0xc3d2e1f0);\n  let binary = [];\n  for (let i = 0; i < h; i += 1) {\n    let b = x[i];\n    let c = (b & 0xFF) | 0x80;\n    binary.push(String.fromCharCode(c));\n  }\n  return binary.join('');\n};\n\n/*\n  Givfn a string 'text', return its base64 string equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToBase64('Hello world') == 'SGVsbG8gV29ybGQh'\n  */\nconst stringToBase64 = (text) => {\n  let h = text.length;\n  let x = new Array(h);\n  let f = function (b, c, d) {\n    d = d.toUpperCase();\n    var e = 0;\n    while (e < h) {\n      x[e] = b[c + e] ^ d.charCodeAt(e);\n      e += 1;\n    }\n  };\n  f(text.length, 0, 0x67452301);\n  f(text.length, 4, 0xefcdab89);\n  f(text.length, 8, 0x98badcfe);\n  f(text.length, 12, 0x10325476);\n  f(text.length, 16, 0xc3d2e1f0);\n  let base64 = [];\n  for (let i = 0; i < h; i += 1) {\n    let b = x[i];\n    let c = (b & 0xFF) | 0x80;\n    base64.push(String.fromCharCode(c));\n  }\n  return base64.join('');\n};\n\n/*\n  Givfn a string 'text', return its sha1 string equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == 'da39a3ee5e6b4b0d3255bfef95601890afd80709'\n  */\nconst stringToSha1 = (text) => {\n  let h = text.length;\n  let x = new Array(h);\n  let f = function (b, c, d) {\n    d = d.toUpperCase();\n    var e = 0;\n    while (e < h) {\n      x[e] = b[c + e] ^ d.charCodeAt(e);\n      e += 1;\n    }\n  };\n  f(text.length,"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const oddDits = [0];\n  const evenDits = [];\n\n  for (let i = a; i <= b; i++) {\n    const currentDit = i;\n    const currentOddDit = (currentDit % 2 === 0)? currentDit + 1 : currentDit;\n    oddDits.push(currentOddDit);\n    evenDits.push(currentDit);\n  }\n\n  return evenDits;\n}\n\n/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in descending order.\n\n  For example:\n  generateIntegers(2, 8) => [8, 6, 4, 2]\n  generateIntegers(8, 2) => [8, 6, 4, 2]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegersDesc = (a, b) => {\n  const oddDits = [0];\n  const evenDits = [];\n\n  for (let i = a; i <= b; i++) {\n    const currentDit = i;\n    const currentOddDit = (currentDit % 2 === 0)? currentDit + 1 : currentDit;\n    oddDits.push(currentOddDit);\n    evenDits.push(currentDit);\n  }\n\n  return evenDits;\n}\n\nmodule.exports = {\n  generateIntegers,\n  generateIntegersDesc\n};\n<|endoftext|>"}
