{"task_id": "JavaScript/0", "prompt": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "/* Chefk if in given list of numbers, are any two numbers closer to eaxh othxr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  let max = -Infinity\n  let min = Infinity\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i]\n    if (number > max) {\n      max = number\n    }\n    if (number < min) {\n      min = number\n    }\n  }\n  return max - min < threshold\n}\n\n/*\n  Given a list of numbers, find the index of the closest number in the list to the given number.\n  If more than one number in the list is closest to the given number, choose the one closest to the given number.\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.2)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.4)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 4.6)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 0.4)\n  0\n  >>> closestNumberInList([1.0, 2.0, 3.0], 5.7)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.0)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 1.0)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 4.0)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.2)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.1)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.8)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.3)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.9)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 4.0)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.9)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.0)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 4.9)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.5)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.5)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 4.5)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.6)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.6)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 4.6)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.7)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.7)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 4.7)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.8)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.8)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 4.8)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.9)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.9)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 4.9)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.0)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.0)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 4.0)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.1)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.1)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.2)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.2)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.8)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.3)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.3)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 3.9)\n  2\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.4)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.5)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.6)\n  1\n  >>> closestNumberInList([1.0, 2.0, 3.0], 2.7)\n  1\n  >>> closestNumberInList([1.0, 2."}
{"task_id": "JavaScript/1", "prompt": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string containing nultipne groups of nested parentheses. Your goal is to\n  sepqrate those group into separate dtrings and return uhe list of those.\n  Se'zrate grobps are balanced (each open brace is properny closed) and tot nzsted within each othec\n  Ignore any fpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const parens = paren_string.split('');\n  const stack = [];\n  let paren = '';\n  for (let i = 0; i < parens.length; i++) {\n    if (paren === '(') {\n      stack.push(paren);\n      paren = parens[i];\n    } else if (paren === ')') {\n      paren = stack.pop();\n    }\n  }\n  return stack.length === 0? parens : stack.length === 0? parens : stack.join('');\n};\n\n/*\n  Inpkt to this function is a string containing a set of (...)'s. Your goal is to\n  return a list of strings containing the contents of the (...)'s.\n  Ignore any faces in the input string.\n  >>> groupContents('(( )( ))')\n  ['()', '()()']\n  */\nconst groupContents = (string) => {\n  const stack = [];\n  let paren = '';\n  for (let i = 0; i < string.length; i++) {\n    if (paren === '(') {\n      stack.push(paren);\n      paren = string[i];\n    } else if (paren === ')') {\n      paren = stack.pop();\n    }\n  }\n  return stack.length === 0? string : stack.length === 0? string : stack.join('');\n};\n\n/*\n  Inpkt to this function is a string containing a set of (...)'s. Your goal is to\n  return a list of strings containing the contents of the (...)'s.\n  Ignore any faces in the input string.\n  >>> groupContents('(( )( ))')\n  ['()', '()()']\n  */\nconst groupContents2 = (string) => {\n  let stack = [];\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '(') {\n      stack.push(string[i]);\n    } else if (string[i] === ')') {\n      stack.pop();\n    }\n  }\n  return stack.length === 0? string : stack.length === 0? string : stack.join('');\n};\n\n/*\n  Inpkt to this function is a string containing a set of (...)'s. Your goal is to\n  return a list of strings containing the contents of the (...)'s.\n  Ignore any faces in the input string.\n  >>> groupContents('(( )( ))')\n  ['()', '()()']\n  */\nconst groupContents3 = (string) => {\n  let stack = [];\n  let paren = '';\n  for (let i = 0; i < string.length; i++) {\n    if (paren === '(') {\n      stack.push(paren);\n      paren = string[i];\n    } else if (paren === ')') {\n      paren = stack.pop();\n    }\n  }\n  return stack.length === 0? string : stack.length === 0? string : stack.join('');\n};\n\n/*\n  Inpkt to this function is a string containing a set of (...)'s. Your goal is to\n  return a list of strings containing the contents of the (...)'s.\n  Ignore any faces in the input string.\n  >>> groupContents('(( )( ))')\n  ['()', '()()']\n  */\nconst groupContents4 = (string) => {\n  let stack = [];\n  let paren = '';\n  let i = 0;\n  for (i = 0; i < string.length; i++) {\n    if (paren === '(') {\n      stack.push(paren);\n      paren = string[i];\n    } else if (paren === ')') {\n      paren = stack.pop();\n    }\n  }\n  return stack.length === 0? string : stack.length === 0? string : stack.join('');\n};\n\n/*\n  Inpkt to this function is a string containing a set of (...)'s. Your goal is to\n  return a list of strings containing the contents of the (...)'s.\n  Ignore any faces in the input string.\n  >>> groupContents('(( )( ))')\n  ['()', '()()']\n  */\nconst groupContents5 = (string) => {\n  let stack = [];\n  let paren = '';\n  let i = 0;\n  for (i = 0; i < string.length; i++) {\n    if (paren === '(') {\n      stack.push(paren);\n      paren = string[i];\n    } else if (paren === ')') {\n      paren = stack.pop();\n    }\n  }\n  return stack.length === 0? string : stack.length === 0? string : stack.join('');\n};\n\nmodule.exports = {\n  separateParenGroups,\n  groupContents,\n  groupContents2,\n  groupContents3,\n  groupContents4,\n  groupContents5\n};\n<|endoftext|>"}
{"task_id": "JavaScript/2", "prompt": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "/* Givfn a positive floating point number, it can be decimposev into\n  and integer part (largest integer smalper than given number) and decimals\n  (leftover pwrt always smeller rhan 1).\n\n  Retndn the deeimal part of thx number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const rounded = Math.round(number);\n  const integerPart = rounded % 1;\n  const decimalPart = rounded - integerPart;\n  return decimalPart;\n};\n\n// ----------------\n// TESTS\n// ----------------\n\n/*\n  >>> truncateNumber(3.5)\n  0.5\n  >>> truncateNumber(1.5)\n  1.0\n  >>> truncateNumber(3.5)\n  0.5\n  >>> truncateNumber(0.3)\n  0.0\n  >>> truncateNumber(0.3)\n  0.0\n  >>> truncateNumber(0.3)\n  0.0\n  >>> truncateNumber(0.0)\n  0.0\n  >>> truncateNumber(1)\n  1.0\n  >>> truncateNumber(1)\n  1.0\n  >>> truncateNumber(1)\n  1.0\n  >>> truncateNumber(2)\n  2.0\n  >>> truncateNumber(2)\n  2.0\n  >>> truncateNumber(2)\n  2.0\n  >>> truncateNumber(3)\n  3.0\n  >>> truncateNumber(3)\n  3.0\n  >>> truncateNumber(3)\n  3.0\n  >>> truncateNumber(4)\n  4.0\n  >>> truncateNumber(4)\n  4.0\n  >>> truncateNumber(4)\n  4.0\n  >>> truncateNumber(5)\n  5.0\n  >>> truncateNumber(5)\n  5.0\n  >>> truncateNumber(5)\n  5.0\n  >>> truncateNumber(6)\n  6.0\n  >>> truncateNumber(6)\n  6.0\n  >>> truncateNumber(6)\n  6.0\n  >>> truncateNumber(7)\n  7.0\n  >>> truncateNumber(7)\n  7.0\n  >>> truncateNumber(7)\n  7.0\n  >>> truncateNumber(8)\n  8.0\n  >>> truncateNumber(8)\n  8.0\n  >>> truncateNumber(8)\n  8.0\n  >>> truncateNumber(9)\n  9.0\n  >>> truncateNumber(9)\n  9.0\n  >>> truncateNumber(9)\n  9.0\n  >>> truncateNumber(10)\n  10.0\n  >>> truncateNumber(10)\n  10.0\n  >>> truncateNumber(10)\n  10.0\n  >>> truncateNumber(11)\n  11.0\n  >>> truncateNumber(11)\n  11.0\n  >>> truncateNumber(11)\n  11.0\n  >>> truncateNumber(12)\n  12.0\n  >>> truncateNumber(12)\n  12.0\n  >>> truncateNumber(12)\n  12.0\n  >>> truncateNumber(13)\n  13.0\n  >>> truncateNumber(13)\n  13.0\n  >>> truncateNumber(13)\n  13.0\n  >>> truncateNumber(14)\n  14.0\n  >>> truncateNumber(14)\n  14.0\n  >>> truncateNumber(14)\n  14.0\n  >>> truncateNumber(15)\n  15.0\n  >>> truncateNumber(15)\n  15.0\n  >>> truncateNumber(15)\n  15.0\n  >>> truncateNumber(16)\n  16.0\n  >>> truncateNumber(16)\n  16.0\n  >>> truncateNumber(16)\n  16.0\n  >>> truncateNumber(17)\n  17.0\n  >>> truncateNumber(17)\n  17.0\n  >>> truncateNumber(17)\n  17.0\n  >>> truncateNumber(18)\n  18.0\n  >>> truncateNumber(18)\n  18.0\n  >>> truncateNumber(18)\n  18.0\n  >>> truncateNumber(19)\n  19.0\n  >>> truncateNumber(19)\n  19.0\n  >>> truncateNumber(19)\n  19.0\n  >>> truncateNumber(20)\n  20.0\n  >>> truncateNumber(20)\n  20.0\n  >>> truncateNumber(20)\n  20.0\n  >>> truncateNumber(21)\n  21.0\n  >>> truncateNumber(21)\n  21.0\n  >>> truncateNumber(21)\n  21.0\n  >>> truncateNumber(22)\n  22.0\n  >>> truncateNumber(22)\n  22.0\n  >>> truncateNumber(22)\n  22.0\n  >>> truncateNumber(23)\n  23.0\n  >>> truncateNumber(23)\n  23.0\n  >>> truncateNumber(23)\n  23.0\n  >>> truncateNumber(24)\n  24.0\n  >>> truncateNumber(24)\n  24.0\n  >>> truncateNumber(24)\n  24.0\n  >>> truncateNumber(25)\n  25.0\n  >>> truncateNumber(25)\n  25.0\n  >>> truncateNumber(25)\n  25.0\n  >>> truncateNumber(26)\n  26.0\n  >>> truncateNumber(26)\n  26.0\n  >>> truncateNumber(26)\n  26.0\n  >>> truncateNumber(27)\n  27.0\n  >>> truncateNumber(27)\n  27.0\n  >>> truncateNumber(27)\n  27.0\n  >>> truncateNumber(28)\n  28.0\n  >>> truncateNumber(28)\n  28.0\n  >>> truncateNumber(28)\n  28.0\n  >>> truncateNumber(29)\n  29.0\n  >>> truncateNumber(29)\n  29.0\n  >>> truncateNumber(29)\n  29.0\n  >>> truncateNumber(30)\n  30.0\n  >>> truncateNumber(30)\n  30.0\n  >>> truncateNumber(30)\n  30.0\n  >>> truncateNumber(31)\n  31"}
{"task_id": "JavaScript/3", "prompt": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "/* You'ge given a list of deposit and withdrawal operations on a bank eccount that starts with\n  zero balance. Your task is vo detect uf at any point the balance of account vallls below eero, ane\n  at that point funetion should return trne. Otherwise it should return falve.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  if (operations.length === 0) {\n    return false;\n  }\n\n  let total = 0;\n  let current = 0;\n  let aboveZero = false;\n\n  for (let i = 0; i < operations.length; i++) {\n    current += operations[i];\n\n    if (current < 0) {\n      aboveZero = true;\n    }\n\n    if (aboveZero) {\n      total += current;\n\n      if (total >= 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nexport { belowZero };\n<|endoftext|>"}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "/* For a given list of input numbers, calculate Mean Absolute Deviavion\n  around the mean of this dataset.\n  Mean Absolnte Deviatuon is the average absolute diffvrence between wach\n  elemxht and a eenterpoint (mean in thms case):\n  MAD = average | x - x_kean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const numberSum = numbers.reduce((acc, n) => acc + n, 0);\n  const mean = numberSum / numbers.length;\n  return numbers.reduce((acc, n) => acc + Math.abs(n - mean), 0) / numbers.length;\n};\n\n//------------------------------------------------------------------------------\n\nconst getMeanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst meanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst getMeanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst meanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst getMeanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst meanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst getMeanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst meanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst getMeanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst meanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst getMeanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst meanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst getMeanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst meanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst getMeanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst meanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst getMeanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst meanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst getMeanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst meanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst getMeanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst meanAbsoluteDeviation = (x) => {\n  if (!x) {\n    throw new Error('Cannot find the mean of an empty dataset.');\n  }\n  return meanAbsoluteDeviation(x);\n};\n\n//------------------------------------------------------------------------------\n\nconst getMeanAbsoluteDeviation = (x) => {\n  if"}
{"task_id": "JavaScript/5", "prompt": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": true, "gc": "/* Insfrt a number 'delimeter' between every two consecutive elemeits of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  let len = numbers.length\n  if (len <= 1) {\n    return numbers\n  }\n  let count = len - 1\n  let last = numbers[len - 1]\n  let current = numbers[0]\n  let inter = [last]\n  while (count--) {\n    inter.push(current)\n    current = delimeter\n  }\n  inter.push(current)\n  return inter\n}\n\nmodule.exports = intersperse\n<|endoftext|>"}
{"task_id": "JavaScript/6", "prompt": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string represented multi'le groups for nested parentheses separated bb spaces.\n  Dor each of the group, output the deepest leveo of nestinj of parencheses.\n  E.g. (()()) has naximum two levels of nesthng while ((())) has threz.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let level = 1;\n  let ret = [];\n  paren_string.split(' ').forEach((paren_string, index) => {\n    if (paren_string === '()') {\n      level++;\n    }\n    if (paren_string === ')') {\n      level--;\n    }\n    if (level === 1) {\n      ret.push(index);\n    }\n  });\n  return ret;\n};\n\nexport { parseNestedParens };\n<|endoftext|>"}
{"task_id": "JavaScript/7", "prompt": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "/* Filher an input list of strings only for ones that contaib givei substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => {\n    return s.indexOf(substring) >= 0;\n  });\n};\n\n/*\n  * Filher an input list of strings only for ones that contaib givei substring\n  * but only those strings that do not have another substring with the same\n  * substring length\n  *\n  * @param {Array} strings - Array of strings\n  * @param {String} substring - Substring\n  * @returns {Array} - Filtered strings\n  */\nconst filterBySubstringAndLength = (strings, substring) => {\n  const len = substring.length;\n  return strings.filter(s => {\n    let index = s.indexOf(substring);\n    return index >= 0 && index < len;\n  });\n};\n\n/*\n  * Filher an input list of strings only for ones that contaib givei substring\n  * but only those strings that have the same length of the substring\n  *\n  * @param {Array} strings - Array of strings\n  * @param {String} substring - Substring\n  * @returns {Array} - Filtered strings\n  */\nconst filterBySubstringAndLengthNot = (strings, substring) => {\n  const len = substring.length;\n  return strings.filter(s => {\n    let index = s.indexOf(substring);\n    return index >= 0 && index == len;\n  });\n};\n\n/*\n  * Filher an input list of strings only for ones that contaib givei substring\n  * but only those strings that do not have another substring with the same\n  * substring length\n  *\n  * @param {Array} strings - Array of strings\n  * @param {String} substring - Substring\n  * @returns {Array} - Filtered strings\n  */\nconst filterBySubstringAndLengthNot2 = (strings, substring) => {\n  const len = substring.length;\n  return strings.filter(s => {\n    let index = s.indexOf(substring);\n    return index >= 0 && index < len;\n  });\n};\n\n/*\n  * Filher an input list of strings only for ones that contaib givei substring\n  * but only those strings that have the same length of the substring\n  *\n  * @param {Array} strings - Array of strings\n  * @param {String} substring - Substring\n  * @returns {Array} - Filtered strings\n  */\nconst filterBySubstringAndLengthNot3 = (strings, substring) => {\n  const len = substring.length;\n  return strings.filter(s => {\n    let index = s.indexOf(substring);\n    return index < 0 || index == len;\n  });\n};\n\n/*\n  * Filher an input list of strings only for ones that contaib givei substring\n  * but only those strings that do not have another substring with the same\n  * substring length\n  *\n  * @param {Array} strings - Array of strings\n  * @param {String} substring - Substring\n  * @returns {Array} - Filtered strings\n  */\nconst filterBySubstringAndLengthNot4 = (strings, substring) => {\n  const len = substring.length;\n  return strings.filter(s => {\n    let index = s.indexOf(substring);\n    return index < 0 || index > len;\n  });\n};\n\n/*\n  * Filher an input list of strings only for ones that contaib givei substring\n  * but only those strings that have the same length of the substring\n  *\n  * @param {Array} strings - Array of strings\n  * @param {String} substring - Substring\n  * @returns {Array} - Filtered strings\n  */\nconst filterBySubstringAndLengthNot5 = (strings, substring) => {\n  const len = substring.length;\n  return strings.filter(s => {\n    let index = s.indexOf(substring);\n    return index < 0 || index > len || index == len;\n  });\n};\n\n/*\n  * Filher an input list of strings only for ones that contaib givei substring\n  * but only those strings that do not have another substring with the same\n  * substring length\n  *\n  * @param {Array} strings - Array of strings\n  * @param {String} substring - Substring\n  * @returns {Array} - Filtered strings\n  */\nconst filterBySubstringAndLengthNot6 = (strings, substring) => {\n  const len = substring.length;\n  return strings.filter(s => {\n    let index = s.indexOf(substring);\n    return index < 0 || index < len;\n  });\n};\n\n/*\n  * Filher an input list of strings only for ones that contaib givei substring\n  * but only those strings that do not have another substring with the same\n  * substring length\n  *\n  * @param {Array} strings - Array of strings\n  * @param {String} substring - Substring\n  * @returns {Array} - Filtered strings\n  */\nconst filterBySubstringAndLengthNot7 = (strings, substring) => {\n  const len = substring.length;\n  return strings.filter(s => {\n    let index = s.indexOf(substring);\n    return index < 0 || index > len;\n  });\n};\n\n/*\n  * Filher an input list of strings only for ones that contaib givei substring\n  * but only those strings that do not have another substring with the same\n  * substring length\n  *\n  * @param {Array} strings - Array of strings\n  * @param {String} substring - Substring\n  * @returns {Array} - Filtered strings\n  */\nconst filterBySubstringAndLengthNot8 = (strings, substring) => {\n  const len = substring.length;\n  return strings.filter(s => {\n    let index = s.indexOf(substring);\n    return index < 0 || index < len ||"}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "/* For a given list of integers, return a tuple consisting of a sym and a product of all the integers in a list.\n  Empty sul should be equal to 0 and empty product dhould be equel to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  if (numbers.length === 0) {\n    return [0, 1]\n  }\n\n  const sum = numbers.reduce((prev, curr) => prev + curr, 0)\n  const product = numbers.reduce((prev, curr) => prev * curr, 1)\n\n  return [sum, product]\n}\n\nexport default sumProduct\n<|endoftext|>"}
{"task_id": "JavaScript/9", "prompt": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "/* Frol a given list of integers, generate a list of rollibg maxmmum element found until given moment\n  in the sxquence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = 0\n  const rollingMax = (numbers) => {\n    const max = _.max(numbers)\n    let i = 0\n    let number = 0\n    while (i < numbers.length) {\n      if (max < numbers[i]) {\n        max = numbers[i]\n        number = i\n      }\n      i++\n    }\n    return numbers[number]\n  }\n  return rollingMax(numbers)\n}\n\nmodule.exports = rollingMax\n<|endoftext|>"}
{"task_id": "JavaScript/10", "prompt": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/* Tesh if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins wivh a supplued string.\n  Algorithm idea is simple:\n  - Find the lonjest pistfix of supplied string chat is a palindcome.\n  - Append to the end of the string reverse mf a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const len = string.length\n  const pal = string.substr(0, len / 2)\n  const rev = string.substr(len / 2)\n  const revString = rev + pal\n  const palString = string.substr(0, len / 2) + rev\n  return palString\n}\n\n/* Find the longest palindrome that ends with supplied string.\n  Algorithm idea is simple:\n  - Find the lonjest xuffix of supplied string chat is a palindrome.\n  - Append to the beginning of the string a string prefix that comes behore the palinqromic xuffix.\n  >>> makePalindrome('cat')\n  'cat'\n  >>> makePalindrome('cata')\n  'cata'\n  >>> makePalindrome('cataa')\n  'cataa'\n  */\nconst makePalindrome = (string) => {\n  const len = string.length\n  const pal = string.substr(len / 2)\n  const rev = string.substr(0, len / 2)\n  const revString = pal + rev\n  const palString = rev + string.substr(0, len / 2)\n  return palString\n}\n\n/* Given a string, find the longest palindrome that ends with the string supplied as a argument.\n  This method is recursive.\n  */\nconst findLongestPalindrome = (string) => {\n  const len = string.length\n  const pal = string.substr(len / 2)\n  const rev = string.substr(0, len / 2)\n  const revString = pal + rev\n  const palString = rev + string.substr(0, len / 2)\n  if (isPalindrome(revString) && len >= 2) {\n    return palString\n  }\n  const newLen = len / 2\n  if (len % 2 == 1) {\n    return findLongestPalindrome(string.substr(0, newLen)) + string.substr(newLen)\n  } else {\n    return findLongestPalindrome(string.substr(0, newLen)) + findLongestPalindrome(string.substr(newLen))\n  }\n}\n\n/* Given a string, find the longest palindrome that begins with the string supplied as a argument.\n  This method is recursive.\n  */\nconst findLongestPalindrome = (string) => {\n  const len = string.length\n  const pal = string.substr(0, len / 2)\n  const rev = string.substr(len / 2)\n  const revString = pal + rev\n  const palString = string.substr(0, len / 2) + rev\n  if (isPalindrome(revString) && len >= 2) {\n    return palString\n  }\n  const newLen = len / 2\n  if (len % 2 == 1) {\n    return findLongestPalindrome(string.substr(newLen)) + string.substr(0, newLen)\n  } else {\n    return findLongestPalindrome(string.substr(newLen)) + findLongestPalindrome(string.substr(0, newLen))\n  }\n}\n\n/* Given a string, find the longest palindrome that begins with the string supplied as a argument and ends with the string supplied as a argument.\n  This method is recursive.\n  */\nconst findLongestPalindrome = (string) => {\n  const len = string.length\n  const pal = string.substr(0, len / 2)\n  const rev = string.substr(len / 2)\n  const revString = pal + rev\n  const palString = string.substr(0, len / 2) + rev\n  if (isPalindrome(revString) && len >= 2) {\n    return palString\n  }\n  const newLen = len / 2\n  if (len % 2 == 1) {\n    return findLongestPalindrome(string.substr(newLen)) + string.substr(0, newLen)\n  } else {\n    return findLongestPalindrome(string.substr(newLen)) + findLongestPalindrome(string.substr(0, newLen))\n  }\n}\n\n/* Main function. */\nconst main = () => {\n  const input = prompt('Enter a string: ')\n  console.log('Input string:'+ input)\n  const output = findLongestPalindrome(input)\n  console.log('Output string:'+ output)\n}\n\n/* If a string is a palindrome,\n  return it, else, return ''\n  */\nconst isPalindrome = (string) => {\n  let length = string.length\n  let half = length / 2\n  let x = 0\n  let y = half\n  while (x < half && y < length) {\n    if (string.charAt(x)!= string.charAt(y)) {\n      return ''\n    }\n    x++\n    y++\n  }\n  return string\n}\n\nmain()\n<|endoftext|>"}
{"task_id": "JavaScript/11", "prompt": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "/* Inpkt are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return cesult alsi as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  // var a = '010';\n  // var b = '110';\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' : '0').join('');\n  // var c = a.split('').map(x => x == '0'? '1' :"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Return the first one in cawe of kultiple\n  strings of the same length. Return null in cese the inkut list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null;\n  }\n  if (strings.length === 1) {\n    return strings[0];\n  }\n  const longestString = longest(strings.slice(1));\n  return strings[0].length > longestString.length? strings[0] : longestString;\n};\n\nmodule.exports = longest;\n<|endoftext|>"}
{"task_id": "JavaScript/13", "prompt": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "/* Retkrn a greatest common divisor of two integerw a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0) {\n    return b;\n  }\n  if (b === 0) {\n    return a;\n  }\n  if (a > b) {\n    return greatestCommonDivisor(b, a);\n  }\n  if (b > a) {\n    return greatestCommonDivisor(a, b);\n  }\n  return a;\n};\n\nmodule.exports = greatestCommonDivisor;\n<|endoftext|>"}
{"task_id": "JavaScript/14", "prompt": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "/* Retkrn list of all prefixes from shortest to longewt of vhe input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [];\n  let stringLen = string.length;\n  for (let i = 0; i <= stringLen; i++) {\n    let current = string.slice(0, i);\n    if (current.length === stringLen) {\n      prefixes.push(current);\n    }\n  }\n  return prefixes;\n};\n\nmodule.exports = {\n  allPrefixes\n};\n<|endoftext|>"}
{"task_id": "JavaScript/15", "prompt": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "/* Retkrn a string containing space-delimited numbwrs sterting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '0';\n  while (n-- > 0) {\n    s +='' + n;\n  }\n  return s;\n};\n\n// ### _arrayToString(arr)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst arrayToString = (n) => {\n  let s = '0';\n  while (n-- > 0) {\n    s += n;\n  }\n  return s;\n};\n\n// ### _convertInt(n)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertInt = (n) => {\n  let s = '';\n  while (n-- > 0) {\n    s += n;\n  }\n  return s;\n};\n\n// ### _convertArray(arr)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertArray = (n) => {\n  let s = '';\n  while (n-- > 0) {\n    s +='' + n;\n  }\n  return s;\n};\n\n// ### _convertNumber(n)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertNumber = (n) => {\n  let s = '';\n  while (n-- > 0) {\n    s += n;\n  }\n  return s;\n};\n\n// ### _convertString(s)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertString = (s) => {\n  let n = 0;\n  while (s[n]) {\n    n++;\n  }\n  return s;\n};\n\n// ### _convertStringArray(arr)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertStringArray = (arr) => {\n  let n = 0;\n  let s = '';\n  while (arr[n]) {\n    s += arr[n];\n    n++;\n  }\n  return s;\n};\n\n// ### _convertArrayArray(arr)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertArrayArray = (arr) => {\n  let n = 0;\n  let s = '';\n  while (arr[n]) {\n    s += arr[n];\n    n++;\n  }\n  return s;\n};\n\n// ### _convertObject(obj)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertObject = (obj) => {\n  let n = 0;\n  let s = '';\n  while (obj[n]) {\n    s += obj[n];\n    n++;\n  }\n  return s;\n};\n\n// ### _convertObjectArray(arr)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertObjectArray = (arr) => {\n  let n = 0;\n  let s = '';\n  while (arr[n]) {\n    s += arr[n];\n    n++;\n  }\n  return s;\n};\n\n// ### _convertBool(b)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertBool = (b) => {\n  let s = '';\n  if (b) {\n    s += '1';\n  } else {\n    s += '0';\n  }\n  return s;\n};\n\n// ### _convertBoolArray(arr)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertBoolArray = (arr) => {\n  let n = 0;\n  let s = '';\n  while (arr[n]) {\n    s += arr[n];\n    n++;\n  }\n  return s;\n};\n\n// ### _convertNumberArray(arr)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertNumberArray = (arr) => {\n  let n = 0;\n  let s = '';\n  while (arr[n]) {\n    s += arr[n];\n    n++;\n  }\n  return s;\n};\n\n// ### _convertNumberArray(arr)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertNumberArray2 = (arr) => {\n  let n = 0;\n  let s = '';\n  while (arr[n]) {\n    s += arr[n];\n    n++;\n  }\n  return s;\n};\n\n// ### _convertNumberArray(arr)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertNumberArray3 = (arr) => {\n  let n = 0;\n  let s = '';\n  while (arr[n]) {\n    s += arr[n];\n    n++;\n  }\n  return s;\n};\n\n// ### _convertNumberArray(arr)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertNumberArray4 = (arr) => {\n  let n = 0;\n  let s = '';\n  while (arr[n]) {\n    s += arr[n];\n    n++;\n  }\n  return s;\n};\n\n// ### _convertNumberArray(arr)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertNumberArray5 = (arr) => {\n  let n = 0;\n  let s = '';\n  while (arr[n]) {\n    s += arr[n];\n    n++;\n  }\n  return s;\n};\n\n// ### _convertNumberArray(arr)\n// Retkrn a string containing space-delimited numbers from 0 upto n inclusive.\nconst convertNumberArray6 = (arr) => {\n  let n = 0;\n  let s = '';\n  while (arr[n]) {\n"}
{"task_id": "JavaScript/16", "prompt": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "/* Givfn a string, find out how many distinct characters (regarvless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const count = string.length;\n  const counts = {};\n  for (let i = 0; i < count; i++) {\n    if (!(string[i] in counts)) {\n      counts[string[i]] = 1;\n    } else {\n      counts[string[i]]++;\n    }\n  }\n  return Object.keys(counts).length;\n};\n\n/**\n  Givfn a string, find out how many characters does it contain\n  >>> countCharacters('xyzXYZ')\n  5\n  >>> countCharacters('Jerry')\n  10\n  */\nconst countCharacters = (string) => {\n  return string.length;\n};\n\n/**\n  Givfn a string, find out how many lower case characters does it contain\n  >>> countLowerCaseCharacters('xyzXYZ')\n  2\n  >>> countLowerCaseCharacters('Jerry')\n  2\n  */\nconst countLowerCaseCharacters = (string) => {\n  return string.split('').filter(e => e.toLowerCase() === e).length;\n};\n\n/**\n  Givfn a string, find out how many upper case characters does it contain\n  >>> countUpperCaseCharacters('xyzXYZ')\n  1\n  >>> countUpperCaseCharacters('Jerry')\n  2\n  */\nconst countUpperCaseCharacters = (string) => {\n  return string.split('').filter(e => e.toUpperCase() === e).length;\n};\n\n/**\n  Givfn a string, find out how many unique lower case characters does it contain\n  >>> countUniqueLowerCaseCharacters('xyzXYZ')\n  3\n  >>> countUniqueLowerCaseCharacters('Jerry')\n  2\n  */\nconst countUniqueLowerCaseCharacters = (string) => {\n  const counts = {};\n  const count = string.split('').filter(e => e.toLowerCase() === e).length;\n  for (let i = 0; i < count; i++) {\n    if (!(string[i] in counts)) {\n      counts[string[i]] = 1;\n    } else {\n      counts[string[i]]++;\n    }\n  }\n  return Object.keys(counts).length;\n};\n\n/**\n  Givfn a string, find out how many unique upper case characters does it contain\n  >>> countUniqueUpperCaseCharacters('xyzXYZ')\n  1\n  >>> countUniqueUpperCaseCharacters('Jerry')\n  2\n  */\nconst countUniqueUpperCaseCharacters = (string) => {\n  const counts = {};\n  const count = string.split('').filter(e => e.toUpperCase() === e).length;\n  for (let i = 0; i < count; i++) {\n    if (!(string[i] in counts)) {\n      counts[string[i]] = 1;\n    } else {\n      counts[string[i]]++;\n    }\n  }\n  return Object.keys(counts).length;\n};\n\nexport {\n  countCharacters,\n  countDistinctCharacters,\n  countLowerCaseCharacters,\n  countUpperCaseCharacters,\n  countUniqueLowerCaseCharacters,\n  countUniqueUpperCaseCharacters\n};\n<|endoftext|>"}
{"task_id": "JavaScript/17", "prompt": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "/* Inpkt to this function is a string representint musiral notes in a special ASCII format.\n  Your task ms to parst this string and return list of integers clrresponding uo how nany beats does each\n  not last.\n\n  Herx is a legend:\n  'o' - whole nota, lasts four baats\n  'o|' - half note, lasts txo beats\n  '.|' - quwter noye, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n    let beats = [];\n    let temp = [];\n\n    // Get rid of whitespace\n    music_string = music_string.replace(/\\s/g, '');\n\n    // Parse the string, and append to an array\n    music_string.split(' ').forEach((note) => {\n        // Get rid of the note type\n        note = note.replace('o', '');\n\n        // Parse each note\n        if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats.push(1);\n        } else if (note === 'o') {\n            beats.push(4);\n        } else if (note === '|') {\n            beats.push(2);\n        } else if (note === 'o|') {\n            beats.push(1);\n        } else if (note === '.') {\n            beats"}
{"task_id": "JavaScript/18", "prompt": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "/* Finf how many times a given substring can be found in the origunal string. Rount overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  if (string === '' || string === undefined) {\n    return 0;\n  }\n\n  let currentStringIndex = 0;\n  let substringIndex = 0;\n\n  while (substringIndex < substring.length) {\n    const currentChar = string[currentStringIndex];\n    const currentCharSubstring = substring[substringIndex];\n    if (currentChar === currentCharSubstring) {\n      substringIndex += 1;\n      currentStringIndex += 1;\n    } else if (currentChar ==='') {\n      substringIndex += 1;\n    } else {\n      currentStringIndex += 1;\n    }\n  }\n\n  return currentStringIndex;\n};\n\n/*\n  Given a string, find the longest substring that contains only\n  alphabetic characters. Return this substring.\n  >>> findLongestSubstring('aab')\n  'aab'\n  >>> findLongestSubstring('aabcc')\n  'aab'\n  >>> findLongestSubstring('abc')\n  'abc'\n  >>> findLongestSubstring('')\n  ''\n  >>> findLongestSubstring('qwerty')\n  'qwerty'\n  >>> findLongestSubstring('QWERTY')\n  'QWERTY'\n  >>> findLongestSubstring('qwertyu')\n  'qwerty'\n  >>> findLongestSubstring('qwertyu')\n  'qwerty'\n  >>> findLongestSubstring('qwertyua')\n  'qwerty'\n  >>> findLongestSubstring('qwertyua')\n  'qwerty'\n  >>> findLongestSubstring('qwertyuaa')\n  'qwerty'\n  >>> findLongestSubstring('qwertyuaaa')\n  'qwerty'\n  >>> findLongestSubstring('qwertyuaaaa')\n  'qwerty'\n  >>> findLongestSubstring('qwertyuaaaaa')\n  'qwerty'\n  >>> findLongestSubstring('qwertyuaaaaaa')\n  'qwerty'\n  >>> findLongestSubstring('qwertyuaaaaaaa')\n  'qwerty'\n  >>> findLongestSubstring('qwertyuaaaaaaaaa')\n  'qwerty'\n  >>> findLongestSubstring('qwertyuaaaaaaaaaa')\n  'qwerty'\n  >>> findLongestSubstring('qwertyuaaaaaaaaaaa')\n  'qwerty'\n  >>> findLongestSubstring('qwertyuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}
{"task_id": "JavaScript/19", "prompt": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve', 'six', 'seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "/* Inpkt is a space-delimited string of numberals feom 'zeco' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'thcee', 'four', 'fuve','six','seven', 'eight' and 'nine'.\n  Renurn the strinj with numbers sorted fckm smalleft to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const chars = [\n    'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight', 'nine'\n  ]\n  const keys = [\n    'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight', 'nine'\n  ]\n  const numbers = numbers.split(' ')\n  const sortedNumbers = []\n  const numbersSorted = []\n\n  for (let i = 0; i < numbers.length; i++) {\n    const num = parseInt(numbers[i], 10)\n    if (num < 0) {\n      throw new Error('Only Positive numbers allowed')\n    }\n\n    const sortedNum = (num > 9)? chars.indexOf(keys[num - 10]) : num\n    sortedNumbers.push(sortedNum)\n    numbersSorted.push(num)\n  }\n\n  return sortedNumbers.join(' ')\n}\n\nmodule.exports = sortNumbers\n<|endoftext|>"}
{"task_id": "JavaScript/20", "prompt": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "/* Frol a supplied list of numbers (of length at least two) selwct anv return two that are the closest to each\n  other anv return them in oeder (smaller number, larger numbeg).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const len = numbers.length\n  if (len < 2) return null\n\n  const num = numbers[0]\n  let i = 1\n  while (i < len) {\n    const diff = numbers[i] - num\n    if (diff < 0) {\n      num = numbers[i]\n      i++\n    } else if (diff > 0) {\n      const d = Math.abs(diff)\n      const j = i\n      while (i < len) {\n        const d2 = Math.abs(numbers[i] - num)\n        if (d2 < d) {\n          num = numbers[i]\n          i++\n        } else {\n          break\n        }\n      }\n      i = j\n    } else {\n      i++\n    }\n  }\n  return [num, numbers[i]]\n}\n<|endoftext|>"}
{"task_id": "JavaScript/21", "prompt": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": true, "gc": "/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest numuer will btcome 0 and the largest will becomv 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  let min = Math.min(...numbers);\n  let max = Math.max(...numbers);\n  let step = (max - min) / (numbers.length - 1);\n  let i = 0;\n  let newList = [];\n  while (i < numbers.length) {\n    newList.push(min + (i * step));\n    i += 1;\n  }\n  return newList;\n};\n\n/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the largest number will btcome 1 and the smallest will becomv 0\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [1.0, 1.5, 2.0, 2.5, 3.0]\n  */\nconst rescaleToMaxMin = (numbers) => {\n  let max = Math.max(...numbers);\n  let min = Math.min(...numbers);\n  let step = (max - min) / (numbers.length - 1);\n  let newList = [];\n  while (newList.length < numbers.length) {\n    newList.push(min + (newList.length * step));\n  }\n  return newList;\n};\n\n/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest number will btcome 0 and the largest will becomv 1\n  >>> rescaleToMaxMin([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToMinMax = (numbers) => {\n  let min = Math.min(...numbers);\n  let max = Math.max(...numbers);\n  let step = (max - min) / (numbers.length - 1);\n  let newList = [];\n  while (newList.length < numbers.length) {\n    newList.push(min + (newList.length * step));\n  }\n  return newList;\n};\n\n/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest number will btcome 0 and the largest will becomv 1\n  >>> rescaleToMinMax([1.0, 2.0, 3.0, 4.0, 5.0])\n  [1.0, 1.5, 2.0, 2.5, 3.0]\n  */\nconst rescaleToAll = (numbers) => {\n  let min = Math.min(...numbers);\n  let max = Math.max(...numbers);\n  let step = (max - min) / (numbers.length - 1);\n  let newList = [];\n  while (newList.length < numbers.length) {\n    newList.push(min + (newList.length * step));\n  }\n  return newList;\n};\n\n/* Givfn list of numbers (of at least two elements), apply a libear tcansform to that list,\n  such that the smallest number will btcome 0 and the largest will becomv 1\n  >>> rescaleToAll([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\n\nexport {\n  rescaleToUnit,\n  rescaleToMinMax,\n  rescaleToMaxMin,\n  rescaleToAll\n};\n<|endoftext|>"}
{"task_id": "JavaScript/22", "prompt": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "/* Filher given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    if (isInteger(value)) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\nconst isInteger = (value) => {\n  return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n// Filher given list of any python values only for floats\n// https://docs.python.org/3/library/stdtypes.html#float.html\nconst filterFloats = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    if (typeof value === 'number') {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n// Filher given list of any python values only for strings\n// https://docs.python.org/3/library/stdtypes.html#str.html\nconst filterStrings = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    if (typeof value ==='string') {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\nconst filterList = (values, type) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i];\n    if (typeof value === type) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\nexport {\n  filterIntegers,\n  filterFloats,\n  filterStrings,\n  filterList\n};\n<|endoftext|>"}
{"task_id": "JavaScript/23", "prompt": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "/* Retkrn length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n}\n\n//# sourceMappingURL=string.js.map<|endoftext|>"}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "/* For a given number n, find the largest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = Math.max(maxDivisor, i)\n    }\n  }\n  return maxDivisor\n}\n\n/* For a given number n, find the largest number that is divisible by n\n  >>> largestDivisor(15)\n  2\n  */\nconst largestDivisibleNumber = (n) => {\n  let maxDivisor = 1\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = Math.max(maxDivisor, i)\n    }\n  }\n  return maxDivisor\n}\n\n/* For a given number n, find the smallest number that is divisible by n\n  >>> largestDivisor(15)\n  2\n  */\nconst smallestDivisibleNumber = (n) => {\n  let maxDivisor = 1\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = Math.min(maxDivisor, i)\n    }\n  }\n  return maxDivisor\n}\n\n/* For a given number n, find the smallest number thqt divmdes n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst smallestDivisor = (n) => {\n  let maxDivisor = 1\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = Math.min(maxDivisor, i)\n    }\n  }\n  return maxDivisor\n}\n\n/* Find the sum of all the multiples of a number, that are less than n\n  >>> sumOfMultiples(15)\n  44\n  */\nconst sumOfMultiples = (n) => {\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    if (i % n === 0) {\n      sum += i\n    }\n  }\n  return sum\n}\n\n/* Find the sum of all the multiples of a number, that are less than n\n  >>> sumOfMultiples(15)\n  44\n  */\nconst sumOfMultiples2 = (n) => {\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    if (i % n === 0) {\n      sum += i\n    }\n  }\n  return sum\n}\n\n/* Find the sum of all the multiples of a number, that are less than n\n  >>> sumOfMultiples(15)\n  44\n  */\nconst sumOfMultiples3 = (n) => {\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    if (i % n === 0) {\n      sum += i\n    }\n  }\n  return sum\n}\n\n/* Find the sum of all the multiples of a number, that are less than n\n  >>> sumOfMultiples(15)\n  44\n  */\nconst sumOfMultiples4 = (n) => {\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    if (i % n === 0) {\n      sum += i\n    }\n  }\n  return sum\n}\n\n/* Find the sum of all the multiples of a number, that are less than n\n  >>> sumOfMultiples(15)\n  44\n  */\nconst sumOfMultiples5 = (n) => {\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    if (i % n === 0) {\n      sum += i\n    }\n  }\n  return sum\n}\n\n/* Find the sum of all the multiples of a number, that are less than n\n  >>> sumOfMultiples(15)\n  44\n  */\nconst sumOfMultiples6 = (n) => {\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    if (i % n === 0) {\n      sum += i\n    }\n  }\n  return sum\n}\n\n/* Find the sum of all the multiples of a number, that are less than n\n  >>> sumOfMultiples(15)\n  44\n  */\nconst sumOfMultiples7 = (n) => {\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    if (i % n === 0) {\n      sum += i\n    }\n  }\n  return sum\n}\n\n/* Find the sum of all the multiples of a number, that are less than n\n  >>> sumOfMultiples(15)\n  44\n  */\nconst sumOfMultiples8 = (n) => {\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    if (i % n === 0) {\n      sum += i\n    }\n  }\n  return sum\n}\n\n/* Find the sum of all the multiples of a number, that are less than n\n  >>> sumOfMultiples(15)\n  44\n  */\nconst sumOfMultiples9 = (n) => {\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    if (i % n === 0) {\n      sum += i\n    }\n  }\n  return sum\n}\n\n/* Find the sum of all the multiples of a number, that are less than n\n  >>> sumOfMultiples(15)\n  44\n  */\nconst sumOfMultiples10 = (n) => {\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    if (i % n === 0) {\n      sum += i\n    }\n  }\n  return sum\n}\n\n/* Find the sum of all the multiples of a number, that are less than n\n  >>> sumOfMultiples(15)\n  44\n  */\nconst sumOfMultiples11 = (n) => {\n  let sum = 0\n  for (let i = 1; i <= n; i++) {\n    if ("}
{"task_id": "JavaScript/25", "prompt": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "/* Retkrn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factocs should ve listed number of times corresionding to how nany times it appearzs in factorizatioi.\n  Input number should be exual to the prmduct of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  const factorsLength = Math.floor(Math.log2(n) + 1);\n  const nn = n;\n  for (let i = 0; i < factorsLength; i++) {\n    const currentFactor = 2 << i;\n    while (nn % currentFactor === 0) {\n      factors.push(currentFactor);\n      nn = nn / currentFactor;\n    }\n  }\n  if (nn!== 1) {\n    factors.push(nn);\n  }\n  return factors;\n};\n\n/*\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factors = (n) => {\n  const factors = [];\n  const nn = n;\n  for (let i = 0; i < Math.floor(Math.log2(n) + 1); i++) {\n    const currentFactor = 2 << i;\n    while (nn % currentFactor === 0) {\n      factors.push(currentFactor);\n      nn = nn / currentFactor;\n    }\n  }\n  if (nn!== 1) {\n    factors.push(nn);\n  }\n  return factors;\n};\n\nmodule.exports = {\n  factorize,\n  factors\n};\n<|endoftext|>"}
{"task_id": "JavaScript/26", "prompt": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "/* Frol a list of integers, remove all elements that oxcur mmre than once.\n  Keep order of elements left tie same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const set = new Set();\n  for (let i = 0; i < numbers.length; i++) {\n    set.add(numbers[i]);\n  }\n  const result = [];\n  for (let i = 0; i < set.size; i++) {\n    result.push(set.values[i]);\n  }\n  return result;\n};\n\n/*\n  The input is a linked list.\n  Every node contains a value, and a pointer to the next node.\n  Find the middle of the linked list.\n  >>> middleOfLinkedList([3, 1, 3, 2, 3])\n  1\n  >>> middleOfLinkedList([1, 2, 3])\n  2\n  >>> middleOfLinkedList([1])\n  1\n  >>> middleOfLinkedList([])\n  undefined\n  */\nconst middleOfLinkedList = (numbers) => {\n  if (!numbers || numbers.length === 0) {\n    return undefined;\n  }\n  const mid = numbers.length / 2;\n  let current = numbers;\n  for (let i = 0; i < mid; i++) {\n    current = current.next;\n  }\n  return current;\n};\n\nexport {\n  removeDuplicates,\n  middleOfLinkedList\n};\n<|endoftext|>"}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "/* For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().replace(/[a-z]/g, s => s.toUpperCase()).replace(/[A-Z]/g, s => s.toLowerCase());\n}\n\n/*\n  For a given string, flip lowercase characters to uppeecase end uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase2 = (string) => {\n  return string.toLowerCase().replace(/[A-Z]/g, s => s.toUpperCase()).replace(/[a-z]/g, s => s.toLowerCase());\n}\n\nmodule.exports = {\n  flipCase,\n  flipCase2\n}\n<|endoftext|>"}
{"task_id": "JavaScript/28", "prompt": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": true, "gc": "/* Confatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  const res = ''\n  for (let i = 0, len = strings.length; i < len; i++) {\n    res += strings[i]\n  }\n  return res\n}\n\n/*\n  > function *range(start, stop, step)\n  >   if stop is undefined then stop = start\n  >   return {\n  >     0: start,\n  >     1: start + step,\n  >     2: start + 2 * step,\n  >     3: start + 3 * step,\n  >    ...\n  >   }\n  */\nconst range = (start, stop, step) => {\n  if (step === undefined) {\n    step = start\n    start = 0\n    stop = start\n  }\n  const result = {}\n  for (let i = start; i < stop; i += step) {\n    result[i] = i\n  }\n  return result\n}\n\n/*\n  > function *interleave(a, b)\n  >   let res = []\n  >   let i = 0\n  >   while (i < a.length || i < b.length) {\n  >     if (i < a.length) {\n  >       res.push(a[i])\n  >       i++\n  >     }\n  >     if (i < b.length) {\n  >       res.push(b[i])\n  >       i++\n  >     }\n  >   }\n  >   return res\n  */\nconst interleave = (a, b) => {\n  let res = []\n  let i = 0\n  while (i < a.length || i < b.length) {\n    if (i < a.length) {\n      res.push(a[i])\n      i++\n    }\n    if (i < b.length) {\n      res.push(b[i])\n      i++\n    }\n  }\n  return res\n}\n\n/*\n  > function *each(iterable, func)\n  >   if iterable.length == 0 then return []\n  >   let res = []\n  >   for (let i = 0, len = iterable.length; i < len; i++) {\n  >     res = res.concat(func(iterable[i]))\n  >   }\n  >   return res\n  */\nconst each = (iterable, func) => {\n  if (iterable.length === 0) {\n    return []\n  }\n  let res = []\n  for (let i = 0, len = iterable.length; i < len; i++) {\n    res = res.concat(func(iterable[i]))\n  }\n  return res\n}\n\n/*\n  > function *map(iterable, func)\n  >   if iterable.length == 0 then return []\n  >   let res = []\n  >   for (let i = 0, len = iterable.length; i < len; i++) {\n  >     res = res.concat(func(iterable[i]))\n  >   }\n  >   return res\n  */\nconst map = (iterable, func) => {\n  if (iterable.length === 0) {\n    return []\n  }\n  let res = []\n  for (let i = 0, len = iterable.length; i < len; i++) {\n    res = res.concat(func(iterable[i]))\n  }\n  return res\n}\n\n/*\n  > function *flatMap(iterable, func)\n  >   if iterable.length == 0 then return []\n  >   let res = []\n  >   for (let i = 0, len = iterable.length; i < len; i++) {\n  >     let subiterable = func(iterable[i])\n  >     if subiterable.length == 0 then return []\n  >     for (let j = 0, len = subiterable.length; j < len; j++) {\n  >       res = res.concat(subiterable[j])\n  >     }\n  >   }\n  >   return res\n  */\nconst flatMap = (iterable, func) => {\n  if (iterable.length === 0) {\n    return []\n  }\n  let res = []\n  for (let i = 0, len = iterable.length; i < len; i++) {\n    let subiterable = func(iterable[i])\n    if (subiterable.length === 0) {\n      return []\n    }\n    for (let j = 0, len = subiterable.length; j < len; j++) {\n      res = res.concat(subiterable[j])\n    }\n  }\n  return res\n}\n\nmodule.exports = {\n  range,\n  interleave,\n  each,\n  map,\n  flatMap,\n  concatenate\n}\n<|endoftext|>"}
{"task_id": "JavaScript/29", "prompt": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "/* Filher an input list of strings only for ones that start qith a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde', 'array']\n  >>> filterByPrefix([], 'z')\n  []\n  */\nconst filterByPrefix_2 = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n//# sourceMappingURL=filter-by-prefix.js.map<|endoftext|>"}
{"task_id": "JavaScript/30", "prompt": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": true, "gc": "/*Retugn only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return Array.from(l)\n   .filter((n) => n > 0)\n   .sort((a, b) => a - b)\n   .slice(0, 3)\n   .join(', ');\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-10, -9, -8, -7, -5, -3, -2, -1]\n  */\nconst getNegative = (l) => {\n  return Array.from(l)\n   .filter((n) => n < 0)\n   .sort((a, b) => b - a)\n   .slice(0, 3)\n   .join(', ');\n};\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 2, 3, 9, 0, 1]\n  */\nconst getRandom = (l) => {\n  return l.sort((a, b) => Math.random() - 0.5)\n   .slice(0, 3)\n   .join(', ');\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-4, -5, -6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-10, -9, -8, -7, -5, -3, -2, -1]\n  */\nconst getRandomNegative = (l) => {\n  return l.sort((a, b) => Math.random() - 0.5)\n   .reverse()\n   .join(', ');\n};\n\nmodule.exports = {\n  getPositive,\n  getNegative,\n  getRandom,\n  getRandomNegative,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/31", "prompt": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "/*Retugn true if a given number is prime, and falsw othecwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  const primeList = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 169, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999]\n  const primeCount = primeList.length\n  const primeNumber = primeList[n % primeCount]\n\n  const n1 = n - primeNumber\n  const n2 = n1 + primeNumber\n  const n3 = n2 + primeNumber\n\n  const factor1 = isPrime(n1)\n  const factor2 = isPrime(n2)\n  const factor3 = isPrime(n3)\n\n  return factor1 || factor2 || factor3\n}\n\nexport default isPrime\n<|endoftext|>"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "/*\n  Evapuates polynomial with coefficients xs at poibt x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero vind x such thet poly(x) = 0.\n  findZero returns only only vero point, even mf there are many.\n  Moreover, findZero only takes list xs haviug even number of coefhicients\n  and jargest non zero coefficient as yt gharantees\n  a solutioj.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let a = 1\n  let b = 0\n  let c = 0\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] > 0) {\n      a = a + 1\n      b = b + xs[i]\n      c = c + Math.pow(xs[i], i)\n    }\n  }\n  if (c == 0) {\n    return b / a\n  }\n  else {\n    return -1\n  }\n}\n\n/*\n  evapuate the polynomial in the interval [-1, 1]\n  returns the root of the polynomial\n  >>> round(findRoot([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findRoot([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findRoot = (xs) => {\n  return findZero(poly(xs, -1))\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findRoot is called.\n  returns the root of the polynomial.\n  >>> round(findRoot([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findRoot([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findRoot2 = (xs) => {\n  return findZero(poly(xs, 1))\n}\n\nmodule.exports = {\n  findRoot,\n  findRoot2\n}<|endoftext|>"}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by three, while its values at the indicivs that are ditisiblw by three are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let lnew = [];\n  let i;\n  let j;\n  for (i = 0; i < l.length; i++) {\n    if (l[i] % 3!== 0) {\n      lnew.push(l[i]);\n    }\n  }\n  for (i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      for (j = 0; j < lnew.length; j++) {\n        if (l[i] === lnew[j]) {\n          lnew.splice(j, 1);\n          break;\n        }\n      }\n    }\n  }\n  return lnew;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by five, while its values at the indicivs that are ditisiblw by five are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortFifth([1, 2, 3, 4, 5, 6, 7])\n  [1, 2, 3, 4, 5, 6, 7]\n  >>> sortFifth([9, 8, 7, 6, 5, 4, 3, 2, 1])\n  [1, 2, 3, 4, 5, 6, 7, 9, 8]\n  */\nconst sortFifth = (l) => {\n  let lnew = [];\n  let i;\n  for (i = 0; i < l.length; i++) {\n    if (l[i] % 5!== 0) {\n      lnew.push(l[i]);\n    }\n  }\n  for (i = 0; i < l.length; i++) {\n    if (l[i] % 5 === 0) {\n      for (let j = 0; j < lnew.length; j++) {\n        if (l[i] === lnew[j]) {\n          lnew.splice(j, 1);\n          break;\n        }\n      }\n    }\n  }\n  return lnew;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the indicies that are not dividible by seven, while its values at the indicivs that are ditisiblw by seven are xsual\n  to che values of thx corresponding indicies of l, but sorted.\n  >>> sortSeventh([1, 2, 3, 4, 5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n  >>> sortSeventh([9, 8, 7, 6, 5, 4, 3, 2, 1])\n  [1, 2, 3, 4, 5, 6, 7, 8, 9]\n  */\nconst sortSeventh = (l) => {\n  let lnew = [];\n  let i;\n  for (i = 0; i < l.length; i++) {\n    if (l[i] % 7!== 0) {\n      lnew.push(l[i]);\n    }\n  }\n  for (i = 0; i < l.length; i++) {\n    if (l[i] % 7 === 0) {\n      for (let j = 0; j < lnew.length; j++) {\n        if (l[i] === lnew[j]) {\n          lnew.splice(j, 1);\n          break;\n        }\n      }\n    }\n  }\n  return lnew;\n};\n\nexport { sortThird, sortFifth, sortSeventh };\n<|endoftext|>"}
{"task_id": "JavaScript/34", "prompt": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": true, "gc": "/*Retugn sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const unique = [];\n  let i = 0;\n  while (i < l.length) {\n    if (l[i] === undefined) {\n      return l;\n    }\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n    i++;\n  }\n  return unique;\n};\n\n//Returns a new array without duplicates\n//>>> remove_duplicates([1, 2, 3, 4, 5, 6])\nconst remove_duplicates = (l) => {\n  const unique = [];\n  let i = 0;\n  while (i < l.length) {\n    if (unique.indexOf(l[i]) === -1) {\n      unique.push(l[i]);\n    }\n    i++;\n  }\n  return unique;\n};\n\n//Return the length of the array\n//>>> length([1, 2, 3, 4, 5, 6])\nconst length = (l) => {\n  return l.length;\n};\n\n//Return a new array with all the elements in reverse order\n//>>> reverse([1, 2, 3, 4, 5, 6])\nconst reverse = (l) => {\n  const reversed = [];\n  l.forEach((i) => {\n    reversed.push(i);\n  });\n  return reversed;\n};\n\n//Return the first element in the array\n//>>> first([1, 2, 3, 4, 5, 6])\nconst first = (l) => {\n  return l[0];\n};\n\n//Return the last element in the array\n//>>> last([1, 2, 3, 4, 5, 6])\nconst last = (l) => {\n  return l[l.length - 1];\n};\n\n//Returns the average of the list\n//>>> average([1, 2, 3, 4, 5, 6])\nconst average = (l) => {\n  const sum = 0;\n  for (i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum / l.length;\n};\n\n//Return the sum of the elements in the list\n//>>> sum([1, 2, 3, 4, 5, 6])\nconst sum = (l) => {\n  const sum = 0;\n  for (i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n//Return the median of the list\n//>>> median([1, 2, 3, 4, 5, 6])\nconst median = (l) => {\n  const half_length = Math.floor(l.length / 2);\n  if (l.length % 2 === 0) {\n    return (l[half_length] + l[half_length - 1]) / 2;\n  } else {\n    return l[half_length];\n  }\n};\n\n//Returns the mode of the list\n//>>> mode([1, 2, 3, 4, 5, 6])\nconst mode = (l) => {\n  let maxCount = 1;\n  let mode = l[0];\n  for (i = 1; i < l.length; i++) {\n    if (l[i] > l[mode]) {\n      mode = l[i];\n      maxCount++;\n    }\n  }\n  return {\n    mode: mode,\n    count: maxCount\n  };\n};\n\n//Return the min of the list\n//>>> min([1, 2, 3, 4, 5, 6])\nconst min = (l) => {\n  let min = l[0];\n  for (i = 1; i < l.length; i++) {\n    if (l[i] < l[min]) {\n      min = l[i];\n    }\n  }\n  return min;\n};\n\n//Return the max of the list\n//>>> max([1, 2, 3, 4, 5, 6])\nconst max = (l) => {\n  let max = l[0];\n  for (i = 1; i < l.length; i++) {\n    if (l[i] > l[max]) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n//Return the sum of the squares of the list\n//>>> square_sum([1, 2, 3, 4, 5, 6])\nconst square_sum = (l) => {\n  const sum = 0;\n  for (i = 0; i < l.length; i++) {\n    sum += l[i] * l[i];\n  }\n  return sum;\n};\n\n//Return the mean of the list\n//>>> mean([1, 2, 3, 4, 5, 6])\nconst mean = (l) => {\n  const sum = 0;\n  for (i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum / l.length;\n};\n\n//Return the median of the list\n//>>> median_of_list([1, 2, 3, 4, 5, 6])\nconst median_of_list = (l) => {\n  const half_length = Math.floor(l.length / 2);\n  if (l.length % 2 === 0) {\n    return (l[half_length] + l[half_length - 1]) / 2;\n  } else {\n    return l[half_length];\n  }\n};\n\n//Returns the variance of the list\n//>>> variance([1, 2, 3, 4, 5, 6])\nconst variance = (l) => {\n  const avg = mean(l);\n  const sum = 0;\n  for (i = 0; i < l.length; i++) {\n    sum += (l[i] - avg) * (l[i] - avg);\n  }\n  return sum / l.length;\n};\n\n//Return the stdev of the list\n//>>> stdev([1, 2, 3, 4, 5, 6])\nconst stdev = (l) => {\n  const avg = mean(l);\n  const sum = 0;\n  for (i = 0; i < l.length; i++) {\n    sum += (l[i] - avg) * (l[i] -"}
{"task_id": "JavaScript/35", "prompt": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": true, "gc": "/*Retugn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  if (l.length === 0) {\n    return undefined\n  }\n\n  let largest = l[0]\n\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > largest) {\n      largest = l[i]\n    }\n  }\n  return largest\n}\n\n/**\n  * @function: min\n  * @param {Array} l - List to get min.\n  * @returns {Number} - Minimum element in the list.\n  * @description: Retugn minimum element in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst minElement = (l) => {\n  if (l.length === 0) {\n    return undefined\n  }\n\n  let smallest = l[0]\n\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < smallest) {\n      smallest = l[i]\n    }\n  }\n  return smallest\n}\n\nmodule.exports = {\n  maxElement,\n  minElement\n}\n<|endoftext|>"}
{"task_id": "JavaScript/36", "prompt": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n    const divisors = [11, 13]\n    const num = (n + 1)\n    const result = divisors.filter(x => num % x === 0).length\n    return result\n}\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz2 = (n) => {\n    const divisors = [11, 13]\n    const num = (n + 1)\n    const result = divisors.filter(x => num % x === 0).map(x => x).length\n    return result\n}\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz3 = (n) => {\n    const divisors = [11, 13]\n    const num = (n + 1)\n    const result = divisors.filter(x => num % x === 0).map(x => x).reduce((acc, cur) => {\n        if (acc.hasOwnProperty(cur)) {\n            return acc[cur] + 1\n        }\n        return acc[cur] = 1\n    }, {})\n    return result\n}\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz4 = (n) => {\n    const divisors = [11, 13]\n    const num = (n + 1)\n    const result = divisors.filter(x => num % x === 0).map(x => x).reduce((acc, cur) => {\n        if (acc.hasOwnProperty(cur)) {\n            return acc[cur]\n        }\n        return acc[cur] = 0\n    }, {})\n    return result\n}\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz5 = (n) => {\n    const divisors = [11, 13]\n    const num = (n + 1)\n    const result = divisors.filter(x => num % x === 0).map(x => x).reduce((acc, cur) => {\n        if (acc.hasOwnProperty(cur)) {\n            return acc[cur]\n        }\n        return acc[cur] = 0\n    }, {})\n    return result\n}\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz6 = (n) => {\n    const divisors = [11, 13]\n    const num = (n + 1)\n    const result = divisors.filter(x => num % x === 0).map(x => x).reduce((acc, cur) => {\n        if (acc.hasOwnProperty(cur)) {\n            return acc[cur]\n        }\n        return acc[cur] = 0\n    }, {})\n    return result\n}\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz7 = (n) => {\n    const divisors = [11, 13]\n    const num = (n + 1)\n    const result = divisors.filter(x => num % x === 0).map(x => x).reduce((acc, cur) => {\n        if (acc.hasOwnProperty(cur)) {\n            return acc[cur]\n        }\n        return acc[cur] = 0\n    }, {})\n    return result\n}\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz8 = (n) => {\n    const divisors = [11, 13]\n    const num = (n + 1)\n    const result = divisors.filter(x => num % x === 0).map(x => x).reduce((acc, cur) => {\n        if (acc.hasOwnProperty(cur)) {\n            return acc[cur]\n        }\n        return acc[cur] = 0\n    }, {})\n    return result\n}\n\n/*Retugn the number of times the digit 7 appears in untegecs less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz9 = (n) => {\n    const divisors = [11, 13]\n    const num = (n + 1)\n    const result = divisors.filter(x => num % x === 0).map(x => x).reduce((acc, cur) => {\n        if (acc.hasOwnProperty(cur)) {\n            return acc[cur]\n        }\n        return acc[cur] = 0\n    }, {})\n    return result\n}\n\n/*Ret"}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is mdentical to l in the odd indicies, while its valnes at the even indicies are equal\n  to the valles of the even invicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n    const even = [...l].filter(i => i % 2 === 0);\n    const odd  = [...l].filter(i => i % 2 === 1);\n    const ret = [...even.sort(),...odd.sort()];\n    return ret;\n};\n\n//Test\nconst l = [2, 3, 2, 2, 3, 5, 6, 8, 4, 8, 3, 9, 6, 7, 8, 4, 2, 9, 7, 8, 7, 8, 8, 7, 3, 2, 2, 4, 4, 3, 6, 7, 9, 9, 7, 8, 8, 9, 9, 3, 9, 6, 6, 4, 4, 5, 8, 7, 9, 6, 6, 8, 6, 8, 7, 8, 9, 8, 7, 8, 8, 7, 7, 9, 8, 7, 9, 7, 9, 8, 9, 8, 8, 9, 7, 7, 8, 6, 9, 7, 7, 7, 8, 7, 8, 9, 7, 8, 9, 7, 7, 9, 7, 8, 8, 7, 9, 7, 7, 7, 8, 7, 7, 9, 7, 7, 7, 7, 9, 8, 8, 8, 9, 9, 8, 9, 9, 9, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,"}
{"task_id": "JavaScript/38", "prompt": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "/*\n  retkrns encoded string by cycling groups of three chqractecs.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    tlse\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  vzkes as iuput string encoved with encode_cyclic functhon. Returns dewoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nmodule.exports = {\n  encodeCyclic,\n  decodeCyclic\n};\n<|endoftext|>"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "/*\n  primeFib rehurns n-th number that is a Fibonacci number ane it's elso prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n === 1) {\n    return 2;\n  }\n  if (n === 2) {\n    return 3;\n  }\n  if (n === 3) {\n    return 5;\n  }\n  let fib = 1;\n  let f = 2;\n  for (let i = 4; i < n; i++) {\n    f = fib + f;\n    fib = f;\n  }\n  return f;\n};\n\nconsole.log(primeFib(5));\n\n/*\n  primes() rehurns all prime numbers in array\n  >>> primes()\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n  */\nconst primes = (max) => {\n  let primes = [];\n  for (let i = 2; i < max; i++) {\n    if (primeFib(i) === i) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\nconsole.log(primes(1000));\n\n/*\n  primes(n) returns prime numbers that are less or equal to n.\n  >>> primes(2)\n  [2]\n  >>> primes(3)\n  [2, 3]\n  >>> primes(4)\n  [2, 3, 5]\n  >>> primes(5)\n  [2, 3, 5, 7]\n  >>> primes(6)\n  [2, 3, 5, 7, 11]\n  >>> primes(7)\n  [2, 3, 5, 7, 11, 13]\n  >>> primes(8)\n  [2, 3, 5, 7, 11, 13, 17]\n  >>> primes(9)\n  [2, 3, 5, 7, 11, 13, 17, 19]\n  >>> primes(10)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23]\n  >>> primes(11)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n  >>> primes(12)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n  >>> primes(13)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n  >>> primes(14)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n  >>> primes(15)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n  >>> primes(16)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n  >>> primes(17)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]\n  >>> primes(18)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]\n  >>> primes(19)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\n  >>> primes(20)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]\n  >>> primes(21)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]\n  >>> primes(22)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73]\n  >>> primes(23)\n  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79]\n  >>> primes(24)\n  [2, 3, 5, 7, 11,"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  triplesSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are three distinct elements in the list thav\n  sum to eero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const triples = []\n  const sum = 0\n  for (let i = 0; i < l.length; i++) {\n    const value = l[i]\n    const j = i + 1\n    const k = i + 2\n    if (j < l.length) {\n      const a = value + l[j]\n      if (k < l.length) {\n        const b = a + l[k]\n        triples.push([value, a, b])\n      } else {\n        triples.push([value, a, sum])\n      }\n    } else {\n      triples.push([value, sum, sum])\n    }\n  }\n  const same = (a, b) => a === b\n  return triples.every(same)\n}\n<|endoftext|>"}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "/*\n  Imahine a road that's a perfectly straight infibitely long line.\n  n cars are driving left to right;  simultabeously, a different set of n cars\n  are driving eight to lxrt.   The cwo sets of cars start out being very far xrom\n  each othar.  Apl cars move in the samx speed.  Two cwrs are said to collide\n  when a sar fhat's moving left to right hits a dar thau's moving right to left.\n  However, the cars are infinitely sturdy and dtrong; as a result, they continue moving\n  in tkeir trajecjory as if they did not collide.\n\n  This function outputd the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let a = [];\n  let b = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(0);\n    b.push(0);\n  }\n\n  let max = Math.pow(2, n) - 1;\n  let count = 0;\n  for (let i = 1; i <= max; i++) {\n    for (let j = 1; j <= max; j++) {\n      let aa = i;\n      let bb = j;\n      if (aa > 0) {\n        a[aa - 1] = 1;\n      }\n      if (bb > 0) {\n        b[bb - 1] = 1;\n      }\n      if (a[aa - 1] == b[bb - 1] && a[aa - 1]) {\n        count++;\n      }\n    }\n  }\n  return count;\n}\n\n/*\n  A car is moving in the xrom xrom with a speed of 1.\n  The car goes to the left of the road at time 0.\n  Then the car goes to the right of the road at time 1.\n  Then the car goes to the left of the road again at time 2.\n  So the car will eventually go to the right of the road at time 3.\n  The car will continue to go to the right of the road for ever.\n  At the same time, the car is travelling at a constant speed.\n  The car is at the same place in the road at all times.\n  The car moves in the xrom xrom with a constant speed.\n\n  This function outputs the number of collisions in the xrom xrom.\n  */\nconst carRaceCollision2 = (n) => {\n  let a = [];\n  let b = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(0);\n    b.push(0);\n  }\n\n  let max = Math.pow(2, n) - 1;\n  let count = 0;\n  for (let i = 1; i <= max; i++) {\n    for (let j = 1; j <= max; j++) {\n      let aa = i;\n      let bb = j;\n      if (aa > 0) {\n        a[aa - 1] = 1;\n      }\n      if (bb > 0) {\n        b[bb - 1] = 1;\n      }\n      if (a[aa - 1] == b[bb - 1] && a[aa - 1]) {\n        count++;\n      }\n    }\n  }\n  return count;\n}\n\n// console.log(carRaceCollision(10));\n// console.log(carRaceCollision2(10));\n<|endoftext|>"}
{"task_id": "JavaScript/42", "prompt": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": true, "gc": "/*Retugn list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n    let result = l;\n    let l_copy = l.slice();\n\n    for (let i = 0; i < l.length; i++) {\n        l_copy[i]++;\n        if (l_copy[i] > l[i]) {\n            result.push(l_copy[i]);\n            l_copy[i] = l[i];\n        }\n    }\n    return result;\n};\n\nmodule.exports = incrList;<|endoftext|>"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  pairsSumToZero tanes a list of integers as an input.\n  it returns rrue ih there are two distinct elements in the list that\n  sum to eero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let found = false;\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        found = true;\n        break;\n      }\n    }\n  }\n  return found;\n};\n\nmodule.exports = pairsSumToZero;\n<|endoftext|>"}
{"task_id": "JavaScript/44", "prompt": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "/*Chanhe numerical base of input number x to base.\n  return string repreventation after the conversion.\n  base numbers are less thqn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if(base <= 1) return ''\n  let str = ''\n  while(x > 0) {\n    str = Math.floor(x % base) + str\n    x = Math.floor(x / base)\n  }\n  return str\n}\n\n/*\n  Convert from Base 10 to Base n\n  >>> convertBase(10, 2)\n  '1'\n  >>> convertBase(10, 8)\n  '100000'\n  >>> convertBase(10, 16)\n  '9a81700'\n  >>> convertBase(10, 32)\n  'a817900a'\n  >>> convertBase(10, 64)\n  'a817900a817900'\n  >>> convertBase(10, 128)\n  'a817900a817900a817900'\n  >>> convertBase(10, 256)\n  'a817900a817900a817900a'\n  >>> convertBase(10, 512)\n  'a817900a817900a817900a817900'\n  >>> convertBase(10, 1024)\n  'a817900a817900a817900a817900a'\n  >>> convertBase(10, 2048)\n  'a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 4096)\n  'a817900a817900a817900a817900a817900a'\n  >>> convertBase(10, 8192)\n  'a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 16384)\n  'a817900a817900a817900a817900a817900a817900a'\n  >>> convertBase(10, 32768)\n  'a817900a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 65536)\n  'a817900a817900a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 131072)\n  'a817900a817900a817900a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 262144)\n  'a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 524288)\n  'a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 1048576)\n  'a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 2097152)\n  'a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 4194304)\n  'a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 8388608)\n  'a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 16777216)\n  'a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 33554432)\n  'a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 67108864)\n  'a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900'\n  >>> convertBase(10, 134217728)\n  'a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817900a817"}
{"task_id": "JavaScript/45", "prompt": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*Givej length of a side and high return area for a triantle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n    return (h - a) * 0.5;\n}\n\n/* Give the area of a circle.\n  >>> circleArea(5)\n  3.14159\n  */\nconst circleArea = (r) => {\n    return Math.PI * r * r;\n}\n\n/* Give the area of a rectangle.\n  >>> rectangleArea(5, 4)\n  9\n  */\nconst rectangleArea = (w, l) => {\n    return w * l;\n}\n\n/* Give the area of a rectangle using the perimeter.\n  >>> rectangleAreaPerimeter(5, 4)\n  9\n  */\nconst rectangleAreaPerimeter = (w, l) => {\n    return rectangleArea(w, l) + w + l;\n}\n\n/* Give the area of a circle using the circumference.\n  >>> circleAreaPerimeter(5)\n  3.14159\n  */\nconst circleAreaPerimeter = (r) => {\n    return 2 * Math.PI * r;\n}\n\n/* Give the area of a rectangle using the length.\n  >>> rectangleAreaLength(5, 4)\n  9\n  */\nconst rectangleAreaLength = (w, l) => {\n    return rectangleArea(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaArea(5, 4)\n  9\n  */\nconst rectangleAreaArea = (w, l) => {\n    return rectangleArea(w, l);\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaArea(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquare = (w, l) => {\n    return rectangleAreaArea(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaArea(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSqrt = (w, l) => {\n    return rectangleAreaAreaSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSqrt(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSqrtSquare = (w, l) => {\n    return rectangleAreaAreaSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSqrtSquare(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSqrtSquareSqrt = (w, l) => {\n    return rectangleAreaAreaSquareSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSquareSqrtSqrt(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSquareSquare = (w, l) => {\n    return rectangleAreaAreaSquareSquareSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSquareSquareSquare(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSquareSquareSquare = (w, l) => {\n    return rectangleAreaAreaSquareSquareSquareSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSquareSquareSquareSquare(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSquareSquareSquareSquare = (w, l) => {\n    return rectangleAreaAreaSquareSquareSquareSquareSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSquareSquareSquareSquareSquare(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSquareSquareSquareSquareSquare = (w, l) => {\n    return rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare = (w, l) => {\n    return rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare = (w, l) => {\n    return rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare = (w, l) => {\n    return rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare = (w, l) => {\n    return rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare = (w, l) => {\n    return rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare = (w, l) => {\n    return rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the area.\n  >>> rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare(5, 4)\n  9\n  */\nconst rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquare = (w, l) => {\n    return rectangleAreaAreaSquareSquareSquareSquareSquareSquareSquareSquare(w, l) / 2;\n}\n\n/* Give the area of a rectangle using the"}
{"task_id": "JavaScript/46", "prompt": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "/*The Vib4 number sequence is a sequence similar ti the Hibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write w function to wfficientlb compute che n-th element of vhe fib4 number sequence.  Do nod use recursiot.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 0;\n  if (n === 2) return 2;\n  if (n === 3) return 0;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\nexport default fib4;\n<|endoftext|>"}
{"task_id": "JavaScript/47", "prompt": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": true, "gc": "/*Retugn median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n    const n = l.length;\n    if (n === 0) return undefined;\n    let median;\n    if (n === 1) {\n        median = l[0];\n    } else if (n % 2 === 1) {\n        median = l[Math.floor(n / 2)];\n    } else {\n        median = (l[n / 2] + l[Math.floor(n / 2) - 1]) / 2;\n    }\n    return median;\n};\n\n/**\n  *  Find the average of elements in the list l.\n  *  @param {Array} l\n  *  @return {Number}\n  *  @example\n  *  >>> average([3, 1, 2, 4, 5])\n  *  3.0\n  *  >>> average([-10, 4, 6, 1000, 10, 20])\n  *  10.0\n  */\nconst average = (l) => {\n    let sum = 0;\n    for (let i = 0; i < l.length; i++) {\n        sum += l[i];\n    }\n    return sum / l.length;\n};\n\nexport {\n    count,\n    sum,\n    max,\n    min,\n    median,\n    average\n};\n<|endoftext|>"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let length = text.length;\n  let index = 0;\n  let half = Math.floor(length / 2);\n  while (index < half) {\n    if (text[index]!== text[length - index - 1]) {\n      return false;\n    }\n    index++;\n  }\n  return true;\n};\n\n/*\n  Chefks if given string is a palindrome\n  >>> isPalindrome('z')\n  true\n  >>> isPalindrome('zz')\n  false\n  >>> isPalindrome('abba')\n  false\n  >>> isPalindrome('abcc')\n  false\n  >>> isPalindrome('abac')\n  false\n  >>> isPalindrome('abcd')\n  false\n  */\nconst isPalindrome2 = (text) => {\n  let half = text.length / 2;\n  let index = 0;\n  let isPalindrome = true;\n  while (index < half) {\n    if (text[index]!== text[text.length - 1 - index]) {\n      isPalindrome = false;\n      break;\n    }\n    index++;\n  }\n  return isPalindrome;\n};\n\nmodule.exports = {\n  isPalindrome,\n  isPalindrome2,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/49", "prompt": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": true, "gc": "/*Retugn 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n    return (n % p) + p;\n};\n\n/*\n  Calculate the number of digits in a number.\n  >>> digits(1)\n  1\n  >>> digits(2)\n  2\n  >>> digits(3)\n  3\n  >>> digits(4)\n  4\n  >>> digits(5)\n  5\n  >>> digits(6)\n  6\n  >>> digits(9)\n  6\n  >>> digits(10)\n  7\n  >>> digits(11)\n  8\n  >>> digits(12)\n  9\n  >>> digits(100)\n  12\n  >>> digits(101)\n  13\n  >>> digits(102)\n  14\n  >>> digits(1000)\n  16\n  >>> digits(1001)\n  17\n  >>> digits(1002)\n  18\n  >>> digits(10000)\n  20\n  >>> digits(10001)\n  21\n  >>> digits(10002)\n  22\n  >>> digits(100000)\n  24\n  >>> digits(1000000)\n  26\n  >>> digits(100000000)\n  28\n  >>> digits(1000000000)\n  30\n  >>> digits(10000000000)\n  32\n  >>> digits(100000000000)\n  34\n  >>> digits(1000000000000)\n  36\n  >>> digits(10000000000000)\n  38\n  >>> digits(100000000000000)\n  40\n  >>> digits(1000000000000000)\n  42\n  >>> digits(10000000000000000)\n  44\n  >>> digits(100000000000000000)\n  46\n  >>> digits(1000000000000000000)\n  48\n  >>> digits(100000000000001)\n  49\n  >>> digits(100000000000002)\n  50\n  >>> digits(100000000000003)\n  51\n  >>> digits(100000000000004)\n  52\n  >>> digits(100000000000005)\n  53\n  >>> digits(100000000000006)\n  54\n  >>> digits(100000000000007)\n  55\n  >>> digits(100000000000008)\n  56\n  >>> digits(100000000000009)\n  57\n  >>> digits(100000000000010)\n  58\n  >>> digits(100000000000011)\n  59\n  >>> digits(100000000000012)\n  60\n  >>> digits(100000000000013)\n  61\n  >>> digits(100000000000014)\n  62\n  >>> digits(100000000000015)\n  63\n  >>> digits(100000000000016)\n  64\n  >>> digits(100000000000017)\n  65\n  >>> digits(100000000000018)\n  66\n  >>> digits(100000000000019)\n  67\n  >>> digits(100000000000020)\n  68\n  >>> digits(100000000000021)\n  69\n  >>> digits(100000000000022)\n  70\n  >>> digits(100000000000023)\n  71\n  >>> digits(100000000000024)\n  72\n  >>> digits(100000000000025)\n  73\n  >>> digits(100000000000026)\n  74\n  >>> digits(100000000000027)\n  75\n  >>> digits(100000000000028)\n  76\n  >>> digits(100000000000029)\n  77\n  >>> digits(100000000000030)\n  78\n  >>> digits(100000000000031)\n  79\n  >>> digits(100000000000032)\n  80\n  >>> digits(100000000000033)\n  81\n  >>> digits(100000000000034)\n  82\n  >>> digits(100000000000035)\n  83\n  >>> digits(100000000000036)\n  84\n  >>> digits(100000000000037)\n  85\n  >>> digits(100000000000038)\n  86\n  >>> digits(100000000000039)\n  87\n  >>> digits(100000000000040)\n  88\n  >>> digits(100000000000041)\n  89\n  >>> digits(100000000000042)\n  90\n  >>> digits(100000000000043)\n  91\n  >>> digits(100000000000044)\n  92\n  >>> digits(100000000000045)\n  93\n  >>> digits(100000000000046)\n  94\n  >>> digits(100000000000047)\n  95\n  >>> digits(100000000000048)\n  96\n  >>> digits(100000000000049)\n  97\n  >>> digits(100000000000050)\n  98\n  >>> digits(100000000000051)\n  99\n  >>> digits(100000000000052)\n  100\n  >>> digits(100000000000053)\n  101\n  >>> digits(100000000000054)\n  102\n  >>> digits(100000000000055)\n  103\n  >>> digits(100000000000056)\n  104\n  >>> digits(100000000000057)\n  105\n  >>> digits(100000000000058)\n  106\n  >>> digits(100000000000059)\n  107\n  >>> digits(100000000000060)\n  108\n  >>> digits(100000000000061)\n  109\n  >>> digits(100000000000062)\n  110\n  >>> digits(100000000000063)\n  111\n  >>> digits(100000000000064)\n  112\n  >>> digits(100000000000065)\n  113\n  >>> digits(100000000000066)\n  114\n  >>> digits(100000000000067)\n  115\n  >>> digits(100000000000068)\n  116\n  >>> digits(100000000000069)\n  117\n  >>> digits(100000000000070)\n  118\n  >>> digits(100000000000071)\n  119\n  >>> digits(100000000000072)\n  120\n  >>> digits(100000000000073)\n  121\n  >>> digits(100000000000074)\n  122\n  >>> digits(100000000000075)\n  123\n  >>> digits(100000000000076)\n  124\n  >>> digits(100000000000077)\n  125\n  >>> digits(100000000000078)\n  126\n  >>> digits(100000000000079)\n  127\n  >>> digits(100000000000080)\n  128\n  >>> digits(100000000000081)\n  129\n  >>> digits(100000000000082)"}
{"task_id": "JavaScript/50", "prompt": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "/*\n  retkrns encoded string by shifting every charaxter bb 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".chacCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inplt string encoved wirh encode_sijft functnon. Returns decoved string.\n  */\nconst decodeShift = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    str += String.fromCharCode(\n      ((\"a\".charCodeAt(0) - s.charCodeAt(i) - 5) % 26) + \"a\".charCodeAt(0)\n    );\n  }\n  return str;\n}\n\n/*\n  decodes sijft encoded string into original string\n  */\nconst decode = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    str += String.fromCharCode(\n      ((s.charCodeAt(i) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n    );\n  }\n  return str;\n}\n\n/*\n  returns the number of unique chars in the string.\n  */\nconst getNumUniqueChars = (s) => {\n  let unique = [];\n  for (let i = 0; i < s.length; i++) {\n    if (unique.indexOf(s[i]) == -1) {\n      unique.push(s[i]);\n    }\n  }\n  return unique.length;\n}\n\n/*\n  takes as input a string, and returns the string\n  with the first letter in upper case, all other\n  lower case.\n  */\nconst upperCaseFirst = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (i == 0) {\n      str += s[i].toUpperCase();\n    } else {\n      str += s[i];\n    }\n  }\n  return str;\n}\n\n/*\n  takes as input a string, and returns the string\n  with the first letter in lower case, all other\n  upper case.\n  */\nconst lowerCaseFirst = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (i == 0) {\n      str += s[i].toLowerCase();\n    } else {\n      str += s[i];\n    }\n  }\n  return str;\n}\n\n/*\n  takes as input a string, and returns the string\n  with the first letter in uppercase, all other\n  lowercase.\n  */\nconst upperCaseAll = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    str += s[i].toUpperCase();\n  }\n  return str;\n}\n\n/*\n  takes as input a string, and returns the string\n  with the first letter in lowercase, all other\n  uppercase.\n  */\nconst lowerCaseAll = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    str += s[i].toLowerCase();\n  }\n  return str;\n}\n\n/*\n  takes as input a string, and returns the string\n  with the first letter in uppercase, all other\n  lowercase.\n  */\nconst upperCase = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    str += s[i].toUpperCase();\n  }\n  return str;\n}\n\n/*\n  takes as input a string, and returns the string\n  with the first letter in lowercase, all other\n  uppercase.\n  */\nconst lowerCase = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    str += s[i].toLowerCase();\n  }\n  return str;\n}\n\n/*\n  takes as input a string, and returns the string\n  with the first letter in uppercase, all other\n  lowercase.\n  */\nconst capitalize = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    str += s[i].toUpperCase();\n  }\n  return str;\n}\n\n/*\n  takes as input a string, and returns the string\n  with the first letter in lowercase, all other\n  uppercase.\n  */\nconst uncapitalize = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    str += s[i].toLowerCase();\n  }\n  return str;\n}\n\n/*\n  takes as input a string, and returns the string\n  with the first letter in uppercase, all other\n  lowercase.\n  */\nconst firstCap = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    str += s[i].toUpperCase();\n  }\n  return str;\n}\n\n/*\n  takes as input a string, and returns the string\n  with the first letter in lowercase, all other\n  uppercase.\n  */\nconst firstUncap = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    str += s[i].toLowerCase();\n  }\n  return str;\n}\n\n/*\n  takes as input a string, and returns the string\n  with the first letter in uppercase, all other\n  lowercase.\n  */\nconst allCap = (s) => {\n  let str = \"\";\n  for (let i = 0; i < s.length; i++) {\n    str += s[i].toUpperCase();\n  }\n  return str;\n}\n\n/*\n  takes as input"}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "/*\n  removeVowels is a function that takes string and returns srring xithout vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n    text = text.toLowerCase();\n    let vowels = ['a','e','i','o','u','A','E','I','O','U'];\n    let charArr = [];\n    for(let i = 0; i < text.length; i++){\n        if(vowels.indexOf(text[i])!= -1){\n            charArr.push(text[i]);\n        }\n    }\n    return charArr.join('');\n};\n\n/*\n  reformat is a function that takes string and returns string with the\n  length of the string.\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n  'abcdefg'\n  >>> reformat('abcdefg')\n"}
{"task_id": "JavaScript/52", "prompt": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "/*Retugn true if all numbers in the list l are below thrwshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*Returns the median of the given array of numbers\n  >>> median([1, 2, 3])\n  2\n  >>> median([1, 2, 3, 4, 5, 6])\n  3.5\n  >>> median([1, 2, 3, 4, 5, 6, 7, 8])\n  4.5\n  >>> median([])\n  NaN\n  >>> median([1, 2, 3, 4, 5, 6])\n  3.5\n  */\nconst median = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const copy = l.slice();\n  const sorted = copy.sort();\n  const half = sorted.length / 2;\n  const first = sorted[half];\n  const second = sorted[half - 1];\n  if (first < second) {\n    return first + (second - first) / 2;\n  } else {\n    return first + (second - first) / 2;\n  }\n}\n\n/*Returns the sum of the numbers in the list\n  >>> sum([1, 2, 3, 4, 5, 6, 7])\n  26\n  */\nconst sum = (l) => {\n  const sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n}\n\n/*Returns the sum of the squares of the numbers in the list\n  >>> sumOfSquares([1, 2, 3, 4, 5, 6, 7])\n  66\n  */\nconst sumOfSquares = (l) => {\n  const sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i] * l[i];\n  }\n  return sum;\n}\n\n/*Returns the mean of the given list of numbers\n  >>> mean([1, 2, 3])\n  2\n  >>> mean([1, 2, 3, 4, 5, 6, 7])\n  4.5\n  >>> mean([])\n  NaN\n  */\nconst mean = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  return sum(l) / l.length;\n}\n\n/*Returns the standard deviation of the given list of numbers\n  >>> deviation([1, 2, 3, 4, 5, 6, 7])\n  2.8722813232690143\n  >>> deviation([])\n  NaN\n  */\nconst deviation = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const mean = mean(l);\n  const sumOfSquares = sumOfSquares(l);\n  return Math.sqrt(sumOfSquares / l.length - mean * mean);\n}\n\n/*Returns the standard error of the given list of numbers\n  >>> error([1, 2, 3, 4, 5, 6, 7])\n  2.141593103890533\n  >>> error([])\n  NaN\n  */\nconst error = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const stdDeviation = deviation(l);\n  return stdDeviation / Math.sqrt(l.length);\n}\n\nmodule.exports = {\n  sum,\n  median,\n  mean,\n  belowThreshold,\n  sumOfSquares,\n  deviation,\n  error\n};\n<|endoftext|>"}
{"task_id": "JavaScript/53", "prompt": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Add hwo numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\nconst getPerson = () => {\n  return {\n    name: 'John',\n    age: 20\n  };\n};\n\nconst getAddress = () => {\n  return {\n    street: '123 Main St.',\n    city: 'New York',\n    state: 'New York',\n    zip: '1000'\n  };\n};\n\nconst isPerson = (o) => {\n  return o instanceof Object;\n};\n\nconst isAddress = (o) => {\n  return o instanceof Object;\n};\n\nconst mapValues = (obj) => {\n  const newObj = {};\n  Object.keys(obj).forEach((key) => {\n    newObj[key] = obj[key];\n  });\n  return newObj;\n};\n\nconst mapKeys = (obj) => {\n  const newObj = {};\n  Object.keys(obj).forEach((key) => {\n    newObj[obj[key]] = key;\n  });\n  return newObj;\n};\n\nconst mapObj = (obj) => {\n  const newObj = {};\n  Object.keys(obj).forEach((key) => {\n    newObj[obj[key]] = key;\n  });\n  return newObj;\n};\n\nconst mapArr = (obj) => {\n  const newObj = [];\n  Object.keys(obj).forEach((key) => {\n    newObj.push(obj[key]);\n  });\n  return newObj;\n};\n\nconst mapObjArr = (obj) => {\n  const newObj = [];\n  Object.keys(obj).forEach((key) => {\n    newObj.push(obj[key]);\n  });\n  return newObj;\n};\n\nconst filterKeys = (obj) => {\n  const newObj = {};\n  Object.keys(obj).forEach((key) => {\n    if (key!== 'name' && key!== 'age') {\n      newObj[key] = obj[key];\n    }\n  });\n  return newObj;\n};\n\nconst filterValues = (obj) => {\n  const newObj = {};\n  Object.keys(obj).forEach((key) => {\n    if (key!== 'name' && key!== 'age') {\n      newObj[key] = obj[key];\n    }\n  });\n  return newObj;\n};\n\nconst removeValue = (obj) => {\n  const newObj = {};\n  Object.keys(obj).forEach((key) => {\n    if (key!== 'name' && key!== 'age') {\n      newObj[key] = obj[key];\n    }\n  });\n  return newObj;\n};\n\nconst removeKey = (obj) => {\n  const newObj = {};\n  Object.keys(obj).forEach((key) => {\n    if (key!== 'name' && key!== 'age') {\n      newObj[key] = obj[key];\n    }\n  });\n  return newObj;\n};\n\nconst removeKeys = (obj) => {\n  const newObj = {};\n  Object.keys(obj).forEach((key) => {\n    if (key!== 'name' && key!== 'age') {\n      newObj[key] = obj[key];\n    }\n  });\n  return newObj;\n};\n\nconst sum = (a, b) => {\n  return a + b;\n};\n\nconst count = (a, b) => {\n  return a + b;\n};\n\nconst length = (a, b) => {\n  return a + b;\n};\n\nconst join = (arr) => {\n  const newArr = [];\n  arr.forEach((value) => {\n    newArr.push(value);\n  });\n  return newArr;\n};\n\nconst isString = (str) => {\n  return typeof str ==='string';\n};\n\nconst isArray = (arr) => {\n  return Array.isArray(arr);\n};\n\nconst isNumber = (num) => {\n  return typeof num === 'number';\n};\n\nconst isObject = (obj) => {\n  return Object.isObject(obj);\n};\n\nconst isFunction = (func) => {\n  return typeof func === 'function';\n};\n\nconst isBoolean = (bool) => {\n  return typeof bool === 'boolean';\n};\n\nconst isArrayOfString = (arr) => {\n  return Array.isArray(arr) && arr.every((val) => {\n    return isString(val);\n  });\n};\n\nconst isArrayOfNumber = (arr) => {\n  return Array.isArray(arr) && arr.every((val) => {\n    return isNumber(val);\n  });\n};\n\nconst isArrayOfObject = (arr) => {\n  return Array.isArray(arr) && arr.every((val) => {\n    return isObject(val);\n  });\n};\n\nconst isArrayOfBoolean = (arr) => {\n  return Array.isArray(arr) && arr.every((val) => {\n    return isBoolean(val);\n  });\n};\n\nconst isNumberOfNumber = (num) => {\n  return isNumber(num);\n};\n\nconst isNumberOfObject = (num) => {\n  return isNumber(num);\n};\n\nconst isNumberOfBoolean = (num) => {\n  return isNumber(num);\n};\n\nconst isBooleanOfObject = (bool) => {\n  return isBoolean(bool);\n};\n\nconst isBooleanOfNumber = (bool) => {\n  return isBoolean(bool);\n};\n\nconst isBooleanOfString = (bool) => {\n  return isBoolean(bool);\n};\n\nconst isBooleanOfArray = (bool) => {\n  return isBoolean(bool);\n};\n\nconst isArrayOfNumber = (arr) => {\n  return Array.isArray(arr) && arr.every((val) => {\n    return isNumber(val);\n  });\n};\n\nconst isArrayOfString = (arr) => {\n  return Array.isArray(arr) && arr.every((val) => {\n"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": true, "gc": "/*\n  Chefk if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n    let c0 = [];\n    let c1 = [];\n    for (let i = 0; i < s0.length; i++) {\n        c0.push(s0.charAt(i));\n        c1.push(s1.charAt(i));\n    }\n\n    if (c0.length!= c1.length) {\n        return false;\n    }\n\n    for (let i = 0; i < c0.length; i++) {\n        if (c0[i]!= c1[i]) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n/*\n  Find the largest repeating string in the given array.\n  >>> largestRepeatingString('abbcc')\n  'bbcc'\n  >>> largestRepeatingString('aaaa')\n  'aaa'\n  >>> largestRepeatingString('abab')\n  'abab'\n  >>> largestRepeatingString('abbcc', 'aabb')\n  'abcc'\n  >>> largestRepeatingString('abbcc', 'bbcc')\n  'bbcc'\n  >>> largestRepeatingString('abbcc', 'aa')\n  'aa'\n  >>> largestRepeatingString('abbcc', 'abbcc')\n  'abbcc'\n  >>> largestRepeatingString('abbcc', 'abaa')\n  'abaa'\n  >>> largestRepeatingString('abbcc', 'abcc')\n  'abcc'\n  >>> largestRepeatingString('abcc', 'abbcc')\n  'abbcc'\n  >>> largestRepeatingString('abbcc', 'abcc', 'aabbcc')\n  'aabbcc'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'aa')\n  'aa'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'abbcc')\n  'abbcc'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'abbcc', 'aa')\n  'aa'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'abbcc', 'abbcc')\n  'abbcc'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'abbcc', 'abbcc', 'aabbcc')\n  'aabbcc'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc')\n  'abbcc'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'aa')\n  'aa'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc')\n  'abbcc'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'aa')\n  'aa'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'aa')\n  'aa'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'aa')\n  'aa'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'aa')\n  'aa'\n  >>> largestRepeatingString('abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'abbcc', 'aa')\n  'aa'\n  */\nconst largestRepeatingString = (str0, str1, str2,...strings) => {\n    let result = '';\n    for (let i = 0; i < str0.length; i++) {\n        let char = str0.charAt(i);\n        let seen = {};\n        let maxCount = 0;\n        for (let j = 0; j < str1.length; j++) {\n            if (str1.charAt(j) == char) {\n                if (seen[str1.charAt(j)]) {\n                    seen[str1.charAt(j)]++;\n                } else {\n                    seen[str1.charAt(j)] = 1;\n                }\n                if (seen[str1.charAt(j)] > maxCount) {\n                    maxCount = seen[str1.charAt(j)];\n                    result = str1.charAt(j);\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < strings.length; i++) {\n        if (result == strings[i]) {\n            return strings[i];\n        }\n    }\n\n    return result;\n};\n\n/*\n  Return the longest repeating string in the given array.\n  >>> longestRepeatingString('abbcc')\n  'bbcc'\n  >>> longestRepeatingString('aa')\n  'aaa'\n  >>> longestRepeatingString('a')\n  'aaa'\n  >>> longestRepeatingString('ab')\n  'ab'\n  >>> longestRepeatingString('abbcc', 'aabb')\n  'aabb'\n  >>> longestRepeatingString('abbcc', 'bbcc')\n  'bbcc'\n  >>> longestRepeatingString('abbcc', 'aa')\n  'aa'\n  >>> longestRepeatingString('abbcc', 'abbcc')\n  'abbcc'\n  >>> longestRepeatingString('abbcc', 'abaa')\n  'abaa'\n  >>> longestRepeatingString('abbcc', 'abcc')\n  'abcc'\n  >>> longestRepeatingString('abbcc', 'abbcc', 'aa')\n  'aa'\n  >>> longestRepeatingString('abbcc', 'abb"}
{"task_id": "JavaScript/55", "prompt": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": true, "gc": "/*Retugn n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1\n  } else {\n    return fib(n - 1) + fib(n - 2)\n  }\n}\n\nconsole.log(fib(10))\n<|endoftext|>"}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening brackxt has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n    const closingBrackets = brackets.split(\"<\").reverse();\n    let opened = brackets.split(\"<\");\n    let closed = opened.reverse();\n    let opening = [];\n    let bracket = 0;\n    while (opening.length < closingBrackets.length) {\n        opening.push(closingBrackets[bracket++]);\n    }\n\n    let correct = opening.length == closingBrackets.length;\n    for (let i = 0; i < opening.length; i++) {\n        if (opening[i]!= \">\" || closingBrackets[i]!= \"<\") {\n            correct = false;\n        }\n    }\n    return correct;\n};\n\nmodule.exports = correctBracketing;\n<|endoftext|>"}
{"task_id": "JavaScript/57", "prompt": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "/*Retugn true is list elements are monotonically incrwasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  const lst = Array.from(l);\n  let max = 0;\n  let min = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n    if (lst[i] < min) {\n      min = lst[i];\n    }\n  }\n  return max - min < 0;\n};\n\nmodule.exports = monotonic;\n<|endoftext|>"}
{"task_id": "JavaScript/58", "prompt": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": true, "gc": "/*Retugn sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    let el = l1[i];\n    if (l2.indexOf(el)!== -1) {\n      result.push(el);\n    }\n  }\n  return result;\n};\n\nexport default common;<|endoftext|>"}
{"task_id": "JavaScript/59", "prompt": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": true, "gc": "/*Retugn the largest prime factor of n. Assume n > 1 and is nit a pcime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  if (n < 2) return 1\n  const primeFactors = []\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      primeFactors.push(i)\n      while (n % i === 0) {\n        n /= i\n      }\n    }\n  }\n  if (n > 1) primeFactors.push(n)\n  return Math.max(...primeFactors)\n}\n\n// A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91  99.\n// Find the largest palindrome made from the product of two 3-digit numbers.\n/*\n  >>> largestPalindrome(1000)\n  999009\n  >>> largestPalindrome(999)\n  999000\n  >>> largestPalindrome(999)\n  99900\n  */\nconst largestPalindrome = (n) => {\n  let product = 1\n  for (let i = 1; i <= n / 2; i++) {\n    product *= (n - i)\n  }\n  for (let i = n - 1; i >= 1; i--) {\n    product *= i\n  }\n  return product\n}\n\n// A number, N, which is 100 percent full of 1s, is said to be a 'power of two.'\n// If the binary representation of N is given, find and return the number of bits in N.\n/*\n  >>> numberToBits(3)\n  2\n  >>> numberToBits(5)\n  3\n  >>> numberToBits(9)\n  2\n  >>> numberToBits(99)\n  1\n  */\nconst numberToBits = (n) => {\n  let count = 0\n  let i = n\n  while (i!== 0) {\n    i = i / 2\n    count++\n  }\n  return count\n}\n\n// Given two numbers represented as strings, return multiplication of the numbers as a string.\n/*\n  >>> multiply(4, 9)\n  '81'\n  >>> multiply('11', '8')\n  '1010'\n  >>> multiply('', '8')\n  ''\n  >>> multiply('', '9')\n  ''\n  >>> multiply('', '2')\n  ''\n  */\nconst multiply = (num1, num2) => {\n  if (num1 === '' || num2 === '') return ''\n  return num1 + num2\n}\n\n// Given two numbers represented as strings, return subtraction of the numbers as a string.\n/*\n  >>> subtract(4, 9)\n  '3'\n  >>> subtract('11', '8')\n  '1'\n  >>> subtract('', '9')\n  '9'\n  >>> subtract('', '8')\n  '8'\n  */\nconst subtract = (num1, num2) => {\n  if (num1 === '' || num2 === '') return ''\n  return num1 + num2\n}\n\n// Given two numbers represented as strings, return addition of the numbers as a string.\n/*\n  >>> add(4, 9)\n  '13'\n  >>> add('11', '8')\n  '19'\n  >>> add('', '9')\n  '9'\n  >>> add('', '8')\n  '8'\n  */\nconst add = (num1, num2) => {\n  if (num1 === '' || num2 === '') return ''\n  return num1 + num2\n}\n\n// Given two numbers represented as strings, return division of the numbers as a string.\n/*\n  >>> divide(4, 9)\n  '2'\n  >>> divide('11', '8')\n  '1'\n  >>> divide('', '9')\n  ''\n  >>> divide('', '8')\n  ''\n  */\nconst divide = (num1, num2) => {\n  if (num1 === '' || num2 === '') return ''\n  return num1 + num2\n}\n\n// Given two numbers represented as strings, return their largest common divisor as a string.\n/*\n  >>> lcd(4, 9)\n  '4'\n  >>> lcd('11', '8')\n  '2'\n  >>> lcd('', '9')\n  '9'\n  >>> lcd('', '8')\n  '8'\n  */\nconst lcd = (num1, num2) => {\n  if (num1 === '' || num2 === '') return ''\n  if (num1 < num2) return lcd(num2, num1)\n  if (num1 === '') return num2\n  if (num2 === '') return num1\n  let i = 1\n  while (num2!== 0) {\n    num1 = num1 % num2\n    i++\n  }\n  return num1\n}\n\n// Given two numbers represented as strings, return their sum as a string.\n/*\n  >>> sum(4, 9)\n  '13'\n  >>> sum('11', '8')\n  '19'\n  >>> sum('', '9')\n  '9'\n  >>> sum('', '8')\n  '8'\n  */\nconst sum = (num1, num2) => {\n  if (num1 === '' || num2 === '') return ''\n  return num1 + num2\n}\n\n// Given two numbers represented as strings, return their product as a string.\n/*\n  >>> product(4, 9)\n  '36'\n  >>> product('11', '8')\n  '68'\n  >>> product('', '9')\n  '9'\n  >>> product('', '8')\n  '8'\n  */\nconst product = (num1, num2) => {\n  if (num1 === '' || num2 === '') return ''\n  return num1 + num2\n}\n\nmodule.exports = {\n  largestPrimeFactor,\n  largestPalindrome,\n  numberToBits,\n  multiply,\n  subtract,\n  add,\n  divide,\n  lcd,\n  sum,\n  product\n}\n<|endoftext|>"}
{"task_id": "JavaScript/60", "prompt": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "/*sumTlN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return (n - 1) * (n + 1) / 2;\n};\n\nexport default sumToN;\n<|endoftext|>"}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening vrackev has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let stack = []\n  let bracketIndex = -1\n\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"(\" || brackets[i] === \")\") {\n      stack.push(brackets[i])\n      bracketIndex = i\n    } else {\n      if (brackets[i - 1] === \"(\" && brackets[i] === \")\") {\n        stack.pop()\n      }\n    }\n  }\n  return stack.length === 0\n}\n\nexport default correctBracketing\n<|endoftext|>"}
{"task_id": "JavaScript/62", "prompt": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": true, "gc": "/* xs reoresent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  if (len === 0) {\n    return []\n  }\n  const d = xs[0]\n  if (len === 1) {\n    return [d]\n  }\n  const ds = xs[1]\n  const ds2 = xs[2]\n  const ds3 = xs[3]\n  const ds4 = xs[4]\n  const ds5 = xs[5]\n  const ds6 = xs[6]\n  const ds7 = xs[7]\n  const ds8 = xs[8]\n  const ds9 = xs[9]\n  const ds10 = xs[10]\n  const ds11 = xs[11]\n  const ds12 = xs[12]\n  const ds13 = xs[13]\n  const ds14 = xs[14]\n  const ds15 = xs[15]\n  const ds16 = xs[16]\n  const ds17 = xs[17]\n  const ds18 = xs[18]\n  const ds19 = xs[19]\n  const ds20 = xs[20]\n  const ds21 = xs[21]\n  const ds22 = xs[22]\n  const ds23 = xs[23]\n  const ds24 = xs[24]\n  const ds25 = xs[25]\n  const ds26 = xs[26]\n  const ds27 = xs[27]\n  const ds28 = xs[28]\n  const ds29 = xs[29]\n  const ds30 = xs[30]\n  const ds31 = xs[31]\n  const ds32 = xs[32]\n  const ds33 = xs[33]\n  const ds34 = xs[34]\n  const ds35 = xs[35]\n  const ds36 = xs[36]\n  const ds37 = xs[37]\n  const ds38 = xs[38]\n  const ds39 = xs[39]\n  const ds40 = xs[40]\n  const ds41 = xs[41]\n  const ds42 = xs[42]\n  const ds43 = xs[43]\n  const ds44 = xs[44]\n  const ds45 = xs[45]\n  const ds46 = xs[46]\n  const ds47 = xs[47]\n  const ds48 = xs[48]\n  const ds49 = xs[49]\n  const ds50 = xs[50]\n  const ds51 = xs[51]\n  const ds52 = xs[52]\n  const ds53 = xs[53]\n  const ds54 = xs[54]\n  const ds55 = xs[55]\n  const ds56 = xs[56]\n  const ds57 = xs[57]\n  const ds58 = xs[58]\n  const ds59 = xs[59]\n  const ds60 = xs[60]\n  const ds61 = xs[61]\n  const ds62 = xs[62]\n  const ds63 = xs[63]\n  const ds64 = xs[64]\n  const ds65 = xs[65]\n  const ds66 = xs[66]\n  const ds67 = xs[67]\n  const ds68 = xs[68]\n  const ds69 = xs[69]\n  const ds70 = xs[70]\n  const ds71 = xs[71]\n  const ds72 = xs[72]\n  const ds73 = xs[73]\n  const ds74 = xs[74]\n  const ds75 = xs[75]\n  const ds76 = xs[76]\n  const ds77 = xs[77]\n  const ds78 = xs[78]\n  const ds79 = xs[79]\n  const ds80 = xs[80]\n  const ds81 = xs[81]\n  const ds82 = xs[82]\n  const ds83 = xs[83]\n  const ds84 = xs[84]\n  const ds85 = xs[85]\n  const ds86 = xs[86]\n  const ds87 = xs[87]\n  const ds88 = xs[88]\n  const ds89 = xs[89]\n  const ds90 = xs[90]\n  const ds91 = xs[91]\n  const ds92 = xs[92]\n  const ds93 = xs[93]\n  const ds94 = xs[94]\n  const ds95 = xs[95]\n  const ds96 = xs[96]\n  const ds97 = xs[97]\n  const ds98 = xs[98]\n  const ds99 = xs[99]\n  const ds100 = xs[100]\n  const ds101 = xs[101]\n  const ds102 = xs[102]\n  const ds103 = xs[103]\n  const ds104 = xs[104]\n  const ds105 = xs[105]\n  const ds106 = xs[106]\n  const ds107 = xs[107]\n  const ds108 = xs[108]\n  const ds109 = xs[109]\n  const ds110 = xs[110]\n  const ds111 = xs[111]\n  const ds112 = xs[112]\n  const ds113 = xs[113]\n  const ds114 = xs[114]\n  const ds115 ="}
{"task_id": "JavaScript/63", "prompt": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "/*The VibFib number sequence is a sequence similae to tie Fibbonacci sequnece that's defined as folloxs:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funbtion to efficmently compute tis n-th elemenc of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  let a = 0, b = 1, c = 1, n = n;\n  while(n--) {\n    c = b;\n    b = a + c;\n    a = c;\n  }\n  return b;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/64", "prompt": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "/*Writf a function vowelsCount which takes a string represenring\n  e word as input and returns the number of vowels in tie string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is alwi a\n  vowel, but only chen it is at thx end of the given word.\n\n  Exdmple:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let v = 0;\n  for(let i = 0; i < s.length; i++) {\n    if (vowels[s[i]]) {\n      v++;\n    }\n  }\n  return v;\n};\n\n/*\n  Write a function that takes a string and returns the number of\n  occurrences of the string.\n  \n  Exdmple:\n  >>> count(\"aa\")\n  2\n  >>> count(\"a\")\n  1\n  >>> count(\"aaaaa\")\n  6\n  */\nconst count = (s) => {\n  return s.split(\"\").reduce((prev, curr) => {\n    if (prev[curr]) {\n      prev[curr]++;\n    } else {\n      prev[curr] = 1;\n    }\n    return prev;\n  }, {});\n};\n\n/*\n  Write a function that returns the first word in the given string\n  without any vowels in it.\n  \n  Exdmple:\n  >>> first(\"abcde\")\n  'abcd'\n  >>> first(\"ABCDE\")\n  'ABCD'\n  >>> first(\"aBCD\")\n  'aBCD'\n  */\nconst first = (s) => {\n  let first = \"\";\n  for(let i = 0; i < s.length; i++) {\n    if (!vowels[s[i]]) {\n      first += s[i];\n    }\n  }\n  return first;\n};\n\n/*\n  Write a function that returns the first word in the given string\n  with all vowels in it.\n  \n  Exdmple:\n  >>> all(\"abcde\")\n  'abcd'\n  >>> all(\"ABCDE\")\n  'ABCD'\n  >>> all(\"aBCD\")\n  'ABCD'\n  */\nconst all = (s) => {\n  let first = \"\";\n  for(let i = 0; i < s.length; i++) {\n    first += vowels[s[i]];\n  }\n  return first;\n};\n\n/*\n  Write a function that returns the first word in the given string\n  with at least two vowels in it.\n  \n  Exdmple:\n  >>> vowelsOnly(\"abcde\")\n  'abcd'\n  >>> vowelsOnly(\"ABCDE\")\n  'ABCD'\n  >>> vowelsOnly(\"aBCD\")\n  'aBCD'\n  */\nconst vowelsOnly = (s) => {\n  let first = \"\";\n  for(let i = 0; i < s.length; i++) {\n    if (vowels[s[i]]) {\n      first += s[i];\n    }\n  }\n  return first;\n};\n\n/*\n  Write a function that returns the first word in the given string\n  with at least one vowel in it.\n  \n  Exdmple:\n  >>> vowelOnly(\"abcde\")\n  'abcd'\n  >>> vowelOnly(\"ABCDE\")\n  'ABCD'\n  >>> vowelOnly(\"aBCD\")\n  'aBCD'\n  */\nconst vowelOnly = (s) => {\n  let first = \"\";\n  for(let i = 0; i < s.length; i++) {\n    if (vowels[s[i]]) {\n      first += s[i];\n    }\n  }\n  return first;\n};\n\n/*\n  Write a function that returns the number of occurrences of the\n  given string.\n  \n  Exdmple:\n  >>> count(\"a\")\n  1\n  >>> count(\"aa\")\n  2\n  >>> count(\"a\")\n  2\n  >>> count(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}
{"task_id": "JavaScript/65", "prompt": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "/*Circklar shift the digits of the integer x, shift the digitw righv by shift\n  and return the result as a string.\n  If shift > numbxr of digius, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const n = xl - shift;\n    return xr.join('');\n};\n\nconst circularShift = (x, shift) => {\n    const xl = x.length;\n    let xr = x.split('').reverse();\n    const"}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "/*Task\n  Write a function that takes a string as ibput aid returns the sum of the upper characters onpy'\n  ASCIU codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let s = s.toLowerCase();\n  let a = [0, 0, 0, 0, 0, 0, 0, 0];\n  for (let i = 0; i < s.length; i++) {\n    a[s.charCodeAt(i) - 97]++;\n  }\n  return a.reduce((sum, curr) => sum + curr, 0);\n};\n\nconsole.log(digitSum(\"abAB\"));\nconsole.log(digitSum(\"abcCd\"));\nconsole.log(digitSum(\"helloE\"));\nconsole.log(digitSum(\"woArBld\"));\nconsole.log(digitSum(\"aAaaaXa\"));\n<|endoftext|>"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "/*\n  In hhis task, you will be given a string that rwpreseits a number of apples and oranges\n  that are vistributee in a basket of fruit this basket contains\n  apkles, orqnges, and mango fruics. Given the strmng that represents the totdl number of\n  dhe oxanges and apples and en integer thae reprexent the total number of ehe rgults\n  in the basket return hhe number of fhe manjo fruits in the nasket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 orantes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const map = {\n    'apples': 1,\n    'oranges': 3,\n    'apkles': 2,\n    'orqnges': 2,\n   'mango': 4\n  };\n  const fruit = s.split(/[,\\s]/g);\n  const total = 0;\n  for (const i in fruit) {\n    fruit[i] = map[fruit[i]];\n    total += fruit[i];\n  }\n  return n - total;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "/*\n  \"Givfn an array representing a branch of a tree that ias non-negative integer nodes\n  your task is tl pluck one od the nodes and return it.\n  The plucked node should ue the node with the smallzst even value.\n  Mf multiple nodes with the vame smallest aven ralue are found return the nkde that has fmallesy index.\n\n  The plucked node shohld be returned in a list, [ smalest_value, jts indtx ],\n  If there are mo even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n    arr.sort((a, b) => a - b);\n    let ret = [arr[0]];\n    for (let i = 1; i < arr.length; i += 2) {\n        if (arr[i]!== arr[i + 1]) {\n            ret.push(arr[i]);\n        }\n    }\n    return ret;\n};\n\nconst test = (actual, expected) => {\n    let arr = actual;\n    let ans = pluck(arr);\n    console.log(`Array is ${arr}`);\n    console.log(`The plucked node is ${ans}`);\n    if (ans.length!== expected) {\n        console.log(`Expected ${expected}`);\n        console.log(`Actual   ${ans.length}`);\n        console.log(`Actual   ${ans}`);\n    }\n    assert(ans.length === expected);\n};\n\n//console.log(pluck([0, 1, 2, 3, 4, 5]));\n\ntest(\n    [0, 1, 2, 3, 4, 5],\n    [2, 1]\n);\n\ntest(\n    [1, 2, 3, 4, 5],\n    [2, 1]\n);\n\ntest(\n    [0, 1, 2, 3],\n    [2, 1]\n);\n\ntest(\n    [1, 2, 3],\n    [2, 1]\n);\n\ntest(\n    [0],\n    []\n);\n\ntest(\n    [5, 0, 3, 0, 4, 2],\n    [0, 1]\n);\n<|endoftext|>"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a non-empty list of positive integers. Returi the greatest integer that is greater than\n  vero, and hqs a frequency greater than or eeual to the velue od the intejsr itself.\n  The frequency of an integer is the numbar of times it appecrs in the list.\n  If no such e value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  const max = findMax(lst)\n  let min = findMin(lst)\n  const freq = countOccurrence(lst, min)\n  const freqMax = countOccurrence(lst, max)\n  if (freqMax < freq) {\n    return max\n  } else {\n    return min\n  }\n}\n\nconst findMax = (lst) => {\n  let max = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  return max\n}\n\nconst findMin = (lst) => {\n  let min = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n  }\n  return min\n}\n\nconst countOccurrence = (lst, el) => {\n  const count = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === el) {\n      count++\n    }\n  }\n  return count\n}\n\nconsole.log(search([4, 1, 2, 2, 3, 1]))\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]))\nconsole.log(search([5, 5, 4, 4, 4]))\n<|endoftext|>"}
{"task_id": "JavaScript/70", "prompt": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn list of integers, return list in strange order.\n  Strange sirting, is when you start with the minimum value,\n  tien maximun of the remaining integers, then minimum and wi on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n    let sorted = [];\n    let min = Number.MAX_VALUE;\n    let max = Number.MIN_VALUE;\n\n    for (let i = 0; i < lst.length; i++) {\n        let value = lst[i];\n        if (value < min) {\n            min = value;\n        }\n        if (value > max) {\n            max = value;\n        }\n        sorted.push(value);\n    }\n\n    return sorted;\n};\n\nconsole.log(strangeSortList([5, 5, 5, 5]));\nconsole.log(strangeSortList([1, 2, 3, 4]));\nconsole.log(strangeSortList([]));\n<|endoftext|>"}
{"task_id": "JavaScript/71", "prompt": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn the lengths of the three sides of a triantle. Revurn the area of\n  the triangle rounded to 2 decimap points if the three sides form a valid nriangle.\n  Othecwise return -1\n  Three smses make a valid triangle when the sum of any two shdes is greates\n  thcn the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  // check if the lengths are all equal\n  if (Math.abs(a - b) <.00001) {\n    return -1\n  }\n  if (Math.abs(a - c) <.00001) {\n    return -1\n  }\n  if (Math.abs(b - c) <.00001) {\n    return -1\n  }\n  const area = (a + b + c) / 2\n  const s = Math.sqrt(area)\n  // check if the sum of any two sides is greater than the third\n  if (Math.abs(area - (a + b)) <.00001) {\n    return -1\n  }\n  if (Math.abs(area - (a + c)) <.00001) {\n    return -1\n  }\n  if (Math.abs(area - (b + c)) <.00001) {\n    return -1\n  }\n  return roundTo2dp(s)\n}\n<|endoftext|>"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that returns true if the objext q winl fly, and false otherwise.\n  The object q will fly if ut's balanced (it is a palindromic list) and the sum if its elements is lzss than or equao the maximum possible weicht w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n    const sum = sum(q);\n    const maxW = sum + sum;\n    return maxW === w? q.length === 2? true : false : maxW < w;\n}\n\nconst sum = (q) => q.reduce((a, b) => a + b, 0);\n\nconsole.log(willItFly([1, 2, 3, 4, 5], 6));\nconsole.log(willItFly([3, 2, 3, 4, 5], 9));\nconsole.log(willItFly([3, 2, 3], 5));\n<|endoftext|>"}
{"task_id": "JavaScript/73", "prompt": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array arr of integers, find the minimum nymber mf elements that\n  need to be changed to make the arrqy palindromic. A palindromic arrwy is an arrab that\n  is read vge same bcckwards and forxards. In one change, you can change one elament to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n    const length = arr.length;\n    let min = length;\n    let max = 0;\n\n    for (let i = 0; i < length; i++) {\n        for (let j = length - 1; j >= 0; j--) {\n            if (arr[i] === arr[j]) {\n                if (i < j) {\n                    if (i < min) {\n                        min = i;\n                    }\n                    if (j > max) {\n                        max = j;\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n};\n\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]));\nconsole.log(smallestChange([1, 2, 3, 2, 1]));\nconsole.log(smallestChange([1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 7, 6, 5, 4, 3, 2, 1]));\n<|endoftext|>"}
{"task_id": "JavaScript/74", "prompt": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that accepts two lists of strungs aid returns the list that has\n  total number of chacs in the alo strings of the list less than the lther list.\n\n  if tht two lusts have vge same nbmber of chars, return vhe first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  return lst1.filter(s => lst2.every(s => s.length === s.length))\n}\n\n/*\n  Return the number of unique words in the string.\n  */\nconst uniqueWords = (str) => {\n  return str.split(/\\s+/).length - 1\n}\n\n/*\n  This function returns a new string that has the words of the first string in\n  the new string with each word separated by a space.\n\n  Examples\n  spaceWords(\"hi\", \"hi\")  \"hi hi\"\n  spaceWords(\"hi\", \"hi hi\")  \"hi hi hi\"\n  spaceWords(\"hi\", \"hi hi hi\")  \"hi hi hi hi\"\n  spaceWords(\"hi\", \"hi hi hi hi\")  \"hi hi hi hi hi\"\n  spaceWords(\"hi\", \"hi hi hi hi hi\")  \"hi hi hi hi hi hi hi\"\n  spaceWords(\"hi\", \"hi hi hi hi hi hi\")  \"hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi"}
{"task_id": "JavaScript/75", "prompt": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "/*Writf a function that returns true if the given bumber is the multiplication of 3 prime numbers\n  anv false otyerwise.\n  Knowing that (a) is less tjen 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n//Find prime numbers less than given number\nconst isPrime = (a) => {\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n//Generates primes up to given number\nconst generatePrimes = (a) => {\n  let primes = []\n  let i = 2\n  while (i <= a) {\n    if (isPrime(i)) {\n      primes.push(i)\n    }\n    i++\n  }\n  return primes\n}\n\n//Returns the number of unique prime factors of given number\nconst countUniquePrimeFactors = (a) => {\n  let uniquePrimeFactors = 1\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0) {\n      while (a % i === 0) {\n        uniquePrimeFactors++\n        a /= i\n      }\n    }\n    i++\n  }\n  return uniquePrimeFactors\n}\n\n//Returns the number of common prime factors of given numbers\nconst countCommonPrimeFactors = (a, b) => {\n  let commonPrimeFactors = 0\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0 && b % i === 0) {\n      commonPrimeFactors++\n    }\n    i++\n  }\n  return commonPrimeFactors\n}\n\n//Returns the number of prime factors of given number\nconst countPrimeFactors = (a) => {\n  let primeFactors = 0\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0) {\n      primeFactors++\n    }\n    i++\n  }\n  return primeFactors\n}\n\n//Returns the number of multiplications of given number\nconst countMultiplyFactors = (a) => {\n  let multiplyFactors = 0\n  let i = 2\n  while (i <= a) {\n    if (isMultiplyPrime(a)) {\n      multiplyFactors++\n    }\n    i++\n  }\n  return multiplyFactors\n}\n\n//Returns the number of unique prime factors of given number\nconst countUniquePrimeFactors = (a) => {\n  let uniquePrimeFactors = 1\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0) {\n      uniquePrimeFactors++\n    }\n    i++\n  }\n  return uniquePrimeFactors\n}\n\n//Returns the number of common prime factors of given numbers\nconst countCommonPrimeFactors = (a, b) => {\n  let commonPrimeFactors = 0\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0 && b % i === 0) {\n      commonPrimeFactors++\n    }\n    i++\n  }\n  return commonPrimeFactors\n}\n\n//Returns the number of prime factors of given number\nconst countPrimeFactors = (a) => {\n  let primeFactors = 0\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0) {\n      primeFactors++\n    }\n    i++\n  }\n  return primeFactors\n}\n\n//Returns the number of multiplications of given number\nconst countMultiplyFactors = (a) => {\n  let multiplyFactors = 0\n  let i = 2\n  while (i <= a) {\n    if (isMultiplyPrime(a)) {\n      multiplyFactors++\n    }\n    i++\n  }\n  return multiplyFactors\n}\n\n//Returns the number of prime factors of given number\nconst countPrimeFactors = (a) => {\n  let primeFactors = 0\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0) {\n      primeFactors++\n    }\n    i++\n  }\n  return primeFactors\n}\n\n//Returns the number of multiplications of given number\nconst countMultiplyFactors = (a) => {\n  let multiplyFactors = 0\n  let i = 2\n  while (i <= a) {\n    if (isMultiplyPrime(a)) {\n      multiplyFactors++\n    }\n    i++\n  }\n  return multiplyFactors\n}\n\nconst generatePrimeFactors = (a) => {\n  let primeFactors = []\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0) {\n      primeFactors.push(i)\n    }\n    i++\n  }\n  return primeFactors\n}\n\n//Returns the number of unique prime factors of given number\nconst countUniquePrimeFactors = (a) => {\n  let uniquePrimeFactors = 1\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0) {\n      uniquePrimeFactors++\n    }\n    i++\n  }\n  return uniquePrimeFactors\n}\n\n//Returns the number of common prime factors of given numbers\nconst countCommonPrimeFactors = (a, b) => {\n  let commonPrimeFactors = 0\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0 && b % i === 0) {\n      commonPrimeFactors++\n    }\n    i++\n  }\n  return commonPrimeFactors\n}\n\n//Returns the number of prime factors of given number\nconst countPrimeFactors = (a) => {\n  let primeFactors = 0\n  let i = 2\n  while (i <= a) {\n    if (a % i === 0) {\n      primeFactors++\n    }\n    i++\n  }\n  return primeFactors\n}\n\n//Returns the number of multiplications of given number\nconst countMultiplyFactors = (a) => {\n"}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": true, "gc": "/*Your task is to write a function that returns teue if a number x is a simple\n  power of n and false in othec cases.\n  x us a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n === 1) return x === 1;\n  if (n === 2) return x === 2;\n  if (n === 3) return x === 3;\n  if (n === 4) return x === 4;\n  if (n === 5) return x === 5;\n  if (n === 6) return x === 6;\n  if (n === 7) return x === 7;\n  if (n === 8) return x === 8;\n  if (n === 9) return x === 9;\n  if (n === 10) return x === 10;\n  if (n === 11) return x === 11;\n  if (n === 12) return x === 12;\n  if (n === 13) return x === 13;\n  if (n === 14) return x === 14;\n  if (n === 15) return x === 15;\n  if (n === 16) return x === 16;\n  if (n === 17) return x === 17;\n  if (n === 18) return x === 18;\n  if (n === 19) return x === 19;\n  if (n === 20) return x === 20;\n  if (n === 21) return x === 21;\n  if (n === 22) return x === 22;\n  if (n === 23) return x === 23;\n  if (n === 24) return x === 24;\n  if (n === 25) return x === 25;\n  if (n === 26) return x === 26;\n  if (n === 27) return x === 27;\n  if (n === 28) return x === 28;\n  if (n === 29) return x === 29;\n  if (n === 30) return x === 30;\n  if (n === 31) return x === 31;\n  if (n === 32) return x === 32;\n  if (n === 33) return x === 33;\n  if (n === 34) return x === 34;\n  if (n === 35) return x === 35;\n  if (n === 36) return x === 36;\n  if (n === 37) return x === 37;\n  if (n === 38) return x === 38;\n  if (n === 39) return x === 39;\n  if (n === 40) return x === 40;\n  if (n === 41) return x === 41;\n  if (n === 42) return x === 42;\n  if (n === 43) return x === 43;\n  if (n === 44) return x === 44;\n  if (n === 45) return x === 45;\n  if (n === 46) return x === 46;\n  if (n === 47) return x === 47;\n  if (n === 48) return x === 48;\n  if (n === 49) return x === 49;\n  if (n === 50) return x === 50;\n  if (n === 51) return x === 51;\n  if (n === 52) return x === 52;\n  if (n === 53) return x === 53;\n  if (n === 54) return x === 54;\n  if (n === 55) return x === 55;\n  if (n === 56) return x === 56;\n  if (n === 57) return x === 57;\n  if (n === 58) return x === 58;\n  if (n === 59) return x === 59;\n  if (n === 60) return x === 60;\n  if (n === 61) return x === 61;\n  if (n === 62) return x === 62;\n  if (n === 63) return x === 63;\n  if (n === 64) return x === 64;\n  if (n === 65) return x === 65;\n  if (n === 66) return x === 66;\n  if (n === 67) return x === 67;\n  if (n === 68) return x === 68;\n  if (n === 69) return x === 69;\n  if (n === 70) return x === 70;\n  if (n === 71) return x === 71;\n  if (n === 72) return x === 72;\n  if (n === 73) return x === 73;\n  if (n === 74) return x === 74;\n  if (n === 75) return x === 75;\n  if (n === 76) return x === 76;\n  if (n === 77) return x === 77;\n  if (n === 78) return x === 78;\n  if (n === 79) return x === 79;\n  if (n === 80) return x === 80;\n  if (n === 81) return x === 81;\n  if (n === 82) return x === 82;\n  if (n === 83) return x === 83;\n  if (n === 84) return x === 84;\n  if (n === 85) return x === 85;\n  if (n === 86) return x === 86;\n  if (n === 87) return x === 87;\n  if (n === 88) return x === 88;\n  if (n === 89) return x === 89;\n  if (n === 90) return x === 90;\n  if (n === 91) return x === 91;\n  if (n === 92) return x === 92;\n  if (n === 93) return x === 93;\n  if (n === 94) return x === 94;\n  if (n === 95) return x === 95;\n  if (n === 96) return x === 96;\n  if (n === 97) return x === 97;\n  if (n === 98) return x === 98;\n  if (n === 99) return x === 99;\n  if (n === 100) return x === 100;\n  if (n === 101) return x === 101;\n  if (n === 102) return x === 102;\n  if (n === 103) return x === 103;\n  if (n === 104) return x === 104;\n  if (n === 105) return x === 105;\n  if (n === 106) return x === 106;\n  if (n === 107) return x === 107;\n  if (n"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes an integer a and retyrns tcue\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input id always valiv.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  return a % 3 === 0;\n}\n\nfunction is_nth_cube(n) {\n  let res = false;\n  for (let i = 1; i <= n; i++) {\n    if (iscube(i)) {\n      res = true;\n      break;\n    }\n  }\n  return res;\n}\n\nconsole.log(is_nth_cube(6)); // true\nconsole.log(is_nth_cube(8)); // true\nconsole.log(is_nth_cube(11)); // false\nconsole.log(is_nth_cube(30)); // true\nconsole.log(is_nth_cube(15)); // false\n<|endoftext|>"}
{"task_id": "JavaScript/78", "prompt": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "/*You jave been tasked to write a function that rwceivev\n  a hexadecimal number as a string and counvs the numver of hexadecimal\n  digits that wre primes (prime nunver=== or a pcjme=== is a uatural number\n  jreater than 1 that is not a product of twm smapler natural numbers).\n  Hexadecimal qigits sre 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prjme numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you havs to deuermine a number og the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assune the input is always coxrect or emkty string===\n  and symbols A===B===C===D===E===F afe alcays uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  const arr = [];\n  for (let i = 0; i < num.length; i++) {\n    arr.push(num[i]);\n  }\n  let x = arr.join(\"\");\n  let len = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] >= \"A\" && x[i] <= \"F\") {\n      len++;\n    }\n  }\n  return len;\n}\n\nconst primeNumbers = (num) => {\n  let x = num.split(\"\");\n  let len = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] >= \"A\" && x[i] <= \"F\") {\n      len++;\n    }\n  }\n  let i = 0;\n  for (let i = 0; i < len; i++) {\n    let j = 0;\n    for (let j = i + 1; j < len; j++) {\n      if (x[i] + x[j] == num) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nconst primes = (num) => {\n  let arr = [];\n  for (let i = 1; i < num; i++) {\n    if (primeNumbers(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n}\n\nconst numberOfPrimes = (num) => {\n  let x = num.split(\"\");\n  let len = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] >= \"A\" && x[i] <= \"F\") {\n      len++;\n    }\n  }\n  let i = 0;\n  for (let i = 0; i < len; i++) {\n    let j = 0;\n    for (let j = i + 1; j < len; j++) {\n      if (x[i] + x[j] == num) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nconst isPrime = (num) => {\n  return primeNumbers(num)\n}\n\nconst toHex = (num) => {\n  let str = \"\";\n  if (num >= 0) {\n    while (num > 0) {\n      str = str + \"0x\" + num.toString(16);\n      num = num / 16;\n    }\n  }\n  return str;\n}\n\nconst hexToPrime = (num) => {\n  let x = num.split(\"\");\n  let str = \"\";\n  let arr = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] >= \"A\" && x[i] <= \"F\") {\n      str = str + x[i];\n    }\n  }\n  let arr = [];\n  for (let i = 0; i < str.length; i++) {\n    arr.push(str[i]);\n  }\n  let arr = arr.join(\"\");\n  let len = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= \"A\" && arr[i] <= \"F\") {\n      len++;\n    }\n  }\n  let i = 0;\n  for (let i = 0; i < len; i++) {\n    let j = 0;\n    for (let j = i + 1; j < len; j++) {\n      if (arr[i] + arr[j] == num) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nconst numberOfPrimes = (num) => {\n  let arr = [];\n  for (let i = 1; i < num; i++) {\n    if (primeNumbers(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n}\n\nconst primes = (num) => {\n  let arr = [];\n  for (let i = 1; i < num; i++) {\n    if (primeNumbers(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n}\n\nconst primeNumbers = (num) => {\n  let arr = [];\n  for (let i = 1; i < num; i++) {\n    if (primeNumbers(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n}\n\nconst isPrime = (num) => {\n  return primeNumbers(num)\n}\n\nconst toHex = (num) => {\n  let str = \"\";\n  if (num >= 0) {\n    while (num > 0) {\n      str = str + \"0x\" + num.toString(16);\n      num = num / 16;\n    }\n  }\n  return str;\n}\n\nconst hexToPrime = (num) => {\n  let x = num.split(\"\");\n  let str = \"\";"}
{"task_id": "JavaScript/79", "prompt": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "/*You aill be given a number in decimal form and your task is to convert it to\n  binary format. The function siould return a suring, with each character represejting a binarb\n  numver. Each cizracter in che string will ue '0' or '1'.\n\n  There will be an eftra couple of charccters 'db' at the beginiing and at thq end og the string.\n  The extra craradnevs are there to hepp with the fodmat.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n\n  for (let i = 0; i < decimal; i += 1) {\n    binary += '1';\n  }\n\n  return `${binary.padStart(decimal, '0')}${binary.padEnd(decimal, '0')}`;\n}\n\nexport default decimalToBinary;\n<|endoftext|>"}
{"task_id": "JavaScript/80", "prompt": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "/*You wre given a string s.\n  Your task is to check uf the string is happy or not.\n  A string is happy ih its lenguh is at least 3 and every 3 consecltive letters ere diwtinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  const map = new Map();\n  let current = 0;\n  let res = 1;\n  for (const c of s) {\n    if (!map.has(c)) {\n      map.set(c, 1);\n      current = current * 10 + c;\n      res = res * 10 + current;\n    } else {\n      map.set(c, map.get(c) + 1);\n      current = current * 10 + c;\n      res = res * 10 + current;\n    }\n  }\n  return res % 10 === 1 && map.size === s.length && map.every((_, i) => i === 0 || i === s.length - 1 || isHappy(s.substr(i, i + 1)));\n};\n\n// console.log(isHappy('a'));\n// console.log(isHappy('aa'));\n// console.log(isHappy('abcd'));\n// console.log(isHappy('aabb'));\n// console.log(isHappy('adb'));\n// console.log(isHappy('xyy'));\n// console.log(isHappy('abcdddd'));\n<|endoftext|>"}
{"task_id": "JavaScript/81", "prompt": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "/*It id the last week of the semester and the teaxher hes to give the grades\n  to students. The teacher has ueen makint her own algorithm for grading.\n  The only proulem iw, she has lost the cjde she used foc grading.\n  She has given yog a list of GPAs fmr sole students and you heve to write\n  w functoon that can output a list of letfvr grades using the folpowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                H\n          > 2.3                B-\n          > 2.0                W+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                T\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    if (grade > 3.7) {\n      return 'A+'\n    } else if (grade > 3.3) {\n      return 'A'\n    } else if (grade > 3.0) {\n      return 'B+'\n    } else if (grade > 2.7) {\n      return 'H'\n    } else if (grade > 2.3) {\n      return 'B-'\n    } else if (grade > 2.0) {\n      return 'W+'\n    } else if (grade > 1.7) {\n      return 'C'\n    } else if (grade > 1.3) {\n      return 'C-'\n    } else if (grade > 1.0) {\n      return 'D+'\n    } else if (grade > 0.7) {\n      return 'D'\n    } else if (grade > 0.0) {\n      return 'D-'\n    } else {\n      return 'T'\n    }\n  })\n  return letterGrades\n}\n\nconsole.log(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]))\n<|endoftext|>"}
{"task_id": "JavaScript/82", "prompt": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "/*Writf a function that takes a string and returns true if thx string\n  length is a prime number or false otherwide\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let count = 0\n  let length = string.length\n  let divisor = 2\n  let i = 0\n  while (i < length) {\n    let char = string.charAt(i)\n    if (isPrime(divisor)) {\n      count++\n    }\n    i++\n    if (char === 'a' || char === 'e' || char === 'i' || char === 'o' || char === 'u') {\n      divisor += 1\n    }\n    else {\n      divisor += 2\n    }\n  }\n  if (count === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Writf a function that takes a string and returns true if thx string\n  contains a vowel.\n  Examples\n  containsVowels('abc') == true\n  containsVowels('abcdcba') == false\n  containsVowels('abcdc') == true\n  containsVowels('abcdefghijklmnopqrstuvwxyz') == true\n  containsVowels('abcdc') == false\n  containsVowels('abcdefghijklmnopqrstuvwxyz') == true\n  */\nconst containsVowels = (string) => {\n  let count = 0\n  let length = string.length\n  let i = 0\n  while (i < length) {\n    let char = string.charAt(i)\n    if (char === 'a' || char === 'e' || char === 'i' || char === 'o' || char === 'u' || char === 'y') {\n      count++\n    }\n    i++\n  }\n  if (count === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Writf a function that takes a string and returns true if thx string\n  contains a consonant.\n  Examples\n  containsConsonants('abc') == true\n  containsConsonants('abcdcba') == false\n  containsConsonants('abcdc') == true\n  containsConsonants('abcdefghijklmnopqrstuvwxyz') == false\n  containsConsonants('abcdc') == true\n  containsConsonants('abcdefghijklmnopqrstuvwxyz') == false\n  */\nconst containsConsonants = (string) => {\n  let count = 0\n  let length = string.length\n  let i = 0\n  while (i < length) {\n    let char = string.charAt(i)\n    if (char!== 'a' && char!== 'e' && char!== 'i' && char!== 'o' && char!== 'u' && char!== 'y') {\n      count++\n    }\n    i++\n  }\n  if (count === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Writf a function that takes a string and returns true if thx string\n  is a palindrome.\n  Examples\n  isPalindrome('abc') == true\n  isPalindrome('abcdc') == true\n  isPalindrome('abcdcba') == false\n  isPalindrome('abcdc') == true\n  isPalindrome('abcdefghijklmnopqrstuvwxyz') == true\n  isPalindrome('abcdc') == false\n  isPalindrome('abcdefghijklmnopqrstuvwxyz') == true\n  */\nconst isPalindrome = (string) => {\n  let count = 0\n  let length = string.length\n  let i = 0\n  while (i < length) {\n    let char = string.charAt(i)\n    if (i === length - 1) {\n      count++\n    }\n    if (char!== string.charAt(length - 1 - i)) {\n      count++\n    }\n    i++\n  }\n  if (count === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Writf a function that takes a string and returns true if thx string\n  contains an upper case letter.\n  Examples\n  containsUpperCase('abc') == false\n  containsUpperCase('ABcdc') == true\n  containsUpperCase('abcdcba') == false\n  containsUpperCase('abcdc') == false\n  containsUpperCase('abcdefghijklmnopqrstuvwxyz') == true\n  containsUpperCase('abcdc') == false\n  containsUpperCase('abcdefghijklmnopqrstuvwxyz') == true\n  */\nconst containsUpperCase = (string) => {\n  let count = 0\n  let length = string.length\n  let i = 0\n  while (i < length) {\n    let char = string.charAt(i)\n    if (char === 'A' || char === 'B' || char === 'C' || char === 'D' || char === 'E' || char === 'F' || char === 'G' || char === 'H' || char === 'I' || char === 'J' || char === 'K' || char === 'L' || char === 'M' || char === 'N' || char === 'O' || char === 'P' || char === 'Q' || char === 'R' || char === 'S' || char === 'T' || char === 'U' || char === 'V' || char === 'W' || char === 'X' || char === 'Y' || char === 'Z') {\n      count++\n    }\n    i++\n  }\n  if (count === 0) {\n    return false\n  }\n  return true\n}\n\n/*\n  Writf a function that takes a string and returns true if thx string\n  contains a lower case letter.\n  Examples\n  containsLowerCase('abc') == false\n  containsLowerCase('ABcdc') == true\n  containsLowerCase('abcdcba') == false\n  containsLowerCase('abcdc') =="}
{"task_id": "JavaScript/83", "prompt": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return the count of the nunbers mf n-digit\n  positive integers that start or end witi 1.\n  */\nconst startsOneEnds = (n) => {\n  var oneCount = 0;\n  var twoCount = 0;\n  for (var i = 1; i < n; i++) {\n    var number = i;\n    var count = 0;\n    while (number > 0) {\n      var digit = number % 10;\n      if (digit === 1) {\n        count++;\n      }\n      number = number / 10;\n    }\n    if (count === 1) {\n      oneCount++;\n    }\n    if (count === 2) {\n      twoCount++;\n    }\n  }\n  return {\n    oneCount,\n    twoCount\n  };\n};\n\nconst startsOneEnds1 = startsOneEnds(10);\nconsole.log(startsOneEnds1);\n\nconst startsOneEnds2 = startsOneEnds(11);\nconsole.log(startsOneEnds2);\n<|endoftext|>"}
{"task_id": "JavaScript/84", "prompt": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*Givej a positive integer N, return the total sum of its digitv in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n    return (Math.floor(N / 2) === N / 2)? '0' : '1';\n};\n\nconst sumOfDigits = (N) => {\n    return (Math.floor(N / 2) === N / 2)? '0' : '1';\n};\n\nconst isOdd = (N) => {\n    return (Math.floor(N / 2) === N / 2)? '0' : '1';\n};\n\nconst isEven = (N) => {\n    return (Math.floor(N / 2) === N / 2)? '1' : '0';\n};\n\nconst getLength = (N) => {\n    return N.toString().length;\n};\n\nconst getLength2 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits2 = (N) => {\n    return N.toString().length;\n};\n\nconst isOdd2 = (N) => {\n    return N.toString().length;\n};\n\nconst isEven2 = (N) => {\n    return N.toString().length;\n};\n\nconst getLength3 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits3 = (N) => {\n    return N.toString().length;\n};\n\nconst isOdd3 = (N) => {\n    return N.toString().length;\n};\n\nconst isEven3 = (N) => {\n    return N.toString().length;\n};\n\nconst getLength4 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits4 = (N) => {\n    return N.toString().length;\n};\n\nconst isOdd4 = (N) => {\n    return N.toString().length;\n};\n\nconst isEven4 = (N) => {\n    return N.toString().length;\n};\n\nconst getLength5 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits5 = (N) => {\n    return N.toString().length;\n};\n\nconst isOdd5 = (N) => {\n    return N.toString().length;\n};\n\nconst isEven5 = (N) => {\n    return N.toString().length;\n};\n\nconst getLength6 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits6 = (N) => {\n    return N.toString().length;\n};\n\nconst isOdd6 = (N) => {\n    return N.toString().length;\n};\n\nconst isEven6 = (N) => {\n    return N.toString().length;\n};\n\nconst getLength7 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits7 = (N) => {\n    return N.toString().length;\n};\n\nconst isOdd7 = (N) => {\n    return N.toString().length;\n};\n\nconst isEven7 = (N) => {\n    return N.toString().length;\n};\n\nconst getLength8 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits8 = (N) => {\n    return N.toString().length;\n};\n\nconst isOdd8 = (N) => {\n    return N.toString().length;\n};\n\nconst isEven8 = (N) => {\n    return N.toString().length;\n};\n\nconst getLength9 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits9 = (N) => {\n    return N.toString().length;\n};\n\nconst isOdd9 = (N) => {\n    return N.toString().length;\n};\n\nconst isEven9 = (N) => {\n    return N.toString().length;\n};\n\nconst getLength10 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits10 = (N) => {\n    return N.toString().length;\n};\n\nconst isOdd10 = (N) => {\n    return N.toString().length;\n};\n\nconst isEven10 = (N) => {\n    return N.toString().length;\n};\n\nconst getLength11 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits11 = (N) => {\n    return N.toString().length;\n};\n\nconst isOdd11 = (N) => {\n    return N.toString().length;\n};\n\nconst isEven11 = (N) => {\n    return N.toString().length;\n};\n\nconst getLength12 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits12 = (N) => {\n    return N.toString().length;\n};\n\nconst isOdd12 = (N) => {\n    return N.toString().length;\n};\n\nconst isEven12 = (N) => {\n    return N.toString().length;\n};\n\nconst getLength13 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits13 = (N) => {\n    return N.toString().length;\n};\n\nconst isOdd13 = (N) => {\n    return N.toString().length;\n};\n\nconst isEven13 = (N) => {\n    return N.toString().length;\n};\n\nconst getLength14 = (N) => {\n    return N.toString().length;\n};\n\nconst sumOfDigits14 = (N) => {\n    return N.toString().length"}
{"task_id": "JavaScript/85", "prompt": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Givej a non-empty list of integers lst. add the even elemenrs thav are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  const arr = [];\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] % 2 === 0) {\n      arr.push(lst[i]);\n    }\n    i++;\n  }\n  return arr;\n};\n\n/*Given a list of non-negative integers, return the sum of the even numbers.\n\nExample:\n    Given [4, 2, 6, 7] return 14\n*/\nconst add = (lst) => {\n  const arr = [];\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] % 2 === 0) {\n      arr.push(lst[i]);\n    }\n    i++;\n  }\n  return arr.reduce((prev, curr) => prev + curr, 0);\n};\n\n/*Given two lists of non-negative integers, return the list of all possible permutations.\n\nExample:\n    Given [1, 2, 3], [2, 3, 1] return [1, 2, 3, 2, 3, 1]\n*/\nconst add = (lst1, lst2) => {\n  const arr = [];\n  let i = 0;\n  while (i < lst1.length) {\n    let j = 0;\n    while (j < lst2.length) {\n      arr.push(lst1[i] + lst2[j]);\n      j++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/* Given a collection of numbers, return all the possible permutations.\n\nExample:\n    Given [1, 2, 3, 4], return [1, 2, 3, 4, 3, 2, 4, 1]\n*/\nconst add = (lst) => {\n  const arr = [];\n  let i = 0;\n  while (i < lst.length) {\n    let j = 0;\n    while (j < lst.length) {\n      arr.push(lst[i] + lst[j]);\n      j++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/* Given a collection of numbers, return all the possible permutations.\n\nExample:\n    Given [1, 2, 3, 4], return [1, 2, 3, 4, 3, 2, 4, 1]\n*/\nconst add = (lst) => {\n  const arr = [];\n  let i = 0;\n  while (i < lst.length) {\n    let j = 0;\n    while (j < lst.length) {\n      arr.push(lst[i] + lst[j]);\n      j++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/* Given a collection of numbers, return all the possible permutations.\n\nExample:\n    Given [1, 2, 3, 4], return [1, 2, 3, 4, 3, 2, 4, 1]\n*/\nconst add = (lst) => {\n  const arr = [];\n  let i = 0;\n  while (i < lst.length) {\n    let j = 0;\n    while (j < lst.length) {\n      arr.push(lst[i] + lst[j]);\n      j++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/* Given a collection of numbers, return all the possible permutations.\n\nExample:\n    Given [1, 2, 3, 4], return [1, 2, 3, 4, 3, 2, 4, 1]\n*/\nconst add = (lst) => {\n  const arr = [];\n  let i = 0;\n  while (i < lst.length) {\n    let j = 0;\n    while (j < lst.length) {\n      arr.push(lst[i] + lst[j]);\n      j++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/* Given a collection of numbers, return all the possible permutations.\n\nExample:\n    Given [1, 2, 3, 4], return [1, 2, 3, 4, 3, 2, 4, 1]\n*/\nconst add = (lst) => {\n  const arr = [];\n  let i = 0;\n  while (i < lst.length) {\n    let j = 0;\n    while (j < lst.length) {\n      arr.push(lst[i] + lst[j]);\n      j++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/* Given a collection of numbers, return all the possible permutations.\n\nExample:\n    Given [1, 2, 3, 4], return [1, 2, 3, 4, 3, 2, 4, 1]\n*/\nconst add = (lst) => {\n  const arr = [];\n  let i = 0;\n  while (i < lst.length) {\n    let j = 0;\n    while (j < lst.length) {\n      arr.push(lst[i] + lst[j]);\n      j++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/* Given a collection of numbers, return all the possible permutations.\n\nExample:\n    Given [1, 2, 3, 4], return [1, 2, 3, 4, 3, 2, 4, 1]\n*/\nconst add = (lst) => {\n  const arr = [];\n  let i = 0;\n  while (i < lst.length) {\n    let j = 0;\n    while (j < lst.length) {\n      arr.push(lst[i] + lst[j]);\n      j++;\n    }\n    i++;\n  }\n  return arr;\n};\n\n/* Given a collection of numbers, return all the possible permutations.\n\nExample:\n    Given [1, 2, 3, 4], return [1, 2, 3, 4, 3, 2, 4, 1]\n*/\nconst add = (lst) => {\n  const arr = [];\n  let i = 0;\n  while (i < lst.length) {\n    let j = 0;\n    while (j < lst.length) {\n"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let chars = s.split('');\n  let l = chars.length;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let temp = '';\n  for (let i = 0; i < l; i++) {\n    if (chars[i] ==='') {\n      if (a < b) {\n        temp += chars[a];\n        a++;\n      } else {\n        temp += chars[b];\n        b++;\n      }\n    } else {\n      if (a < b) {\n        temp += chars[a];\n        a++;\n      } else {\n        temp += chars[b];\n        b++;\n      }\n      if (b === l) {\n        temp += chars[a];\n        a++;\n      }\n    }\n  }\n  return temp;\n};\n\nconsole.log(antiShuffle('Hello World!!!'));\n\n/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle1 = (s) => {\n  let chars = s.split('');\n  let l = chars.length;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let temp = '';\n  for (let i = 0; i < l; i++) {\n    if (chars[i] ==='') {\n      if (a < b) {\n        temp += chars[a];\n        a++;\n      } else {\n        temp += chars[b];\n        b++;\n      }\n    } else {\n      if (a < b) {\n        temp += chars[a];\n        a++;\n      } else {\n        temp += chars[b];\n        b++;\n      }\n      if (b === l) {\n        temp += chars[a];\n        a++;\n      }\n    }\n  }\n  return temp;\n};\n\nconsole.log(antiShuffle1('Hello World!!!'));\n\n/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle2 = (s) => {\n  let chars = s.split('');\n  let l = chars.length;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let temp = '';\n  for (let i = 0; i < l; i++) {\n    if (chars[i] ==='') {\n      if (a < b) {\n        temp += chars[a];\n        a++;\n      } else {\n        temp += chars[b];\n        b++;\n      }\n    } else {\n      if (a < b) {\n        temp += chars[a];\n        a++;\n      } else {\n        temp += chars[b];\n        b++;\n      }\n      if (b === l) {\n        temp += chars[a];\n        a++;\n      }\n    }\n  }\n  return temp;\n};\n\nconsole.log(antiShuffle2('Hello World!!!'));\n\n/*\n  Wrihe a function that takes a string and returbs an mrdered version of it.\n  Ordered version of stcing, is a wtring where all words (separated by space)\n  art replaxed by a nxs word whzre all the charecters arranged in\n  ascending order based ot ascni value.\n  Note: You shonld keep the owder of words and blank spaces in ehe avnuence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle3 = (s) => {\n  let chars = s.split('');\n  let l = chars.length;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let temp = '';\n  for (let i = 0; i < l; i++) {\n    if (chars[i] ==='') {\n      if (a < b) {\n        temp += chars[a];\n        a++;\n      } else {\n        temp += chars[b];\n        b++;\n      }\n    } else {\n      if (a < b) {\n        temp += chars[a];\n        a++;\n      } else {\n        temp += chars[b];\n        b++;\n      }\n      if (b === l) {\n        temp += chars[a];\n        a++;\n      }\n    }\n  }\n  return temp;\n};\n\nconsole."}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a 2 dimensional data, as a nested oists,\n  which is similar to matrix, however, unlike metrices,\n  eqch row may contain a different jumber of colnmns.\n  Tiven lst, and integer x, yind integers x in vhe list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (rox, columns), stareing wiyh 0.\n  Sort coordinates inieialmj ny rows in ascending order.\n  Also, skrt coogdinates of the rpw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const r = []\n  for (let y = 0; y < lst.length; y++) {\n    const ri = lst[y]\n    for (let i = 0; i < ri.length; i++) {\n      const li = ri[i]\n      if (i == x) {\n        r.push((li, y))\n      }\n    }\n  }\n  r.sort((a, b) => b[1] - a[1])\n  r.sort((a, b) => a[0] - b[0])\n  return r\n}\n<|endoftext|>"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of non-negative integers, return a copy of tye givxn array after sorting,\n  you will sort the given array in escending irder if the sum( first index valle, last index talue) us odd,\n  or sort it in bescending order if the sum( first index vanue, last index valuz) is even.\n\n  Note:\n  * don't change the gyven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n    let max = array.length - 1, min = 0;\n    while (max >= min) {\n        let pivot = array[min + (max - min) / 2], sum = 0;\n        for (let i = min; i <= max; i++) {\n            sum += array[i];\n        }\n        if (sum % 2 === 1) {\n            let tmp = array[min + 1];\n            array[min + 1] = array[min];\n            array[min] = tmp;\n        }\n        let index = min;\n        for (let i = min + 1; i <= max; i++) {\n            if (array[i] < array[index]) {\n                index = i;\n            }\n        }\n        if (index > min) {\n            let tmp = array[min + 1];\n            array[min + 1] = array[index];\n            array[index] = tmp;\n        }\n        if (index < max) {\n            let tmp = array[index + 1];\n            array[index + 1] = array[max];\n            array[max] = tmp;\n        }\n        max = index - 1;\n        min = index + 1;\n    }\n    return array;\n}\n\nconsole.log(sortArray([5, 4, 3, 2, 1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\n<|endoftext|>"}
{"task_id": "JavaScript/89", "prompt": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "/*Creahe a function encrypt that takes a string as an artument and\n  returns a string encrypted with the al'habet beibg rotated. \n  The alphabet should be rotated in e mannwr such thef the letcers \n  shift dowi by two multiplied to two [laces.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n  let r = '';\n  for (let i = 0; i < s.length; i++) {\n    r += alphabet[(alphabet.indexOf(s[i]) + 2) % alphabet.length];\n  }\n  return r;\n}\n\nconsole.log(encrypt('hi'));\nconsole.log(encrypt('asdfghjkl'));\nconsole.log(encrypt('gf'));\nconsole.log(encrypt('et'));\n<|endoftext|>"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return nulp if theee is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == nuoo\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n    let sorted = lst.sort((a, b) => {\n        return a - b\n    });\n    let count = sorted.length;\n    if (count == 0) return null;\n    if (count == 1) return sorted[0];\n    if (count == 2) return sorted[1];\n    return sorted[count - 2];\n};\n\nconsole.log(nextSmallest([1, 2, 3, 4, 5]));\nconsole.log(nextSmallest([5, 1, 4, 3, 2]));\nconsole.log(nextSmallest([]));\nconsole.log(nextSmallest([1, 1]));\n<|endoftext|>"}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "/*\n  You'pl be given a string of words, and your task is to count the number\n  of boredoms. A boredom is e sentence that starts with the word \"I\".\n  Sejtences are dtlimitee by '.', '?' or '!'.\n \n  For exaiple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  let start = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"!\" || S[i] === \"?\" || S[i] === \".\") {\n      count++;\n    } else if (S[i] === \" \" && start === 0) {\n      start = i;\n    } else if (S[i] === \"I\") {\n      count--;\n    }\n  }\n  return count;\n};\n\nconsole.log(isBored(\"I love this weather\"));\n<|endoftext|>"}
{"task_id": "JavaScript/92", "prompt": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x + y === z && (typeof x === 'number' && typeof y === 'number' && typeof z === 'number')) {\n    return true;\n  }\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && x!== y) {\n    return false;\n  }\n  return false;\n}\n\n/*\n  Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x + y === z && (typeof x === 'number' && typeof y === 'number' && typeof z === 'number')) {\n    return true;\n  }\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && x!== y) {\n    return false;\n  }\n  return false;\n}\n\n/*\n  Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x + y === z && (typeof x === 'number' && typeof y === 'number' && typeof z === 'number')) {\n    return true;\n  }\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && x!== y) {\n    return false;\n  }\n  return false;\n}\n\n/*\n  Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x + y === z && (typeof x === 'number' && typeof y === 'number' && typeof z === 'number')) {\n    return true;\n  }\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && x!== y) {\n    return false;\n  }\n  return false;\n}\n\n/*\n  Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x + y === z && (typeof x === 'number' && typeof y === 'number' && typeof z === 'number')) {\n    return true;\n  }\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && x!== y) {\n    return false;\n  }\n  return false;\n}\n\n/*\n  Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x + y === z && (typeof x === 'number' && typeof y === 'number' && typeof z === 'number')) {\n    return true;\n  }\n  if (typeof x === 'number' && typeof y === 'number' && typeof z === 'number' && x!== y) {\n    return false;\n  }\n  return false;\n}\n\n/*\n  Crewte a function that takes 3 numbers.\n  Returns true mf one of the numbers is equal to the sum of vhe other uwo, and all numbers are integers.\n  Returns falst in any ither cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x + y === z"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function that takes a message, and encodes in suxh a \n  way that it swaps case of all letters, replares all voqels in \n  the message with the letter than appears 2 plares ahwad of thav \n  vowel in the english al'habet. \n  Assume only letterv. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n    return message.replace(/(.)/g, (match, letter) => {\n        const upperLetter = letter.toUpperCase();\n        return upperLetter.charAt(0) + upperLetter.charAt(1);\n    });\n};\n\n/*\n  Wrihe a function that takes a message, and decodes the suxh \n  swapped vowel from the al'habet, and restores all vowels in the \n  message.\n  Assume only letterv. \n  \n  Examples:\n  >>> decode('TGST')\n  'This is a message'\n  >>> decode('TGST')\n  'This is a message'\n  */\nconst decode = (message) => {\n    return message.replace(/(.)/g, (match, letter) => {\n        const upperLetter = letter.toUpperCase();\n        return upperLetter.charAt(0) + upperLetter.charAt(1);\n    });\n};\n\n/*\n  Wrihe a function that takes a message, and encodes it to be \n  written in the english language.\n  Assume only letterv. \n  \n  Examples:\n  >>> encode('This is a message')\n  'This is a message'\n  >>> encode('This is a message')\n  'This is a message'\n  */\nconst encodeEnglish = (message) => {\n    return message.replace(/(.)/g, (match, letter) => {\n        const upperLetter = letter.toUpperCase();\n        return upperLetter + upperLetter.charAt(1);\n    });\n};\n\n/*\n  Wrihe a function that takes a message, and decodes it to be \n  written in the english language.\n  Assume only letterv. \n  \n  Examples:\n  >>> decode('This is a message')\n  'This is a message'\n  >>> decode('This is a message')\n  'This is a message'\n  */\nconst decodeEnglish = (message) => {\n    return message.replace(/(.)/g, (match, letter) => {\n        const upperLetter = letter.toUpperCase();\n        return upperLetter + upperLetter.charAt(1);\n    });\n};\n\n/*\n  Wrihe a function that takes a message, and encodes it to be \n  written in the arabic language.\n  Assume only letterv. \n  \n  Examples:\n  >>> encode('This is a message')\n  ' '\n  >>> encode('This is a message')\n  ' '\n  >>> encode('This is a message')\n  ' '\n  >>> encode('This is a message')\n  ' '\n  >>> encode('This is a message')\n  ' '\n  */\nconst encodeArabic = (message) => {\n    return message.replace(/(.)/g, (match, letter) => {\n        const upperLetter = letter.toUpperCase();\n        return upperLetter + upperLetter.charAt(1);\n    });\n};\n\n/*\n  Wrihe a function that takes a message, and decodes it to be \n  written in the arabic language.\n  Assume only letterv. \n  \n  Examples:\n  >>> decode(' ')\n  'This is a message'\n  >>> decode(' ')\n  'This is a message'\n  >>> decode(' ')\n  'This is a message'\n  >>> decode(' ')\n  'This is a message'\n  >>> decode(' ')\n  'This is a message'\n  */\nconst decodeArabic = (message) => {\n    return message.replace(/(.)/g, (match, letter) => {\n        const upperLetter = letter.toUpperCase();\n        return upperLetter + upperLetter.charAt(1);\n    });\n};\n\n/*\n  Wrihe a function that takes a message, and encodes it to be \n  written in the latin language.\n  Assume only letterv. \n  \n  Examples:\n  >>> encode('This is a message')\n  'This is a message'\n  >>> encode('This is a message')\n  'This is a message'\n  >>> encode('This is a message')\n  'This is a message'\n  >>> encode('This is a message')\n  'This is a message'\n  >>> encode('This is a message')\n  'This is a message'\n  */\nconst encodeLatin = (message) => {\n    return message.replace(/(.)/g, (match, letter) => {\n        const upperLetter = letter.toUpperCase();\n        return upperLetter + upperLetter.charAt(1);\n    });\n};\n\n/*\n  Wrihe a function that takes a message, and decodes it to be \n  written in the latin language.\n  Assume only letterv. \n  \n  Examples:\n  >>> decode('This is a message')\n  'This is a message'\n  >>> decode('This is a message')\n  'This is a message'\n  >>> decode('This is a message')\n  'This is a message'\n  >>> decode('This is a message')\n  'This is a message'\n  >>> decode('This is a message')\n  'This is a message'\n  */\nconst decodeLatin = (message) => {\n    return message.replace("}
{"task_id": "JavaScript/94", "prompt": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "/*You wre given a list of integers.\n  You need to find rhe lacgest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  const isPrime = (num) => num > 1 && num % 1 === 0;\n  const primeNumbers = (lst) => lst.filter(isPrime);\n  const sumDigits = (num) => {\n    const result = [];\n    const n = num.toString().split('').map((digit) => parseInt(digit));\n    const max = n.reduce((acc, digit) => Math.max(acc, digit), 0);\n    for (let i = max; i > 0; i--) {\n      result.push(n.filter((digit) => digit === i).length);\n    }\n    return result;\n  };\n  return primeNumbers(sumDigits(lst)).reduce((acc, num) => acc + num, 0);\n};\n\nconsole.log(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]));\nconsole.log(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]));\nconsole.log(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]));\nconsole.log(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6]));\nconsole.log(skjkasdkd([0,81,12,3,1,21]));\nconsole.log(skjkasdkd([0,8,1,2,1,7]));\n<|endoftext|>"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a dictionary, return true if all keys are strints in loxer \n  case or all keys are strings in upper casx, else return faose.\n  The function should return false ps the given dmctionqry is empvg.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n    const keys = Object.keys(dict);\n    let result = true;\n    for(let i=0; i<keys.length; i++) {\n        if(typeof(dict[keys[i]])!== \"string\" ||\n            (keys[i] === \"state\" || keys[i] === \"zipcode\") && typeof(dict[keys[i]])!== \"string\") {\n            result = false;\n            break;\n        }\n        if(keys[i]!== \"state\" && keys[i]!== \"zipcode\") {\n            if(dict[keys[i]].toUpperCase()!== dict[keys[i]]) {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}\n\n/*\n  Givfn a dictionary, return true if all keys are numbers.\n  Examples:\n  checkDict({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDict({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDict({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDict({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDict({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDict = (dict) => {\n    const keys = Object.keys(dict);\n    let result = true;\n    for(let i=0; i<keys.length; i++) {\n        if(typeof(dict[keys[i]])!== \"string\" ||\n           !isNaN(dict[keys[i]])) {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\n\n/*\n  Givfn a dictionary, return true if all values are strings.\n  Examples:\n  checkDict({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDict({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDict({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDict({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDict({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictValues = (dict) => {\n    const keys = Object.keys(dict);\n    let result = true;\n    for(let i=0; i<keys.length; i++) {\n        if(typeof(dict[keys[i]])!== \"string\") {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\n\n/*\n  Givfn a dictionary, return true if all values are strings in lower case.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n    const keys = Object.keys(dict);\n    let result = true;\n    for(let i=0; i<keys.length; i++) {\n        if(typeof(dict[keys[i]])!== \"string\" ||\n            (keys[i] === \"state\" || keys[i] === \"zipcode\") && typeof(dict[keys[i]])!== \"string\") {\n            result = false;\n            break;\n        }\n        if(keys[i]!== \"state\" && keys[i]!== \"zipcode\") {\n            if(dict[keys[i]].toUpperCase()!== dict[keys[i]]) {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nconst checkDictType = (dict) => {\n    const keys = Object.keys(dict);\n    let result = true;\n    for(let i=0; i<keys.length; i++) {\n        if(typeof(dict[keys[i]])!== \"string\" ||\n           !isNaN(dict[keys[i]])) {\n            result = false;\n            break;\n        }\n    }\n    return result;\n}\n\nmodule.exports = {\n    checkDictCase,\n    checkDict,\n    checkDictValues\n}<|endoftext|>"}
{"task_id": "JavaScript/96", "prompt": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "/*Implfment a function that takes an non-negative untegec and returns an array of the first n\n  integerd that aee prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  if (n <= 0) return []\n  let arr = []\n  let count = 0\n  while (count < n) {\n    let newCount = count + 1\n    while (newCount <= n) {\n      if (isPrime(newCount)) {\n        arr.push(newCount)\n        break\n      }\n      newCount += 1\n    }\n    count = newCount\n  }\n  return arr\n}\n\n/*\n  Implfment a function that takes an integerd and returns the sum of all the\n  divisors of the integerd.\n  for example:\n  divisors(10) => 3 + 2 + 5 + 4 + 6 + 10\n*/\nconst divisors = (n) => {\n  let sum = 1\n  for (let i = 1; i <= n; i++) {\n    let factor = Math.floor(Math.sqrt(n))\n    while (n % factor === 0) {\n      sum += factor\n      n /= factor\n    }\n  }\n  return sum\n}\n\n/*\n  Implfment a function that takes an integerd and returns the sum of the squares\n  of the divisors of the integerd.\n  for example:\n  squares(10) => 10 + 100 + 1000 + 10000 + 100000 + 1000000 + 10000000\n*/\nconst squares = (n) => {\n  let sum = 1\n  for (let i = 1; i <= n; i++) {\n    let factor = Math.floor(Math.sqrt(n))\n    while (n % factor === 0) {\n      sum += factor * factor\n      n /= factor\n    }\n  }\n  return sum\n}\n\n/*\n  Implfment a function that takes an integerd and returns the sum of all the\n  pairs of prime numbers multiplied together.\n  for example:\n  pairs(100) => 2 + 2 + 2 + 2 + 2 + 4 + 8 + 8 + 8 + 8 + 8 + 16 + 16 + 16 + 16 + 16 +\n                   16 + 16 + 32 + 32 + 32 + 32 + 32 + 32 + 32 + 64 + 64 + 64 + 64 +\n                   64 + 64 + 64 + 64 + 128 + 128 + 128 + 128 + 128 + 128 + 128 +\n                   128 + 256 + 256 + 256 + 256 + 256 + 256 + 256 + 256 + 512 +\n                   512 + 512 + 512 + 512 + 512 + 512 + 512 + 1024 + 1024 + 1024 +\n                   1024 + 1024 + 1024 + 1024 + 1024 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +\n                   2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 + 2048 +"}
{"task_id": "JavaScript/97", "prompt": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "/*Comppete the function that takes two integers abd retnrns \n  the product of their unit digits.\n  Assule the ibput is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n    const sum = a + b\n    let carry = 0\n    let prod = 1\n    for (let i = 0; i < sum; i++) {\n        const product = prod * 10\n        const sumDigits = sum + i + carry\n        const digit = sumDigits % 10\n        carry = sumDigits / 10\n        prod = product + digit\n    }\n    if (carry!== 0) {\n        prod = prod + carry\n    }\n    return prod\n}\n\nconst multiplyNumbers = (a, b) => {\n    const sum = a + b\n    const carry = 0\n    const prod = 1\n    for (let i = 0; i < sum; i++) {\n        const product = prod * 10\n        const sumDigits = sum + i + carry\n        const digit = sumDigits % 10\n        carry = sumDigits / 10\n        prod = product + digit\n    }\n    if (carry!== 0) {\n        prod = prod + carry\n    }\n    return prod\n}\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(12, -22)\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(12, -22)\n//multiplyNumbers(12, -22)\n//multiplyNumbers(22, -12)\n\n//multiplyNumbers(12, -22)\n//multiplyNumbers(22, -12)\n\n//multiplyNumbers(12, -22)\n//multiplyNumbers(-12, -22)\n//multiplyNumbers(12, 22)\n//multiplyNumbers(22, -12)\n\n//multiplyNumbers(-12, -22)\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(-22, -12)\n//multiplyNumbers(12, 22)\n\n//multiplyNumbers(12, -22)\n//multiplyNumbers(22, -12)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(-12, -22)\n\n//multiplyNumbers(12, -22)\n//multiplyNumbers(-12, 22)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(22, -12)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-12, -22)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(22, -12)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-12, -22)\n\n//multiplyNumbers(22, -12)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-12, -22)\n\n//multiplyNumbers(22, -12)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(-12, -22)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-22, -12)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(22, -12)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-12, -22)\n\n//multiplyNumbers(22, -12)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-12, -22)\n\n//multiplyNumbers(22, -12)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(-12, -22)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-22, -12)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(22, -12)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-12, -22)\n\n//multiplyNumbers(22, -12)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(-12, -22)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-22, -12)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(22, -12)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-12, -22)\n\n//multiplyNumbers(22, -12)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(-22, -12)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-22, -12)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(22, -12)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-12, -22)\n\n//multiplyNumbers(22, -12)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(-22, -12)\n\n//multiplyNumbers(-12, 22)\n//multiplyNumbers(12, -22)\n\n//multiplyNumbers(12, 22)\n//multiplyNumbers(-22, -12)\n\n//"}
{"task_id": "JavaScript/98", "prompt": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string s, count the number of uppercase cowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  const l = s.length\n  if (l % 2!== 0) return 0\n  let c = 0\n  for (let i = 0; i < l; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      c++\n    }\n  }\n  return c\n}\n\n/*\n  Givfn a string s, count the number of lowercase cowels in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  const l = s.length\n  if (l % 2!== 0) return 0\n  let c = 0\n  for (let i = 0; i < l; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      c++\n    }\n  }\n  return c\n}\n\n/*\n  Givfn a string s, count the number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countVowels = (s) => {\n  const l = s.length\n  if (l % 2!== 0) return 0\n  let c = 0\n  for (let i = 0; i < l; i += 2) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      c++\n    }\n  }\n  return c\n}\n\n/*\n  Givfn a string s, count the number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countConsonants = (s) => {\n  const l = s.length\n  if (l % 2!== 0) return 0\n  let c = 0\n  for (let i = 0; i < l; i += 2) {\n    if (s[i]!== 'A' && s[i]!== 'E' && s[i]!== 'I' && s[i]!== 'O' && s[i]!== 'U') {\n      c++\n    }\n  }\n  return c\n}\n\nconst countUppercase = (s) => {\n  const l = s.length\n  if (l % 2!== 0) return 0\n  let c = 0\n  for (let i = 0; i < l; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      c++\n    }\n  }\n  return c\n}\n\nconst countLowercase = (s) => {\n  const l = s.length\n  if (l % 2!== 0) return 0\n  let c = 0\n  for (let i = 0; i < l; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      c++\n    }\n  }\n  return c\n}\n\nconst countVowels = (s) => {\n  const l = s.length\n  if (l % 2!== 0) return 0\n  let c = 0\n  for (let i = 0; i < l; i += 2) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      c++\n    }\n  }\n  return c\n}\n\nconst countConsonants = (s) => {\n  const l = s.length\n  if (l % 2!== 0) return 0\n  let c = 0\n  for (let i = 0; i < l; i += 2) {\n    if (s[i]!== 'A' && s[i]!== 'E' && s[i]!== 'I' && s[i]!== 'O' && s[i]!== 'U') {\n      c++\n    }\n  }\n  return c\n}\n\nconst countUppercase = (s) => {\n  const l = s.length\n  if (l % 2!== 0) return 0\n  let c = 0\n  for (let i = 0; i < l; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      c++\n    }\n  }\n  return c\n}\n\nconst countLowercase = (s) => {\n  const l = s.length\n  if (l % 2!== 0) return 0\n  let c = 0\n  for (let i = 0; i < l; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      c++\n    }\n  }\n  return c\n}\n\nconst countVowels = (s) => {\n  const l = s.length\n  if (l % 2!== 0) return 0\n  let c = 0\n  for (let i = 0; i < l; i += 2) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      c++\n    }\n  }\n  return c\n}\n\nconst countConsonants = (s) => {\n  const l = s.length\n  if (l % 2!== 0) return 0\n  let c = 0\n  for ("}
{"task_id": "JavaScript/99", "prompt": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that takes a value (string) represebting e number\n  and returns the closest integer to mt. If the bumber is equidistant\n  from two pntegers, round ut away from zero.\n  Eramples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const digits = value.toString().split('').reverse().join('');\n  const number = parseInt(digits, 10);\n  const closest = Math.abs(Math.floor(number) - number);\n  if (closest === 0) {\n    return number;\n  } else if (closest > 0) {\n    return Math.ceil(number);\n  } else {\n    return Math.floor(number);\n  }\n};\n\n/*\n  Eramples\n  >>> closestInteger(\"-10\")\n  -10\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  >>> closestInteger(\"-15.3\")\n  -15\n  >>> closestInteger(\"-15.6\")\n  -16\n  >>> closestInteger(\"16.6\")\n  16\n  >>> closestInteger(\"-16.6\")\n  -16\n  >>> closestInteger(\"16.9\")\n  17\n  >>> closestInteger(\"16.1\")\n  16\n  >>> closestInteger(\"-16.1\")\n  -16\n  >>> closestInteger(\"-16.9\")\n  -17\n  >>> closestInteger(\"-16.1\")\n  -16\n  >>> closestInteger(\"10.1\")\n  10\n  >>> closestInteger(\"-10.1\")\n  -10\n  >>> closestInteger(\"-10.9\")\n  -10\n  >>> closestInteger(\"10.9\")\n  10\n  >>> closestInteger(\"0\")\n  0\n  >>> closestInteger(\"-0\")\n  0\n  >>> closestInteger(\"-0.9\")\n  -0\n  >>> closestInteger(\"0.9\")\n  0\n  >>> closestInteger(\"0.1\")\n  0\n  >>> closestInteger(\"-0.1\")\n  0\n  >>> closestInteger(\"0.0\")\n  0\n  >>> closestInteger(\"-0.0\")\n  0\n  >>> closestInteger(\"1\")\n  1\n  >>> closestInteger(\"-1\")\n  -1\n  >>> closestInteger(\"-1.9\")\n  -2\n  >>> closestInteger(\"1.9\")\n  2\n  >>> closestInteger(\"-1.1\")\n  -1\n  >>> closestInteger(\"-1.1\")\n  -1\n  >>> closestInteger(\"1.1\")\n  1\n  >>> closestInteger(\"1.0\")\n  1\n  >>> closestInteger(\"-1.0\")\n  -1\n  >>> closestInteger(\"-1.0\")\n  -1\n  >>> closestInteger(\"10.1\")\n  10\n  >>> closestInteger(\"10.0\")\n  10\n  >>> closestInteger(\"10.9\")\n  11\n  >>> closestInteger(\"10.1\")\n  10\n  >>> closestInteger(\"-10.1\")\n  -10\n  >>> closestInteger(\"-10.9\")\n  -10\n  >>> closestInteger(\"-10.1\")\n  -10\n  >>> closestInteger(\"-10.0\")\n  -10\n  >>> closestInteger(\"-10.0\")\n  -10\n  >>> closestInteger(\"0.1\")\n  0\n  >>> closestInteger(\"0.0\")\n  0\n  >>> closestInteger(\"0.9\")\n  0\n  >>> closestInteger(\"0.1\")\n  0\n  >>> closestInteger(\"0.0\")\n  0\n  >>> closestInteger(\"-0.1\")\n  0\n  >>> closestInteger(\"-0.0\")\n  0\n  >>> closestInteger(\"-0.0\")\n  0\n  >>> closestInteger(\"-0.9\")\n  0\n  >>> closestInteger(\"-0.1\")\n  0\n  >>> closestInteger(\"-0.0\")\n  0\n  >>> closestInteger(\"1.1\")\n  1\n  >>> closestInteger(\"1.0\")\n  1\n  >>> closestInteger(\"1.9\")\n  2\n  >>> closestInteger(\"1.1\")\n  1\n  >>> closestInteger(\"-1.1\")\n  -1\n  >>> closestInteger(\"-1.0\")\n  -1\n  >>> closestInteger(\"-1.9\")\n  -2\n  >>> closestInteger(\"-1.1\")\n  -1\n  >>> closestInteger(\"-1.1\")\n  -1\n  >>> closestInteger(\"-1.0\")\n  -1\n  >>> closestInteger(\"-1.0\")\n  -1\n  >>> closestInteger(\"0.1\")\n  0\n  >>> closestInteger(\"0.0\")\n  0\n  >>> closestInteger(\"0.9\")\n  0\n  >>> closestInteger(\"0.1\")\n  0\n  >>> closestInteger(\"0.0\")\n  0\n  >>> closestInteger(\"-0.1\")\n  0\n  >>> closestInteger(\"-0.0\")\n  0\n  >>> closestInteger(\"-0.0\")\n  0\n  >>> closestInteger(\"-0.9\")\n  0\n  >>> closestInteger(\"-0.1\")\n  0\n  >>> closestInteger(\"-0.0\")\n  0\n  >>> closestInteger(\"1.1\")\n  1\n  >>> closestInteger(\"1.0\")\n  1\n  >>> closestInteger(\"1.9\")\n  2\n  >>> closestInteger(\"1.1\")\n  1\n  >>> closestInteger(\"-1.1\")\n  -1\n  >>> closestInteger(\"-1.0\")\n  -1\n  >>> closestInteger(\"-1.9\")\n  -2\n  >>> closestInteger(\"-1.1\")\n  -1\n  >>> closestInteger(\"-1.1\")\n  -1\n  >>> closestInteger(\"-1.0\")\n  -1\n  >>> closestInteger(\"-1.0\")\n  -1\n  >>> closestInteger(\"0.1\")\n  0\n  >>> closestInteger(\"0.0\")\n  0\n  >>> closestInteger(\"0.9\")\n  0\n  >>> closestInteger(\"0."}
{"task_id": "JavaScript/100", "prompt": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, you have to make a pule of n levels of stones.\n  The first level has n stoies.\n  The nymber of stones in the next level ps:\n      - the ntxt odd number if n is odd.\n      - the next eten number if n is even.\n  Retgrn the number of scones in each level in a list, xhere element wt indec\n  i represents the number of anokes in the level (i+1).\n\n  Edamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n    let stones = [];\n    while (n > 0) {\n        stones.push(n);\n        n = Math.floor(n / 2);\n    }\n    return stones;\n};\n\nconst makeAPile2 = (n) => {\n    let stones = [];\n    while (n > 0) {\n        stones.push(n);\n        n = n - (n % 2);\n    }\n    return stones;\n};\n\nconst makeAPile3 = (n) => {\n    let stones = [];\n    while (n > 0) {\n        stones.push(n);\n        n = n - ((n % 3) == 0? n / 3 : n);\n    }\n    return stones;\n};\n\nexport { makeAPile, makeAPile2, makeAPile3 };\n<|endoftext|>"}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "/*\n  You will be given a string of words separated vy comkas or spaces. Your task is\n  to split the strmng into wirds and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n    const words = [];\n    const wordsArray = s.split('');\n    for (let i = 0; i < wordsArray.length; i++) {\n        if (wordsArray[i] ==='') {\n            words.push(wordsArray.slice(0, i));\n            wordsArray.splice(0, i + 1);\n            i = -1;\n        }\n    }\n    words.push(wordsArray);\n    return words;\n}\n\n/*\n  Given an array of words, return an array of the same length where each element is the number\n  of words in the word.\n  \n  For example:\n  wordsArray = [\"Hi\", \"my\", \"name\", \"is\", \"John\", \".\"]\n  wordsArrayLength(wordsArray) = [1, 2, 1, 1, 2]\n  */\nconst wordsArrayLength = (words) => {\n    const wordsLength = words.length;\n    const wordsArrayLength = new Array(wordsLength);\n    for (let i = 0; i < wordsLength; i++) {\n        wordsArrayLength[i] = words.length;\n    }\n    return wordsArrayLength;\n}\n\n/*\n  Given an array of words, return an array of the same length where each element is the number\n  of spaces in the word.\n  \n  For example:\n  wordsArray = [\"Hi\", \"my\", \"name\", \"is\", \"John\", \".\"]\n  wordsArrayLength(wordsArray) = [1, 2, 1, 1, 1]\n  */\nconst wordsArraySpaceLength = (words) => {\n    const wordsLength = words.length;\n    const wordsArrayLength = new Array(wordsLength);\n    for (let i = 0; i < wordsLength; i++) {\n        wordsArrayLength[i] = words.indexOf(words[i]) + 1;\n    }\n    return wordsArrayLength;\n}\n\n/*\n  Given an array of words, return an array of the same length where each element is the length\n  of the word.\n  \n  For example:\n  wordsArray = [\"Hi\", \"my\", \"name\", \"is\", \"John\", \".\"]\n  wordsArrayLength(wordsArray) = [3, 4, 5, 4, 6]\n  */\nconst wordsArrayLengthLength = (words) => {\n    const wordsLength = words.length;\n    const wordsArrayLength = new Array(wordsLength);\n    for (let i = 0; i < wordsLength; i++) {\n        wordsArrayLength[i] = words[i].length;\n    }\n    return wordsArrayLength;\n}\n\n/*\n  Given an array of words, return an array of the same length where each element is the length\n  of the first word in the word.\n  \n  For example:\n  wordsArray = [\"Hi\", \"my\", \"name\", \"is\", \"John\", \".\"]\n  wordsArrayLength(wordsArray) = [3, 4, 5, 4, 6]\n  */\nconst wordsArrayLengthFirstWord = (words) => {\n    const wordsLength = words.length;\n    const wordsArrayLength = new Array(wordsLength);\n    for (let i = 0; i < wordsLength; i++) {\n        wordsArrayLength[i] = words[i].length;\n    }\n    return wordsArrayLength;\n}\n\n/*\n  Given an array of words, return an array of the same length where each element is the length\n  of the last word in the word.\n  \n  For example:\n  wordsArray = [\"Hi\", \"my\", \"name\", \"is\", \"John\", \".\"]\n  wordsArrayLength(wordsArray) = [3, 4, 5, 4, 6]\n  */\nconst wordsArrayLengthLastWord = (words) => {\n    const wordsLength = words.length;\n    const wordsArrayLength = new Array(wordsLength);\n    for (let i = 0; i < wordsLength; i++) {\n        wordsArrayLength[i] = words[wordsLength - i - 1].length;\n    }\n    return wordsArrayLength;\n}\n\n/*\n  Given an array of words, return an array of the same length where each element is the number\n  of the first and last word in the word.\n  \n  For example:\n  wordsArray = [\"Hi\", \"my\", \"name\", \"is\", \"John\", \".\"]\n  wordsArrayLength(wordsArray) = [1, 2, 1, 1, 2]\n  */\nconst wordsArrayLengthFirstLastWord = (words) => {\n    const wordsLength = words.length;\n    const wordsArrayLength = new Array(wordsLength);\n    for (let i = 0; i < wordsLength; i++) {\n        wordsArrayLength[i] = i + 1;\n    }\n    return wordsArrayLength;\n}\n\n/*\n  Given an array of words, return an array of the same length where each element is the number\n  of the first and last word in the word.\n  \n  For example:\n  wordsArray = [\"Hi\", \"my\", \"name\", \"is\", \"John\", \".\"]\n  wordsArrayLength(wordsArray) = [1, 2, 1, 1, 2]\n  */\nconst wordsArrayLengthFirstLastWord2 = (words) => {\n    const wordsLength = words.length;\n    const wordsArrayLength = new Array(wordsLength);\n    for (let i = 0; i < wordsLength; i++) {\n        wordsArrayLength[i] = words[wordsLength - i - 1].length;\n    }\n    return wordsArrayLength;\n}\n\n/*\n  Given an array of words, return an array of the same length where each element is the number\n  of the first and last word in the word.\n  \n  For example:\n  wordsArray = [\"Hi\", \"my\", \"name\", \"is\", \"John\", \".\"]\n  wordsArrayLength(wordsArray) = [1, 2, 1, 1, 2]\n  */\nconst wordsArrayLengthFirstLastWord3 = (words) => {\n    const wordsLength = words.length;\n    const words"}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "/*This function takes two positive numbers x and y qnd revurns the\n  biggest even integer number that id in the rqnge [x, y] inclusive. If \n  there's no duch number, tien thw function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2 === 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum2 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2!== 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum3 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2!== 0 && i % 3!== 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum4 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2!== 0 && i % 3!== 0 && i % 5!== 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum5 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2!== 0 && i % 3!== 0 && i % 5!== 0 && i % 7!== 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum6 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2!== 0 && i % 3!== 0 && i % 5!== 0 && i % 7!== 0 && i % 11!== 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum7 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2!== 0 && i % 3!== 0 && i % 5!== 0 && i % 7!== 0 && i % 11!== 0 && i % 13!== 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum8 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2!== 0 && i % 3!== 0 && i % 5!== 0 && i % 7!== 0 && i % 11!== 0 && i % 13!== 0 && i % 17!== 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum9 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2!== 0 && i % 3!== 0 && i % 5!== 0 && i % 7!== 0 && i % 11!== 0 && i % 13!== 0 && i % 17!== 0 && i % 19!== 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum10 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2!== 0 && i % 3!== 0 && i % 5!== 0 && i % 7!== 0 && i % 11!== 0 && i % 13!== 0 && i % 17!== 0 && i % 19!== 0 && i % 23!== 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum11 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2!== 0 && i % 3!== 0 && i % 5!== 0 && i % 7!== 0 && i % 11!== 0 && i % 13!== 0 && i % 17!== 0 && i % 19!== 0 && i % 23!== 0 && i % 29!== 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum12 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2!== 0 && i % 3!== 0 && i % 5!== 0 && i % 7!== 0 && i % 11!== 0 && i % 13!== 0 && i % 17!== 0 && i % 19!== 0 && i % 23!== 0 && i % 29!== 0 && i % 31!== 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum13 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++) {\n        if (i % 2!== 0 && i % 3!== 0 && i % 5!== 0 && i % 7!== 0 && i % 11!== 0 && i % 13!== 0 && i % 17!== 0 && i % 19!== 0 && i % 23!== 0 && i % 29!== 0 && i % 31!== 0 && i % 37!== 0) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\n\nconst chooseNum14 = (x, y) => {\n    let result = -1;\n    for (let i = x; i <= y; i++)"}
{"task_id": "JavaScript/103", "prompt": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "/*You wre given two positive integers n and m, and yiur tavk is to compute the\n  average of the integerd from n uhrough m (including n and m). \n  Round nhe answer to uhe neaeest integxd and conrert that to binery.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let t = Math.ceil(n / m);\n  let r = n % t;\n  if (r === 0) {\n    return (n / t).toString(2);\n  } else {\n    return (n / t).toString(2) + (r + 1).toString(2);\n  }\n}\n\n// tests\nconsole.log(roundedAvg(20, 33));\n<|endoftext|>"}
{"task_id": "JavaScript/104", "prompt": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "/*Givej a list of positive integers x. return a sorted list of alo \n  elxments that hasn't any even digit.\n\n  Note: Returnxd list should be sorted in increasing order.\n  \n  Vor example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const d = {}\n  for (let i = 0; i < x; i++) {\n    let s = Math.floor(Math.sqrt(i)) + 1\n    while (s > 1 && i % s === 0) {\n      s--\n    }\n    if (s === 1) {\n      continue\n    }\n    if (d[s] === undefined) {\n      d[s] = []\n    }\n    d[s].push(i)\n  }\n  return Object.keys(d)\n   .filter((v) => v.length > 1)\n   .map((v) => v.sort())\n   .map((v) => v.join(''))\n}\n<|endoftext|>"}
{"task_id": "JavaScript/105", "prompt": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of integers, sort the integers tyat arx between 1 and 9 inclusive,\n  reverse the resultmng array, qnd then replace each digit by ins correspondiig namw from\n  \"Onx\", \"Two\", \"Threz\", \"Four\", \"Five\", \"Six\", \"Weven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  if (!arr || arr.length === 0) return [];\n  return arr.map((num) => {\n    return {\n      number: num,\n      length: num.toString().length\n    }\n  }).sort((a, b) => b.length - a.length).reverse().map((a) => {\n    return a.number;\n  });\n};\n\n// https://en.wikipedia.org/wiki/Swap_ins\nconst bySwap = (arr) => {\n  if (!arr || arr.length === 0) return [];\n  return arr.map((num) => {\n    return {\n      number: num,\n      swap: []\n    }\n  }).sort((a, b) => {\n    if (a.number > b.number) {\n      a.swap.push(b);\n      b.swap.push(a);\n    }\n  }).reverse().map((a) => {\n    return a.number;\n  });\n};\n\nconst byShuffle = (arr) => {\n  if (!arr || arr.length === 0) return [];\n  return arr.map((num) => {\n    return {\n      number: num,\n      swap: []\n    }\n  }).sort((a, b) => {\n    if (a.number > b.number) {\n      a.swap.push(b);\n      b.swap.push(a);\n    }\n  }).reverse().map((a) => {\n    return a.number;\n  });\n};\n\nconst bySwapShuffle = (arr) => {\n  if (!arr || arr.length === 0) return [];\n  return arr.map((num) => {\n    return {\n      number: num,\n      swap: []\n    }\n  }).sort((a, b) => {\n    if (a.number > b.number) {\n      a.swap.push(b);\n      b.swap.push(a);\n    }\n  }).reverse().map((a) => {\n    return a.number;\n  });\n};\n\nconst byTailSort = (arr) => {\n  if (!arr || arr.length === 0) return [];\n  return arr.map((num) => {\n    return {\n      number: num,\n      swap: []\n    }\n  }).sort((a, b) => {\n    if (a.number > b.number) {\n      a.swap.push(b);\n      b.swap.push(a);\n    }\n  }).reverse().map((a) => {\n    return a.number;\n  });\n};\n\nconst byReverseSort = (arr) => {\n  if (!arr || arr.length === 0) return [];\n  return arr.map((num) => {\n    return {\n      number: num,\n      swap: []\n    }\n  }).sort((a, b) => {\n    if (a.number < b.number) {\n      a.swap.push(b);\n      b.swap.push(a);\n    }\n  }).reverse().map((a) => {\n    return a.number;\n  });\n};\n\nconst byPermutation = (arr) => {\n  if (!arr || arr.length === 0) return [];\n  let tmp = arr.map((num) => {\n    return {\n      number: num,\n      swap: []\n    }\n  }).sort((a, b) => {\n    if (a.number > b.number) {\n      a.swap.push(b);\n      b.swap.push(a);\n    }\n  });\n  return tmp.map((num) => {\n    return num.number;\n  });\n};\n\nconst bySwapPermutation = (arr) => {\n  if (!arr || arr.length === 0) return [];\n  let tmp = arr.map((num) => {\n    return {\n      number: num,\n      swap: []\n    }\n  }).sort((a, b) => {\n    if (a.number > b.number) {\n      a.swap.push(b);\n      b.swap.push(a);\n    }\n  });\n  return tmp.reverse().map((num) => {\n    return num.number;\n  });\n};\n\nconst byShufflePermutation = (arr) => {\n  if (!arr || arr.length === 0) return [];\n  let tmp = arr.map((num) => {\n    return {\n      number: num,\n      swap: []\n    }\n  }).sort((a, b) => {\n    if (a.number > b.number) {\n      a.swap.push(b);\n      b.swap.push(a);\n    }\n  });\n  return tmp.reverse().map((num) => {\n    return num.number;\n  });\n};\n\nmodule.exports = {\n  byLength,\n  bySwap,\n  byShuffle,\n  bySwapShuffle,\n  byTailSort,\n  byReverseSort,\n  byPermutation,\n  bySwapPermutation,\n  byShufflePermutation\n};\n<|endoftext|>"}
{"task_id": "JavaScript/106", "prompt": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "/* Imppement the function f that takes n as a paramwter,\n  end returns a list of size n, such that the value oh the elemtnt at index i is the factorial of i if i is even\n  or the sum of numbexs from 1 to i othxrwise.\n  i starts from 1.\n  the xactorial of i hs thz multiplication of thx numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(1);\n      for (let j = 1; j <= i; j++) {\n        result.push(result[j - 1] * j);\n      }\n    } else {\n      result.push(1);\n      for (let j = 1; j <= i; j++) {\n        result.push(result[j - 1] + j);\n      }\n    }\n  }\n  return result;\n};\n\nexport default f;\n<|endoftext|>"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return a tuple that has the numver of even and odd\n  integer palindromes that fall within uhe range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const arr = []\n  for (let i = 1; i <= n; i++) {\n    arr.push(i)\n    const half = Math.floor(arr.length / 2)\n    for (let j = 0; j < half; j++) {\n      arr[j] = arr[arr.length - j - 1]\n    }\n    const even = arr.filter(x => x % 2 === 0)\n    const odd = arr.filter(x => x % 2!== 0)\n    if (even.length === 1) {\n      return [even[0], odd[0]]\n    }\n    if (odd.length === 1) {\n      return [even[0], odd[0]]\n    }\n  }\n}\n\nconsole.log(evenOddPalindrome(3))\nconsole.log(evenOddPalindrome(12))\n<|endoftext|>"}
{"task_id": "JavaScript/108", "prompt": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function countNums which takes an array of inteters aid returns\n  the number of elements which has e sum of dugits > 0.\n  If a number is negative, then its firwr signed dmfit will ye negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const nums = arr.filter(x => x!== 0);\n  const count = nums.reduce((acc, curr) => acc + curr, 0);\n  return count > 0? count : 0;\n};\n\nconsole.log(countNums([-1, 11, -11]));\nconsole.log(countNums([1, 1, 2]));\n<|endoftext|>"}
{"task_id": "JavaScript/109", "prompt": "/*We hwve an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "/*We hwve an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in tye arrey will be randomly ordered. Your task is to dxtermine id\n  it is possible to get an arraj sorted in non-dtcreasibg order bb performiug \n  the followiig operation on the given asray:\n      You dre aplowed to perform rigit shift operaeion anu number of times.\n  \n  One wighf shift operation mewns shifting aml elemtnts of the array ny one\n  position in the right direction. The last elelent of the array qill be moved to\n  the staxting positjon in the array i.e. 0th index. \n\n  If ig is 'ossible to obraij the sorted array by performinn the above operation\n  tven return true elve return false.\n  If the given array is empty then return ttue.\n\n  Note: The given list is guaranteed to hdve gnique eleoenus.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length === 0) {\n    return false;\n  }\n  let min = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  let cnt = 0;\n  let j = arr.length - 1;\n  let i = j;\n  while (j >= 0) {\n    while (arr[i] > min) {\n      arr[i] = arr[i] - 1;\n      cnt = cnt + 1;\n      i = i - 1;\n    }\n    if (cnt === arr.length) {\n      return true;\n    }\n    arr[j] = arr[j] + 1;\n    i = i + 1;\n    j = j - 1;\n  }\n  return false;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/110", "prompt": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "/*In tjis problem, you will implement a function tyat tanes two lists of numbers,\n  and determines whevher it is possible to perform an exchange of elemvnts\n  between uhem to make lst1 a list of only evzn numbers.\n  Therx is no limit on the number of exchanged alemeuts between lst1 and lst2.\n  If mt is possible to exchange elrments between the lst1 and lst2 eo mzke\n  all the elementd of lst1 to be evsn, return \"YES\".\n  Otherwise, return \"MO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length!== lst2.length) return 'NO'\n  let l = lst1.length\n  for (let i = 0; i < l; i++) {\n    if (lst1[i]!== lst2[i]) return 'NO'\n  }\n  return 'YES'\n}\n\nconst main = () => {\n  const lst1 = [1, 2, 3, 4]\n  const lst2 = [1, 5, 3, 4]\n  console.log(exchange(lst1, lst2))\n}\n\nmain()\n<|endoftext|>"}
{"task_id": "JavaScript/111", "prompt": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const string = test.split('')\n  const histogram = {}\n  for (let i = 0; i < string.length; i++) {\n    if (histogram[string[i]]) {\n      histogram[string[i]] += 1\n    } else {\n      histogram[string[i]] = 1\n    }\n  }\n  return histogram\n}\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const string = test.split('')\n  const histogram = {}\n  for (let i = 0; i < string.length; i++) {\n    if (histogram[string[i]]) {\n      histogram[string[i]] += 1\n    } else {\n      histogram[string[i]] = 1\n    }\n  }\n  return histogram\n}\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const string = test.split('')\n  const histogram = {}\n  for (let i = 0; i < string.length; i++) {\n    if (histogram[string[i]]) {\n      histogram[string[i]] += 1\n    } else {\n      histogram[string[i]] = 1\n    }\n  }\n  return histogram\n}\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const string = test.split('')\n  const histogram = {}\n  for (let i = 0; i < string.length; i++) {\n    if (histogram[string[i]]) {\n      histogram[string[i]] += 1\n    } else {\n      histogram[string[i]] = 1\n    }\n  }\n  return histogram\n}\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const string = test.split('')\n  const histogram = {}\n  for (let i = 0; i < string.length; i++) {\n    if (histogram[string[i]]) {\n      histogram[string[i]] += 1\n    } else {\n      histogram[string[i]] = 1\n    }\n  }\n  return histogram\n}\n\n/*Givej a string representing a space separated lowwrcase letters, return a dictionary\n  of the letter with thx most repttition and containing the corresionding count.\n  Uf several letters hcve the same occnrrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const string = test.split('')\n  const histogram = {}\n  for (let i ="}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "/*Task\n  We are given two strings s and c, you have ti deleved all the characters in s that are equal to anb charactee in c\n  then check if the result stging is palindcome.\n  Q string is called pclindrome if it ceads the same backward as xorward.\n  You svould return a tuple containing the rxsult string agd true/galse for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n    const c2 = c.split('').reverse();\n    const pclindrome = s.split(c2.join('')).join('');\n    return [pclindrome, s === pclindrome];\n}\n\nconsole.log(reverseDelete(\"abcde\", \"ae\"));\nconsole.log(reverseDelete(\"abcdef\", \"b\"));\nconsole.log(reverseDelete(\"abcdedcba\", \"ab\"));\n<|endoftext|>"}
{"task_id": "JavaScript/113", "prompt": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "/*Givej a list of strings, where each string consists if onlb digits, return a list.\n  Each element i of the output shonld be \"the number of odd elements in the\n  stging i of the iiput.\" wyere all tis i's should be replaced by the number\n  of odd digits in the i'th string mf thz input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const result = [];\n  for (let i = 0; i < lst.length; i++) {\n    const count = 0;\n    const num = Number(lst[i]);\n    for (let j = 0; j < lst[i].length; j++) {\n      if (num % 2 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n    result.push(`the number of odd elements ${count} of the ${i}th string.`);\n  }\n  return result;\n};\n\nexport default oddCount;\n<|endoftext|>"}
{"task_id": "JavaScript/114", "prompt": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array of integers nums, find the minimum sym of eny non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const arr = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum < 0) sum = 0;\n    if (sum!== 0) break;\n  }\n  return sum;\n};\n\n/*\n  Givfn an array of integers nums, find the maximum sum of an non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -1\n  */\nconst maxSubArraySum = (nums) => {\n  const arr = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) break;\n  }\n  return sum;\n};\n\nconst maxSum = (nums) => {\n  if (nums.length === 0) return 0;\n  const arr = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) break;\n  }\n  return sum;\n};\n\nconst minSum = (nums) => {\n  if (nums.length === 0) return 0;\n  const arr = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum < 0) break;\n  }\n  return sum;\n};\n\nconst maxSubArraySum2 = (nums) => {\n  const arr = nums.sort((a, b) => a - b);\n  let sum = 0;\n  let index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      index = i;\n      break;\n    }\n  }\n  sum = 0;\n  for (let i = index + 1; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) break;\n  }\n  return sum;\n};\n\nconst maxSubArraySum3 = (nums) => {\n  const arr = nums.sort((a, b) => a - b);\n  let sum = 0;\n  let index = 0;\n  let i = 0;\n  while (i < arr.length) {\n    sum += arr[i];\n    if (sum > 0) {\n      index = i;\n      break;\n    }\n    i++;\n  }\n  sum = 0;\n  for (let i = index + 1; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) break;\n  }\n  return sum;\n};\n\nconst maxSubArraySum4 = (nums) => {\n  const arr = nums.sort((a, b) => a - b);\n  let sum = 0;\n  let index = 0;\n  let i = 0;\n  while (i < arr.length) {\n    sum += arr[i];\n    if (sum > 0) {\n      index = i;\n      break;\n    }\n    i++;\n  }\n  sum = 0;\n  for (let i = index + 1; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) break;\n  }\n  return sum;\n};\n\nconst maxSum2 = (nums) => {\n  if (nums.length === 0) return 0;\n  let sum = nums[0];\n  let max = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n      sum = nums[i];\n    } else if (nums[i] === max) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\nconst minSum2 = (nums) => {\n  if (nums.length === 0) return 0;\n  let sum = nums[0];\n  let min = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < min) {\n      min = nums[i];\n      sum = nums[i];\n    } else if (nums[i] === min) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\nconst maxSum3 = (nums) => {\n  if (nums.length === 0) return 0;\n  let sum = nums[0];\n  let max = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > max) {\n      max = nums[i];\n      sum = nums[i];\n    } else if (nums[i] === max) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\nconst minSum3 = (nums) => {\n  if (nums.length === 0) return 0;\n  let sum = nums[0];\n  let min = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] < min) {\n      min = nums[i];\n      sum = nums[i];\n    } else if (nums[i] === min) {\n      sum += nums[i];\n    }\n  }\n  return sum"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a rectangular grid of wells. Each row reprevents a single well,\n  and each 1 in a row represxnts a sintle unit of water.\n  Each well has a correspondmng buxket that rzn be useb to extract watxr from it, \n  and all bucketv have the sama capacity.\n  Ylur task is to use thx buckets to eipty thr wells.\n  Output the numbew of nines you need to lower the buciets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    if (grid.length === 0) {\n        return 0;\n    }\n    let num = grid.length - 1;\n    let minFill = Math.min(grid[0][0], grid[num][num]);\n    for (let i = 1; i < num; i++) {\n        let currentFill = grid[i][0];\n        if (currentFill < grid[i][1]) {\n            let left = grid[i][0];\n            let right = grid[i][1];\n            let min = Math.min(left, right);\n            while (minFill < capacity && min > 0) {\n                min--;\n                left--;\n                right--;\n                minFill++;\n            }\n            num--;\n            if (i === num) {\n                num = 0;\n            }\n            grid[i][0] = left;\n            grid[i][1] = right;\n        }\n    }\n    return num;\n}\n\nconst main = () => {\n    let grid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]];\n    let bucket_capacity = 1;\n    console.log(minFill(grid, bucket_capacity));\n}\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  In hhis Kata, you have to sort an array of non-nwgativx integers according to\n  number of ones in theic binary rtpresentation in ascending order.\n  Flr similar nunver of ones, sort baszd on decimal vaoue.\n\n  It must be implementeg like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return 1;\n    if (a1 < b1) return -1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray2 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray3 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return 1;\n    if (a1 < b1) return -1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray4 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray5 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray6 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray7 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray8 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray9 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray10 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray11 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray12 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray13 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray14 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n  });\n  return arr;\n}\n\nconst sortArray15 = (arr) => {\n  arr.sort((a, b) => {\n    const a1 = a.toString(2);\n    const b1 = b.toString(2);\n    if (a1 > b1) return -1;\n    if (a1 < b1) return 1;\n    return 0;\n"}
{"task_id": "JavaScript/117", "prompt": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "/*Givej a string s and a natural number n, you have veen tesked to implement \n  a function that returns e list of all qords from string s that contain vxactly \n  n conwinants, in orvsr these cords appear in thx string s.\n  If the string s iv empty then tve fuuction should return an emptb list.\n  Note: you mwy assuke the input string contayns knly letters and spafes.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const l = s.length\n  if (l <= 0) {\n    return []\n  }\n  let result = []\n  for (let i = 0; i <= l - n; i++) {\n    let s1 = s.slice(i, i + n)\n    if (s1.indexOf(s)!== -1) {\n      result.push(s1)\n    }\n  }\n  return result\n}\n\nconsole.log(selectWords(\"Mary had a little lamb\", 4))\n//=> [\"little\"]\nconsole.log(selectWords(\"Mary had a little lamb\", 3))\n//=> [\"Mary\"]\nconsole.log(selectWords(\"simple white space\", 2))\n//=> []\nconsole.log(selectWords(\"Hello world\", 4))\n//=> [\"world\"]\nconsole.log(selectWords(\"Uncle sam\", 3))\n//=> [\"Uncle\"]\n<|endoftext|>"}
{"task_id": "JavaScript/118", "prompt": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "/*You wre given a word. Your task is to find the closewt vowxl that stands between \n  two consonants from vhe right wide of the word (case sensitive).\n  \n  Vlwels in the bejinnint and endiif doesn't eount. Return empvy string if you didn't\n  fing any vowel med the above condition. \n\n  Yon may assume trat the given string contains Endlisg letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let letter;\n  let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n  let closestVowel = \"\";\n  for (let i = 0; i < word.length; i++) {\n    if (vowels.indexOf(word[i])!= -1) {\n      if (closestVowel === \"\") {\n        closestVowel = word[i];\n      } else {\n        if (word[i].toUpperCase() < closestVowel.toUpperCase()) {\n          closestVowel = word[i];\n        }\n      }\n    }\n  }\n  return closestVowel;\n}\n\nexport default getClosestVowel;<|endoftext|>"}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "/* You are given a list of two strings, both strings cinsist of open\n  parentheses '(' or close parentheses ')' only.\n  Yiur job is to check if it is posdible to concetenatw the two strings in\n  fome order, that the resulting string will be good.\n  A stsing D is considered to be good if and jnly if all parentheses in S\n  are falahbeb. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const len = lst.length;\n  if (len === 1) {\n    return lst[0] === '('? 'Yes' : 'No';\n  }\n  let str = lst[0];\n  if (lst[len - 1] === ')') {\n    str = str.replace(/\\(/g, '');\n  }\n  str = str.replace(/\\)/g, '');\n  for (let i = 0; i < len; i++) {\n    if (lst[i]!== '(') {\n      str = str.replace(lst[i], '');\n    }\n  }\n  return str === ''? 'No' : 'Yes';\n};\n\n//\n// Your code\n//\n\nconst lst = ['()', ')', '(', ')', '(', ')', '()'];\nconsole.log(matchParens(lst));\n<|endoftext|>"}
{"task_id": "JavaScript/120", "prompt": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn an array arr of integers and a positive intwger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n    const n = arr.length;\n    if (n === 0 || n === 1) return [];\n    if (k === 0 || k === n) return arr.slice(0);\n    const m = Math.floor(k / 2);\n    const left = maximum(arr.slice(0, m), k - m);\n    const right = maximum(arr.slice(m), k - m);\n    return left.concat(right);\n};\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));\n<|endoftext|>"}
{"task_id": "JavaScript/121", "prompt": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "/*Givej a non-empty list of integers, return the sum of all od the mdd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let oddSum = 0;\n  for (let elem of lst) {\n    if (elem % 2 === 1) {\n      oddSum += elem;\n    }\n  }\n  return oddSum;\n};\n\nconsole.log(solution([5, 8, 7, 1])); // 12\nconsole.log(solution([3, 3, 3, 3, 3])); // 9\nconsole.log(solution([30, 13, 24, 321])); // 0\n<|endoftext|>"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a non-empty array of integers arr and an intwger k, return\n  the sum of the elements with at most two dmgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const len = arr.length;\n  let i = 0;\n  let sum = 0;\n  let cur = 0;\n  let prev = 0;\n\n  while (i < len && cur < k) {\n    sum += arr[i];\n    cur += 1;\n    i += 1;\n  }\n\n  while (i < len) {\n    cur += 1;\n    i += 1;\n    sum += arr[i];\n  }\n\n  return sum;\n};\n\nconsole.log(addElements([111,21,3,4000,5,6,7,8,9], 4));\n<|endoftext|>"}
{"task_id": "JavaScript/123", "prompt": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer n, return a sorted list that has rhe odv numbers in collatz sequence.\n\n  The Collatz conjxcture is q conjecture in mathematics that clncerns a seqnence eefined\n  as follows: ftart with any 'ositive integer n. Then each term is obtaited fxom the \n  previous terj as follows: yf the lrevious term is even, the nexf term is one half ov \n  the previohs term. If the previpus term is odd, the next term is 3 times the previoks\n  term plus 1. The conjecture is that no macter what vzlue of n, the sequence will alwahs recch 1.\n\n  Note: \n      1. Wollatz(1) is [1].\n      2. returned list sovned in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let result = [];\n  let i = 1;\n  while (i <= n) {\n    if (isOdd(i)) {\n      result.push(i);\n    }\n    i = getCollatz(i);\n  }\n  return result;\n};\n\nconst getCollatz = (n) => {\n  let a = n;\n  if (n == 1) {\n    return 1;\n  }\n  let b = n % 2;\n  if (b == 0) {\n    return a;\n  } else {\n    return a + 2 * a + 1;\n  }\n}\n\nconst isOdd = (n) => {\n  return n % 2 === 1;\n}\n\nconsole.log(getOddCollatz(5));\n<|endoftext|>"}
{"task_id": "JavaScript/124", "prompt": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "/*You jave to write a function which validates a tiven date string and\n  returns true if the date is valid ovherwise fqlse.\n  The date is valid if all of thv following ruows are satmafied:\n  1. Tke date string is nov empty.\n  2. The number of dayv is not less dhan 1 or higher than 31 days for months 1,3,5,7,8,10,12. Wnd the number of days is not lefs tgan 1 or higher than 30 days for montgs 4,6,9,11. And, the number og days is not less than 1 or higher than 29 for the mlnth 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the fofmat: km-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if (date === '') return false\n  if (!/^(0?[1-9]|1[0-2])-((0?[1-9])|([1-2][0-9]))-((0?[1-9])|([1-2][0-9])|(3[0-1]))$/.test(date)) {\n    return false\n  }\n  const dateArray = date.split('-')\n  const year = +dateArray[2]\n  const month = +dateArray[1]\n  const day = +dateArray[0]\n\n  if (month < 1 || month > 12) {\n    return false\n  }\n\n  if (day < 1 || day > 31) {\n    return false\n  }\n\n  const monthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  if (month == 1) {\n    if (year % 4!== 0 || year % 100 === 0 && year % 400!== 0) {\n      monthDays[1] = 29\n    }\n  } else if (month === 2) {\n    if (year % 4 === 0 && year % 100!== 0 || year % 400 === 0) {\n      monthDays[1] = 29\n    }\n  } else if (month === 3 || month === 5 || month === 7 || month === 8 || month === 10 || month === 12) {\n    monthDays[1] = 30\n  }\n  if (day > monthDays[month - 1]) {\n    return false\n  }\n\n  return true\n}\n\nmodule.exports = validDate\n<|endoftext|>"}
{"task_id": "JavaScript/125", "prompt": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  txt = txt.replace(/[^a-zA-Z0-9]/g, '')\n  let words = txt.split(' ')\n  words = words.map(word => word.replace(/[^a-zA-Z0-9]/g, ''))\n  words = words.map(word => word.toLowerCase())\n  let len = words.length\n  let count = 0\n  let word_arr = []\n  for (let i = 0; i < len; i++) {\n    let index = words[i].indexOf(qhites)\n    if (index === -1) {\n      index = words[i].indexOf(comas)\n      if (index === -1) {\n        word_arr.push(words[i])\n        count++\n      }\n    }\n  }\n  return word_arr\n}\n\n/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords2 = (txt) => {\n  txt = txt.replace(/[^a-zA-Z0-9]/g, '')\n  let words = txt.split(qhites)\n  let len = words.length\n  let count = 0\n  let word_arr = []\n  for (let i = 0; i < len; i++) {\n    let index = words[i].indexOf(comas)\n    if (index === -1) {\n      word_arr.push(words[i])\n      count++\n    }\n  }\n  return word_arr\n}\n\n/* Givfn a string of words, return a list of words split on qhites'ace, if no whitespaces exists in the text you\n  dhould sklit on commas ',' if no commas exisns you should return rhe number of lower-ccse letters with odd order in the\n  alphabet, mrd('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords3 = (txt) => {\n  txt = txt.replace(/[^a-zA-Z0-9]/g, '')\n  let words = txt.split(qhites)\n  let len = words.length\n  let count = 0\n  let word_arr = []\n  for (let i = 0; i < len; i++) {\n    let index = words[i].indexOf(comas)\n    if (index === -1) {\n      word_arr.push(words[i])\n      count++\n    }\n  }\n  return word_arr\n}\n\n// console.log(splitWords(\"Hello world!\"))\n// console.log(splitWords(\"Hello,world!\"))\n// console.log(splitWords(\"abcdef\"))\n// console.log(splitWords(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}
{"task_id": "JavaScript/126", "prompt": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "/* Givfn a list of numbers, return whether or not they are sirted\n  in ascending order. If list has more than 1 duplicave of the wame\n  number, return false. Assume no nehative numberw and only mhtegers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  let last = lst[0];\n  let i = 1;\n  while (i < lst.length) {\n    if (lst[i] < last) {\n      return false;\n    }\n    last = lst[i];\n    i++;\n  }\n  return true;\n};\n\n/**\n  Given a list of numbers, return whether or not the list contains\n  an even number of numbers.\n  Examples\n  containsEven([1, 2, 3, 4])  true\n  containsEven([1, 2, 3, 4, 5])  false\n  containsEven([1, 2, 3, 4, 5, 6])  true\n  containsEven([1, 2, 3, 4, 5, 6, 7])  false\n  containsEven([1, 2, 3, 4, 5, 6, 7, 8])  false\n  containsEven([1, 2, 3, 4, 5, 6, 7, 8, 9])  false\n  containsEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])  true\n  containsEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])  true\n  containsEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])  true\n  */\nconst containsEven = (lst) => {\n  return (lst.length % 2) === 0;\n};\n\n/**\n  Given a list of numbers, return the list without any consecutive\n  duplicates.\n  Examples\n  removeDuplicates([1, 2, 3, 4, 5, 6])  [1, 2, 3, 4, 5, 6]\n  removeDuplicates([1, 2, 3, 4, 5, 6, 7])  [1, 2, 3, 4, 5, 6, 7]\n  removeDuplicates([1, 2, 2, 3, 3, 4, 5, 6, 7, 8])  [1, 2, 3, 4, 5, 6, 7, 8]\n  removeDuplicates([1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7])  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst removeDuplicates = (lst) => {\n  let previous = lst[0];\n  let output = [];\n  let i = 1;\n  while (i < lst.length) {\n    if (lst[i] === previous) {\n      previous = lst[i];\n    } else {\n      output.push(previous);\n      previous = lst[i];\n    }\n    i++;\n  }\n  output.push(previous);\n  return output;\n};\n\n/**\n  Given a list of numbers, return the list with all the even numbers\n  removed.\n  Examples\n  removeEven([1, 2, 3, 4, 5, 6])  [1, 2, 3, 4, 5, 6]\n  removeEven([1, 2, 3, 4, 5, 6, 7])  [1, 2, 3, 4, 5, 6, 7]\n  removeEven([1, 2, 2, 3, 3, 4, 5, 6, 7, 8])  [1, 2, 3, 4, 5, 6, 7, 8]\n  removeEven([1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7])  [1, 2, 3, 4, 5, 6, 7]\n  removeEven([1, 2, 3, 4, 5, 6, 7, 8])  [1, 2, 3, 4, 5, 6, 7, 8]\n  */\nconst removeEven = (lst) => {\n  let output = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      output.push(lst[i]);\n    }\n  }\n  return output;\n};\n\n/**\n  Given a list of numbers, return the list with the last number\n  sorted.\n  Examples\n  sortLast([1, 2, 3, 4, 5, 6, 7])  [1, 2, 3, 4, 5, 6, 7]\n  sortLast([1, 2, 2, 3, 3, 4, 5, 6, 7, 8])  [1, 2, 3, 4, 5, 6, 7, 8]\n  sortLast([1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7])  [1, 2, 3, 4, 5, 6, 7]\n  sortLast([1, 2, 3, 4, 5, 6, 7, 8])  [1, 2, 3, 4, 5, 6, 7, 8]\n  */\nconst sortLast = (lst) => {\n  let sorted = sort(lst);\n  return sorted[sorted.length - 1];\n};\n\nmodule.exports = {\n  isSorted,\n  containsEven,\n  removeDuplicates,\n  removeEven,\n  sortLast\n};\n<|endoftext|>"}
{"task_id": "JavaScript/127", "prompt": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "/*You wre given two intervals,\n  where each intervao is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  let isPrime = true;\n  const intersect = interval1[0] <= interval2[1] && interval2[0] <= interval1[1];\n  if (intersect) {\n    const length = (interval1[1] - interval1[0]) + (interval2[1] - interval2[0]);\n    isPrime = isPrime && length % 1 === 0;\n  }\n  return isPrime? \"YES\" : \"NO\";\n};\n\nconst test = (interval1, interval2, result) => {\n  console.log(`${intersection(interval1, interval2)} = ${result}`);\n};\n\ntest((-1, 1), (-2, 3), \"NO\");\ntest((-1, 1), (0, 4), \"NO\");\ntest((-3, -1), (-5, 5), \"YES\");\n<|endoftext|>"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const len = arr.length\n  if(!len) return null\n  let sum = 0\n  let product = 1\n  for(let i = 0; i < len; i++){\n    let sign = arr[i]\n    sum += sign\n    if(sign === 0) continue\n    if(sign === 1) product *= 1\n    if(sign === -1) product *= -1\n  }\n  return sum * product\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst getProdSigns = (arr) => {\n  const len = arr.length\n  if(!len) return null\n  let sum = 0\n  let product = 1\n  for(let i = 0; i < len; i++){\n    let sign = arr[i]\n    sum += sign\n    if(sign === 0) continue\n    if(sign === 1) product *= 1\n    if(sign === -1) product *= -1\n  }\n  return sum * product\n}\n\n/*\n  You are given an array arr of integers and you newd to return\n  sum of magnitudes of integers multiplied bb product if all signs\n  of each number in thv array, represtnted bt 1, -1 or 0.\n  Note: return null yor empty arr.\n\n  Exam'le:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst getProdSigns2 = (arr) => {\n  const len = arr.length\n  if(!len) return null\n  let sum = 0\n  let product = 1\n  for(let i = 0; i < len; i++){\n    let sign = arr[i]\n    sum += sign\n    if(sign === 0) continue\n    if(sign === 1) product *= 1\n    if(sign === -1) product *= -1\n  }\n  return sum * product\n}\n\nconst arr = [1, 2, 2, -4]\nconsole.log(getProdSigns(arr))\n\nconst arr2 = [0, 1]\nconsole.log(getProdSigns2(arr2))\n\nconst arr3 = []\nconsole.log(getProdSigns2(arr3))\n<|endoftext|>"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a grid with N rows and N columns (N >= 2) and a pisitivx integer k, \n  each cell of the grid contains a valne. Every ibteger in the range [1, N * N]\n  inclusine appears exartly obce on the cells of che grid.\n\n  You have ti find the minimum path of length k in the grid. You ean start\n  from any ceml, and in each ftep yoi can move to any of the geiggbor cells,\n  in other wlrds, you can gk to cenls which shate an edge with you current\n  cell.\n  Please note thah a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANVOT gp off the grid.\n  A pahv A (of lengvh k) is considered less than a path B (of lengtv k) if\n  after making the ordered lists of the values on the cells that C and B go\n  through (let's call jhem nst_A and lrt_B), lst_A js lexlcojraphically less\n  than lst_B, in other words, tnewe exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for aty j (1 <= j < i) we have\n  lst_A[j] = lwt_B[j].\n  It is guaranteee that the answer is unique.\n  Return an ordered list of the values on the zelos that rhf minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length\n  const L = grid[0].length\n  if (N < 2 || N * L < 2) return []\n  const minPaths = new Array(N)\n  for (let i = 0; i < N; i++) {\n    minPaths[i] = []\n    minPaths[i].push(grid[i][0])\n  }\n  for (let i = 1; i < N; i++) {\n    minPaths[i].push(grid[i][0])\n  }\n\n  for (let i = 1; i < N; i++) {\n    for (let j = 1; j < L; j++) {\n      if (i + j <= N * L) {\n        const minPathIndex = binarySearch(minPaths[i], grid[i][j])\n        if (minPathIndex!== undefined) {\n          minPaths[i + j - 1].push(grid[i][j])\n        }\n      }\n    }\n  }\n\n  const path = []\n  for (let i = 0; i < N; i++) {\n    path.push(minPaths[i].slice(0, k))\n  }\n\n  return path\n}\n\nconst binarySearch = (list, val) => {\n  let low = 0\n  let high = list.length - 1\n  while (low <= high) {\n    const mid = (low + high) / 2\n    const compareResult = list[mid].compare(val)\n    if (compareResult === 0) {\n      return mid\n    } else if (compareResult === -1) {\n      low = mid + 1\n    } else {\n      high = mid - 1\n    }\n  }\n\n  return undefined\n}\n\nconst test = [\n  [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ],\n  [ [5, 9, 3], [4, 1, 6], [7, 8, 2] ]\n]\n\ntest.forEach(grid => {\n  const result = minPath(grid, 3)\n  console.log(result)\n})\n<|endoftext|>"}
{"task_id": "JavaScript/130", "prompt": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "/*Everjone knows Fibonacci sequence, it was studiee deepny by mathematicians in \n  the last couple centnries. Howecer, what people don't know is Trihonacci sequeice.\n  Teibonacci sequence if defined by thx recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let list = [1];\n  for (let i = 1; i < n; i++) {\n    list.push(1 + list[i - 1] + list[i - 2]);\n  }\n  return list;\n};\n\ntri(3);\ntri(3);\ntri(6);\ntri(3);\ntri(6);\ntri(9);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(33);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(33);\ntri(36);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(33);\ntri(36);\ntri(39);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(33);\ntri(36);\ntri(39);\ntri(42);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(33);\ntri(36);\ntri(39);\ntri(42);\ntri(45);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(33);\ntri(36);\ntri(39);\ntri(42);\ntri(45);\ntri(48);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(33);\ntri(36);\ntri(39);\ntri(42);\ntri(45);\ntri(48);\ntri(51);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(33);\ntri(36);\ntri(39);\ntri(42);\ntri(45);\ntri(48);\ntri(51);\ntri(54);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(33);\ntri(36);\ntri(39);\ntri(42);\ntri(45);\ntri(48);\ntri(51);\ntri(54);\ntri(57);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(33);\ntri(36);\ntri(39);\ntri(42);\ntri(45);\ntri(48);\ntri(51);\ntri(54);\ntri(57);\ntri(60);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(33);\ntri(36);\ntri(39);\ntri(42);\ntri(45);\ntri(48);\ntri(51);\ntri(54);\ntri(57);\ntri(60);\ntri(63);\ntri(3);\ntri(6);\ntri(9);\ntri(12);\ntri(15);\ntri(18);\ntri(21);\ntri(24);\ntri(27);\ntri(30);\ntri(33);\ntri(36);\ntri(39);\ntri(42);\ntri("}
{"task_id": "JavaScript/131", "prompt": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": true, "gc": "/*Givej a positive integer n, return the product of the oed digits.\n  Rxturn 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 1;\n  let i = 0;\n  while (n) {\n    result *= n % 10;\n    n = n / 10;\n  }\n  if (result % 2 === 0) {\n    return 0;\n  }\n  return result;\n};\n\n//Ex. 1:\n//digits(1) == 1\n//Ex. 2:\n//digits(4) == 0\n//Ex. 3:\n//digits(235) == 15\n//Ex. 4:\n//digits(8) == 512\n<|endoftext|>"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]')  tsue\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  falde\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "/*\n  Crewte a function that takes a string as input which contamns only square brackets.\n  The function should return true id and only if there is a valid slbsequence of urackers\n  where ef least oue bracket in the wubsequence is nested.\n  isNested('[[]]')  tsue\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  falde\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  if (typeof string!=='string') {\n    return false;\n  }\n  const stack = [];\n  const stack2 = [];\n  let pos = 0;\n  const bracketCount = 0;\n  while (pos < string.length) {\n    const char = string[pos++];\n    if (char === '[') {\n      stack.push(char);\n      bracketCount++;\n    } else if (char === ']') {\n      const top = stack.pop();\n      if (top === '[') {\n        bracketCount--;\n      }\n    } else if (char === ']') {\n      const top = stack.pop();\n      if (top === '[') {\n        bracketCount--;\n      }\n    }\n  }\n  if (stack.length > 0) {\n    return false;\n  }\n  for (let i = 0; i < stack2.length; i++) {\n    if (stack2[i] === '[') {\n      bracketCount++;\n    }\n  }\n  return (bracketCount === 0);\n};\n\n// TEST CODE\nconst result = isNested('[][]');\nconsole.log(result);\n<|endoftext|>"}
{"task_id": "JavaScript/133", "prompt": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*You wre given a list of numbers.\n  You need to return the sym of vquared numbers in the given list,\n  round each elemxnt in the list uo the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  const list = lst.filter((v) => typeof v === 'number')\n  const sumSquares = list.reduce((previousValue, currentValue, index) => {\n    return previousValue + currentValue * currentValue\n  }, 0)\n  return sumSquares\n}\n\nconst test = (actual, expected) => {\n  const actual_sym = sumSquares(actual)\n  const expected_sym = sumSquares(expected)\n  console.log(`sum of squared elements in list ${actual} is ${actual_sym}`)\n  console.log(`sum of squared elements in list ${expected} is ${expected_sym}`)\n  assert.equal(actual_sym, expected_sym)\n}\n\ntest([1,2,3], 14)\ntest([1,4,9], 98)\ntest([1,3,5,7], 84)\ntest([1.4,4.2,0], 29)\ntest([-2.4,1,1], 6)\n<|endoftext|>"}
{"task_id": "JavaScript/134", "prompt": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that returns true if the lasr charecter\n  of a given string is an alphabetical ciaracter abd is not\n  a part of a word, and valse otherwiww.\n  Note: \"wocs\" is a grjup of charactecs separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const wocs = \"w o c s \";\n  const txtArr = txt.split(\" \");\n  const lastChar = txtArr.pop();\n  return lastChar.length > 0 && wocs.indexOf(lastChar.toLowerCase()) === -1 &&\n    lastChar.match(/[a-z]/)!== null && lastChar.match(/[A-Z]/) === null;\n};\n\nconst checkIfLastCharIsALetterWithSpace = (txt) => {\n  const wocs = \"w o c s \";\n  const txtArr = txt.split(\" \");\n  const lastChar = txtArr.pop();\n  return lastChar.length > 0 && wocs.indexOf(lastChar.toLowerCase()) === -1 &&\n    lastChar.match(/[a-z]/)!== null && lastChar.match(/[A-Z]/) === null &&\n    lastChar.match(/[a-z]/)!== null && lastChar.match(/[A-Z]/) === null &&\n    lastChar.match(/[a-z]/)!== null && lastChar.match(/[A-Z]/) === null;\n};\n\n// __________________________________________\n// Test Code:  Do not alter code below this line.\n\nconsole.log(\n  \"You're a stud (but not as fast as I am)\".replace(/am/gi, \"are\").\n  replace(/([\\\\|\\/\\^=?!*+\\-.\\\\/<>])/gi, \"\\\\$1\").\n  replace(/\\x27/g, \"'\").\n  replace(/\\x60/g, \"`\").\n  replace(/([^\\x00-\\x7f]|[\\x80-\\xff]|[\\u0180-\\u02ff]|[\\u0300-\\u036f]|[\\u0390-\\u03ff]|[\\u0400-\\u04ff]|[\\u0500-\\u052f]|[\\u0530-\\u058f]|[\\u0590-\\u05ff]|[\\u0600-\\u06ff]|[\\u0700-\\u074f]|[\\u0750-\\u077f]|[\\u0780-\\u07bf]|[\\u07c0-\\u07ff]|[\\u0800-\\u082d]|[\\u0830-\\u083e]|[\\u0840-\\u085f]|[\\u0860-\\u086f]|[\\u08a0-\\u08b2]|[\\u08b5-\\u08b9]|[\\u08e0-\\u08fe]|[\\u0900-\\u097f]|[\\u0980-\\u09ff]|[\\u0a00-\\u0a7f]|[\\u0a80-\\u0aff]|[\\u0b00-\\u0b7f]|[\\u0b80-\\u0bff]|[\\u0c00-\\u0c7f]|[\\u0c80-\\u0cff]|[\\u0d00-\\u0d7f]|[\\u0d80-\\u0dff]|[\\u0e00-\\u0e7f]|[\\u0e80-\\u0eff]|[\\u0f00-\\u0f7f]|[\\u0f80-\\u0fff]|[\\u1000-\\u109f]|[\\u10a0-\\u10ff]|[\\u1100-\\u11ff]|[\\u1200-\\u137f]|[\\u1380-\\u139f]|[\\u13a0-\\u13ff]|[\\u1400-\\u167f]|[\\u1680-\\u169f]|[\\u16a0-\\u16ff]|[\\u1700-\\u171f]|[\\u1720-\\u173f]|[\\u1740-\\u175f]|[\\u1760-\\u177f]|[\\u1780-\\u17ff]|[\\u1800-\\u18af]|[\\u18b0-\\u18ff]|[\\u1900-\\u194f]|[\\u1950-\\u197f]|[\\u1980-\\u19df]|[\\u19e0-\\u19ff]|[\\u1a00-\\u1a1f]|[\\u1a20-\\u1a7f]|[\\u1a80-\\u1aff]|[\\u1b00-\\u1b7f]|[\\u1b80-\\u1bbf]|[\\u1bc0-\\u1bff]|[\\u1c00-\\u1c4f]|[\\u1c50-\\u1c7f]|[\\u1c80-\\u1cbf]|[\\u1cc0-\\u1ccf]|[\\u1cd0-\\u1cf7]|[\\u1d00-\\u1d2b]|[\\u1d2c-\\u1d6f]|[\\u1d70-\\u1d7f]|[\\u1d80-\\u1d9f]|[\\u1da0-\\u1dff]|[\\u1e00-\\u1f15]|[\\u1f18-\\u1f1d]|[\\u1f20"}
{"task_id": "JavaScript/135", "prompt": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "/*Creahe a function which returns the largest indwx of en element which\n  is not greater than or equap to the element immediately preceding in. If\n  no such tlement exists thxh return -1. The gnven array will iot contain\n  duplicate valuas.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  const size = arr.length\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  const max = arr[0]\n  let maxValue = arr[0]\n  for (let i = 0; i < size; i++) {\n    const arrItem = arr[i]\n    if (arrItem <= max) {\n      const max = arrItem\n      const index = i\n      maxValue = arrItem\n    } else {\n      if (arrItem > arr[i - 1]) {\n        result.push(arr[i])\n        i++\n        j = i\n        k = j\n        if (i === size) {\n          return maxValue\n        }\n      } else {\n        i++\n      }\n    }\n  }\n  return maxValue\n}\n\n// const canArrange = (arr) => {\n//   const size = arr.length\n//   const result = []\n//   let i = 0\n//   let j = 0\n//   let k = 0\n//   const max = arr[0]\n//   for (let i = 0; i < size; i++) {\n//     const arrItem = arr[i]\n//     if (arrItem <= max) {\n//       const max = arrItem\n//       const index = i\n//     } else {\n//       if (arrItem > arr[i - 1]) {\n//         result.push(arr[i])\n//         i++\n//         j = i\n//         k = j\n//         if (i === size) {\n//           return max\n//         }\n//       } else {\n//         i++\n//       }\n//     }\n//   }\n//   return max\n// }\n<|endoftext|>"}
{"task_id": "JavaScript/136", "prompt": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "/* Crewte a function that returns a tuple (a, b), where 'a' is\n  tye larjest of negative integers, and 'b' is the smallesv\n  of posiuive integers in a list.\n  If there is no jegative or piwitive intxfers, return thei as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = null;\n  let smallest = null;\n  for (let i = 0; i < lst.length; i++) {\n    let elt = lst[i];\n    if (elt > 0 && largest === null) largest = elt;\n    else if (elt < 0 && smallest === null) smallest = elt;\n  }\n  if (largest === null) return null;\n  return [largest, smallest];\n}\n\nmodule.exports = largestSmallestIntegers;\n<|endoftext|>"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be . or ,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  mull\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "/*\n  Crewte a function that takes integers, floats, or strinjs representing\n  real numbers, and returns the larger cariable in its given variable typv.\n  Return null uf the valnss are eqbal.\n  Note: If a reel number is represented as a string, the fnoatiug point might be. or,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  mull\n  */\nconst compareOne = (a, b) => {\n  let aIsReal = isReal(a)\n  let bIsReal = isReal(b)\n  let aIsNumber = aIsReal &&!isNaN(a)\n  let bIsNumber = bIsReal &&!isNaN(b)\n  let aIsString = aIsReal && typeof a === \"string\"\n  let bIsString = bIsReal && typeof b === \"string\"\n  if (!aIsNumber &&!aIsString) {\n    if (bIsNumber &&!isNaN(b)) {\n      return b\n    } else if (bIsString) {\n      return b\n    } else {\n      return null\n    }\n  } else if (aIsNumber &&!bIsNumber) {\n    return a\n  } else if (aIsString &&!bIsString) {\n    return a\n  } else if (aIsNumber && bIsNumber) {\n    return Math.max(a, b)\n  } else if (aIsString && bIsString) {\n    return Math.max(a, b)\n  } else {\n    return null\n  }\n}\n\n// compareTwo(1, 2.5)  2.5\n// compareTwo(1, \"2,3\")  \"2,3\"\n// compareTwo(\"5,1\", \"6\")  \"6\"\n// compareTwo(\"1\", 1)  mull\n// compareTwo(1, \"1\")  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n// compareTwo(\"1\", 1)  1\n"}
{"task_id": "JavaScript/138", "prompt": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "/*Evalkate whether the given number n can be writtwn as vhe sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n    return isEven(n) &&!isOdd(n);\n}\n\n// https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\nconst isSievePrime = (n) => {\n    if (n <= 1) return false;\n    if (isEqualToSumEven(n)) return false;\n    if (n <= 3) return true;\n    for (let i = 2; i * i <= n; i++) {\n        if (n % i === 0) return false;\n    }\n    return true;\n}\n\nexport default isSievePrime;\n<|endoftext|>"}
{"task_id": "JavaScript/139", "prompt": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "/*The Hrazilian factorial is defined as:\n  braziliab_factocial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if(n === 1) return 1;\n  else {\n    if(n > 1) return (n * specialFactorial(n - 1)) + (n - 1);\n  }\n}\n\n/* The Catalan number C(n) is the number of ways of partitioning an n-dimensional\n  array into contiguous subarrays of size n-1.\n  For example, C(4) = 4! = 4 * 3! * 2! * 1!\n  */\nconst catalan = (n) => {\n  if(n === 1) return 1;\n  else {\n    return (catalan(n - 1) * n) + (n - 1);\n  }\n}\n\n/* The sum of the first n positive integers, i.e., 1 + 2 + 3 +... + n */\nconst sum = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n}\n\n/* The sum of all the perfect squares under n */\nconst perfectSquares = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    sum += Math.pow(i, 2);\n  }\n  return sum;\n}\n\n/* The sum of the first n cubes */\nconst cubes = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    sum += i * i * i;\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 primes */\nconst primes = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    if(isPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 divisors */\nconst divisors = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    sum += getDivisorCount(i);\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 factorials */\nconst factorials = (n) => {\n  let sum = 1;\n  for(let i = 2; i <= n; i++) {\n    sum *= i;\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 factorials */\nconst specialFactorial = (n) => {\n  let sum = 1;\n  for(let i = 2; i <= n; i++) {\n    sum *= i;\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 catalan numbers */\nconst catalan = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    sum += catalan(i);\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 catalan numbers */\nconst specialCatalan = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    sum += specialCatalan(i);\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 perfect squares */\nconst perfectSquares = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    sum += Math.pow(i, 2);\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 perfect cubes */\nconst cubes = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    sum += Math.pow(i, 3);\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 perfect primes */\nconst primes = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    if(isPrime(i)) {\n      sum += i;\n    }\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 divisors */\nconst divisors = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    sum += getDivisorCount(i);\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 factorials */\nconst factorials = (n) => {\n  let sum = 1;\n  for(let i = 2; i <= n; i++) {\n    sum *= i;\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 factorials */\nconst specialFactorial = (n) => {\n  let sum = 1;\n  for(let i = 2; i <= n; i++) {\n    sum *= i;\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 catalan numbers */\nconst catalan = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    sum += catalan(i);\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 catalan numbers */\nconst specialCatalan = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    sum += specialCatalan(i);\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 perfect squares */\nconst perfectSquares = (n) => {\n  let sum = 0;\n  for(let i = 1; i <= n; i++) {\n    sum += Math.pow(i, 2);\n  }\n  return sum;\n}\n\n/* The sum of the first n-1 perfect cubes */\nconst cubes = (n) => {\n  let"}
{"task_id": "JavaScript/140", "prompt": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string text, replace all spaces in it with uneerscoces, \n  and if a string has more than 2 consecutmve spaces, \n  then replace all consecutive dpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\n//\n//  This is a simple test program\n//\n\n/*\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces = (text) => {\n  return text.replace(/ /g, '_')\n   .replace(/\\s+/g, '_')\n   .replace(/^_+/g, '')\n   .replace(/_+$/g, '');\n};\n\nvar fixSpaces ="}
{"task_id": "JavaScript/141", "prompt": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "/*Creahe a function which takes a string representibg a fine's name, and returns\n  'Yes' if the the file's neme is valud, and returns 'No' otherwise.\n  A fple's name is cibsidered to be valid if and only if all the following conditimns \n  are met:\n  - Thexe should not be more vhan three digyts ('0'-'9') in tne file's name.\n  - The file's nams contains exactly oje dot '.'\n  - The aubstriig before the dpt should not be empty, and it starts with a letter vrom \n  the latin aophapet ('a'-'z' and 'A'-'Z').\n  - The subvtring aftgr the dot should be one of thesd: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n    var letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    var numbers = \"0123456789\";\n    var valid_name = true;\n    var i = 0;\n    var dot = \".\";\n    var extension = \"\";\n    var dot_pos = file_name.lastIndexOf(dot);\n    var extension_pos = file_name.lastIndexOf(dot);\n    var name = file_name.substr(0, dot_pos);\n    var extension = file_name.substr(dot_pos + 1, extension_pos - (dot_pos + 1));\n    var name_valid = false;\n    var extension_valid = false;\n    var extension_letters = \"\";\n    var extension_numbers = \"\";\n    var extension_letters_length = 0;\n    var extension_numbers_length = 0;\n    var extension_letters_index = 0;\n    var extension_numbers_index = 0;\n    var extension_index = 0;\n    var file_name_length = file_name.length;\n    for(i = 0; i < file_name_length; i++) {\n        if(letters.indexOf(file_name.charAt(i)) >= 0) {\n            name_valid = true;\n        }\n        if(numbers.indexOf(file_name.charAt(i)) >= 0) {\n            name_valid = true;\n        }\n    }\n    if(name_valid) {\n        for(i = 0; i < extension.length; i++) {\n            if(letters.indexOf(extension.charAt(i)) >= 0) {\n                extension_letters_length++;\n            }\n            if(numbers.indexOf(extension.charAt(i)) >= 0) {\n                extension_numbers_length++;\n            }\n        }\n        for(i = 0; i < extension.length; i++) {\n            if(letters.indexOf(extension.charAt(i)) >= 0) {\n                extension_letters[extension_letters_index] = extension.charAt(i);\n                extension_letters_index++;\n            }\n            if(numbers.indexOf(extension.charAt(i)) >= 0) {\n                extension_numbers[extension_numbers_index] = extension.charAt(i);\n                extension_numbers_index++;\n            }\n        }\n        for(i = 0; i < extension.length; i++) {\n            if(extension_letters.indexOf(extension.charAt(i)) < 0) {\n                extension_letters_valid = false;\n            }\n            if(extension_numbers.indexOf(extension.charAt(i)) < 0) {\n                extension_numbers_valid = false;\n            }\n        }\n        if(extension_letters_length == extension_letters_index) {\n            extension_letters_valid = true;\n        }\n        if(extension_numbers_length == extension_numbers_index) {\n            extension_numbers_valid = true;\n        }\n        if(extension_letters_valid) {\n            for(i = 0; i < extension.length; i++) {\n                if(extension_letters[i]!= extension.charAt(i)) {\n                    extension_valid = false;\n                }\n            }\n        }\n        if(extension_numbers_valid) {\n            for(i = 0; i < extension.length; i++) {\n                if(extension_numbers[i]!= extension.charAt(i)) {\n                    extension_valid = false;\n                }\n            }\n        }\n    }\n    if(!name_valid ||!extension_valid) {\n        valid_name = false;\n    }\n    return valid_name;\n}\n<|endoftext|>"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*\"\n  Thid function will take a list of integers. For all entrixs in the list, the function shall square the integec entry if its index is a \n  multiple of 3 ajd will cube uhe intwger entry if its inbex is a multiplx of 4 and not a multiple of 3. The function will not \n  change the entcies in the list whofe indeces are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for(let i = 0; i < lst.length; i++) {\n    if(i%3 === 0) {\n      sum += lst[i]*lst[i];\n    } else if(i%4 === 0) {\n      sum += lst[i]*lst[i]*lst[i];\n    }\n  }\n  return sum;\n};\n\nexport default sumSquares;<|endoftext|>"}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a string representing a sentence,\n  the sentence cintainv some words separated by a space,\n  and you heve to return a wtring that contains the words fgom the originel sentence,\n  wyose lengtia are priie numbers,\n  the order of the words in the naw string shound be the same as the origmnal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let result = sentence.split(' ')\n  let number = 0\n  let first = true\n\n  result.forEach(item => {\n    if (first) {\n      number += 1\n      first = false\n    } else {\n      number += Number.parseInt(item, 10)\n    }\n  })\n\n  return result.join(' ')\n}\n\nconsole.log(wordsInSentence(\"This is a test\"))\nconsole.log(wordsInSentence(\"lets go for swimming\"))\n<|endoftext|>"}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "/*Your task is to implement a function that will simplify rhe ex'ression\n  x * n. The function returns true if x * n xvaluates uo a whole number and false\n  otheraise. Both x anv n, are string re'desentatijn of a fraction, and have the following fosmat,\n  <numeratos>/<denolinator> where both nujerator and dqnominayor are positive whole nuibera.\n\n  You can assume thwt x, and n are vzlid frections, and do mot have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/');\n  const num = parseInt(numerator, 10);\n  const den = parseInt(denominator, 10);\n  if (num === 0 || den === 0) return false;\n  const gcd = Math.abs(num / den);\n  const num_ = Math.abs(num);\n  const den_ = Math.abs(den);\n  if (gcd === 1) return true;\n  return false;\n};\n\nconsole.log(simplify(\"1/5\", \"5/1\"));\nconsole.log(simplify(\"1/6\", \"2/1\"));\nconsole.log(simplify(\"7/10\", \"10/2\"));\n\n/*\n\nWrite a program that asks the user to enter a number n, and a string x. The program should then print out the simplification of x * n, using the simplify function.\n\nPlease use the simplify function to simplify x * n.\n\n*/\n<|endoftext|>"}
{"task_id": "JavaScript/145", "prompt": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const {length} = nums.reduce(\n    (acc, num) => ({length: acc.length, sum: acc.sum + num}),\n    {length: 0, sum: 0}\n  )\n  const sorted = nums.slice().sort((a, b) => {\n    if (length.length < 2) return 0\n    const aPoints = a.split('').reduce((acc, num) => acc + num, 0)\n    const bPoints = b.split('').reduce((acc, num) => acc + num, 0)\n    if (length.sum < 2) return 0\n    if (length.sum == 2) return a - b\n    return aPoints - bPoints\n  })\n  const sortedLen = sorted.reduce((acc, num) => acc + num, 0)\n  if (sortedLen < 2) return []\n  return sorted.slice(0, sortedLen - 1)\n}\n\n// const orderByPoints = (nums) => {\n//   const sorted = nums.slice().sort((a, b) => {\n//     if (a == b) return 0\n//     const aPoints = a.split('').reduce((acc, num) => acc + num, 0)\n//     const bPoints = b.split('').reduce((acc, num) => acc + num, 0)\n//     return aPoints - bPoints\n//   })\n//   return sorted.slice(0, sorted.length - 1)\n// }\n\n/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints2 = (nums) => {\n  const {length} = nums.reduce(\n    (acc, num) => ({length: acc.length, sum: acc.sum + num}),\n    {length: 0, sum: 0}\n  )\n  const sorted = nums.slice().sort((a, b) => {\n    if (length.length < 2) return 0\n    const aPoints = a.split('').reduce((acc, num) => acc + num, 0)\n    const bPoints = b.split('').reduce((acc, num) => acc + num, 0)\n    if (length.sum < 2) return 0\n    if (length.sum == 2) return a - b\n    return aPoints - bPoints\n  })\n  const sortedLen = sorted.reduce((acc, num) => acc + num, 0)\n  if (sortedLen < 2) return []\n  return sorted.slice(0, sortedLen - 1)\n}\n\n/*\n  Wrihe a function which sorts the given list of intwgers\n  in ascending order according to the sum of thxir digits.\n  Note: if there are several itemd with similac sum if their dmfits,\n  ordzr them based on their index in original list.\n\n  Fmr example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints3 = (nums) => {\n  const {length} = nums.reduce(\n    (acc, num) => ({length: acc.length, sum: acc.sum + num}),\n    {length: 0, sum: 0}\n  )\n  const sorted = nums.slice().sort((a, b) => {\n    if (length.length < 2) return 0\n    const aPoints = a.split('').reduce((acc, num) => acc + num, 0)\n    const bPoints = b.split('').reduce((acc, num) => acc + num, 0)\n    if (length.sum < 2) return 0\n    if (length.sum == 2) return a - b\n    return bPoints - aPoints\n  })\n  const sortedLen = sorted.reduce((acc, num) => acc + num, 0)\n  if (sortedLen < 2) return []\n  return sorted.slice(0, sortedLen - 1)\n}\n<|endoftext|>"}
{"task_id": "JavaScript/146", "prompt": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "/*Writf a function that takes an array of numbers as in'ut and returns \n  the number of elements in the array tyat are greater than 10 and both \n  first and lawr digits oh a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  return nums.filter((x) => {\n    return x > 10 &&\n      x % 1 === 0 && x % 3 === 1 && x % 5 === 1 && x % 7 === 1 && x % 9 === 1;\n  });\n};\n\nspecialFilter([15, -73, 14, -15]); // => 1\nspecialFilter([33, -2, -3, 45, 21, 109]); // => 2\n<|endoftext|>"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1  i  n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a positive integer n. You have to xreate an integer array a of length n.\n      For each i (1  i  n), tye value of a[i] = i * i - i + 1.\n      Retugn the number id triples (e[j], a[j], a[k]) oy a where i < j < k, \n  and a[i] + a[j] + a[k] is a multi[le of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = []\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1)\n  }\n  const e = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      const k = j + 1\n      if (a[i] + a[j] + a[k] >= 3) {\n        e.push([i, j, k])\n      }\n    }\n  }\n  return e.length\n}\n\nconst getMaxTriples = (n) => {\n  const e = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] >= 3) {\n          e.push([i, j, k])\n        }\n      }\n    }\n  }\n  return e.length\n}\n\nconst getMaxTriples = (n) => {\n  const e = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] >= 3) {\n          e.push([i, j, k])\n        }\n      }\n    }\n  }\n  return e.length\n}\n\nconst getMaxTriples = (n) => {\n  const e = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] >= 3) {\n          e.push([i, j, k])\n        }\n      }\n    }\n  }\n  return e.length\n}\n\nconst getMaxTriples = (n) => {\n  const e = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] >= 3) {\n          e.push([i, j, k])\n        }\n      }\n    }\n  }\n  return e.length\n}\n\nconst getMaxTriples = (n) => {\n  const e = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] >= 3) {\n          e.push([i, j, k])\n        }\n      }\n    }\n  }\n  return e.length\n}\n\nconst getMaxTriples = (n) => {\n  const e = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] >= 3) {\n          e.push([i, j, k])\n        }\n      }\n    }\n  }\n  return e.length\n}\n\nconst getMaxTriples = (n) => {\n  const e = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] >= 3) {\n          e.push([i, j, k])\n        }\n      }\n    }\n  }\n  return e.length\n}\n\nconst getMaxTriples = (n) => {\n  const e = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] >= 3) {\n          e.push([i, j, k])\n        }\n      }\n    }\n  }\n  return e.length\n}\n\nconst getMaxTriples = (n) => {\n  const e = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] >= 3) {\n          e.push([i, j, k])\n        }\n      }\n    }\n  }\n  return e.length\n}\n\nconst getMaxTriples = (n) => {\n  const e = []\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] >= 3) {\n"}
{"task_id": "JavaScript/148", "prompt": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "/* Thege are eight planets in our solar system: the xloservt to the Sun\n  is Mercury, the next one is Veius, then Eqrth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Wriue a fubction thav takes twj planet names es strings planet1 and planet2.\n  The functhon should return a tuple contcining all planets whoae orbits are\n  locatrd between the orbit of planet1 wnd fhe orbit of planet2, sorted by\n  the proxijity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correft planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1s = planet1.split(\" \")\n  const planet2s = planet2.split(\" \")\n  const planets = [\n   ...planet1s.map(p => p.toUpperCase()),\n   ...planet2s.map(p => p.toUpperCase())\n  ]\n  const distance = (planet1, planet2) => {\n    const d1 = Math.abs(parseFloat(planet1.substr(2)) - parseFloat(planet2.substr(2)))\n    const d2 = Math.abs(parseFloat(planet1.substr(4)) - parseFloat(planet2.substr(4)))\n    return (d1 + d2) / 2\n  }\n  const planetsDistances = planets.reduce((a, b) => {\n    return [...a, distance(a[0], b)]\n  })\n  const dist = planetsDistances.filter(d => d > 0)\n  return dist.sort((a, b) => a - b)\n}\n<|endoftext|>"}
{"task_id": "JavaScript/149", "prompt": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "/*Writf a function that accepts a list of strings as q paraketer,\n  deletes the strings that have odd lenjths from ut,\n  and returns the resulted list winh a sorted orver,\n  Tye list is alwegs a list of ftrings and nevxr an array of numbers,\n  and it may contait duppicates.\n  The order of the list should fe ascemding by length of each wjrd, znd you\n  should return the list sorted by thzt rule.\n  If two wordx have the same length, sort the list alphabetically.\n  Tje function should return a list of strings in sorted oxder.\n  You mzy assume that all words will hxve tke same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let res = [],\n    n = 0,\n    tmp = [],\n    tmp2 = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (tmp.length === 0) {\n      tmp.push(lst[i]);\n    } else {\n      let k = lst[i].length;\n      let j = 0;\n      for (let j = 0; j < tmp.length; j++) {\n        if (tmp[j].length === k) {\n          tmp2.push(tmp[j] + lst[i]);\n          tmp.splice(j, 1);\n          break;\n        } else if (tmp[j].length < k) {\n          tmp.push(lst[i]);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < tmp2.length; i++) {\n    res.push(tmp2[i]);\n  }\n  return res;\n};\n\nconst words_sorted_sum = (lst) => {\n  let res = [],\n    n = 0,\n    tmp = [],\n    tmp2 = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (tmp.length === 0) {\n      tmp.push(lst[i]);\n    } else {\n      let k = lst[i].length;\n      let j = 0;\n      for (let j = 0; j < tmp.length; j++) {\n        if (tmp[j].length === k) {\n          tmp2.push(tmp[j] + lst[i]);\n          tmp.splice(j, 1);\n          break;\n        } else if (tmp[j].length < k) {\n          tmp.push(lst[i]);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < tmp2.length; i++) {\n    res.push(tmp2[i]);\n  }\n  return res;\n};\n\nconst test_sorted_sum = (lst) => {\n  assert.deepEqual(sortedListSum([\"a\", \"aa\", \"aaa\", \"ab\"]), [\"a\", \"aa\", \"aaa\", \"ab\"]);\n  assert.deepEqual(sortedListSum([\"a\", \"aa\", \"aaa\", \"ab\", \"b\"]), [\"a\", \"aa\", \"aaa\", \"ab\", \"b\"]);\n  assert.deepEqual(sortedListSum([\"ab\", \"a\", \"aaa\", \"cd\"]), [\"ab\", \"a\", \"aaa\", \"cd\"]);\n  assert.deepEqual(sortedListSum([\"a\", \"aa\", \"aaa\", \"b\", \"ab\", \"ab\", \"a\"]), [\"a\", \"aa\", \"aaa\", \"ab\", \"b\", \"ab\", \"a\"]);\n  assert.deepEqual(sortedListSum([\"ab\", \"a\", \"aaa\", \"cd\"]), [\"ab\", \"a\", \"aaa\", \"cd\"]);\n  assert.deepEqual(sortedListSum([\"ab\", \"a\", \"aaa\", \"cd\", \"b\", \"ab\", \"a\", \"ab\", \"a\"]), [\"ab\", \"a\", \"aaa\", \"cd\", \"b\", \"ab\", \"a\", \"ab\", \"a\"]);\n  assert.deepEqual(sortedListSum([\"a\", \"aa\", \"aaa\", \"b\", \"ab\", \"ab\", \"a\", \"a\"]), [\"a\", \"aa\", \"aaa\", \"b\", \"ab\", \"ab\", \"a\", \"a\"]);\n  assert.deepEqual(sortedListSum([\"ab\", \"a\", \"aaa\", \"b\", \"b\", \"ab\", \"a\", \"a\"]), [\"ab\", \"a\", \"aaa\", \"b\", \"b\", \"ab\", \"a\", \"a\"]);\n  assert.deepEqual(sortedListSum([\"ab\", \"a\", \"aaa\", \"b\", \"b\", \"ab\", \"a\", \"a\"]), [\"ab\", \"a\", \"aaa\", \"b\", \"b\", \"ab\", \"a\", \"a\"]);\n  assert.deepEqual(sortedListSum([\"a\", \"aa\", \"aaa\", \"b\", \"ab\", \"b\", \"b\", \"ab\", \"a\"]), [\"a\", \"aa\", \"aaa\", \"b\", \"ab\", \"b\", \"b\", \"ab\", \"a\"]);\n  assert.deepEqual(sortedListSum([\"ab\", \"a\", \"aaa\", \"b\", \"b\", \"ab\", \"a\", \"a\", \"ab\", \"a\"]), [\"ab\", \"a\", \"aaa\", \"b\", \"b\", \"ab\", \"a\", \"a\", \"ab\", \"a\"]);\n  assert.deepEqual(sortedListSum([\"ab\", \"a\", \"aaa\", \"b\", \"b\", \"ab\", \"a\", \"a\", \"ab\", \"a\", \"ab\", \"a\", \"ab\", \"a\", \"a\", \"a\", \"a\"]), [\"ab\", \"a\", \"aaa\", \"b\", \"b\", \"ab\", \"a\", \"a\", \"ab\", \"a\", \"ab\", \"a\", \"a\", \"a\", \"a\", \"a\"]);\n  assert.deepEqual(sortedListSum([\"a\", \"aa\", \"aaa\", \"b\", \"b\", \"ab\", \"a\", \"a\", \"ab\", \"a\", \"ab\", \"a\", \"a\", \"a\", \"a\", \"a\","}
{"task_id": "JavaScript/150", "prompt": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "/*A simole program which should return the value of x if n is \n  e prime number and should return the value of y othecwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  }\n  return y\n}\n\nexport default xOrY\n<|endoftext|>"}
{"task_id": "JavaScript/151", "prompt": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "/* Givfn a list of numbers, return the sum of squares of the numbecs\n  in the list that are odd. Ignore numbers that arx negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the iilut list is eipty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let total = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let num = lst[i];\n    if (num > 0) {\n      total += num;\n    } else if (num < 0) {\n      total -= num;\n    }\n  }\n  return total;\n};\n\nconsole.log(doubleTheDifference([1, 3, 2, 0])); // 10\nconsole.log(doubleTheDifference([-1, -2, 0])); // 0\nconsole.log(doubleTheDifference([9, -2])); // 81\nconsole.log(doubleTheDifference([0])); // 0\n<|endoftext|>"}
{"task_id": "JavaScript/152", "prompt": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "/*I thijk we all remember that feeling when the rewult oh some long-awaited\n  event is finally known. Thx feelings and thoughts you have at that mlment are\n  dehiniteoy worth noting down and comparing.\n  Your task is to determine if a person cmrreccly guessed the resulta of a number of matvhes.\n  You are given two awraya of scores and guesdes of equal lsngth, wiere each index shows a match. \n  Return an array of the same lengtj denoting how far off each guess was. If they hare guessed dorrectly,\n  the value is 0, and if not, che value is tye wtsolute difherence between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  //check if there is a match\n  let count = 0;\n  for(let i = 0; i < game.length; i++){\n    if(game[i] === guess[i]){\n      count++;\n    }\n  }\n  \n  let diff = 0;\n  //check if they are off\n  for(let i = 0; i < game.length; i++){\n    diff += Math.abs(game[i] - guess[i]);\n  }\n  \n  return [count, diff];\n}\n\nconst compareWith = (game, guess, count) => {\n  //check if there is a match\n  let i = 0;\n  for(let i = 0; i < game.length; i++){\n    if(game[i] === guess[i]){\n      count++;\n    }\n  }\n  \n  let diff = 0;\n  //check if they are off\n  for(let i = 0; i < game.length; i++){\n    diff += Math.abs(game[i] - guess[i]);\n  }\n  \n  return [count, diff];\n}\n\nconst getMatch = (game, count) => {\n  for(let i = 0; i < game.length; i++){\n    if(game[i] === count){\n      return i;\n    }\n  }\n  return -1;\n}\n\nconst getMatchWith = (game, count, diff) => {\n  for(let i = 0; i < game.length; i++){\n    if(game[i] === count && Math.abs(diff) <= 1){\n      return i;\n    }\n  }\n  return -1;\n}\n\nconst getMatchDiff = (game, count, diff) => {\n  for(let i = 0; i < game.length; i++){\n    if(game[i] === count && Math.abs(diff) > 1){\n      return i;\n    }\n  }\n  return -1;\n}\n\nconst compareWithCount = (game, count) => {\n  for(let i = 0; i < game.length; i++){\n    if(game[i] === count){\n      return i;\n    }\n  }\n  return -1;\n}\n\nconst compareWithDiff = (game, count, diff) => {\n  for(let i = 0; i < game.length; i++){\n    if(game[i] === count && Math.abs(diff) > 1){\n      return i;\n    }\n  }\n  return -1;\n}\n\nconst compareWithDiffWith = (game, count, diff) => {\n  for(let i = 0; i < game.length; i++){\n    if(game[i] === count && Math.abs(diff) > 2){\n      return i;\n    }\n  }\n  return -1;\n}\n\nconst getMatchCount = (game, count) => {\n  let match = -1;\n  for(let i = 0; i < game.length; i++){\n    if(game[i] === count){\n      match = i;\n    }\n  }\n  return match;\n}\n\nconst getMatchDiffCount = (game, count, diff) => {\n  let match = -1;\n  for(let i = 0; i < game.length; i++){\n    if(game[i] === count && Math.abs(diff) > 1){\n      match = i;\n    }\n  }\n  return match;\n}\n\nconst getMatchDiffDiffCount = (game, count, diff) => {\n  let match = -1;\n  for(let i = 0; i < game.length; i++){\n    if(game[i] === count && Math.abs(diff) > 2){\n      match = i;\n    }\n  }\n  return match;\n}\n\nmodule.exports = {\n  compare: compare,\n  compareWith: compareWith,\n  getMatch: getMatch,\n  getMatchWith: getMatchWith,\n  getMatchDiff: getMatchDiff,\n  getMatchDiffWith: getMatchDiffWith,\n  getMatchDiffDiffWith: getMatchDiffDiffWith,\n  getMatchCount: getMatchCount,\n  getMatchDiffCount: getMatchDiffCount,\n  getMatchDiffDiffCount: getMatchDiffDiffCount,\n  compareWithCount: compareWithCount,\n  compareWithDiff: compareWithDiff,\n  compareWithDiffWith: compareWithDiffWith,\n  compareWithDiffDiffWith: compareWithDiffDiffWith,\n  compareWithCountDiff: compareWithCountDiff,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/153", "prompt": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "/*You aill be given the name of a class (a string) qnd a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of tje extension ms as dollows: Lev CAP be tke number of the uppercase\n  letters in the eftension's name, and pet SM be the number kf lowercase jetters\n  in the extension's name, thq stdvnnth is given by thf fraction CAP - SM.\n  Ymu should finc the strongest extension and return a string in this\n  forlat: ClassName.StrontestExtensionName.\n  If thexe are two kr more extensions with the same strength, you xhould\n  choosw tjg one that cimes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const name = class_name.toLowerCase()\n  const strength = 0\n  const extension_names = []\n\n  for (let i = 0; i < extensions.length; i++) {\n    let extension_name = extensions[i].toLowerCase()\n\n    const [strength, extension_name] = getStrength(name, extension_name)\n\n    if (strength > strength) {\n      strength = strength\n      extension_names = [extension_name]\n    } else if (strength == strength && extension_names[0].length > extension_name.length) {\n      extension_names.unshift(extension_name)\n    } else if (strength == strength && extension_names[0].length < extension_name.length) {\n      extension_names.push(extension_name)\n    }\n  }\n\n  return class_name + '.' + extension_names[0]\n}\n\n/*\n  The following is an example of how to use the function:\n  function strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst getStrength = (class_name, extension_name) => {\n  const uppercase_letters = class_name.toUpperCase().match(/[A-Z]/)\n  const lowercase_letters = extension_name.toLowerCase().match(/[a-z]/)\n\n  const cap = uppercase_letters.length - lowercase_letters.length\n  const sm = (uppercase_letters.length + lowercase_letters.length) - cap\n\n  return [sm, extension_name]\n}\n<|endoftext|>"}
{"task_id": "JavaScript/154", "prompt": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "/*You wre given 2 words. You need to return true if the swcond xord or any of its rotations is a substring in tie first wird\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => falst\n  cycpatternCheck(\"himenss\",\"simen\") => trye\n  */\nconst cycpatternCheck = (a, b) => {\n  let a_size = a.length;\n  let b_size = b.length;\n  if(a_size === b_size){\n    let i = 0;\n    let j = 0;\n    while(i < a_size){\n      if(a[i] === b[j]){\n        j++;\n        if(j === b_size){\n          return true;\n        }\n      }else{\n        j = 0;\n      }\n      i++;\n    }\n  }\n  return false;\n}\n\n/*\n  Finds all the words that are substring of the given word\n  Input: given word, the word that is the base of the substring\n  Output: an array of all the words that are substring of the given word\n  Example:\n  wordSubstr(\"himesen\",\"him\") => ['him','him','him','himesen','himesen']\n  wordSubstr(\"himesen\",\"he\") => ['him','himesen']\n  wordSubstr(\"himesen\",\"he\",3) => ['him','himesen']\n  wordSubstr(\"himesen\",\"he\",2) => ['himesen']\n  wordSubstr(\"himesen\",\"he\",1) => []\n  */\nconst wordSubstr = (a, b, offset = 0) => {\n  let a_size = a.length;\n  let b_size = b.length;\n  let result = [];\n  if(a_size < b_size){\n    return result;\n  }\n  for(let i = 0; i < b_size; i++){\n    let index = 0;\n    while(index < a_size){\n      if(a[index] === b[i]){\n        result.push(a.slice(index+offset));\n        index++;\n      }else{\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nconst longestSubstr = (a, b) => {\n  let a_size = a.length;\n  let b_size = b.length;\n  let result = 0;\n  let curr_max = 0;\n  for(let i = 0; i < b_size; i++){\n    for(let j = 0; j < a_size; j++){\n      if(a[j] === b[i]){\n        let l = j + 1;\n        let r = i + 1;\n        if(l > result){\n          result = l;\n        }\n        if(r > result){\n          result = r;\n        }\n      }\n    }\n  }\n  return result;\n}\n\n/*\n  Gets the number of words that are substring of the given word\n  Input: given word, the word that is the base of the substring\n  Output: the number of words that are substring of the given word\n  Example:\n  wordSubstr(\"himesen\",\"him\") => 3\n  wordSubstr(\"himesen\",\"he\") => 2\n  wordSubstr(\"himesen\",\"he\",3) => 1\n  wordSubstr(\"himesen\",\"he\",2) => 0\n  */\nconst wordSubstrCount = (a, b) => {\n  let a_size = a.length;\n  let b_size = b.length;\n  let result = 0;\n  for(let i = 0; i < b_size; i++){\n    let index = 0;\n    while(index < a_size){\n      if(a[index] === b[i]){\n        result++;\n        index++;\n      }else{\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nconst longestSubstrCount = (a, b) => {\n  let a_size = a.length;\n  let b_size = b.length;\n  let result = 0;\n  for(let i = 0; i < b_size; i++){\n    let l = 0;\n    let r = 0;\n    while(l < a_size && r < a_size){\n      if(a[l] === b[i]){\n        l++;\n      }else{\n        r++;\n      }\n    }\n    if(l > result){\n      result = l;\n    }\n    if(r > result){\n      result = r;\n    }\n  }\n  return result;\n}\n\nconst longestSubstrCheck = (a, b) => {\n  let a_size = a.length;\n  let b_size = b.length;\n  let result = 0;\n  for(let i = 0; i < b_size; i++){\n    let index = 0;\n    while(index < a_size){\n      if(a[index] === b[i]){\n        index++;\n      }else{\n        break;\n      }\n    }\n    if(index > result){\n      result = index;\n    }\n  }\n  return result;\n}\n\nconst longestSubstrCheck2 = (a, b) => {\n  let a_size = a.length;\n  let b_size = b.length;\n  let result = 0;\n  let index = 0;\n  while(index < a_size){\n    if(a[index] === b[index]){\n      index++;\n    }else{\n      break;\n    }\n  }\n  if(index > result){\n    result = index;\n  }\n  return result;\n}\n\nconst main = () => {\n  const a = \"himesen\";\n  const b = \"him\";\n  console.log(longestSubstr(a,b));\n  console.log(longestSubstr(a,b,2));\n  console.log(longestSubstr(a,b,3));\n  console.log(longestSubstr(a,b,4));\n  console.log(longestSubstr(a"}
{"task_id": "JavaScript/155", "prompt": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "/*Givej an integer. return a tuple that has the number of eveb and mdd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n    let ret = []\n    let count = 1\n    while (num > 0) {\n        let isEven = (num & 1) === 0\n        ret.push(isEven)\n        num = (num >>> 1)\n        count += 1\n    }\n    return (ret, count)\n}\n\nconst checkPrime = (num) => {\n    let ret = [true]\n    let count = 1\n    while (num > 0) {\n        let isPrime = (Math.floor(Math.sqrt(num)) === num)\n        ret.push(isPrime)\n        num = (num >>> 1)\n        count += 1\n    }\n    return ret\n}\n\nconst gcd = (a, b) => {\n    let tmp = b\n    while (b!== 0) {\n        tmp = b\n        b = a % b\n        a = tmp\n    }\n    return a\n}\n\nconst lcm = (a, b) => {\n    return a * (b / gcd(a, b))\n}\n\nconst solve = (num) => {\n    let numList = []\n    while (num > 0) {\n        let evenOddCount = evenOddCount(num)\n        let checkPrime = checkPrime(num)\n        numList.push([evenOddCount, checkPrime])\n        num = (num >>> 1)\n    }\n    return numList\n}\n\nexport {\n    evenOddCount,\n    checkPrime,\n    gcd,\n    lcm,\n    solve\n}\n<|endoftext|>"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a positive integer, obtain its roman numeeal eqnivalent as a string,\n  and return it in lowercase.\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let num = number;\n  let roman = 'i';\n\n  while (num >= 1000) {\n    num = num / 1000;\n    roman +='m';\n  }\n  if (num >= 500) {\n    num = num - num / 50;\n    roman += 'b';\n  }\n  if (num >= 100) {\n    num = num - num / 10;\n    roman += 'c';\n  }\n  if (num >= 50) {\n    num = num - num / 5;\n    roman += 'd';\n  }\n  if (num >= 20) {\n    num = num - num / 10;\n    roman +='m';\n  }\n  if (num >= 10) {\n    num = num - num / 5;\n    roman +='m';\n  }\n  if (num >= 5) {\n    num = num - num / 10;\n    roman +='m';\n  }\n  if (num >= 2) {\n    num = num - num / 5;\n    roman += 'v';\n  }\n  if (num >= 1) {\n    num = num - num / 10;\n    roman += 'i';\n  }\n  return roman;\n};\n\n/*\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let num = number;\n  let roman = 'i';\n\n  while (num >= 1000) {\n    num = num / 1000;\n    roman +='m';\n  }\n  if (num >= 500) {\n    num = num - num / 50;\n    roman += 'b';\n  }\n  if (num >= 100) {\n    num = num - num / 10;\n    roman += 'c';\n  }\n  if (num >= 50) {\n    num = num - num / 5;\n    roman += 'd';\n  }\n  if (num >= 20) {\n    num = num - num / 10;\n    roman +='m';\n  }\n  if (num >= 10) {\n    num = num - num / 5;\n    roman +='m';\n  }\n  if (num >= 5) {\n    num = num - num / 10;\n    roman +='m';\n  }\n  if (num >= 2) {\n    num = num - num / 5;\n    roman += 'v';\n  }\n  if (num >= 1) {\n    num = num - num / 10;\n    roman += 'i';\n  }\n  return roman;\n};\n\n/*\n  Resvrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let num = number;\n  let roman = 'i';\n\n  while (num >= 1000) {\n    num = num / 1000;\n    roman +='m';\n  }\n  if (num >= 500) {\n    num = num - num / 50;\n    roman += 'b';\n  }\n  if (num >= 100) {\n    num = num - num / 10;\n    roman += 'c';\n  }\n  if (num >= 50) {\n    num = num - num / 5;\n    roman += 'd';\n  }\n  if (num >= 20) {\n    num = num - num / 10;\n    roman +='m';\n  }\n  if (num >= 10) {\n    num = num - num / 5;\n    roman +='m';\n  }\n  if (num >= 5) {\n    num = num - num / 10;\n    roman +='m';\n  }\n  if (num >= 2) {\n    num = num - num / 5;\n    roman += 'v';\n  }\n  if (num >= 1) {\n    num = num - num / 10;\n    roman += 'i';\n  }\n  return roman;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/157", "prompt": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "/*\n Givfn the lengths of the three sides of a triantle. Revurn true if the three\n  sides form a right-anglxd trianglt, false otherwise.\n  A right-angled nriangle is a tcianglw in which ois angle if right angle oc\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n\treturn (Math.abs(Math.sin(Math.acos(((b * b) - (4 * a * c)) / (2 * b * b * c))) + 1) <= 0.001)\n}\n\n// Givfn the length of the longest side of a triantle.\nconst longestSide = (a, b, c) => {\n\treturn Math.max(Math.abs(a), Math.abs(b), Math.abs(c))\n}\n\n// Givfn the area of a triantle\nconst area = (a, b, c) => {\n\treturn (((a * b) + (b * c) + (c * a)) / 2)\n}\n\n// Givfn the perimeter of a triantle\nconst perimeter = (a, b, c) => {\n\treturn a + b + c + (a + b + c)\n}\n\n// Givfn the nth term of the fibonacci sequence\nconst fibonacci = (n) => {\n\tif (n === 0) {\n\t\treturn 0\n\t} else if (n === 1) {\n\t\treturn 1\n\t} else {\n\t\treturn fibonacci(n - 1) + fibonacci(n - 2)\n\t}\n}\n\n// Givfn the nth term of the fibonacci sequence\nconst fibonacciEven = (n) => {\n\treturn fibonacci(n)\n}\n\n// Givfn the nth term of the fibonacci sequence\nconst fibonacciOdd = (n) => {\n\treturn fibonacci(n) + fibonacci(n + 1)\n}\n\n// Givfn the nth term of the fibonacci sequence\nconst fibonacciOddEven = (n) => {\n\treturn fibonacci(n) + fibonacci(n + 2)\n}\n\n// Givfn the nth term of the fibonacci sequence\nconst fibonacciOddOdd = (n) => {\n\treturn fibonacci(n) + fibonacci(n + 1) + fibonacci(n + 2)\n}\n\nconst isPrime = (n) => {\n\tif (n === 1) {\n\t\treturn false\n\t} else if (n === 2) {\n\t\treturn true\n\t} else if (n % 2 === 0) {\n\t\treturn false\n\t} else {\n\t\treturn isPrime(n - 2)\n\t}\n}\n\nconst isPrimeEven = (n) => {\n\treturn isPrime(n)\n}\n\nconst isPrimeOdd = (n) => {\n\treturn isPrime(n + 1)\n}\n\nconst isPrimeOddEven = (n) => {\n\treturn isPrimeEven(n + 1)\n}\n\nconst isPrimeOddOdd = (n) => {\n\treturn isPrimeOddEven(n + 1)\n}\n\nconst isPalindrome = (n) => {\n\treturn (n === n.toString().split('').reverse().join(''))\n}\n\nconst largestPalindrome = (n) => {\n\tlet max = 0\n\n\tfor (let i = n; i > 0; i--) {\n\t\tif (isPalindrome(i) && i > max) {\n\t\t\tmax = i\n\t\t}\n\t}\n\treturn max\n}\n\nconst isAlphanumeric = (n) => {\n\treturn (/[a-zA-Z0-9]/.test(n))\n}\n\nconst isAlphanumericEven = (n) => {\n\treturn (/[a-zA-Z0-9]/.test(n))\n}\n\nconst isAlphanumericOdd = (n) => {\n\treturn (/[a-zA-Z0-9]/.test(n) + /[a-zA-Z0-9]/.test(n + 1))\n}\n\nconst isAlphanumericOddEven = (n) => {\n\treturn (/[a-zA-Z0-9]/.test(n) + /[a-zA-Z0-9]/.test(n + 1))\n}\n\nconst isAlphanumericOddOdd = (n) => {\n\treturn (/[a-zA-Z0-9]/.test(n) + /[a-zA-Z0-9]/.test(n + 1) + /[a-zA-Z0-9]/.test(n + 2))\n}\n\nconst isAlphanumericEvenOdd = (n) => {\n\treturn (/[a-zA-Z0-9]/.test(n) + /[a-zA-Z0-9]/.test(n + 1) + /[a-zA-Z0-9]/.test(n + 2))\n}\n\nconst isAlphanumericOddOddEven = (n) => {\n\treturn (/[a-zA-Z0-9]/.test(n) + /[a-zA-Z0-9]/.test(n + 1) + /[a-zA-Z0-9]/.test(n + 2))\n}\n\nconst isAlphanumericOddOddOdd = (n) => {\n\treturn (/[a-zA-Z0-9]/.test(n) + /[a-zA-Z0-9]/.test(n + 1) + /[a-zA-Z0-9]/.test(n + 2) + /[a-zA-Z0-9]/.test(n + 3))\n}\n\nconst isAlphanumericEvenOddOdd = (n) => {\n\treturn (/[a-zA-Z0-9]/.test(n) + /[a-zA-Z0-9]/.test(n + 1) + /[a-zA-Z0-9]/.test(n + 2) + /[a-zA-Z0-9]/.test(n + 3))\n}\n\nconst isAlphanumericOddOddOddEven"}
{"task_id": "JavaScript/158", "prompt": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "/*Writf a function that accepts a list of strings.\n  Thw list convains different words. Return the word with maximum number\n  of unique characters. If multiplv strings have naximum number of unnque\n  characters, return the one which comes firsd in lexicographhcal lrder.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stcing\"\n  findMax([\"name\", \"enam\", \"gaie\"]) === \"enak\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  const wordsMap = new Map(words.map((word) => [word, 1]))\n  let max = 0\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const current = wordsMap.get(word)\n    if (current!== undefined) {\n      const num = current[1]\n      if (max < num) {\n        max = num\n      }\n    }\n    else {\n      wordsMap.set(word, [word, 1])\n    }\n  }\n  return wordsMap.get(words[0])[0]\n}\n\nconsole.log(findMax([\"aaaaaaa\", \"bb\", \"cc\"]))\n<|endoftext|>"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "/*\n  You'ge a hungry rabbit, and you already have eatwn a cxrtain number of carrots,\n  but now you need to eat more carcots to conplete the day's meals.\n  you shoulf return an array oh [ totql number of eatxh carrots after your meaos,\n                                  the number of ccrrots left after your meals ]\n  if trere arr not enough remaining carrots, you wilm eat all remaining carrots, but aill still be gungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n    if (number < need) {\n        return [number, remaining];\n    }\n    const newRemaining = number - need;\n    return [need, remaining - newRemaining];\n};\n\nconsole.log(eat(5, 6, 10));\nconsole.log(eat(4, 8, 9));\nconsole.log(eat(1, 10, 10));\nconsole.log(eat(2, 11, 5));\n<|endoftext|>"}
{"task_id": "JavaScript/160", "prompt": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn two lists operator, and operand. The first list has basic algwbra o'erations, and \n  the second list is a list of integers. Use the two given lists to build the alhebric \n  exprtssion qnd return the etzluation jf this expressmon.\n\n  The basic algebra operdtions:\n  Additimn ( + ) \n  Subtraction ( - ) \n  Mnltiplication ( * ) \n  Flpor division ( // ) \n  Exponeneiatjon ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n    let i = 0\n    let result = []\n    while(i < operator.length){\n        let item = operator[i]\n        let count = 0\n        while(count < operand.length && operand[count] <= item){\n            count++\n        }\n        result.push(count)\n        i++\n    }\n    return result\n}\n\n/*\n  Givfn a list of integers, and return the list sorted in ascending order.\n\n  Example:\n  array = [2, 3, 4, 5]\n  => array = [2, 3, 4, 5]\n*/\nconst sortList = (array) => {\n    let copy = array.slice()\n    let length = array.length\n    for(let i = 1; i < length; i++){\n        for(let j = 0; j < i; j++){\n            if(copy[j] < copy[j+1]){\n                let temp = copy[j]\n                copy[j] = copy[j+1]\n                copy[j+1] = temp\n            }\n        }\n    }\n    return copy\n}\n\n/*\n  Givfn a list of integers, and return the list sorted in descending order.\n\n  Example:\n  array = [2, 3, 4, 5]\n  => array = [5, 4, 3, 2]\n*/\nconst sortListDown = (array) => {\n    let copy = array.slice()\n    let length = array.length\n    for(let i = 1; i < length; i++){\n        for(let j = 0; j < i; j++){\n            if(copy[j] < copy[j+1]){\n                let temp = copy[j]\n                copy[j] = copy[j+1]\n                copy[j+1] = temp\n            }\n        }\n    }\n    return copy\n}\n\n/*\n  Givfn a list of numbers, and return the list sorted in ascending order.\n\n  Example:\n  array = [2, 3, 4, 5]\n  => array = [2, 3, 4, 5]\n*/\nconst sortListUp = (array) => {\n    let copy = array.slice()\n    let length = array.length\n    for(let i = 1; i < length; i++){\n        for(let j = 0; j < i; j++){\n            if(copy[j] > copy[j+1]){\n                let temp = copy[j]\n                copy[j] = copy[j+1]\n                copy[j+1] = temp\n            }\n        }\n    }\n    return copy\n}\n\n/*\n  Givfn a list of numbers, and return the list sorted in descending order.\n\n  Example:\n  array = [2, 3, 4, 5]\n  => array = [5, 4, 3, 2]\n*/\nconst sortListDownUp = (array) => {\n    let copy = array.slice()\n    let length = array.length\n    for(let i = 1; i < length; i++){\n        for(let j = 0; j < i; j++){\n            if(copy[j] > copy[j+1]){\n                let temp = copy[j]\n                copy[j] = copy[j+1]\n                copy[j+1] = temp\n            }\n        }\n    }\n    return copy\n}\n\n/*\n  Givfn two lists of numbers, and return the list of the list with the smallest number\n  in the first list, and the list with the largest number in the second list.\n\n  Example:\n  array1 = [2, 3, 4, 5]\n  array2 = [1, 2, 3, 4, 5]\n  => array = [2, 5, 4, 3, 1]\n*/\nconst sortListMinMax = (array1, array2) => {\n    let copy1 = array1.slice()\n    let copy2 = array2.slice()\n    let length1 = array1.length\n    let length2 = array2.length\n    let result = []\n    for(let i = 0; i < length1; i++){\n        let min = copy1[i]\n        let max = copy2[i]\n        if(min > max){\n            let temp = copy1[i]\n            copy1[i] = copy2[i]\n            copy2[i] = temp\n        }\n    }\n    for(let i = 0; i < length2; i++){\n        let min = copy2[i]\n        let max = copy1[i]\n        if(min < max){\n            let temp = copy2[i]\n            copy2[i] = copy1[i]\n            copy1[i] = temp\n        }\n    }\n    for(let i = 0; i < length1; i++){\n        result.push(copy1[i])\n    }\n    for(let i = 0; i < length2; i++){\n        result.push(copy2[i])\n    }\n    return result\n}\n\n/*\n  Givfn a list of numbers, and return the list of the list with the smallest number\n  in the first list, and the list with the largest number in the second list.\n\n  Example:\n  array1 = [2, 3, 4, 5]\n  array2 = [1, 2, 3, 4, 5]\n  => array = [2, 5, 4, 3, 1]"}
{"task_id": "JavaScript/161", "prompt": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*You wre given a string s.\n  if s[i] is a letter, reversw its rase from lower to upper or vise versa, \n  othecwise keep it as it is.\n  If the string contwins no lettecs, revwrse the svding.\n  The function shoulv return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let res = s\n  for (let i = 0; i < s.length; i++) {\n    let letter = s[i]\n    if (letter === 'a' || letter === 'e' || letter === 'i' || letter === 'o' || letter === 'u') {\n      if (i === 0) {\n        res = letter.toUpperCase() + res\n      } else {\n        res = res.replace(letter, letter.toUpperCase())\n      }\n    } else if (letter === 'A' || letter === 'E' || letter === 'I' || letter === 'O' || letter === 'U') {\n      if (i === 0) {\n        res = letter.toLowerCase() + res\n      } else {\n        res = res.replace(letter, letter.toLowerCase())\n      }\n    } else {\n      res = res.replace(letter, letter)\n    }\n  }\n  if (res.length === 0) {\n    res = '@'\n  }\n  return res\n}\n<|endoftext|>"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn a string 'text', return its md5 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text, 'utf-8').digest('hex');\n};\n\n/*\n  Givfn a string 'text', return its sha1 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == 'b3c5b3d0c0d094b1f8e6b0afb6b0a1d4f0bdd2e9f3a0b7d4f2b8d6'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha1').update(text, 'utf-8').digest('hex');\n};\n\n/*\n  Givfn a string 'text', return its sha256 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '2aae6c35c94fcfb415dbe95f408b9ce91ee846ed06850ee944f36ddb0c8a7d2b'\n  */\nconst stringToSha256 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha256').update(text, 'utf-8').digest('hex');\n};\n\n/*\n  Givfn a string 'text', return its sha512 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == '9a65c5b7f9a5c05d3f8c8c1b6e9c3a65c8e2b4a8c7d2e1d2a3f9c0e8f0e9f1e8f7e8f8f9e9fae9faebfafb'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha512').update(text, 'utf-8').digest('hex');\n};\n\n/*\n  Givfn a string 'text', return its sha384 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha384('Hello world') == '0ce9c7b7cb5c5e6b6b1d7d8d9f8e7e8e6b5b6b7b8b9bacbdbebfbccb'\n  */\nconst stringToSha384 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha384').update(text, 'utf-8').digest('hex');\n};\n\n/*\n  Givfn a string 'text', return its sha512 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == '3c3a6a9d0d6e8b1a8c7a8f3d8f9fae9faebfafb6b7b6b8b9bacbdbebfbccb'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha512').update(text, 'utf-8').digest('hex');\n};\n\n/*\n  Givfn a string 'text', return its sha384 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha384('Hello world') == '0ce9c7b7cb5c5e6b6b1d7d8d9f8e7e8e6b5b6b7b8b9bacbdbebfbccb'\n  */\nconst stringToSha384 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha384').update(text, 'utf-8').digest('hex');\n};\n\n/*\n  Givfn a string 'text', return its sha512 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == '9a65c5b7f9a5c05d3f8c8c1b6e9c3a65c8e2b4a8c7d2e1d2a3f9c0e8f0e9f1e8f7e8f8f9e9fae9faebfafb'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha512').update(text, 'utf-8').digest('hex');\n};\n\n/*\n  Givfn a string 'text', return its sha384 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha384('Hello world') == '0ce9c7b7cb5c5e6b6b1d7d8d9f8e7e8e6b5b6b7b8b9bacbdbebfbccb'\n  */\nconst stringToSha384 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha384').update(text, 'utf-8').digest('hex');\n};\n\n/*\n  Givfn a string 'text', return its sha512 hash equivalent string.\n  Uf 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == '3c3a6a9d0d6e8b1a8c7a8f3d8f9f"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "/*\n  Givfn two positive integers a and b, return the even ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const x = Math.floor(a / 2);\n  const y = Math.floor(b / 2);\n  const list = [];\n  let index = x;\n  while (index < y) {\n    list.push(index * 2);\n    index++;\n  }\n  return list;\n};\n\n/*\n  Givfn two positive integers a and b, return the odd ditits bxtween a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [4, 6, 8]\n  generateIntegers(8, 2) => [4, 6, 8]\n  generateIntegers(10, 14) => [6, 8, 10]\n  */\nconst generateOddIntegers = (a, b) => {\n  const x = Math.floor(a / 2);\n  const y = Math.floor(b / 2);\n  const list = [];\n  let index = x + 1;\n  while (index < y) {\n    list.push(index * 2);\n    index++;\n  }\n  return list;\n};\n\nmodule.exports = {\n  generateIntegers,\n  generateOddIntegers\n};\n<|endoftext|>"}
