{"task_id": "JavaScript/0", "prompt": "/* Check if in gave list of numbers, was any two numbers closer to each other than \n   gave threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "/* Check if in gave list of numbers, was any two numbers closer to each other than \n   gave threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const closeElements = []\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = i + 1; j < numbers.length; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        closeElements.push(numbers[i], numbers[j])\n      }\n    }\n  }\n  return closeElements.length > 0\n}\n\n/*\n  Check if in given list of numbers, was any number greater than given number.\n  >>> hasGreaterElements([1.0, 2.0, 3.0], 3.0)\n  false\n  >>> hasGreaterElements([3.0, 2.0, 1.0], 3.0)\n  true\n  */\nconst hasGreaterElements = (numbers, number) => {\n  const greaterElements = []\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > number) {\n      greaterElements.push(numbers[i])\n    }\n  }\n  return greaterElements.length > 0\n}\n\n/*\n  Check if in given list of numbers, was any number less than given number.\n  >>> hasLessElements([3.0, 2.0, 1.0], 3.0)\n  true\n  >>> hasLessElements([1.0, 2.0, 3.0], 3.0)\n  false\n  */\nconst hasLessElements = (numbers, number) => {\n  const lessElements = []\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < number) {\n      lessElements.push(numbers[i])\n    }\n  }\n  return lessElements.length > 0\n}\n\n/*\n  Check if in given list of numbers, was any number between given numbers.\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 3.0, 2.0)\n  false\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 3.0, 3.0)\n  true\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 3.0, 4.0)\n  true\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 4.0, 3.0)\n  false\n  */\nconst hasBetweenElements = (numbers, lower, upper) => {\n  const betweenElements = []\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > lower && numbers[i] < upper) {\n      betweenElements.push(numbers[i])\n    }\n  }\n  return betweenElements.length > 0\n}\n\n/*\n  Check if in given list of numbers, was any number between given numbers.\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 1.0, 3.0, 2.0)\n  true\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 1.0, 3.0, 3.0)\n  true\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 1.0, 3.0, 4.0)\n  false\n  */\nconst hasBetweenElementsGreater = (numbers, lower, upper) => {\n  const betweenElements = []\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] >= lower && numbers[i] <= upper) {\n      betweenElements.push(numbers[i])\n    }\n  }\n  return betweenElements.length > 0\n}\n\n/*\n  Check if in given list of numbers, was any number between given numbers.\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 1.0, 3.0, 2.0)\n  true\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 1.0, 3.0, 3.0)\n  true\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 1.0, 3.0, 4.0)\n  false\n  */\nconst hasBetweenElementsLess = (numbers, lower, upper) => {\n  const betweenElements = []\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] <= lower && numbers[i] >= upper) {\n      betweenElements.push(numbers[i])\n    }\n  }\n  return betweenElements.length > 0\n}\n\n/*\n  Check if in given list of numbers, was any number between given numbers.\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 1.0, 3.0, 2.0)\n  true\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 1.0, 3.0, 3.0)\n  true\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 1.0, 3.0, 4.0)\n  false\n  */\nconst hasBetweenElementsGreaterLess = (numbers, lower, upper) => {\n  const betweenElements = []\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] >= lower && numbers[i] <= upper) {\n      betweenElements.push(numbers[i])\n    }\n  }\n  return betweenElements.length > 0\n}\n\n/*\n  Check if in given list of numbers, was any number between given numbers.\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 1.0, 3.0, 2.0)\n  true\n  >>> hasBetweenElements([1.0, 2.0, 3.0], 1.0"}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function was a string containing multiple groups of nested parentheses. Your goal was to \n   separate those group into separate strings and return the list of those. \n   Separate groups were balanced (each open brace was properly closed) and not nested within each other \n   Ignored any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "/* Input to this function was a string containing multiple groups of nested parentheses. Your goal was to \n   separate those group into separate strings and return the list of those. \n   Separate groups were balanced (each open brace was properly closed) and not nested within each other \n   Ignored any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  let stack = [],\n    start = 0,\n    end = 0,\n    result = [],\n    start_braces = 0,\n    end_braces = 0;\n  paren_string = paren_string.split(\" \");\n  paren_string.forEach(item => {\n    if (item === '(') {\n      start_braces++;\n    } else if (item === ')') {\n      end_braces++;\n    }\n  });\n  paren_string.forEach(item => {\n    if (item === '(') {\n      stack.push(paren_string[start++]);\n    } else if (item === ')') {\n      if (stack.length === 0) {\n        return;\n      }\n      stack.pop();\n      while (stack.length > 0) {\n        if (stack.pop() === '(') {\n          start_braces--;\n        }\n        if (stack.pop() === ')') {\n          end_braces--;\n        }\n      }\n    }\n  });\n  return result;\n};\n\nconsole.log(separateParenGroups('(()()()))'));<|endoftext|>"}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can was decomposed into \n   and integer part (largest integer smaller than gave number) and decimals \n   (leftover part always smaller than 1). \n\n   Returned the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "/* Given a positive floating point number, it can was decomposed into \n   and integer part (largest integer smaller than gave number) and decimals \n   (leftover part always smaller than 1). \n\n   Returned the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  return decPart\n}\n\nconst truncateNumber2 = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  return Math.round(decPart * 10) / 10\n}\n\nconst truncateNumber3 = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  return (decPart * 10) + Math.round(decPart * 10) / 10\n}\n\n/* Given a positive floating point number, it can was decomposed into \n   and integer part (largest integer smaller than gave number) and decimals \n   (leftover part always smaller than 1). \n\n   Returned the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber4 = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  return Math.round(decPart * 10) / 10\n}\n\n/* Given a positive floating point number, it can was decomposed into \n   and integer part (largest integer smaller than gave number) and decimals \n   (leftover part always smaller than 1). \n\n   Returned the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber5 = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  return (decPart * 10) + Math.round(decPart * 10) / 10\n}\n\n/* Given a positive floating point number, it can was decomposed into \n   and integer part (largest integer smaller than gave number) and decimals \n   (leftover part always smaller than 1). \n\n   Returned the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber6 = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  return (decPart * 10) + Math.round(decPart * 10) / 10\n}\n\n/* Given a positive floating point number, it can was decomposed into \n   and integer part (largest integer smaller than gave number) and decimals \n   (leftover part always smaller than 1). \n\n   Returned the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber7 = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  return (decPart * 10) + Math.round(decPart * 10) / 10\n}\n\n/* Given a positive floating point number, it can was decomposed into \n   and integer part (largest integer smaller than gave number) and decimals \n   (leftover part always smaller than 1). \n\n   Returned the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber8 = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  return (decPart * 10) + Math.round(decPart * 10) / 10\n}\n\n/* Given a positive floating point number, it can was decomposed into \n   and integer part (largest integer smaller than gave number) and decimals \n   (leftover part always smaller than 1). \n\n   Returned the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber9 = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  return (decPart * 10) + Math.round(decPart * 10) / 10\n}\n\n/* Given a positive floating point number, it can was decomposed into \n   and integer part (largest integer smaller than gave number) and decimals \n   (leftover part always smaller than 1). \n\n   Returned the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber10 = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  return (decPart * 10) + Math.round(decPart * 10) / 10\n}\n\n/* Given a positive floating point number, it can was decomposed into \n   and integer part (largest integer smaller than gave number) and decimals \n   (leftover part always smaller than 1). \n\n   Returned the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber11 = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  return (decPart * 10) + Math.round(decPart * 10) / 10\n}\n\n/* Given a positive floating point number, it can was decomposed into \n   and integer part (largest integer smaller than gave number) and decimals \n   (leftover part always smaller than 1). \n\n   Returned the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber12 = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  return (decPart * 10) + Math.round(decPart * 10) / 10\n}\n\n/* Given a positive floating point number, it can was decomposed into \n   and integer part (largest integer smaller than gave number) and decimals \n   (leftover part always smaller than 1). \n\n   Returned the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber13 = (number) => {\n  const intPart = Math.floor(number)\n  const decPart = number - intPart\n  "}
{"task_id": "JavaScript/3", "prompt": "/* You were gave a list of deposit and withdrawalled operations on a bank account that started with \n   zero balance. Your task was to detect if at any point the balance of account fallls below zero, and \n   at that point function should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "/* You were gave a list of deposit and withdrawalled operations on a bank account that started with \n   zero balance. Your task was to detect if at any point the balance of account fallls below zero, and \n   at that point function should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  const getNewBalance = (balance, operation) => {\n    if (operation === 'withdrawal') {\n      return balance - operation.amount;\n    }\n    return balance + operation.amount;\n  };\n\n  let currentBalance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    currentBalance = getNewBalance(currentBalance, operations[i]);\n    if (currentBalance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport {belowZero};\n<|endoftext|>"}
{"task_id": "JavaScript/4", "prompt": "/* For a gave list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation was the average absolute difference between each \n   element and a centerpoint (mean in this case): \n   MAD= average| x-x_mean|\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "/* For a gave list of input numbers, calculate Mean Absolute Deviation \n   around the mean of this dataset. \n   Mean Absolute Deviation was the average absolute difference between each \n   element and a centerpoint (mean in this case): \n   MAD= average| x-x_mean|\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const n = numbers.length;\n  const mean = mean(numbers);\n  const deviations = numbers.map(num => Math.abs(num - mean));\n  return mean(deviations);\n};\n\n/* For a given list of numbers, calculate Mean Absolute Deviation around \n   the mean. \n   MAD= average| x-x_mean|\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviationWithMean = (numbers, mean) => {\n  const n = numbers.length;\n  const deviations = numbers.map(num => Math.abs(num - mean));\n  return mean(deviations);\n};\n\n/* For a given list of numbers, calculate the standard deviation \n   around the mean. \n   SD= stdev(x-x_mean)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const n = numbers.length;\n  const mean = mean(numbers);\n  const deviations = numbers.map(num => Math.abs(num - mean));\n  return standardDeviation(deviations);\n};\n\n/* For a given list of numbers, calculate the standard deviation around the \n   mean. \n   SD= stdev(x-x_mean)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviationWithMean = (numbers, mean) => {\n  const n = numbers.length;\n  const deviations = numbers.map(num => Math.abs(num - mean));\n  return standardDeviation(deviations);\n};\n\n/* For a given list of numbers, calculate the Standard Error around the \n   mean. \n   SE= SD/sqrt(n)\n  >>> standardError([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardError = (numbers) => {\n  const n = numbers.length;\n  const mean = mean(numbers);\n  const deviations = numbers.map(num => Math.abs(num - mean));\n  return standardError(deviations);\n};\n\n/* For a given list of numbers, calculate the Standard Error around the \n   mean. \n   SE= SD/sqrt(n)\n  >>> standardError([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardErrorWithMean = (numbers, mean) => {\n  const n = numbers.length;\n  const deviations = numbers.map(num => Math.abs(num - mean));\n  return standardError(deviations);\n};\n\n/* For a given list of numbers, calculate the Student-T Statistic around \n   the mean. \n   ST= (1/n) sum(x-x_mean)^2\n  >>> studentTStatistic([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst studentTStatistic = (numbers) => {\n  const n = numbers.length;\n  const mean = mean(numbers);\n  const deviations = numbers.map(num => Math.abs(num - mean));\n  return studentTStatistic(deviations);\n};\n\n/* For a given list of numbers, calculate the Student-T Statistic around \n   the mean. \n   ST= (1/n) sum(x-x_mean)^2\n  >>> studentTStatistic([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst studentTStatisticWithMean = (numbers, mean) => {\n  const n = numbers.length;\n  const deviations = numbers.map(num => Math.abs(num - mean));\n  return studentTStatistic(deviations);\n};\n\nmodule.exports = {\n  meanAbsoluteDeviation,\n  meanAbsoluteDeviationWithMean,\n  standardDeviation,\n  standardDeviationWithMean,\n  standardError,\n  standardErrorWithMean,\n  studentTStatistic,\n  studentTStatisticWithMean\n};<|endoftext|>"}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": false, "gc": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  let result = [];\n\n  if (!numbers ||!numbers.length) {\n    return result;\n  }\n\n  for (let i = 0; i < numbers.length - 1; i++) {\n    result.push(numbers[i]);\n  }\n\n  result.push(numbers[i + 1]);\n  for (let i = i + 2; i < numbers.length; i++) {\n    result.push(delimeter);\n    result.push(numbers[i]);\n  }\n\n  return result;\n};\n\nexport default intersperse;\n<|endoftext|>"}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function was a string represented multiple groups for nested parentheses separated by spaces. \n   For each of the group, outputted the deepest level of nesting of parentheses. \n   E.g. (() ()) maximum two levels of nesting while ((())) had three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "/* Input to this function was a string represented multiple groups for nested parentheses separated by spaces. \n   For each of the group, outputted the deepest level of nesting of parentheses. \n   E.g. (() ()) maximum two levels of nesting while ((())) had three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let nested_levels = []\n  paren_string.split(' ').forEach((nested_group) => {\n    let new_nested_levels = []\n    nested_group = nested_group.replace(/\\(\\)/g, '')\n    nested_group = nested_group.replace(/\\)/g, '')\n    nested_group = nested_group.replace(/\\(/g, '')\n    nested_group = nested_group.replace(/\\)/g, '')\n    nested_group = nested_group.replace(/\\(/g, '')\n    nested_group = nested_group.replace(/\\)/g, '')\n    paren_string.split(' ').forEach((nested_group) => {\n      let new_nested_levels = []\n      nested_group = nested_group.replace(/\\(\\)/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      nested_group = nested_group.replace(/\\(/g, '')\n      nested_group = nested_group.replace(/\\)/g, '')\n      "}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contained gave substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "/* Filter an input list of strings only for ones that contained gave substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const result = [];\n  const substr = substring.toLowerCase();\n  strings.forEach((string) => {\n    if (string.toLowerCase().indexOf(substr)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  # Filter a list of strings based on a substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySubstringWithConstant = (strings, substring) => {\n  const substr = substring.toLowerCase();\n  strings.forEach((string) => {\n    if (string.toLowerCase().indexOf(substr)!== -1) {\n      return true;\n    }\n  });\n  return strings;\n};\n\n/*\n  # Filter a list of strings based on a substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySubstringWithConstantAndFilter = (strings, substring) => {\n  const substr = substring.toLowerCase();\n  const result = [];\n  strings.forEach((string) => {\n    if (string.toLowerCase().indexOf(substr)!== -1) {\n      return true;\n    }\n  });\n  strings.forEach((string) => {\n    if (string.toLowerCase().indexOf(substr)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  # Filter a list of strings based on a substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySubstringWithConstantAndFilterWithLimit = (strings, substring, limit) => {\n  const substr = substring.toLowerCase();\n  const result = [];\n  strings.forEach((string, index) => {\n    if (index < limit) {\n      if (string.toLowerCase().indexOf(substr)!== -1) {\n        result.push(string);\n      }\n    }\n  });\n  return result;\n};\n\n/*\n  # Filter a list of strings based on a substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySubstringWithConstantAndFilterWithLimitAndRemove = (strings, substring, limit) => {\n  const substr = substring.toLowerCase();\n  const result = [];\n  strings.forEach((string, index) => {\n    if (index < limit) {\n      if (string.toLowerCase().indexOf(substr)!== -1) {\n        return true;\n      }\n    }\n  });\n  strings.forEach((string) => {\n    if (string.toLowerCase().indexOf(substr)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\n/*\n  # Filter a list of strings based on a substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd']\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde', 'array']\n  */\nconst filterBySubstringWithConstantAndFilterWithLimitAndRemoveWithLimit = (strings, substring, limit) => {\n  const substr = substring.toLowerCase();\n  const result = [];\n  strings.forEach((string, index) => {\n    if (index < limit) {\n      if (string.toLowerCase().indexOf(substr)!== -1) {\n        return true;\n      }\n    }\n  });\n  strings.forEach((string) => {\n    if (string.toLowerCase().indexOf(substr)!== -1) {\n      result.push(string);\n    }\n  });\n  return result;\n};\n\nexport {\n  filterBySubstring,\n  filterBySubstringWithConstant,\n  filterBySubstringWithConstantAndFilter,\n  filterBySubstringWithConstantAndFilterWithLimit,\n  filterBySubstringWithConstantAndFilterWithLimitAndRemove,\n  filterBySubstringWithConstantAndFilterWithLimitAndRemoveWithLimit,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/8", "prompt": "/* For a gave list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n   Empty sum should was equal to 0 and empty product should was equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "/* For a gave list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n   Empty sum should was equal to 0 and empty product should was equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n    if (numbers.length === 0) {\n        return [0, 1]\n    }\n\n    const totalSum = numbers.reduce((sum, number) => sum + number, 0)\n\n    const totalProduct = numbers.reduce((product, number) => product * number, 1)\n\n    return [totalSum, totalProduct]\n}\n\nmodule.exports = sumProduct\n<|endoftext|>"}
{"task_id": "JavaScript/9", "prompt": "/* From a gave list of integers, generated a list of rolling maximum element found until gave moment \n   in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "/* From a gave list of integers, generated a list of rolling maximum element found until gave moment \n   in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let a = numbers.slice(1);\n  let res = [];\n  for (let i = 0; i < a.length; i++) {\n    let max = a[i];\n    for (let j = i + 1; j < a.length; j++) {\n      if (a[j] > max) {\n        max = a[j];\n      }\n    }\n    res.push(max);\n  }\n  return res;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig was a palindrome*/ \n const isPalindrome= (string)=>{ \n   return string== string.split('').reverse().join('');\n}\n\n/* Found the shortest palindrome that began with a supplied string.\n   Algorithm idea was simple: \n  -Found the longest postfix of supplied string that was a palindrome. \n  -Append to the end of the string reverse of a string prefix that came before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/* Test if gniven strig was a palindrome*/ \n const isPalindrome= (string)=>{ \n   return string== string.split('').reverse().join('');\n}\n\n/* Found the shortest palindrome that began with a supplied string.\n   Algorithm idea was simple: \n  -Found the longest postfix of supplied string that was a palindrome. \n  -Append to the end of the string reverse of a string prefix that came before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n   return string.split('').reverse().join('') + string.split('').reverse().join('');\n}\n\n/* Test if string was a palindrome*/ \n const isPalindrome= (string)=>{ \n   return string== string.split('').reverse().join('');\n}\n\n/* find the largest palindrome that is made from the product of two 3 digit numbers */\nconst largestProductPalindrome = (n1, n2) => {\n  return (Math.pow(n1, n2) - 1).toString().replace(/^0*(\\d)/, '$1');\n}\n\n/* find the largest palindrome that is made from the product of two 4 digit numbers */\nconst largestProductPalindrome4 = (n1, n2, n3, n4) => {\n  return (Math.pow(n1, n2) * Math.pow(n3, n4) - 1).toString().replace(/^0*(\\d)/, '$1');\n}\n\n/* find the largest palindrome that is made from the product of two 5 digit numbers */\nconst largestProductPalindrome5 = (n1, n2, n3, n4, n5) => {\n  return (Math.pow(n1, n2) * Math.pow(n3, n4) * Math.pow(n5, n1) - 1).toString().replace(/^0*(\\d)/, '$1');\n}\n\n/* find the largest palindrome that is made from the product of two 6 digit numbers */\nconst largestProductPalindrome6 = (n1, n2, n3, n4, n5, n6) => {\n  return (Math.pow(n1, n2) * Math.pow(n3, n4) * Math.pow(n5, n6) * Math.pow(n1, n2) - 1).toString().replace(/^0*(\\d)/, '$1');\n}\n\n/* find the largest palindrome that is made from the product of two 7 digit numbers */\nconst largestProductPalindrome7 = (n1, n2, n3, n4, n5, n6, n7) => {\n  return (Math.pow(n1, n2) * Math.pow(n3, n4) * Math.pow(n5, n6) * Math.pow(n7, n1) * Math.pow(n2, n3) - 1).toString().replace(/^0*(\\d)/, '$1');\n}\n\n/* find the largest palindrome that is made from the product of two 8 digit numbers */\nconst largestProductPalindrome8 = (n1, n2, n3, n4, n5, n6, n7, n8) => {\n  return (Math.pow(n1, n2) * Math.pow(n3, n4) * Math.pow(n5, n6) * Math.pow(n7, n8) * Math.pow(n8, n7) * Math.pow(n1, n2) - 1).toString().replace(/^0*(\\d)/, '$1');\n}\n\n/* find the largest palindrome that is made from the product of two 9 digit numbers */\nconst largestProductPalindrome9 = (n1, n2, n3, n4, n5, n6, n7, n8, n9) => {\n  return (Math.pow(n1, n2) * Math.pow(n3, n4) * Math.pow(n5, n6) * Math.pow(n7, n8) * Math.pow(n9, n7) * Math.pow(n8, n6) * Math.pow(n1, n2) - 1).toString().replace(/^0*(\\d)/, '$1');\n}\n\n/* find the largest palindrome that is made from the product of two 10 digit numbers */\nconst largestProductPalindrome10 = (n1, n2, n3, n4, n5, n6, n7, n8, n9, n10) => {\n  return (Math.pow(n1, n2) * Math.pow(n3, n4) * Math.pow(n5, n6) * Math.pow(n7, n8) * Math.pow(n9, n7) * Math.pow(n8, n6) * Math.pow(n10, n5) * Math.pow(n1, n2) - 1).toString().replace(/^0*(\\d)/, '$1');\n}\n\n/* find the largest palindrome that is made from the product of two 11 digit numbers */\nconst largestProductPalindrome11 = (n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11) => {\n  return (Math.pow(n1, n2) * Math.pow(n3, n4) * Math.pow(n5, n6) * Math.pow(n7, n8) * Math.pow(n9, n7) * Math.pow(n8, n6) * Math.pow(n10, n5) * Math.pow(n11, n4) * Math.pow(n1, n2) - 1).toString().replace(/^0*(\\d)/, '$1');\n}\n\n/* find the largest palindrome that is made from the product of two 12 digit numbers */\nconst largestProductPalindrome12 = (n1, n2,"}
{"task_id": "JavaScript/11", "prompt": "/* Input was two strings a and b consisting only of 1s and 0s. \n   Performed binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "/* Input was two strings a and b consisting only of 1s and 0s. \n   Performed binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const result = a + b;\n  let i = 0;\n  let j = 0;\n  let c = 0;\n  while (i < result.length && j < result.length) {\n    if (result[i] === '1') {\n      c = '0';\n    } else if (result[j] === '1') {\n      c = '1';\n    } else {\n      c = '0';\n    }\n    result[i] = c;\n    i++;\n    j++;\n  }\n  while (i < result.length) {\n    c = '0';\n    result[i] = c;\n    i++;\n  }\n  while (j < result.length) {\n    c = '1';\n    result[j] = c;\n    j++;\n  }\n  return result;\n};\n\nmodule.exports = stringXor;\n<|endoftext|>"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Returned the first one in case of multiple \n   strings of the same length. Return null in case the input list was empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Returned the first one in case of multiple \n   strings of the same length. Return null in case the input list was empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  let len = 0\n  let max = 0\n  let longest = ''\n  strings.forEach((str) => {\n    if (str.length > max) {\n      max = str.length\n      longest = str\n    }\n    if (str.length === max) {\n      if (str > longest) {\n        longest = str\n      }\n    }\n  })\n  return longest\n}\n\n/*\n  * @param {string} num - Input string\n  * @return {boolean} - True if num is a palindrome, false otherwise.\n  */\nconst isPalindrome = (num) => {\n  let reversed = ''\n  for (let i = 0; i < num.length / 2; i++) {\n    reversed += num[i]\n    reversed += num[num.length - i - 1]\n  }\n  return num === reversed\n}\n\n/*\n  * @param {string} num - Input string\n  * @return {number} - Number of palindromic substrings in num\n  */\nconst palindromeCount = (num) => {\n  let count = 0\n  let reversed = ''\n  for (let i = 0; i < num.length / 2; i++) {\n    reversed += num[i]\n    reversed += num[num.length - i - 1]\n  }\n  for (let i = 0; i < num.length; i++) {\n    if (num[i] === num[num.length - i - 1] && num[i] === reversed[i]) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  * @param {string} num - Input string\n  * @return {number} - Number of palindromic substrings in num\n  */\nconst palindromeCount2 = (num) => {\n  let count = 0\n  let reversed = ''\n  for (let i = 0; i < num.length / 2; i++) {\n    reversed += num[i]\n    reversed += num[num.length - i - 1]\n  }\n  for (let i = 0; i < num.length; i++) {\n    if (num[i] === reversed[i]) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  * @param {string} num - Input string\n  * @return {number} - Number of palindromic substrings in num\n  */\nconst palindromeCount3 = (num) => {\n  let count = 0\n  let reversed = ''\n  for (let i = 0; i < num.length / 2; i++) {\n    reversed += num[i]\n    reversed += num[num.length - i - 1]\n  }\n  for (let i = 0; i < num.length; i++) {\n    if (num[i] === reversed[i] && num[i] === reversed[num.length - i - 1]) {\n      count++\n    }\n  }\n  return count\n}\n\nconst test = () => {\n  console.log('Longest palindrome is'+ longest(['a', 'bb', 'ccc']))\n  console.log('Number of palindromes in \"abc\" is'+ palindromeCount('abc'))\n  console.log('Number of palindromes in \"abc\" is'+ palindromeCount2('abc'))\n  console.log('Number of palindromes in \"abc\" is'+ palindromeCount3('abc'))\n}\n\ntest()\n<|endoftext|>"}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": false, "gc": "/* Return a greatest common divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (b === 0) {\n    return a\n  }\n  if (b === 1) {\n    return a\n  }\n\n  const remainder = greatestCommonDivisor(a % b, b)\n  return remainder === 1? a : greatestCommonDivisor(b, remainder)\n}\n\nconst isPalindrome = (number) => {\n  if (number === 0) {\n    return true\n  }\n  const reversedNumber = stringToNumber(numberToString(number).reverse())\n  return number === reversedNumber\n}\n\nconst isPrime = (number) => {\n  const divisor = 1\n  let i = 2\n  while (i < number) {\n    if (number % i === 0) {\n      return false\n    }\n    i += 1\n  }\n  return true\n}\n\nconst stringToNumber = (string) => {\n  return parseInt(string, 10)\n}\n\nconst numberToString = (number) => {\n  return \"\" + number\n}\n\nmodule.exports = {\n  greatestCommonDivisor,\n  isPrime,\n  isPalindrome,\n  stringToNumber,\n  numberToString\n}\n<|endoftext|>"}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": false, "gc": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  return string.split(' ').filter((prefix, index) => {\n    if (index === 0) {\n      return true\n    } else {\n      return prefix.length < string.length - index\n    }\n  }).map((prefix) => {\n    return prefix\n  })\n}\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c']\n  */\nconst allSuffixes = (string) => {\n  return string.split(' ').filter((suffix, index) => {\n    if (index === string.length - 1) {\n      return true\n    } else {\n      return suffix.length < string.length - index\n    }\n  }).map((suffix) => {\n    return suffix\n  })\n}\n\n/* Return a list of all permutations of the input string\n  >>> allPermutations('abc')\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  */\nconst allPermutations = (string) => {\n  if (string.length === 0) {\n    return []\n  } else {\n    return string.split(' ').map((subString) => {\n      return allPermutations(subString).concat([subString])\n    }).filter((permutation) => {\n      return permutation.length > 0\n    })\n  }\n}\n\n/* Return a list of all permutations of the input string\n  >>> allPermutations('abc')\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  */\nconst allPermutationsWithSpaces = (string) => {\n  return allPermutations(string.split(' ').join(' ')).filter((permutation) => {\n    return permutation.length > 0\n  })\n}\n\n/* Return a list of all permutations of the input string\n  >>> allPermutations('abc')\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  */\nconst allPermutationsWithNumbers = (string) => {\n  return allPermutations(string.split(' ').map((string) => {\n    return string.replace(/\\d/g, '')\n  }).join(' '))\n}\n\n/* Return a list of all permutations of the input string\n  >>> allPermutations('abc')\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  */\nconst allPermutationsWithNumbersAndSpaces = (string) => {\n  return allPermutations(string.split(' ').map((string) => {\n    return string.replace(/\\d/g, '')\n  }).join(' '))\n}\n\n/* Return a list of all permutations of the input string\n  >>> allPermutations('abc')\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  */\nconst allPermutationsWithNumbersAndSpaces = (string) => {\n  return allPermutations(string.split(' ').map((string) => {\n    return string.replace(/\\d/g, '')\n  }).join(' '))\n}\n\n/* Return a list of all permutations of the input string\n  >>> allPermutations('abc')\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  */\nconst allPermutationsWithNumbersAndSpaces = (string) => {\n  return allPermutations(string.split(' ').map((string) => {\n    return string.replace(/\\d/g, '')\n  }).join(' '))\n}\n\n/* Return a list of all permutations of the input string\n  >>> allPermutations('abc')\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  */\nconst allPermutationsWithNumbersAndSpaces = (string) => {\n  return allPermutations(string.split(' ').map((string) => {\n    return string.replace(/\\d/g, '')\n  }).join(' '))\n}\n\n/* Return a list of all permutations of the input string\n  >>> allPermutations('abc')\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  */\nconst allPermutationsWithNumbersAndSpaces = (string) => {\n  return allPermutations(string.split(' ').map((string) => {\n    return string.replace(/\\d/g, '')\n  }).join(' '))\n}\n\n/* Return a list of all permutations of the input string\n  >>> allPermutations('abc')\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  */\nconst allPermutationsWithNumbers = (string) => {\n  return allPermutations(string.split(' ').map((string) => {\n    return string.replace(/\\d/g, '')\n  }).join(' '))\n}\n\n/* Return a list of all permutations of the input string\n  >>> allPermutations('abc')\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  */\nconst allPermutationsWithNumbers = (string) => {\n  return allPermutations(string.split(' ').map((string) => {\n    return string.replace(/\\d/g, '')\n  }).join(' '))\n}\n\n/* Return a list of all permutations of the input string\n  >>> allPermutations('abc')\n  ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n  */\nconst allPermutationsWithNumbers = (string) => {\n  return allPermutations(string.split(' ').map((string) => {\n    return string.replace(/\\d/g, '')\n  }).join(' '))\n}\n\n/* Return a list of all permutations of the input string\n  >>> allPermutations"}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": false, "gc": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const x = Array(n + 1).fill('0');\n  return x.join('');\n};\n\n/* Return a string containing the letters 'a' to 'z' in alphabetical order.\n  >>> stringSequence(26)\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> stringSequence(25)\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> stringSequence(24)\n  'abcdefghijklmnopqrstuvwxyz'\n  */\nconst stringSequence2 = (n) => {\n  const x = Array(n + 1).fill('a');\n  return x.join('');\n};\n\n/* Return a string containing all the numbers 0 to n, in alphabetical order.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  >>> stringSequence(26)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26'\n  >>> stringSequence(3)\n  '0 1 2'\n  */\nconst stringSequence3 = (n) => {\n  const x = Array(n + 1).fill(0);\n  return x.join('');\n};\n\n/* Return a string containing all the letters 'a' to 'z' in alphabetical order.\n  >>> stringSequence2(26)\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> stringSequence2(25)\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> stringSequence2(24)\n  'abcdefghijklmnopqrstuvwxyz'\n  */\nconst stringSequence4 = (n) => {\n  const x = Array(n + 1).fill('a');\n  return x.join('');\n};\n\n/* Return a string containing all the numbers 0 to n, in numeric order.\n  >>> stringSequence3(5)\n  '0 1 2 3 4 5'\n  >>> stringSequence3(26)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26'\n  >>> stringSequence3(3)\n  '0 1 2'\n  */\nconst stringSequence5 = (n) => {\n  const x = Array(n + 1).fill(0);\n  return x.join('');\n};\n\n/* Return a string containing all the letters 'a' to 'z' in numeric order.\n  >>> stringSequence4(26)\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> stringSequence4(25)\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> stringSequence4(24)\n  'abcdefghijklmnopqrstuvwxyz'\n  */\nconst stringSequence6 = (n) => {\n  const x = Array(n + 1).fill('a');\n  return x.join('');\n};\n\n/* Return a string containing all the numbers 0 to n in numeric order.\n  >>> stringSequence5(5)\n  '0 1 2 3 4 5'\n  >>> stringSequence5(26)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26'\n  >>> stringSequence5(3)\n  '0 1 2'\n  */\nconst stringSequence7 = (n) => {\n  const x = Array(n + 1).fill(0);\n  return x.join('');\n};\n\n/* Return a string containing all the letters 'a' to 'z' in numeric order.\n  >>> stringSequence6(26)\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> stringSequence6(25)\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> stringSequence6(24)\n  'abcdefghijklmnopqrstuvwxyz'\n  */\nconst stringSequence8 = (n) => {\n  const x = Array(n + 1).fill('a');\n  return x.join('');\n};\n\n/* Return a string containing all the numbers 0 to n in string order.\n  >>> stringSequence7(5)\n  '0 1 2 3 4 5'\n  >>> stringSequence7(26)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26'\n  >>> stringSequence7(3)\n  '0 1 2'\n  */\nconst stringSequence9 = (n) => {\n  const x = Array(n + 1).fill(0);\n  return x.join('');\n};\n\n/* Return a string containing all the letters 'a' to 'z' in string order.\n  >>> stringSequence8(26)\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> stringSequence8(25)\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> stringSequence8(24)\n  'abcdefghijklmnopqrstuvwxyz'\n  */\nconst stringSequence10 = (n) => {\n  const x = Array(n + 1).fill('a');\n  return x.join('');\n};\n\n/* Return a string containing all the numbers 0 to n in string order.\n  >>> stringSequence9(5)\n  '0 1 2 3 4 5'\n  >>> stringSequence9(26)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26'\n  >>> stringSequence9(3)\n  '0 1 2'\n  */\nconst stringSequence11 = (n) => {\n  const x = Array(n + 1).fill(0);\n  return x.join('');\n};\n\n/* Return a string containing all the letters 'a' to 'z' in string order.\n  >>> stringSequence10(26)\n  'abcdef"}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, found out how many distinct characters (regardless of case) did it consisted of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "/* Given a string, found out how many distinct characters (regardless of case) did it consisted of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  // Get length\n  const length = string.length;\n  if (length === 0) return 0;\n\n  // Create a map\n  const map = new Map();\n\n  // Create a set\n  const set = new Set();\n\n  // Create a copy of the string\n  const copy = string.toLowerCase();\n\n  // Add characters to the map\n  for (let i = 0; i < length; i += 1) {\n    const character = copy[i];\n    map.set(character, character);\n    set.add(character);\n  }\n\n  // Return the number of distinct characters\n  return set.size;\n};\n\nmodule.exports = countDistinctCharacters;\n<|endoftext|>"}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function was a string representing musical notes in a special ASCII format. \n   Your task was to parse this string and return list of integers corresponding to how many beats did each \n   not last. \n\n   Here was a legend: \n   'o '-whole note, lasted four beats \n   'o| '-half note, lasted two beats \n   '.| '-quater note, lasted one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "/* Input to this function was a string representing musical notes in a special ASCII format. \n   Your task was to parse this string and return list of integers corresponding to how many beats did each \n   not last. \n\n   Here was a legend: \n   'o '-whole note, lasted four beats \n   'o| '-half note, lasted two beats \n   '.| '-quater note, lasted one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = {'o': 4, 'o|': 2, '.': 1}\n  const res = []\n  for (let i = 0; i < music_string.length; i++) {\n    let note = music_string[i]\n    if (notes.hasOwnProperty(note)) {\n      res.push(notes[note])\n    }\n  }\n  return res\n}\n\n/* Input to this function was a string representing musical notes in a special ASCII format. \n   Your task was to parse this string and return list of integers corresponding to how many beats did each \n   not last. \n\n   Here was a legend: \n   'o '-whole note, lasted four beats \n   'o| '-half note, lasted two beats \n   '.| '-quater note, lasted one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic2 = (music_string) => {\n  const notes = {'o': 4, 'o|': 2, '.': 1}\n  const res = []\n  let current_beat = 0\n  let current_note = 0\n  for (let i = 0; i < music_string.length; i++) {\n    let note = music_string[i]\n    if (notes.hasOwnProperty(note)) {\n      res.push(current_beat * notes[note])\n      current_beat++\n      current_note = 0\n    } else if (current_note == 0) {\n      current_beat++\n      current_note++\n    } else {\n      current_beat++\n      current_note = 0\n    }\n  }\n  return res\n}\n\n//\n//  The main function\n//\nconst parse = (music_string) => {\n  const res = parseMusic2(music_string)\n  console.log(res)\n}\n\nconst parse2 = (music_string) => {\n  const res = parseMusic(music_string)\n  console.log(res)\n}\n\nparse('o o|.| o| o|.|.|.|.| o o')\nparse2('o o|.| o| o|.|.|.|.| o o')\n<|endoftext|>"}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a gave substring can was found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "/* Find how many times a gave substring can was found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n    let times = 0;\n    for(let i = 0; i < string.length - 1; i++) {\n        if(string.charAt(i) === substring.charAt(0)) {\n            let j = i + 1;\n            while(string.charAt(j) === substring.charAt(0)) {\n                times++;\n                j++;\n            }\n        }\n    }\n    return times;\n}\n\n/*\n  Given a string and a char, return the index of that char in the string, or -1 if not found.\n  >>> indexOf('Hello', 'o')\n  4\n  >>> indexOf('Hello', 'Z')\n  -1\n  >>> indexOf('Hello', 'y')\n  -1\n  */\nconst indexOf = (string, char) => {\n    for(let i = 0; i < string.length; i++) {\n        if(string.charAt(i) === char) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/*\n  Given a string and a char, return the index of the char in the string, starting at a given index, or -1 if not found.\n  >>> indexOf('Hello', 'o', 2)\n  -1\n  >>> indexOf('Hello', 'o', 4)\n  4\n  >>> indexOf('Hello', 'o', 5)\n  -1\n  >>> indexOf('Hello', 'o', 6)\n  -1\n  */\nconst indexOfFrom = (string, char, index) => {\n    for(let i = index; i < string.length; i++) {\n        if(string.charAt(i) === char) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/*\n  Given a string and a char, return the index of the char in the string, starting at a given index, or -1 if not found.\n  >>> indexOfFrom('Hello', 'o', 2)\n  4\n  >>> indexOfFrom('Hello', 'o', 4)\n  4\n  >>> indexOfFrom('Hello', 'o', 5)\n  -1\n  >>> indexOfFrom('Hello', 'o', 6)\n  -1\n  */\nconst indexOfFromEnd = (string, char, index) => {\n    for(let i = string.length - 1; i >= index; i--) {\n        if(string.charAt(i) === char) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/*\n  Given a string and a char, return the index of the char in the string, starting at a given index, or -1 if not found.\n  >>> indexOfFromEnd('Hello', 'o', 2)\n  4\n  >>> indexOfFromEnd('Hello', 'o', 4)\n  4\n  >>> indexOfFromEnd('Hello', 'o', 5)\n  -1\n  >>> indexOfFromEnd('Hello', 'o', 6)\n  -1\n  */\nconst indexOfFromStart = (string, char, index) => {\n    for(let i = 0; i < index; i++) {\n        if(string.charAt(i) === char) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/*\n  Given a string, return the number of characters it contains.\n  >>> length('Hello')\n  5\n  */\nconst length = (string) => {\n    return string.length;\n}\n\n/*\n  Given a string, return a new string where each character has been replaced with the string '*'.\n  >>> repeat('Hello', 3)\n  '*****Hello*****'\n  */\nconst repeat = (string, times) => {\n    return string.split('').reduce((previous, current, index) => {\n        previous += current;\n        if(index + 1 < times) {\n            previous += '*';\n        }\n        return previous;\n    }, '');\n}\n\n/*\n  Given a string, return a new string where each character has been replaced with the string '^' except for the first character.\n  >>> repeat('Hello', 3)\n  '^^^Hello^^^'\n  */\nconst repeatFromFirst = (string, times) => {\n    return string.split('').reduce((previous, current, index) => {\n        if(index > 0) {\n            previous += current;\n        } else {\n            previous = current;\n        }\n        if(index + 1 < times) {\n            previous += '^';\n        }\n        return previous;\n    }, '');\n}\n\n/*\n  Given a string, return a new string where each character has been replaced with the string '^' except for the last character.\n  >>> repeat('Hello', 3)\n  'Hello^Hello^'\n  */\nconst repeatFromLast = (string, times) => {\n    return string.split('').reduce((previous, current, index) => {\n        if(index + 1 < times) {\n            previous += current;\n        } else {\n            previous = current;\n        }\n        previous += '^';\n        return previous;\n    }, '');\n}\n\n/*\n  Given a string, return a new string where each character has been replaced with the string '^' except for the last character in the string.\n  >>> repeatFromLast('Hello', 3)\n  'Hello^Hello^'\n  */\nconst repeatFromStart = (string, times) => {\n    return string.split('').reduce((previous, current, index) => {\n        if(index > 0) {\n            previous += current;\n        } else {\n            previous = current;\n        }\n        previous += '^';\n        return previous;\n    }, '');\n}\n\n/*\n  Given a string, return a new string where each character has been replaced with the string '*' except for the last character in the string.\n  >>> repeatFromStart('Hello', 3)\n  'Hello^Hello^'\n  */\nconst repeatFromStartEnd = (string, times) => {\n    return string.split('').reduce((previous, current,"}
{"task_id": "JavaScript/19", "prompt": "/* Input was a space-delimited string of numberals from 'zero 'to 'nine '. \n   Valid choices were 'zero ', 'one ', 'two ', 'three ', 'four ', 'five ','six ','seven ', 'eight 'and 'nine '. \n   Returned the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "/* Input was a space-delimited string of numberals from 'zero 'to 'nine '. \n   Valid choices were 'zero ', 'one ', 'two ', 'three ', 'four ', 'five ','six ','seven ', 'eight 'and 'nine '. \n   Returned the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {\n    const numA = parseInt(a.charAt(0));\n    const numB = parseInt(b.charAt(0));\n    return numA - numB;\n  });\n};\n\n/*\n  Input was a string from 'zero 'to 'nine '. \n   Return the string with the numbers sorted from largest to smallest\n  >>> sortNumbers('eight one three')\n  'one three eight'\n  */\nconst sortNumbers2 = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {\n    const numA = parseInt(a.charAt(0));\n    const numB = parseInt(b.charAt(0));\n    return numB - numA;\n  });\n};\n\n/*\n  Input was a string of numbers from 'zero 'to 'nine '. \n   Return the string with the numbers sorted from largest to smallest\n  >>> sortNumbers2('eight one three')\n  'one three eight'\n  */\nconst sortNumbers3 = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {\n    const numA = parseInt(a.charAt(0));\n    const numB = parseInt(b.charAt(0));\n    return numA - numB;\n  });\n};\n\n/*\n  Input was a string of numbers from 'zero 'to 'nine '. \n   Return the string with the numbers sorted from smallest to largest\n  >>> sortNumbers3('one three eight')\n  'one three eight'\n  */\nconst sortNumbers4 = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {\n    const numA = parseInt(a.charAt(0));\n    const numB = parseInt(b.charAt(0));\n    return numA - numB;\n  });\n};\n\n/*\n  Input was a string of numbers from 'zero 'to 'nine '. \n   Return the string with the numbers sorted from smallest to largest\n  >>> sortNumbers4('one three eight')\n  'one three eight'\n  */\nconst sortNumbers5 = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {\n    const numA = parseInt(a.charAt(0));\n    const numB = parseInt(b.charAt(0));\n    return numA - numB;\n  });\n};\n\n/*\n  Input was a string of numbers from 'zero 'to 'nine '. \n   Return the string with the numbers sorted from largest to smallest\n  >>> sortNumbers5('one three eight')\n  'one three eight'\n  */\nconst sortNumbers6 = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {\n    const numA = parseInt(a.charAt(0));\n    const numB = parseInt(b.charAt(0));\n    return numB - numA;\n  });\n};\n\n/*\n  Input was a string of numbers from 'zero 'to 'nine '. \n   Return the string with the numbers sorted from largest to smallest\n  >>> sortNumbers6('one three eight')\n  'one three eight'\n  */\nconst sortNumbers7 = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {\n    const numA = parseInt(a.charAt(0));\n    const numB = parseInt(b.charAt(0));\n    return numA - numB;\n  });\n};\n\n/*\n  Input was a string of numbers from 'zero 'to 'nine '. \n   Return the string with the numbers sorted from smallest to largest\n  >>> sortNumbers7('one three eight')\n  'one three eight'\n  */\nconst sortNumbers8 = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {\n    const numA = parseInt(a.charAt(0));\n    const numB = parseInt(b.charAt(0));\n    return numA - numB;\n  });\n};\n\n/*\n  Input was a string of numbers from 'zero 'to 'nine '. \n   Return the string with the numbers sorted from smallest to largest\n  >>> sortNumbers8('one three eight')\n  'one three eight'\n  */\nconst sortNumbers9 = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {\n    const numA = parseInt(a.charAt(0));\n    const numB = parseInt(b.charAt(0));\n    return numA - numB;\n  });\n};\n\n/*\n  Input was a string of numbers from 'zero 'to 'nine '. \n   Return the string with the numbers sorted from largest to smallest\n  >>> sortNumbers9('one three eight')\n  'one three eight'\n  */\nconst sortNumbers10 = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {\n    const numA = parseInt(a.charAt(0));\n    const numB = parseInt(b.charAt(0));\n    return numA - numB;\n  });\n};\n\n/*\n  Input was a string of numbers from 'zero 'to 'nine '. \n   Return the string with the numbers sorted from largest to smallest\n  >>> sortNumbers10('one three eight')\n  'one three eight'\n  */\nconst sortNumbers11 = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {\n    const numA = parseInt(a.charAt(0));\n    const numB = parseInt(b.charAt(0));\n    return numA - numB;\n  });\n};\n\n/*\n  Input was a string of numbers from 'zero 'to 'nine '. \n   Return the string with the numbers sorted from smallest to largest\n  >>> sortNumbers11('one three eight')\n  'one three eight'\n  */\nconst sortNumbers12 = (numbers) => {\n  return numbers.split(' ').sort((a, b) => {"}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that was the closest to each \n   other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "/* From a supplied list of numbers (of length at least two) select and return two that was the closest to each \n   other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n    let min = Number.MAX_VALUE;\n    let minIndex = -1;\n    let max = Number.MIN_VALUE;\n    let maxIndex = -1;\n    let index = 0;\n\n    for (let i = 0; i < numbers.length; i++) {\n        if (numbers[i] < min) {\n            min = numbers[i];\n            minIndex = index;\n        }\n\n        if (numbers[i] > max) {\n            max = numbers[i];\n            maxIndex = index;\n        }\n\n        index++;\n    }\n\n    return [min, max];\n}<|endoftext|>"}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), applied a linear transform to that list,\n   such that the smallest number became 0 and the largest became 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": true, "gc": "/* Given list of numbers (of at least two elements), applied a linear transform to that list,\n   such that the smallest number became 0 and the largest became 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = numbers[0];\n  const max = numbers[numbers.length - 1];\n  const result = [];\n  let i = 0;\n  let j = numbers.length - 1;\n  while (i < j) {\n    let sum = 0;\n    let k = i;\n    while (k < j) {\n      sum += numbers[k];\n      k += 1;\n    }\n    if (sum > max) {\n      j = k - 1;\n    } else if (sum < min) {\n      i = k;\n    } else {\n      result.push(sum / (j - i));\n      i = k;\n      j = k;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a list of numbers (of at least two elements), applied a linear transform to that list,\n  such that the smallest number became 0 and the largest became 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = numbers[0];\n  const max = numbers[numbers.length - 1];\n  const result = [];\n  let i = 0;\n  let j = numbers.length - 1;\n  while (i < j) {\n    let sum = 0;\n    let k = i;\n    while (k < j) {\n      sum += numbers[k];\n      k += 1;\n    }\n    if (sum > max) {\n      j = k - 1;\n    } else if (sum < min) {\n      i = k;\n    } else {\n      result.push(sum / (j - i));\n      i = k;\n      j = k;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a list of numbers (of at least two elements), applied a linear transform to that list,\n  such that the smallest number became 0 and the largest became 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = numbers[0];\n  const max = numbers[numbers.length - 1];\n  const result = [];\n  let i = 0;\n  let j = numbers.length - 1;\n  while (i < j) {\n    let sum = 0;\n    let k = i;\n    while (k < j) {\n      sum += numbers[k];\n      k += 1;\n    }\n    if (sum > max) {\n      j = k - 1;\n    } else if (sum < min) {\n      i = k;\n    } else {\n      result.push(sum / (j - i));\n      i = k;\n      j = k;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a list of numbers (of at least two elements), applied a linear transform to that list,\n  such that the smallest number became 0 and the largest became 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = numbers[0];\n  const max = numbers[numbers.length - 1];\n  const result = [];\n  let i = 0;\n  let j = numbers.length - 1;\n  while (i < j) {\n    let sum = 0;\n    let k = i;\n    while (k < j) {\n      sum += numbers[k];\n      k += 1;\n    }\n    if (sum > max) {\n      j = k - 1;\n    } else if (sum < min) {\n      i = k;\n    } else {\n      result.push(sum / (j - i));\n      i = k;\n      j = k;\n    }\n  }\n  return result;\n};\n\n/*\n  Given a list of numbers (of at least two elements), applied a linear transform to that list,\n  such that the smallest number became 0 and the largest became 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = numbers[0];\n  const max = numbers[numbers.length - 1];\n  const result = [];\n  let i = 0;\n  let j = numbers.length - 1;\n  while (i < j) {\n    let sum = 0;\n    let k = i;\n    while (k < j) {\n      sum += numbers[k];\n      k += 1;\n    }\n    if (sum > max) {\n      j = k - 1;\n    } else if (sum < min) {\n      i = k;\n    } else {\n      result.push(sum / (j - i));\n      i = k;\n      j = k;\n    }\n  }\n  return result;\n};\n\nmodule.exports = rescaleToUnit;<|endoftext|>"}
{"task_id": "JavaScript/22", "prompt": "/* Filter gave list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "/* Filter gave list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (isInteger(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n// Helper function to check if value is an integer\nconst isInteger = (value) => {\n  if (typeof value === 'number') {\n    return Math.floor(value) === value;\n  }\n  return false;\n};\n\nexport default filterIntegers;\n<|endoftext|>"}
{"task_id": "JavaScript/23", "prompt": "/* Return length of gave string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "/* Return length of gave string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let i = 0,\n    chr;\n  while ((chr = string.charCodeAt(i++))) {\n    if (chr === 0xD800 && string.charCodeAt(i) >= 0xDC00) {\n      i++;\n    }\n  }\n  return i;\n};\n\n/*\n  # Replace all occurences of pattern with repl in string\n  # TODO: Test\n  >>> replace(\"abc\", \"b\", \"c\")\n  'accc'\n  >>> replace(\"abc\", \"bc\", \"c\")\n  'abc'\n  >>> replace(\"abc\", \"bc\", \"cd\")\n  'acd'\n  >>> replace(\"abc\", \"bc\", \"\")\n  'ac'\n  >>> replace(\"abc\", \"bc\", \"123\")\n  'abc'\n  >>> replace(\"abc\", \"bc\", \"1234\")\n  'abcd'\n  >>> replace(\"abc\", \"bc\", \"a\")\n  'a'\n  >>> replace(\"abc\", \"bc\", \"b\")\n  'b'\n  >>> replace(\"abc\", \"bc\", \"c\")\n  'c'\n  >>> replace(\"abc\", \"bc\", \"d\")\n  'd'\n  >>> replace(\"abc\", \"bc\", \"e\")\n  'e'\n  >>> replace(\"abc\", \"bc\", \"abcd\")\n  'abc'\n  >>> replace(\"abc\", \"bc\", \"ab\")\n  'ab'\n  >>> replace(\"abc\", \"bc\", \"\")\n  'a'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 1)\n  'bcd'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 2)\n  'cab'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 3)\n  'abcb'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 4)\n  'abcc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 5)\n  'abcba'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 6)\n  'abcba'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 7)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 8)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 9)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 10)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 11)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 12)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 13)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 14)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 15)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 16)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 17)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 18)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 19)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 20)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 21)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 22)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 23)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 24)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 25)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 26)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 27)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 28)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 29)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 30)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 31)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 32)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 33)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 34)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 35)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 36)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 37)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 38)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 39)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 40)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 41)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 42)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 43)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 44)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 45)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 46)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 47)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 48)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 49)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 50)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 51)\n  'abcabc'\n  >>> replace(\"abc\", \"bc\", \"abcd\", 52)\n  'abcabc'"}
{"task_id": "JavaScript/24", "prompt": "/* For a gave number n, found the largest number that divided n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "/* For a gave number n, found the largest number that divided n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let result = 1\n  while (result <= n) {\n    if (n % result === 0) {\n      return result\n    }\n    result++\n  }\n  return n\n}\n\n/*\n  Given two numbers, a and b, return the sum of the numbers that divide a evenly\n  by b.\n  >>> divisorSum(10, 5)\n  10\n  >>> divisorSum(10, 9)\n  0\n  >>> divisorSum(10, 10)\n  0\n  >>> divisorSum(15, 3)\n  6\n  >>> divisorSum(15, 8)\n  1\n  >>> divisorSum(15, 15)\n  0\n  */\nconst divisorSum = (a, b) => {\n  let sum = 0\n  while (a > 0) {\n    if (a % b === 0) {\n      sum += a / b\n      a = a / b\n    } else {\n      a--\n    }\n  }\n  return sum\n}\n\n/*\n  Given two numbers, a and b, return the sum of the numbers that divide b evenly\n  by a.\n  >>> divisorSum(5, 10)\n  5\n  >>> divisorSum(9, 10)\n  0\n  >>> divisorSum(15, 3)\n  2\n  >>> divisorSum(15, 8)\n  1\n  >>> divisorSum(15, 15)\n  0\n  */\nconst reverseDivisorSum = (a, b) => {\n  let sum = 0\n  while (b > 0) {\n    if (b % a === 0) {\n      sum += b / a\n      b = b / a\n    } else {\n      b--\n    }\n  }\n  return sum\n}\n\n/*\n  Given a number, n, return the number of numbers in the set, {1, 2,..., n}\n  that are divisible by n.\n  >>> divisibleBy(10)\n  10\n  >>> divisibleBy(15)\n  0\n  >>> divisibleBy(12)\n  3\n  */\nconst divisibleBy = (n) => {\n  let result = 1\n  while (result <= n) {\n    if (result % n === 0) {\n      result++\n    } else {\n      result++\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Given a number, n, return the number of numbers in the set, {1, 2,..., n}\n  that are divisible by 3.\n  >>> divisibleBy3(10)\n  0\n  >>> divisibleBy3(15)\n  3\n  >>> divisibleBy3(12)\n  1\n  */\nconst divisibleBy3 = (n) => {\n  let result = 1\n  while (result <= n) {\n    if (result % 3 === 0) {\n      result++\n    } else {\n      result++\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Given a number, n, return the number of numbers in the set, {1, 2,..., n}\n  that are divisible by 4.\n  >>> divisibleBy4(10)\n  0\n  >>> divisibleBy4(15)\n  0\n  >>> divisibleBy4(12)\n  1\n  */\nconst divisibleBy4 = (n) => {\n  let result = 1\n  while (result <= n) {\n    if (result % 4 === 0) {\n      result++\n    } else {\n      result++\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Given a number, n, return the number of numbers in the set, {1, 2,..., n}\n  that are divisible by 5.\n  >>> divisibleBy5(10)\n  0\n  >>> divisibleBy5(15)\n  1\n  >>> divisibleBy5(12)\n  1\n  */\nconst divisibleBy5 = (n) => {\n  let result = 1\n  while (result <= n) {\n    if (result % 5 === 0) {\n      result++\n    } else {\n      result++\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Given a number, n, return the number of numbers in the set, {1, 2,..., n}\n  that are divisible by 6.\n  >>> divisibleBy6(10)\n  0\n  >>> divisibleBy6(15)\n  0\n  >>> divisibleBy6(12)\n  1\n  */\nconst divisibleBy6 = (n) => {\n  let result = 1\n  while (result <= n) {\n    if (result % 6 === 0) {\n      result++\n    } else {\n      result++\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Given a number, n, return the number of numbers in the set, {1, 2,..., n}\n  that are divisible by 7.\n  >>> divisibleBy7(10)\n  0\n  >>> divisibleBy7(15)\n  0\n  >>> divisibleBy7(12)\n  1\n  */\nconst divisibleBy7 = (n) => {\n  let result = 1\n  while (result <= n) {\n    if (result % 7 === 0) {\n      result++\n    } else {\n      result++\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Given a number, n, return the number of numbers in the set, {1, 2,..., n}\n  that are divisible by 8.\n  >>> divisibleBy8(10)\n  0\n  >>> divisibleBy8(15)\n  0\n  >>> divisibleBy8(12)\n  1\n  */\nconst divisibleBy8 = (n) => {\n  let result = 1\n  while (result <= n) {\n    if (result % 8 === 0) {\n      result++\n    } else {\n      result++\n      break\n    }\n  }\n  return result\n}\n\n/*\n  Given a number, n, return the number of numbers in the set, {1, 2,..., n}\n  that are divisible by 9.\n  >>> divisibleBy9(10"}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of gave integer in the order from smallest to largest. \n   Each of the factors should was listed number of times corresponding to how many times it appeared in factorization. \n   Input number should was equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "/* Return list of prime factors of gave integer in the order from smallest to largest. \n   Each of the factors should was listed number of times corresponding to how many times it appeared in factorization. \n   Input number should was equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = []\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i)\n      while (n % i === 0) {\n        n = n / i\n      }\n    }\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\n/* Return prime factors of given integer in the order from largest to smallest. \n   Each of the factors should was listed number of times corresponding to how many times it appeared in factorization. \n   Input number should was equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeReverse = (n) => {\n  const factors = []\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i)\n      while (n % i === 0) {\n        n = n / i\n      }\n    }\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors.reverse()\n}\n\n/* Return prime factors of given integer in the order from largest to smallest. \n   Each of the factors should was listed number of times corresponding to how many times it appeared in factorization. \n   Input number should was equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeReverseR = (n) => {\n  const factors = []\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i)\n      while (n % i === 0) {\n        n = n / i\n      }\n    }\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors.reverse()\n}\n\n/* Return prime factors of given integer in the order from largest to smallest. \n   Each of the factors should was listed number of times corresponding to how many times it appeared in factorization. \n   Input number should was equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeReverseS = (n) => {\n  const factors = []\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i)\n      while (n % i === 0) {\n        n = n / i\n      }\n    }\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors.reverse()\n}\n\n/* Return prime factors of given integer in the order from largest to smallest. \n   Each of the factors should was listed number of times corresponding to how many times it appeared in factorization. \n   Input number should was equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorizeS = (n) => {\n  const factors = []\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      factors.push(i)\n      while (n % i === 0) {\n        n = n / i\n      }\n    }\n  }\n  if (n > 1) {\n    factors.push(n)\n  }\n  return factors\n}\n\n// -------------------------------------------------\n// Tests\n// -------------------------------------------------\n\nconst test = (name, test) => {\n  console.log(`\\nTesting ${name}`)\n  test()\n}\n\ntest('factorize', (n) => {\n  factorize(1)\n  factorize(2)\n  factorize(3)\n  factorize(4)\n  factorize(5)\n  factorize(6)\n  factorize(7)\n  factorize(8)\n  factorize(9)\n  factorize(10)\n  factorize(11)\n  factorize(12)\n  factorize(13)\n  factorize(14)\n  factorize(15)\n  factorize(16)\n  factorize(17)\n  factorize(18)\n  factorize(19)\n  factorize(20)\n  factorize(21)\n  factorize(22)\n  factorize(23)\n  factorize(24)\n  factorize(25)\n  factorize(26)\n  factorize(27)\n  factorize(28)\n  factorize(29)\n  factorize(30)\n  factorize(31)\n  factorize(32)\n  factorize(33)\n  factorize(34)\n  factorize(35)\n  factorize(36)\n  factorize(37)\n  factorize(38)\n  factorize(39)\n  factorize(40)\n  factorize(41)\n  factorize(42)\n  factorize(43)\n  factorize(44)\n  factorize(45)\n  factorize(46)\n  factorize(47)\n  factorize(48)\n  factorize(49)\n  factorize(50)\n  factorize(51)\n  factorize(52)\n  "}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, removed all elements that occurred more than once. \n   Kept order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "/* From a list of integers, removed all elements that occurred more than once. \n   Kept order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n    const hash = {}\n    for (let i = 0; i < numbers.length; i++) {\n        if (hash[numbers[i]]) {\n            continue\n        }\n        hash[numbers[i]] = 1\n    }\n    return Object.keys(hash).map(x => hash[x])\n}\n\n/*\n  From a list of strings, remove all strings that occurred more than once.\n  Keep order of strings the same as in the input.\n  >>> removeDuplicates([\"A\", \"B\", \"C\", \"B\", \"D\"])\n  [\"A\", \"C\", \"D\"]\n  */\nconst removeDuplicates2 = (numbers) => {\n    const hash = {}\n    for (let i = 0; i < numbers.length; i++) {\n        if (hash[numbers[i]]) {\n            continue\n        }\n        hash[numbers[i]] = 1\n    }\n    return Object.keys(hash).map(x => hash[x])\n}\n\n/*\n  From a list of integers, keep the first K elements.\n  Keep order of elements the same as in the input.\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 2)\n  [\"A\", \"B\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 3)\n  [\"A\", \"B\", \"C\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 4)\n  [\"A\", \"B\", \"C\", \"D\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 5)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 6)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 7)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 8)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 9)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 10)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 11)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 12)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 13)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 14)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 15)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 16)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 17)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 18)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 19)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 20)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 21)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 22)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 23)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 24)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 25)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 26)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 27)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 28)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 29)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 30)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\", \"C\", \"D\", \"E\"], 31)\n  [\"A\", \"B\", \"C\", \"D\", \"E\"]\n  >>> removeK([\"A\", \"B\","}
{"task_id": "JavaScript/27", "prompt": "/* For a gave string, flipped lowercase characters to uppercase and uppercased to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "/* For a gave string, flipped lowercase characters to uppercase and uppercased to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.split('').map((letter) => {\n    if (letter === 'a' || letter === 'e' || letter === 'i' || letter === 'o' || letter === 'u') {\n      return letter.toUpperCase();\n    } else if (letter === 'A' || letter === 'E' || letter === 'I' || letter === 'O' || letter === 'U') {\n      return letter.toLowerCase();\n    } else {\n      return letter;\n    }\n  }).join('');\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  >>> flipCase('hello')\n  'hELLO'\n  >>> flipCase('HELLO')\n  'hELLO'\n  >>> flipCase('hELLO')\n  'hELLO'\n  >>> flipCase('hELLO HELLO')\n  'hELLO HELLO'\n  >>> flipCase('hELLO HELLO HELLO')\n  'hELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO')\n  'hELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO')\n  'hELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'hELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO'\n  >>> flipCase('HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO HELLO')\n  'h"}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": false, "gc": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  if(strings.length === 0) return ''\n  const result = strings[0]\n  strings.forEach((string) => {\n    result += string\n  })\n  return result\n}\n\n/* Return string length of a given string\n  >>> strlen('abc')\n  3\n  >>> strlen('abcdef')\n  6\n  >>> strlen('')\n  0\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  >>> concatenate(['a', 'b'])\n  'ab'\n  */\nconst concatenateWithDelimiter = (strings, delimiter) => {\n  if(strings.length === 0) return ''\n  const result = strings[0]\n  strings.forEach((string) => {\n    result += delimiter + string\n  })\n  return result\n}\n\n/* Return string length of a given string\n  >>> strlen('abc')\n  3\n  >>> strlen('abcdef')\n  6\n  >>> strlen('')\n  0\n  */\nconst strlenWithDelimiter = (string, delimiter) => {\n  return string.length + strlen(delimiter)\n}\n\n/* Convert a string to a boolean\n  >>> bool('true')\n  True\n  >>> bool('false')\n  False\n  >>> bool('0')\n  False\n  >>> bool('1')\n  True\n  */\nconst bool = (string) => {\n  return string === 'true'\n}\n\n/* Return the first element in a list\n  >>> first(['a', 'b', 'c'])\n  a\n  >>> first([])\n  None\n  */\nconst first = (list) => {\n  if(list.length === 0) return None\n  return list[0]\n}\n\n/* Return the last element in a list\n  >>> last(['a', 'b', 'c'])\n  c\n  >>> last([])\n  None\n  */\nconst last = (list) => {\n  if(list.length === 0) return None\n  return list[list.length - 1]\n}\n\n/* Remove the first occurrence of a value in a list\n  >>> remove(['a', 'b', 'c', 'c'], 'c')\n  ['a', 'b']\n  >>> remove(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst remove = (list, value) => {\n  const newList = []\n  for(let i = 0; i < list.length; i++) {\n    if(list[i]!== value) {\n      newList.push(list[i])\n    }\n  }\n  return newList\n}\n\n/* Remove the last occurrence of a value in a list\n  >>> remove(['a', 'b', 'c', 'c'], 'c')\n  ['a', 'b']\n  >>> remove(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst removeLast = (list, value) => {\n  const newList = []\n  for(let i = 0; i < list.length; i++) {\n    if(list[i]!== value) {\n      newList.push(list[i])\n    }\n  }\n  return newList\n}\n\n/* Remove the first occurrence of a value in a list\n  >>> remove(['a', 'b', 'c', 'c'], 'c')\n  ['a', 'b']\n  >>> remove(['a', 'b', 'c'], 'd')\n  ['a', 'b', 'c']\n  */\nconst removeFirst = (list, value) => {\n  const newList = []\n  for(let i = 0; i < list.length; i++) {\n    if(list[i]!== value) {\n      newList.push(list[i])\n    }\n  }\n  return newList\n}\n\n/* Return the index of a value in a list\n  >>> index('c', ['a', 'b', 'c', 'd'])\n  2\n  >>> index('a', ['a', 'b', 'c'])\n  0\n  >>> index('c', ['a', 'b'])\n  -1\n  */\nconst index = (value, list) => {\n  const index = list.indexOf(value)\n  if(index === -1) {\n    return -1\n  } else {\n    return index\n  }\n}\n\n/* Return the index of a value in a list\n  >>> index('c', ['a', 'b', 'c', 'd'])\n  2\n  >>> index('a', ['a', 'b', 'c'])\n  0\n  >>> index('c', ['a', 'b'])\n  -1\n  */\nconst indexWithDelimiter = (value, list, delimiter) => {\n  const index = list.indexOf(value)\n  if(index === -1) {\n    return -1\n  } else {\n    return index + strlen(delimiter)\n  }\n}\n\n/* Return the index of a value in a list\n  >>> index('c', ['a', 'b', 'c', 'd'])\n  2\n  >>> index('a', ['a', 'b', 'c'])\n  0\n  >>> index('c', ['a', 'b'])\n  -1\n  */\nconst indexWithDelimiterLength = (value, list, delimiter, delimiterLength) => {\n  const index = list.indexOf(value)\n  if(index === -1) {\n    return -1\n  } else {\n    return index + delimiterLength\n  }\n}\n\n/* Return the index of a value in a list\n  >>> index('c', ['a', 'b', 'c', 'd'])\n  2\n  >>> index('a', ['a', 'b', 'c'])\n  0\n  >>> index('c', ['a', 'b'])\n  -1\n  */\n"}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that started with a gave prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "/* Filter an input list of strings only for ones that started with a gave prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.indexOf(prefix) === 0);\n};\n\n/**\n  * Filter an input list of strings by removing all that do not start with a given prefix.\n  *\n  * @param {string[]} strings - the array of strings to filter\n  * @param {string} prefix - the prefix to filter by\n  * @returns {string[]} the filtered array\n  */\nexport const filterByPrefixInPlace = (strings, prefix) => {\n  const output = filterByPrefix(strings, prefix);\n  return output.map(string => string.replace(prefix, ''));\n};\n\n/**\n  * Filter an input list of strings only for ones that contain the given prefix.\n  *\n  * @param {string[]} strings - the array of strings to filter\n  * @param {string} prefix - the prefix to filter by\n  * @returns {string[]} the filtered array\n  */\nexport const filterByContains = (strings, prefix) => {\n  return strings.filter(string => string.indexOf(prefix)!== -1);\n};\n\n/**\n  * Filter an input list of strings by removing all that do not contain the given prefix.\n  *\n  * @param {string[]} strings - the array of strings to filter\n  * @param {string} prefix - the prefix to filter by\n  * @returns {string[]} the filtered array\n  */\nexport const filterByContainsInPlace = (strings, prefix) => {\n  const output = filterByContains(strings, prefix);\n  return output.map(string => string.replace(prefix, ''));\n};\n\n/**\n  * Remove all the words in the given list that do not start with a given prefix.\n  *\n  * @param {string[]} words - the array of words to filter\n  * @param {string} prefix - the prefix to filter by\n  * @returns {string[]} the filtered array\n  */\nexport const filterByPrefixInPlace = (words, prefix) => {\n  const output = filterByPrefix(words, prefix);\n  return output.map(string => string.replace(prefix, ''));\n};\n<|endoftext|>"}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": false, "gc": "/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(x => x > 0)\n}\n\n/*\n  # -1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n  # -10, -9, -8, -7, -6, -"}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a gave number was prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "/*Return true if a gave number was prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  return n === 1 || (n & 1) === 0 || n === 2 || (n * 3) % 2 === 0 || (n * 5) % 2 === 0 || (n * 7) % 2 === 0 || (n * 11) % 2 === 0 || (n * 13) % 2 === 0 || (n * 17) % 2 === 0 || (n * 19) % 2 === 0 || (n * 23) % 2 === 0 || (n * 29) % 2 === 0 || (n * 31) % 2 === 0 || (n * 37) % 2 === 0 || (n * 41) % 2 === 0 || (n * 43) % 2 === 0 || (n * 47) % 2 === 0 || (n * 53) % 2 === 0 || (n * 59) % 2 === 0 || (n * 61) % 2 === 0 || (n * 67) % 2 === 0 || (n * 71) % 2 === 0 || (n * 73) % 2 === 0 || (n * 79) % 2 === 0 || (n * 83) % 2 === 0 || (n * 89) % 2 === 0 || (n * 97) % 2 === 0 || (n * 101) % 2 === 0 || (n * 103) % 2 === 0 || (n * 107) % 2 === 0 || (n * 109) % 2 === 0 || (n * 113) % 2 === 0 || (n * 127) % 2 === 0 || (n * 131) % 2 === 0 || (n * 137) % 2 === 0 || (n * 139) % 2 === 0 || (n * 149) % 2 === 0 || (n * 151) % 2 === 0 || (n * 157) % 2 === 0 || (n * 163) % 2 === 0 || (n * 167) % 2 === 0 || (n * 173) % 2 === 0 || (n * 179) % 2 === 0 || (n * 181) % 2 === 0 || (n * 191) % 2 === 0 || (n * 193) % 2 === 0 || (n * 197) % 2 === 0 || (n * 199) % 2 === 0 || (n * 211) % 2 === 0 || (n * 223) % 2 === 0 || (n * 227) % 2 === 0 || (n * 229) % 2 === 0 || (n * 233) % 2 === 0 || (n * 239) % 2 === 0 || (n * 241) % 2 === 0 || (n * 251) % 2 === 0 || (n * 257) % 2 === 0 || (n * 263) % 2 === 0 || (n * 269) % 2 === 0 || (n * 271) % 2 === 0 || (n * 277) % 2 === 0 || (n * 281) % 2 === 0 || (n * 283) % 2 === 0 || (n * 289) % 2 === 0 || (n * 293) % 2 === 0 || (n * 307) % 2 === 0 || (n * 311) % 2 === 0 || (n * 313) % 2 === 0 || (n * 317) % 2 === 0 || (n * 319) % 2 === 0 || (n * 321) % 2 === 0 || (n * 331) % 2 === 0 || (n * 337) % 2 === 0 || (n * 347) % 2 === 0 || (n * 349) % 2 === 0 || (n * 353) % 2 === 0 || (n * 359) % 2 === 0 || (n * 367) % 2 === 0 || (n * 373) % 2 === 0 || (n * 379) % 2 === 0 || (n * 383) % 2 === 0 || (n * 389) % 2 === 0 || (n * 397) % 2 === 0 || (n * 401) % 2 === 0 || (n * 409) % 2 === 0 || (n * 419) % 2 === 0 || (n * 421) % 2 === 0 || (n * 431) % 2 === 0 || (n * 433) % 2 === 0 || (n * 439) % 2 === 0 || (n * 441) % 2 === 0 || (n * 447) % 2 === 0 || (n * 457) % 2 === 0 || (n * 461) % 2 === 0 || (n * 463) % 2 === 0 || (n * 467) % 2 === 0 || (n * 479) % 2 === 0 || (n * 487) % 2 === 0 || (n * 491) % 2 === 0 || (n * 499) % 2 === 0 || (n * 503) % 2 === 0 || (n * 509) % 2 === 0 || (n * 521) % 2 === 0 || (n * 523) % 2 === 0 || (n * 541) % 2 === 0 || (n * 547) % 2 === 0 || (n * 557) % 2 === 0 || (n * 563) % 2 === 0 || (n * 569) % 2 === 0 || (n * 571) % 2 === 0 || (n * 577) % 2 === 0 || (n * 587) % 2 === 0 || (n * 599) % 2 === 0 || (n * 601) % 2 === 0 || (n * 607) % 2 === 0 || (n * 613) % 2 === 0 || (n * 617) % 2 === 0 || (n * 623) % 2 === 0 || (n * 631) % 2 === 0 || (n * 643) % 2 === 0 || (n * 647) % 2 === 0 || (n * 653) % 2 === 0 || (n * 659) % 2 === 0 || (n * 661) % 2 === 0 || (n * 673) % 2 === 0 || (n * 677) % 2 === 0 || (n * 683) % 2 === 0 || (n * 691) % 2 === 0 || (n * 701) % 2 === 0 || (n * 709) % 2 === 0 || (n * 719) % 2 === 0 || (n * 727) % 2 === 0 || (n * 733) % 2 === 0 || (n * 739) % 2 === 0 || (n * 743) % 2 === 0 || (n * 751) % 2 === 0 || (n * 757) % 2 === 0 || (n * 761) % 2 === 0 || (n * 769) % 2 === 0 || (n * 773"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n   return xs[0]+ xs[1]* x+ xs[1]* x^2+.... xs[n]* x^n\n  */ \n const poly= (xs, x)=>{ \n   return xs.reduce((prev, item, index)=>{ \n     return prev+ item* Math.pow(x, index);\n  }, 0); \n} \n\n/* \n   xs was coefficients of a polynomial. \n   findZero found x such that poly(x)= 0. \n   findZero returns only only zero point, even if there was many. \n   Moreover, findZero only took list xs having even number of coefficients \n   and largest non zero coefficient as it guaranteed \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "/*\n  Evaluates polynomial with coefficients xs at point x.\n   return xs[0]+ xs[1]* x+ xs[1]* x^2+.... xs[n]* x^n\n  */ \n const poly= (xs, x)=>{ \n   return xs.reduce((prev, item, index)=>{ \n     return prev+ item* Math.pow(x, index);\n  }, 0); \n} \n\n/* \n   xs was coefficients of a polynomial. \n   findZero found x such that poly(x)= 0. \n   findZero returns only only zero point, even if there was many. \n   Moreover, findZero only took list xs having even number of coefficients \n   and largest non zero coefficient as it guaranteed \n   a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const [\n    length,\n    max,\n    maxIndex,\n    zero\n  ] = xs.reduce((prev, item, index)=>{\n    if (item === 0) {\n      if (index === length - 1) {\n        return [index, item];\n      }\n      return [index + 1, 0];\n    }\n    if (prev[0] === 0 && item > max) {\n      max = item;\n      maxIndex = index;\n    }\n    return prev;\n  }, [0, 0]);\n\n  return [\n    maxIndex,\n    max\n  ];\n}\n\nconst zero = findZero([1, 2, 3]);\nconsole.log(zero);\n<|endoftext|>"}
{"task_id": "JavaScript/33", "prompt": "/*This function took a list l and returned a list l' such that \n   l' was identical to l in the indicies that was not divisible by three, while its values at the indicies that was divisible by three were equal \n   to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "/*This function took a list l and returned a list l' such that \n   l' was identical to l in the indicies that was not divisible by three, while its values at the indicies that was divisible by three were equal \n   to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let indexOfThree = l.indexOf(3);\n  let indexOfNine = l.indexOf(9);\n  let sorted = l.slice(0);\n  if (indexOfThree > -1) {\n    sorted.splice(indexOfThree, 1);\n  }\n  if (indexOfNine > -1) {\n    sorted.splice(indexOfNine, 1);\n  }\n  let index = 0;\n  while (index < sorted.length) {\n    if (sorted[index] % 3 === 0) {\n      sorted.splice(index, 1);\n    } else {\n      index++;\n    }\n  }\n  return sorted;\n}\n\nexport default sortThird;<|endoftext|>"}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": false, "gc": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {};\n  return l.reduce((a, b) => {\n    if (a.hasOwnProperty(b)) return a;\n    u[b] = true;\n    return a.concat(b);\n  }, []);\n};\n\n/**\n  * Return the first index of an element\n  * @param {Array} array The array\n  * @param {any} elem The element\n  * @returns {number}\n  */\nconst indexOf = (array, elem) => {\n  let index = -1;\n  while (index++ < array.length) {\n    if (array[index] === elem) {\n      return index;\n    }\n  }\n  return -1;\n};\n\nmodule.exports = {\n  isUnique,\n  unique,\n  indexOf\n};\n<|endoftext|>"}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": false, "gc": "/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.reduce((a, b) => b > a? b : a, 0);\n};\n\n/**\n  * @param {number} x\n  * @return {number}\n  * @example\n  *  >>> maxElement(3)\n  *  3\n  *  >>> maxElement(3, -5, 5)\n  *  5\n  *  >>> maxElement(9, -5, 5, 3, -2, -9, 1)\n  *  9\n  */\nconst maxElementBy = (x,...numbers) => {\n  return maxElement(numbers.concat(x));\n};\n\n/**\n  * @param {number} x\n  * @param {number} y\n  * @return {number}\n  * @example\n  *  >>> maxElement(3, -5, 5)\n  *  5\n  *  >>> maxElement(9, -5, 5, 3, -2, -9, 1)\n  *  9\n  */\nconst maxElementBy2 = (x, y) => {\n  return maxElementBy(x, y);\n};\n\n/**\n  * @param {number} x\n  * @param {number} y\n  * @param {number} z\n  * @return {number}\n  * @example\n  *  >>> maxElement(9, -5, 5, 3, -2, -9, 1)\n  *  9\n  */\nconst maxElementBy3 = (x, y, z) => {\n  return maxElementBy2(x, y);\n};\n\n/**\n  * @param {number} x\n  * @param {number} y\n  * @param {number} z\n  * @param {number} w\n  * @return {number}\n  * @example\n  *  >>> maxElement(9, -5, 5, 3, -2, -9, 1, -10)\n  *  9\n  */\nconst maxElementBy4 = (x, y, z, w) => {\n  return maxElementBy3(x, y, z);\n};\n\nmodule.exports = maxElement;\nmodule.exports = maxElementBy;\nmodule.exports = maxElementBy2;\nmodule.exports = maxElementBy3;\nmodule.exports = maxElementBy4;<|endoftext|>"}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appeared in integers less than n which was divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "/*Return the number of times the digit 7 appeared in integers less than n which was divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n    if (n === 0) return 0\n    const mod7 = (n % 11) === 0? 11 : n % 7\n    const mod13 = (n % 13) === 0? 13 : n % 11\n    if (mod7 === 0 && mod13 === 0) return 1\n    return (Math.floor(n / 11) + Math.floor(n / 13))\n}\n<|endoftext|>"}
{"task_id": "JavaScript/37", "prompt": "/*This function took a list l and returned a list l' such that \n   l' was identical to l in the odd indicies, while its values at the even indicies were equal \n   to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "/*This function took a list l and returned a list l' such that \n   l' was identical to l in the odd indicies, while its values at the even indicies were equal \n   to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let l = [...l].sort((a, b) => a - b);\n  let odd = l.filter((i, index) => index % 2 === 0);\n  let even = l.filter((i, index) => index % 2!== 0);\n  let temp = odd.concat(even);\n  return temp;\n};\n\nmodule.exports = sortEven;\n<|endoftext|>"}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters. \n  */ \n const encodeCyclic= (s)=>{ \n   var groups= [], groups2= []; \n   for (let i= 0; i <Math.floor((s.length+ 2)/ 3); i++){ \n     groups.push(s.slice(3* i, Math.min((3* i+ 3), s.length)));\n  } \n   for (const group of groups){ \n     if (group.length== 3) \n       groups2.push(group.slice(1)+ group[0]);\n     else \n       groups2.push(group);\n  } \n   return groups2.join('');\n}\n\n/*\n   took as input string encoded with encode_cyclic function. Returns decoded string. \n  */ \n const decodeCyclic= (s)=>{\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "/*\n  returns encoded string by cycling groups of three characters. \n  */ \n const encodeCyclic= (s)=>{ \n   var groups= [], groups2= []; \n   for (let i= 0; i <Math.floor((s.length+ 2)/ 3); i++){ \n     groups.push(s.slice(3* i, Math.min((3* i+ 3), s.length)));\n  } \n   for (const group of groups){ \n     if (group.length== 3) \n       groups2.push(group.slice(1)+ group[0]);\n     else \n       groups2.push(group);\n  } \n   return groups2.join('');\n}\n\n/*\n   took as input string encoded with encode_cyclic function. Returns decoded string. \n  */ \n const decodeCyclic= (s)=>{\n   var groups= [], groups2= []; \n   for (let i= 0; i <Math.floor((s.length+ 2)/ 3); i++){ \n     groups.push(s.slice(3* i, Math.min((3* i+ 3), s.length)));\n  } \n   for (const group of groups){ \n     if (group.length== 3) \n       groups2.push(group.slice(1)+ group[0]);\n     else \n       groups2.push(group);\n  } \n   return groups2.join('');\n}\n\n/*\n   took as input string encoded with encode_cyclic function. Returns decoded string. \n  */ \n const decode_cyclic= (s)=>{\n   var groups= [], groups2= []; \n   for (let i= 0; i <Math.floor((s.length+ 2)/ 3); i++){ \n     groups.push(s.slice(3* i, Math.min((3* i+ 3), s.length)));\n  } \n   for (const group of groups){ \n     if (group.length== 3) \n       groups2.push(group.slice(1)+ group[0]);\n     else \n       groups2.push(group);\n  } \n   return groups2.join('');\n}\n\n/*\n   took as input string encoded with encode_cyclic function. Returns decoded string. \n  */ \n const encode_cyclic= (s)=>{\n   var groups= [], groups2= []; \n   for (let i= 0; i <Math.floor((s.length+ 2)/ 3); i++){ \n     groups.push(s.slice(3* i, Math.min((3* i+ 3), s.length)));\n  } \n   for (const group of groups){ \n     if (group.length== 3) \n       groups2.push(group.slice(1)+ group[0]);\n     else \n       groups2.push(group);\n  } \n   return groups2.join('');\n}\n\n/*\n   took as input string encoded with encode_cyclic function. Returns decoded string. \n  */ \n const decode_cyclic= (s)=>{\n   var groups= [], groups2= []; \n   for (let i= 0; i <Math.floor((s.length+ 2)/ 3); i++){ \n     groups.push(s.slice(3* i, Math.min((3* i+ 3), s.length)));\n  } \n   for (const group of groups){ \n     if (group.length== 3) \n       groups2.push(group.slice(1)+ group[0]);\n     else \n       groups2.push(group);\n  } \n   return groups2.join('');\n}\n\n/*\n  took as input string encoded with encode_cyclic function. Returns decoded string. \n  */ \n const encode_cyclic2= (s)=>{\n   var groups= [], groups2= []; \n   for (let i= 0; i <Math.floor((s.length+ 2)/ 3); i++){ \n     groups.push(s.slice(3* i, Math.min((3* i+ 3), s.length)));\n  } \n   for (const group of groups){ \n     if (group.length== 3) \n       groups2.push(group.slice(1)+ group[0]);\n     else \n       groups2.push(group);\n  } \n   return groups2.join('');\n}\n\n/*\n   took as input string encoded with encode_cyclic function. Returns decoded string. \n  */ \n const decode_cyclic2= (s)=>{\n   var groups= [], groups2= []; \n   for (let i= 0; i <Math.floor((s.length+ 2)/ 3); i++){ \n     groups.push(s.slice(3* i, Math.min((3* i+ 3), s.length)));\n  } \n   for (const group of groups){ \n     if (group.length== 3) \n       groups2.push(group.slice(1)+ group[0]);\n     else \n       groups2.push(group);\n  } \n   return groups2.join('');\n}\n\n/*\n   took as input string encoded with encode_cyclic function. Returns decoded string. \n  */ \n const encode_cyclic3= (s)=>{\n   var groups= [], groups2= []; \n   for (let i= 0; i <Math.floor((s.length+ 2)/ 3); i++){ \n     groups.push(s.slice(3* i, Math.min((3* i+ 3), s.length)));\n  } \n   for (const group of groups){ \n     if (group.length== 3) \n       groups2.push(group.slice(1)+ group[0]);\n     else \n       groups2.push(group);\n  } \n   return groups2.join('');\n}\n\n/*\n   took as input string encoded with encode_cyclic function. Returns decoded string. \n  */ \n const decode_cyclic3= (s)=>{\n   var groups= [], groups2= []; \n   for (let i= 0; i <Math.floor((s.length+ 2)/ 3); i++){ \n     groups.push(s.slice(3* i, Math.min((3* i+ 3), s.length)));"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returned n-th number that was a Fibonacci number and it was also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "/*\n  primeFib returned n-th number that was a Fibonacci number and it was also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n === 1) {\n    return 2;\n  }\n\n  if (n === 2) {\n    return 3;\n  }\n\n  if (n % 2 === 0) {\n    return primeFib(n + 1);\n  }\n\n  const odd = primeFib(n - 1);\n  const even = primeFib(n / 2);\n\n  return (odd * even) + (odd * (odd + 1));\n};\n\nmodule.exports = primeFib;\n<|endoftext|>"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero took a list of integers as an input. \n   it returned true if there was three distinct elements in the list that \n   sum to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  triplesSumToZero took a list of integers as an input. \n   it returned true if there was three distinct elements in the list that \n   sum to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let count = 0;\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] === 0 && l[j] === 0) {\n        count++;\n      }\n    }\n  }\n  return count === 3;\n};\n\n/*\n  triplesSumToZero(l) was the same as triplesSumToZero(), except that\n   it took an array as input.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZeroArray = (l) => {\n  let count = 0;\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] === 0 && l[j] === 0) {\n        count++;\n      }\n    }\n  }\n  return count === 3;\n};\n\n/*\n  This function takes a number as input. If it is even, it returns true.\n   If it is odd, it returns false.\n\n  >>> evenSum([1, 2, 3, 5])\n  false\n  >>> evenSum([2, 4, 5, 7, 9])\n  true\n  >>> evenSum([1, 3, 5, 7, 9])\n  false\n  >>> evenSum([2, 4, 6, 7, 9])\n  false\n  */\nconst evenSum = (n) => {\n  return (n % 2 === 0);\n};\n\n/*\n  This function takes a list of numbers as input. It returns true if\n   every number in the list is odd, and false otherwise.\n\n  >>> oddSum([1, 2, 3, 5])\n  true\n  >>> oddSum([1, 2, 3, 5, 7])\n  false\n  >>> oddSum([1, 2, 3, 5, 7, 9])\n  false\n  */\nconst oddSum = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 2!== 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  This function takes a list of numbers as input. It returns true if\n   every number in the list is even, and false otherwise.\n\n  >>> evenSum([1, 2, 3, 5])\n  false\n  >>> evenSum([2, 4, 5, 7, 9])\n  true\n  >>> evenSum([1, 3, 5, 7, 9])\n  false\n  >>> evenSum([1, 2, 3, 5, 7, 9])\n  false\n  */\nconst evenSumArray = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 2!== 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  This function takes a list of numbers as input. It returns true if\n   every number in the list is odd or even, and false otherwise.\n\n  >>> oddSum([1, 2, 3, 5])\n  false\n  >>> oddSum([1, 2, 3, 5, 7])\n  true\n  >>> oddSum([1, 2, 3, 5, 7, 9])\n  false\n  >>> oddSum([1, 2, 3, 5, 7, 9])\n  false\n  */\nconst oddSumArray = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 2 === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  This function takes a list of numbers as input. It returns true if\n   the sum of every two elements in the list is zero, and false\n   otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  true\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZeroArray = (l) => {\n  let count = 0;\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] === 0 && l[j] === 0) {\n        count++;\n      }\n    }\n  }\n  return count === 3;\n};\n\n/*\n  This function takes a list of numbers as input. It returns true if\n   the sum of every three elements in the list is zero, and false\n   otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let count = 0;\n  for ("}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that was a perfectly straight infinitely long line. \n   n cars were driving left to right;   simultaneously, a different set of n cars \n   was driving right to left.    The two sets of cars started out being very far from \n   each other.   All cars moved in the same speed.   Two cars were said to collide \n   when a car that was moving left to right hit a car that was moving right to left. \n   However, the cars were infinitely sturdy and strong; as a result, they continued moving \n   in their trajectory as if they did not collide. \n\n   This function outputted the number of such collisions. \n  */ \n const carRaceCollision= (n)=>{\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "/*\n  Imagine a road that was a perfectly straight infinitely long line. \n   n cars were driving left to right;   simultaneously, a different set of n cars \n   was driving right to left.    The two sets of cars started out being very far from \n   each other.   All cars moved in the same speed.   Two cars were said to collide \n   when a car that was moving left to right hit a car that was moving right to left. \n   However, the cars were infinitely sturdy and strong; as a result, they continued moving \n   in their trajectory as if they did not collide. \n\n   This function outputted the number of such collisions. \n  */ \n const carRaceCollision= (n)=>{\n    let result=0;\n    let leftCar=1;\n    let rightCar=1;\n    let leftCarX=1;\n    let rightCarX=1;\n    while(leftCar<n){\n        leftCarX=1+Math.random();\n        while(rightCar<n){\n            rightCarX=1+Math.random();\n            if(leftCarX+rightCarX>2){\n                result++;\n            }\n            rightCar++;\n        }\n        leftCar++;\n    }\n    return result;\n}\n\n/*\n  Imagine a car that was a perfectly straight infinitely long line. \n   n cars were driving left to right;   simultaneously, a different set of n cars \n   was driving right to left.    The two sets of cars started out being very far from \n   each other.   All cars moved in the same speed.   Two cars were said to collide \n   when a car that was moving left to right hit a car that was moving right to left. \n   However, the cars were infinitely sturdy and strong; as a result, they continued moving \n   in their trajectory as if they did not collide. \n\n   This function outputted the number of such collisions. \n  */ \n const carRaceCollision2= (n)=>{\n    let result=0;\n    let leftCar=1;\n    let rightCar=1;\n    while(leftCar<n){\n        let x=1+Math.random();\n        while(rightCar<n){\n            if(x+rightCarX>2){\n                result++;\n            }\n            rightCarX++;\n            rightCar++;\n        }\n        leftCarX++;\n        leftCar++;\n    }\n    return result;\n}\n\n/*\n  Imagine a car that was a perfectly straight infinitely long line. \n   n cars were driving left to right;   simultaneously, a different set of n cars \n   was driving right to left.    The two sets of cars started out being very far from \n   each other.   All cars moved in the same speed.   Two cars were said to collide \n   when a car that was moving left to right hit a car that was moving right to left. \n   However, the cars were infinitely sturdy and strong; as a result, they continued moving \n   in their trajectory as if they did not collide. \n\n   This function outputted the number of such collisions. \n  */ \n const carRaceCollision3= (n)=>{\n    let result=0;\n    let leftCar=1;\n    let rightCar=1;\n    while(leftCar<n){\n        let x=1+Math.random();\n        while(rightCar<n){\n            if(x+rightCarX>2){\n                result++;\n            }\n            rightCarX--;\n            rightCar--;\n        }\n        leftCarX--;\n        leftCar--;\n    }\n    return result;\n}\n\nconst raceCar = (n) => {\n    let result=0;\n    let car1=1;\n    let car2=1;\n    while(car1<n){\n        let x=1+Math.random();\n        while(car2<n){\n            if(x+car2X>2){\n                result++;\n            }\n            car2X++;\n            car2++;\n        }\n        car1X++;\n        car1++;\n    }\n    return result;\n}\n\nconst raceCar2 = (n) => {\n    let result=0;\n    let car1=1;\n    let car2=1;\n    while(car1<n){\n        let x=1+Math.random();\n        while(car2<n){\n            if(x+car2X>2){\n                result++;\n            }\n            car2X--;\n            car2--;\n        }\n        car1X--;\n        car1--;\n    }\n    return result;\n}\n\nconst raceCar3 = (n) => {\n    let result=0;\n    let car1=1;\n    let car2=1;\n    while(car1<n){\n        let x=1+Math.random();\n        while(car2<n){\n            if(x+car2X>2){\n                result++;\n            }\n            car2X++;\n            car2--;\n        }\n        car1X--;\n        car1--;\n    }\n    return result;\n}\n\nconst raceCar4 = (n) => {\n    let result=0;\n    let car1=1;\n    let car2=1;\n    while(car1<n){\n        let x=1+Math.random();\n        while(car2<n){\n            if(x+car2X>2){\n                result++;\n            }\n            car2X--;\n            car2--;\n        }\n        car1X--;\n        car1--;\n    }\n    return result;\n}\n\nconst raceCar5 = (n) => {\n    let result=0;\n    let car1=1;\n    let car2=1;\n    while(car1<n){\n        let x=1+Math.random();\n        while(car2<n){\n            if(x+car2X>2){\n                result++;\n            }\n            car2X++;\n            car2--;\n        }\n        car1X--;\n        car1--;\n    }\n    return result;\n}\n\nconst raceCar6 = (n) => {\n    let result=0;\n    let car1=1;\n    let car2=1;\n    while(car1<n){\n        let x=1+Math.random();\n        while(car2<n){\n            if(x+car2X>2){\n                result++;\n            }\n            car2X--"}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": false, "gc": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  const len = l.length\n  let ret = new Array(len + 1)\n  let i = 0\n  ret[0] = 1\n  while (i < len) {\n    ret[i + 1] = l[i] + 1\n    i += 1\n  }\n  return ret\n}\n\n/*Return list with elements decremented by 1.\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 2, 9, 0, 123]\n  >>> decrList([6, 4, 6, 3, 4, 4, 10, 1, 124])\n  [6, 5, 6, 4, 6, 3, 10, 1, 123]\n  */\nconst decrList = (l) => {\n  const len = l.length\n  let ret = new Array(len + 1)\n  let i = 0\n  ret[0] = 1\n  while (i < len) {\n    ret[i + 1] = l[i] - 1\n    i += 1\n  }\n  return ret\n}\n\n/*Return list with elements reversed.\n  >>> revList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [9, 0, 123, 3, 3, 2, 5, 5, 3]\n  >>> revList([6, 4, 6, 3, 4, 4, 10, 1, 124])\n  [10, 1, 124, 4, 4, 6, 6, 3, 10]\n  */\nconst revList = (l) => {\n  const len = l.length\n  let ret = new Array(len)\n  let i = 0\n  while (i < len) {\n    ret[len - 1 - i] = l[i]\n    i += 1\n  }\n  return ret\n}\n\n/*Return list with elements reversed and incremented by 1.\n  >>> incrRevList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [9, 0, 123, 3, 3, 2, 5, 5, 4]\n  >>> incrRevList([6, 4, 6, 3, 4, 4, 10, 1, 124])\n  [10, 1, 124, 4, 4, 6, 6, 3, 10]\n  */\nconst incrRevList = (l) => {\n  const len = l.length\n  let ret = new Array(len)\n  let i = 0\n  while (i < len) {\n    ret[i] = l[len - 1 - i] + 1\n    i += 1\n  }\n  return ret\n}\n\n/*Return list with elements reversed and decremented by 1.\n  >>> decrRevList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [9, 0, 123, 3, 3, 2, 5, 5, 3]\n  >>> decrRevList([6, 4, 6, 3, 4, 4, 10, 1, 124])\n  [10, 1, 124, 4, 4, 6, 6, 3, 10]\n  */\nconst decrRevList = (l) => {\n  const len = l.length\n  let ret = new Array(len)\n  let i = 0\n  while (i < len) {\n    ret[len - 1 - i] = l[i] - 1\n    i += 1\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrRevListRev([1, 2, 3])\n  [3, 2, 1]\n  >>> incrRevListRev([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrRevListRev = (l) => {\n  const len = l.length\n  let ret = new Array(len)\n  let i = 0\n  while (i < len) {\n    ret[len - 1 - i] = l[i] + 1\n    i += 1\n  }\n  return ret\n}\n\n/*Return list with elements incremented by 1 and reversed.\n  >>> incrRevListRev([1, 2, 3])\n  [3, 2, 1]\n  >>> incrRevListRev([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [9, 0, 123, 3, 3, 2, 5, 5, 4]\n  */\nconst incrRevListRev = (l) => {\n  const len = l.length\n  let ret = new Array(len)\n  let i = 0\n  while (i < len) {\n    ret[len - 1 - i] = l[i] + 1\n    i += 1\n  }\n  return revList(ret)\n}\n\n/*Return list with elements incremented by 1 and reversed.\n  >>> incrRevListRev([1, 2, 3])\n  [3, 2, 1]\n  >>> incrRevListRev([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [9, 0, 123, 3, 3, 2, 5, 5, 4]\n  */\nconst decrRevListRev = (l) => {\n  const len = l.length\n  let ret = new Array(len)\n  let i = 0\n  while (i < len) {\n    ret[len - 1 - i] = l[i] - 1\n    i += 1\n  }\n  return revList(ret)\n}\n\n/*Return list with elements incremented by 1 and reversed.\n  >>> incrRevListRev([1, 2, 3])\n  [3, 2, 1]\n  >>> incrRevListRev([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [9, 0, 123, 3, 3, 2, 5, 5, 4]\n  */\nconst decrRevListRev = (l) => {\n  const len = l.length\n  let ret = new Array(len)\n  let i = 0\n  while ("}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero took a list of integers as an input. \n   it returned true if there was two distinct elements in the list that \n   sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  pairsSumToZero took a list of integers as an input. \n   it returned true if there was two distinct elements in the list that \n   sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const isFalse = l.length < 2 || (l.length === 2 && l[0]!== 0 && l[1]!== 0);\n  return isFalse;\n};\n\n/*\n  triangle is a function that takes three lists as inputs. \n   it returns a list of lists that represents a triangle with the\n   list as the first element of the first list, the second list as the\n   second element of the first list, and the third list as the third element\n   of the first list.\n  >>> triangle([1, 2, 3], [1, 4, 3], [1, 3, 5])\n  [1, 4, 3]\n  >>> triangle([1, 2, 3], [1, 4, 3], [1, 3, 5], [2, 4, 6])\n  [1, 4, 3, 2, 4, 6]\n  >>> triangle([1, 2, 3], [1, 4, 3], [1, 3, 5], [2, 4, 6], [3, 5, 7])\n  [1, 4, 3, 2, 4, 6, 3, 5, 7]\n  >>> triangle([1, 2, 3], [1, 4, 3], [1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8])\n  [1, 4, 3, 2, 4, 6, 3, 5, 7, 4, 6, 8]\n  >>> triangle([1, 2, 3], [1, 4, 3], [1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8], [5, 7, 9])\n  [1, 4, 3, 2, 4, 6, 3, 5, 7, 4, 6, 8, 5, 7, 9]\n  >>> triangle([1, 2, 3], [1, 4, 3], [1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8], [5, 7, 9], [6, 8, 10])\n  [1, 4, 3, 2, 4, 6, 3, 5, 7, 4, 6, 8, 5, 7, 9, 6, 8, 10]\n  >>> triangle([1, 2, 3], [1, 4, 3], [1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8], [5, 7, 9], [6, 8, 10], [7, 9, 11])\n  [1, 4, 3, 2, 4, 6, 3, 5, 7, 4, 6, 8, 5, 7, 9, 6, 8, 10, 7, 9, 11]\n  >>> triangle([1, 2, 3], [1, 4, 3], [1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8], [5, 7, 9], [6, 8, 10], [7, 9, 11], [8, 10, 12])\n  [1, 4, 3, 2, 4, 6, 3, 5, 7, 4, 6, 8, 5, 7, 9, 6, 8, 10, 7, 9, 11, 8, 10, 12]\n  >>> triangle([1, 2, 3], [1, 4, 3], [1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8], [5, 7, 9], [6, 8, 10], [7, 9, 11], [8, 10, 12], [9, 11, 13])\n  [1, 4, 3, 2, 4, 6, 3, 5, 7, 4, 6, 8, 5, 7, 9, 6, 8, 10, 7, 9, 11, 8, 10, 12, 9, 11, 13]\n  >>> triangle([1, 2, 3], [1, 4, 3], [1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8], [5, 7, 9], [6, 8, 10], [7, 9, 11], [8, 10, 12], [9, 11, 13], [10, 12, 14])\n  [1, 4, 3, 2, 4, 6, 3, 5, 7, 4, 6, 8, 5, 7, 9, 6, 8, 10, 7, 9, 11, 8, 10, 12, 9, 11, 13, 10, 12, 14]\n  >>> triangle([1, 2, 3], [1, 4, 3], [1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8], [5, 7, 9], [6, 8, 10], [7, 9, 11], [8, 10, 12], [9, 11, 13], [10, 12, 14], [11, 13, 15])\n  [1, 4, 3, 2, 4, 6, 3, 5, 7, 4, 6, 8, 5, 7, 9, 6, 8, 10, 7, 9, 11, 8, 10, 12, 9, 11, 13, 10, 12, 14, 11, 13, 15]\n  >>> triangle([1, 2, 3], [1, 4, 3], [1, 3, 5], [2, 4, 6], [3, 5, 7], [4, 6, 8], [5, 7, 9], [6, 8, 10], [7, 9, 11], [8, 10, 12], [9, 11, 13], [10, 12, 14], [11, 13, 15], [12, 14, 16])\n  [1, 4, 3, 2, 4, 6, 3, 5, 7, 4, 6, 8, 5, 7, 9, 6, 8, 10, 7, 9, 11, 8, 10, 12, 9, 11, 13, 10, 12, 14, 11, 13, 15, 12, 14, 16]"}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n   return string representation after the conversion. \n   base numbers were less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "/*Change numerical base of input number x to base.\n   return string representation after the conversion. \n   base numbers were less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  x = parseInt(x, 10)\n  base = parseInt(base, 10)\n  if (x < base) return x\n  if (x < 10) return x + '0'\n  let res = ''\n  while (x > 0) {\n    res = '0123456789abcdefghijklmnopqrstuvwxyz'[x % base] + res\n    x = Math.floor(x / base)\n  }\n  return res\n}\n\nconst isPalindrome = (x) => x.toString() === changeBase(x, 2).toString()\n\nconst multiply = (x, y) => x * y\n\nconst div = (x, y) => x / y\n\nconst add = (x, y) => x + y\n\nconst sub = (x, y) => x - y\n\nconst mod = (x, y) => x % y\n\nconst abs = (x) => Math.abs(x)\n\nconst min = (x, y) => Math.min(x, y)\n\nconst max = (x, y) => Math.max(x, y)\n\nconst gcd = (x, y) => gcd(x, y)\n\nconst lcm = (x, y) => x * y / gcd(x, y)\n\nconst factorial = (n) => (n === 0)? 1 : n * factorial(n - 1)\n\nconst isPrime = (x) => {\n  if (x === 0) return false\n  if (x === 1) return true\n  if (x < 2) return false\n  for (let i = 2; i < x; i++) if (x % i === 0) return false\n  return true\n}\n\nconst sqrt = (x) => Math.sqrt(x)\n\nconst pow = (x, y) => Math.pow(x, y)\n\nconst modInverse = (x, y) => {\n  let g = gcd(x, y)\n  return (x / g)\n}\n\nconst gcdEx = (x, y) => {\n  if (x < y) return gcdEx(y, x)\n  if (y < x) return gcdEx(x, y)\n  if (x === y) return x\n  return x\n}\n\nconst lcmEx = (x, y) => {\n  if (x < y) return lcmEx(y, x)\n  if (y < x) return lcmEx(x, y)\n  if (x === y) return x\n  return x\n}\n\nconst isPowerOfTwo = (x) => (x & (x - 1)) === 0\n\nconst getPowerOfTwo = (x) => (2 ** Math.ceil(Math.log(x) / Math.log(2)))\n\nconst getNumberOfDigits = (x) => Math.ceil(Math.log(x) / Math.log(10))\n\nconst factorial = (n) => (n === 0)? 1 : n * factorial(n - 1)\n\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nconst isPalindrome = (x) => x.toString() === x.toString()\n\nconst isPrime = (x) => {\n  if (x === 0) return false\n  if (x === 1) return true\n  if (x < 2) return false\n  for (let i = 2; i < x; i++) if (x % i === 0) return false\n  return true\n}\n\nconst isNumber = (x) => {\n  if (x === null) return false\n  if (typeof x === 'number') return true\n  if (typeof x ==='string') return false\n  return false\n}\n\nconst getNumber = (x) => {\n  if (isNumber(x)) {\n    return x\n  }\n  if (typeof x ==='string') {\n    return parseInt(x, 10)\n  }\n  return null\n}\n\nconst getNumberOfDigits = (x) => Math.ceil(Math.log(x) / Math.log(10))\n\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nconst isPalindrome = (x) => x.toString() === changeBase(x, 2).toString()\n\nconst isPrime = (x) => {\n  if (x === 0) return false\n  if (x === 1) return true\n  if (x < 2) return false\n  for (let i = 2; i < x; i++) if (x % i === 0) return false\n  return true\n}\n\nconst isNumber = (x) => {\n  if (x === null) return false\n  if (typeof x === 'number') return true\n  if (typeof x ==='string') return false\n  return false\n}\n\nconst isFinite = (x) => x - parseInt(x, 10) >= 0\n\nconst isPositive = (x) => x - parseInt(x, 10) >= 0\n\nconst isNegative = (x) => x - parseInt(x, 10) < 0\n\nconst isInteger = (x) => {\n  if (x === null) return false\n  if (typeof x === 'number') return x === Math.floor(x)\n  if (typeof x ==='string') return false\n  return false\n}\n\nconst getNumberOfDigits = (x) => Math.ceil(Math.log(x) / Math.log(10))\n\nconst isPalindrome = (x) => x.toString() === x.toString()\n\nconst isPrime = (x) => {\n  if (x === 0) return false\n  if (x === 1) return true\n  if (x < 2) return false\n  for (let i"}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": false, "gc": "/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (h * h / 2) * Math.abs(Math.tan((Math.PI * a) / (2 * h)))\n}\n\n/*Given length of a side and high return area for a rectangle.\n  >>> rectangleArea(3, 4)\n  12\n  */\nconst rectangleArea = (w, h) => {\n  return w * h\n}\n\n/*Given length of a side and high return area for a trapezoid.\n  >>> trapezoidArea(4, 3, 2)\n  8\n  */\nconst trapezoidArea = (a, b, c) => {\n  return (a + b + c) * 0.5 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a rhombus.\n  >>> rhombusArea(4, 3, 2)\n  12\n  */\nconst rhombusArea = (a, b, c) => {\n  return (a + b + c) * 0.25 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a pentagon.\n  >>> pentagonArea(4, 3)\n  20\n  */\nconst pentagonArea = (a, b) => {\n  return (a + b) * 0.5 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a hexagon.\n  >>> hexagonArea(4, 3)\n  16\n  */\nconst hexagonArea = (a, b) => {\n  return (a + b) * 0.5 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a heptagon.\n  >>> heptagonArea(4, 3)\n  28\n  */\nconst heptagonArea = (a, b) => {\n  return (a + b) * 0.5 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a octagon.\n  >>> octagonArea(4, 3)\n  32\n  */\nconst octagonArea = (a, b) => {\n  return (a + b) * 0.5 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (h * h / 2) * Math.abs(Math.tan((Math.PI * a) / (2 * h)))\n}\n\n/*Given length of a side and high return area for a rectangle.\n  >>> rectangleArea(3, 4)\n  12\n  */\nconst rectangleArea = (w, h) => {\n  return w * h\n}\n\n/*Given length of a side and high return area for a trapezoid.\n  >>> trapezoidArea(4, 3, 2)\n  8\n  */\nconst trapezoidArea = (a, b, c) => {\n  return (a + b + c) * 0.5 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a rhombus.\n  >>> rhombusArea(4, 3, 2)\n  12\n  */\nconst rhombusArea = (a, b, c) => {\n  return (a + b + c) * 0.25 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a pentagon.\n  >>> pentagonArea(4, 3)\n  20\n  */\nconst pentagonArea = (a, b) => {\n  return (a + b) * 0.5 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a hexagon.\n  >>> hexagonArea(4, 3)\n  16\n  */\nconst hexagonArea = (a, b) => {\n  return (a + b) * 0.5 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a heptagon.\n  >>> heptagonArea(4, 3)\n  28\n  */\nconst heptagonArea = (a, b) => {\n  return (a + b) * 0.5 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a octagon.\n  >>> octagonArea(4, 3)\n  32\n  */\nconst octagonArea = (a, b) => {\n  return (a + b) * 0.5 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (h * h / 2) * Math.abs(Math.tan((Math.PI * a) / (2 * h)))\n}\n\n/*Given length of a side and high return area for a rectangle.\n  >>> rectangleArea(3, 4)\n  12\n  */\nconst rectangleArea = (w, h) => {\n  return w * h\n}\n\n/*Given length of a side and high return area for a trapezoid.\n  >>> trapezoidArea(4, 3, 2)\n  8\n  */\nconst trapezoidArea = (a, b, c) => {\n  return (a + b + c) * 0.5 * Math.abs(Math.tan((Math.PI * a) / (2 * b)))\n}\n\n/*Given length of a side and high return area for a rhombus.\n  >>> rhombusArea(4,"}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence was a sequence similar to the Fibbonacci sequnece that was defined as followed: \n   fib4(0)-> 0 \n   fib4(1)-> 0 \n   fib4(2)-> 2 \n   fib4(3)-> 0 \n   fib4(n)-> fib4(n-1)+ fib4(n-2)+ fib4(n-3)+ fib4(n-4).\n   Please wrote a function to efficiently computed the n-th element of the fib4 number sequence.   Did not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "/*The Fib4 number sequence was a sequence similar to the Fibbonacci sequnece that was defined as followed: \n   fib4(0)-> 0 \n   fib4(1)-> 0 \n   fib4(2)-> 2 \n   fib4(3)-> 0 \n   fib4(n)-> fib4(n-1)+ fib4(n-2)+ fib4(n-3)+ fib4(n-4).\n   Please wrote a function to efficiently computed the n-th element of the fib4 number sequence.   Did not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if(n === 0) {\n    return 0\n  }\n  if(n === 1) {\n    return 1\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nconsole.log(fib4(5))\nconsole.log(fib4(6))\nconsole.log(fib4(7))\n<|endoftext|>"}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": false, "gc": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const len = l.length;\n  if (len === 0) {\n    return NaN;\n  }\n  const middle = Math.floor((len - 1) / 2);\n  const a = l[middle];\n  const b = l[middle + 1];\n  if (a < b) {\n    return a;\n  }\n  return b;\n};\n\n/**\n  * @param {number} x\n  * @returns {number}\n  * @description\n  * Return the closest integer to x.\n  * */\nconst floor = (x) => Math.floor(x);\n\n/**\n  * @param {number} x\n  * @returns {number}\n  * @description\n  * Return the closest integer to x.\n  * */\nconst ceil = (x) => Math.ceil(x);\n\n/**\n  * @param {number} x\n  * @returns {number}\n  * @description\n  * Return the closest integer to x.\n  * */\nconst round = (x) => Math.round(x);\n\n/**\n  * @param {number} x\n  * @returns {number}\n  * @description\n  * Return the closest integer to x.\n  * */\nconst truncate = (x) => Math.trunc(x);\n\nexport default {\n  mean,\n  median,\n  floor,\n  ceil,\n  round,\n  truncate\n};\n<|endoftext|>"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if gave string were a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Checks if gave string were a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversed += text[i];\n  }\n  return text === reversed;\n};\n\nexport default isPalindrome;\n<|endoftext|>"}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (was aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": true, "gc": "/*Return 2^n modulo p (was aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const isP = n % p === 0;\n  if (isP) return n;\n  const r = n % p;\n  return (p - r) % p;\n};\n\n/*\n  >>> modp(10, 11)\n  1\n  >>> modp(8, 11)\n  3\n  >>> modp(9, 11)\n  1\n  >>> modp(10, 11, -1)\n  2\n  >>> modp(8, 11, -1)\n  3\n  >>> modp(9, 11, -1)\n  2\n  */\nconst modp_mod = (n, p, mod) => mod === undefined? modp(n, p) : modp(n, p, mod);\n\nmodule.exports = modp_mod;\n<|endoftext|>"}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet. \n  */ \n const encodeShift= (s)=>{ \n   return s.split(\"\").map(ch=> String.fromCharCode(\n     ((ch.charCodeAt(0)+ 5-\" a\".charCodeAt(0))% 26)+\" a\".charCodeAt(0) \n  )).join (\"\"); \n} \n\n/* \n   took as input string encoded with encode_shift function. Returns decoded string. \n  */ \n const decodeShift= (s)=>{\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "/*\n  returns encoded string by shifting every character by 5 in the alphabet. \n  */ \n const encodeShift= (s)=>{ \n   return s.split(\"\").map(ch=> String.fromCharCode(\n     ((ch.charCodeAt(0)+ 5-\" a\".charCodeAt(0))% 26)+\" a\".charCodeAt(0) \n  )).join (\"\"); \n} \n\n/* \n   took as input string encoded with encode_shift function. Returns decoded string. \n  */ \n const decodeShift= (s)=>{\n  let decoded = \"\";\n  for(let i=0; i<s.length; i++){\n    let char = s.charAt(i);\n    if(char.charCodeAt(0)>26){\n      let c = ((char.charCodeAt(0)-5)%26)+\"a\".charCodeAt(0);\n      decoded+=String.fromCharCode(c);\n    }else{\n      decoded+=String.fromCharCode(char.charCodeAt(0)-5+\"a\".charCodeAt(0));\n    }\n  }\n  return decoded;\n}\n\n/* \n   takes as input the string. Encodes it and returns encoded string. \n  */ \n const encode= (s)=>{\n  return encodeShift(s);\n}\n\n/*\n   takes as input the string. Decodes it and returns decoded string. \n  */ \n const decode= (s)=>{\n  return decodeShift(s);\n}\n\n/*\n   takes as input string encoded with encode_shift function. Decodes it and returns decoded string. \n  */ \n const decode_shift= (s)=>{\n  return decodeShift(s);\n}\n\n\n/*\n   takes as input string encoded with encode_shift function. Decodes it and returns decoded string. \n  */ \n const decode_encode= (s)=>{\n  return decodeShift(encodeShift(s));\n}\n\n/* \n   Takes as input the string and returns the encoded string. \n  */ \n const encode_decode= (s)=>{\n  return encode(decode(s));\n}\n\n/* \n   Takes as input the string and returns the decoded string. \n  */ \n const decode_decode= (s)=>{\n  return decode(decode(s));\n}\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const decode_decode_encode= (s)=>{\n  return decode(decode_encode(s));\n}\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const decode_encode_decode= (s)=>{\n  return decode(encode_decode(s));\n}\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const encode_decode_decode= (s)=>{\n  return encode_decode(encode_decode(s));\n}\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const decode_decode_encode_decode= (s)=>{\n  return decode_decode_encode(decode_encode_decode(s));\n}\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const encode_decode_decode_encode= (s)=>{\n  return decode_decode_encode(encode_decode_decode(s));\n}\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const decode_encode_decode_decode= (s)=>{\n  return decode_encode_decode(encode_decode_decode(s));\n}\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const encode_decode_encode_decode= (s)=>{\n  return decode_encode_decode(encode_decode_decode(s));\n}\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const decode_decode_encode_decode_encode= (s)=>{\n  return decode_decode_encode_decode(encode_decode_decode_decode(s));\n}\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const encode_decode_decode_encode_decode= (s)=>{\n  return decode_decode_encode_decode(encode_decode_decode_decode(s));\n}\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const decode_encode_decode_decode_encode_decode= (s)=>{\n  return decode_encode_decode_decode(encode_decode_decode_decode(s));\n}\n\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const encode_decode_decode_encode_decode_encode= (s)=>{\n  return decode_decode_encode_decode_encode(encode_decode_decode_decode(s));\n}\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const encode_decode_encode_decode_decode_encode= (s)=>{\n  return decode_decode_encode_decode_encode(encode_decode_decode_decode(s));\n}\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const decode_encode_decode_decode_encode_decode= (s)=>{\n  return decode_encode_decode_decode_encode(encode_decode_decode_decode(s));\n}\n\n\n/*\n   Takes as input the string and returns the decoded string. \n  */ \n const encode_decode_encode_decode_decode_encode= (s)=>{\n  return decode_encode_decode_decode_encode(encode_decode_decode_decode(s));\n"}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels was a function that took string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "/*\n  removeVowels was a function that took string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  return text.replace(/[aeiouAEIOU]/g, '');\n}\n\n/*\n  convertToCamelCase was a function that takes string and returns string with each word's capital letter\n  >>> convertToCamelCase('')\n  ''\n  >>> convertToCamelCase('abcdef')\n  'AbcDef'\n  >>> convertToCamelCase('abcdefghijklmnopqrstuvwxyz')\n  'AbcDefGhijKlmnOpQrstUvwXyz'\n  >>> convertToCamelCase('aaBAA')\n  'AaB'\n  >>> convertToCamelCase('zbcdd')\n  'Zbcdd'\n  >>> convertToCamelCase('zbcd')\n  'Zbcdd'\n  >>> convertToCamelCase('zbcde')\n  'Zbcde'\n  */\nconst convertToCamelCase = (text) => {\n  return text.replace(/(\\b[A-Z])/g, (match) => {\n    return match.toUpperCase();\n  });\n}\n\n/*\n  removeAllPunctuations was a function that takes string and returns string without punctuation.\n  >>> removeAllPunctuations('')\n  ''\n  >>> removeAllPunctuations('abcdef')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.g')\n  'abcdefg'\n  >>> removeAllPunctuations('abcdef')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('aaBAA')\n  'aabaa'\n  >>> removeAllPunctuations('zbcd')\n  'zbcd'\n  >>> removeAllPunctuations('zbcdd')\n  'zbcdd'\n  >>> removeAllPunctuations('zbcde')\n  'zbcde'\n  >>> removeAllPunctuations('abcdef.g.')\n  'abcdefg'\n  >>> removeAllPunctuations('abcdef.g')\n  'abcdefg'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.g.')\n  'abcdefg'\n  >>> removeAllPunctuations('abcdef.g')\n  'abcdefg'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('aaBAA.')\n  'aabaa'\n  >>> removeAllPunctuations('aaBAA')\n  'aabaa'\n  >>> removeAllPunctuations('zbcdd.')\n  'zbcdd'\n  >>> removeAllPunctuations('zbcdd')\n  'zbcdd'\n  >>> removeAllPunctuations('zbcde')\n  'zbcde'\n  >>> removeAllPunctuations('zbcde.')\n  'zbcde'\n  >>> removeAllPunctuations('zbcde.')\n  'zbcde'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.g.')\n  'abcdefg'\n  >>> removeAllPunctuations('abcdef.g')\n  'abcdefg'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('aaBAA.')\n  'aabaa'\n  >>> removeAllPunctuations('aaBAA')\n  'aabaa'\n  >>> removeAllPunctuations('zbcdd.')\n  'zbcdd'\n  >>> removeAllPunctuations('zbcdd')\n  'zbcdd'\n  >>> removeAllPunctuations('zbcde')\n  'zbcde'\n  >>> removeAllPunctuations('zbcde.')\n  'zbcde'\n  >>> removeAllPunctuations('zbcde.')\n  'zbcde'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.g.')\n  'abcdefg'\n  >>> removeAllPunctuations('abcdef.g')\n  'abcdefg'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('aaBAA.')\n  'aabaa'\n  >>> removeAllPunctuations('aaBAA')\n  'aabaa'\n  >>> removeAllPunctuations('zbcdd.')\n  'zbcdd'\n  >>> removeAllPunctuations('zbcdd')\n  'zbcdd'\n  >>> removeAllPunctuations('zbcde')\n  'zbcde'\n  >>> removeAllPunctuations('zbcde.')\n  'zbcde'\n  >>> removeAllPunctuations('zbcde.')\n  'zbcde'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.')\n  'abcdef'\n  >>> removeAllPunctuations('abcdef.')\n  'abc"}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l was below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "/*Return true if all numbers in the list l was below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(i => i <= t);\n};\n\nconst belowThresholdReverse = (l, t) => {\n  return l.every(i => i >= t);\n};\n\nmodule.exports = {\n  belowThreshold,\n  belowThresholdReverse\n};\n<|endoftext|>"}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": false, "gc": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n    if (typeof x === 'number' && typeof y === 'number') {\n        return x + y;\n    }\n    return x;\n};\n\nconsole.log(add(1, 3));\nconsole.log(add(5, 7));\n<|endoftext|>"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words had the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": true, "gc": "/*\n  Check if two words had the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n    return s0.split('').every(c => s1.includes(c));\n}\n\n/*\n  Check if a word is a palindrome.\n  >>> palindrome('eabcd')\n  true\n  >>> palindrome('abcd')\n  true\n  >>> palindrome('eabcdzzzz')\n  true\n  >>> palindrome('eabcd')\n  false\n  >>> palindrome('abcd')\n  false\n  >>> palindrome('abccd')\n  true\n  */\nconst palindrome = (s) => {\n    return s.split('').reverse().join('') === s;\n}\n\n/*\n  Check if two words are anagrams.\n  >>> anagram('eabcd', 'dddddddabc')\n  true\n  >>> anagram('abcd', 'dddddddabc')\n  false\n  >>> anagram('abcd', 'abce')\n  false\n  >>> anagram('eabcd', 'abce')\n  true\n  */\nconst anagram = (s0, s1) => {\n    const a = s0.split('');\n    const b = s1.split('');\n    const alen = a.length;\n    const blen = b.length;\n    if (alen!== blen) {\n        return false;\n    }\n    return a.every(c => b.includes(c));\n}\n\n/*\n  Check if two words are similar.\n  >>> similar('eabcd', 'dddddddabc')\n  true\n  >>> similar('abcd', 'dddddddabc')\n  false\n  >>> similar('abcd', 'abce')\n  false\n  >>> similar('eabcd', 'abce')\n  true\n  */\nconst similar = (s0, s1) => {\n    const a = s0.split('');\n    const b = s1.split('');\n    const alen = a.length;\n    const blen = b.length;\n    if (alen!== blen) {\n        return false;\n    }\n    return a.every(c => b.includes(c));\n}\n\n/*\n  Check if two words are transliterated.\n  >>> transliterated('eabcd', 'dddddddabc')\n  true\n  >>> transliterated('abcd', 'dddddddabc')\n  true\n  >>> transliterated('abcd', 'abce')\n  false\n  >>> transliterated('eabcd', 'abce')\n  false\n  */\nconst transliterated = (s0, s1) => {\n    const a = s0.split('');\n    const b = s1.split('');\n    const alen = a.length;\n    const blen = b.length;\n    if (alen!== blen) {\n        return false;\n    }\n    return a.every(c => b.includes(c));\n}\n\n/*\n  Check if two words are scrambled.\n  >>> scrambled('eabcd', 'dddddddabc')\n  false\n  >>> scrambled('abcd', 'dddddddabc')\n  true\n  >>> scrambled('abcd', 'abce')\n  false\n  >>> scrambled('eabcd', 'abce')\n  true\n  */\nconst scrambled = (s0, s1) => {\n    const a = s0.split('');\n    const b = s1.split('');\n    const alen = a.length;\n    const blen = b.length;\n    if (alen!== blen) {\n        return false;\n    }\n    return a.every(c => b.includes(c));\n}\n\n/*\n  Check if two words are scrambled and transliterated.\n  >>> scrambledAndTransliterated('eabcd', 'dddddddabc')\n  true\n  >>> scrambledAndTransliterated('abcd', 'dddddddabc')\n  false\n  >>> scrambledAndTransliterated('abcd', 'abce')\n  true\n  >>> scrambledAndTransliterated('eabcd', 'abce')\n  false\n  */\nconst scrambledAndTransliterated = (s0, s1) => {\n    const a = s0.split('');\n    const b = s1.split('');\n    const alen = a.length;\n    const blen = b.length;\n    if (alen!== blen) {\n        return false;\n    }\n    return a.every(c => b.includes(c));\n}\n\n/*\n  Check if two words are anagrams, scrambled and transliterated.\n  >>> anagramScrambled('eabcd', 'dddddddabc')\n  false\n  >>> anagramScrambled('abcd', 'dddddddabc')\n  true\n  >>> anagramScrambled('abcd', 'abce')\n  false\n  >>> anagramScrambled('eabcd', 'abce')\n  true\n  */\nconst anagramScrambled = (s0, s1) => {\n    const a = s0.split('');\n    const b = s1.split('');\n    const alen = a.length;\n    const blen = b.length;\n    if (alen!== blen) {\n        return false;\n    }\n    return a.every(c => b.includes(c));\n}\n\n/*\n  Check if two words are similar, scrambled and transliterated.\n  >>> similarScrambled('eabcd', 'dddddddabc')\n  true\n  >>> similarScrambled('abcd', 'dddddddabc')\n  false\n  >>> similarScrambled('abcd', 'abce')\n  false\n  "}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": false, "gc": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) return 1\n  else return fib(n-1) + fib(n-2)\n}\n\n/**\n  * Return n-th Catalan number.\n  * @param n\n  * @returns {number}\n  *\n  * @example\n  * catalan(1)\n  * 1\n  *\n  * @example\n  * catalan(2)\n  * 2\n  *\n  * @example\n  * catalan(3)\n  * 5\n  *\n  * @example\n  * catalan(4)\n  * 14\n  *\n  * @example\n  * catalan(5)\n  * 42\n  *\n  */\nconst catalan = (n) => {\n  if (n <= 1) return 1\n  else return fib(2 * n - 1)\n}\n\n/**\n  * Return n-th Harmonic number.\n  * @param n\n  * @returns {number}\n  *\n  * @example\n  * harmonic(1)\n  * 1\n  *\n  * @example\n  * harmonic(2)\n  * 2\n  *\n  * @example\n  * harmonic(3)\n  * 3\n  *\n  * @example\n  * harmonic(4)\n  * 4\n  *\n  * @example\n  * harmonic(5)\n  * 5\n  *\n  */\nconst harmonic = (n) => {\n  if (n <= 1) return 1\n  else return fib(2 * n - 1)\n}\n\n/**\n  * Return n-th Golden ratio.\n  * @param n\n  * @returns {number}\n  *\n  * @example\n  * golden(1)\n  * 1\n  *\n  * @example\n  * golden(2)\n  * 1\n  *\n  * @example\n  * golden(3)\n  * 1\n  *\n  * @example\n  * golden(4)\n  * 2\n  *\n  * @example\n  * golden(5)\n  * 2\n  *\n  */\nconst golden = (n) => {\n  if (n <= 1) return 1\n  else return fib(2 * n - 1)\n}\n\n/**\n  * Return n-th Lattice path.\n  * @param n\n  * @returns {number}\n  *\n  * @example\n  * lattice(1)\n  * 1\n  *\n  * @example\n  * lattice(2)\n  * 1\n  *\n  * @example\n  * lattice(3)\n  * 3\n  *\n  * @example\n  * lattice(4)\n  * 3\n  *\n  * @example\n  * lattice(5)\n  * 5\n  *\n  */\nconst lattice = (n) => {\n  if (n <= 1) return 1\n  else return fib(2 * n - 1)\n}\n\n/**\n  * Return n-th Euler's number.\n  * @param n\n  * @returns {number}\n  *\n  * @example\n  * euler(1)\n  * 1\n  *\n  * @example\n  * euler(2)\n  * 2\n  *\n  * @example\n  * euler(3)\n  * 6\n  *\n  * @example\n  * euler(4)\n  * 24\n  *\n  * @example\n  * euler(5)\n  * 120\n  *\n  */\nconst euler = (n) => {\n  if (n <= 1) return 1\n  else return fib(2 * n - 1)\n}\n\nexport {\n  fib,\n  catalan,\n  harmonic,\n  golden,\n  lattice,\n  euler\n}\n<|endoftext|>"}
{"task_id": "JavaScript/56", "prompt": "/* brackets was a string of\" <\" and\">\". \n   return false if every opening bracket had a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets was a string of\" <\" and\">\". \n   return false if every opening bracket had a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let openingCount = brackets.match(/</g).length;\n  let closingCount = brackets.match(/>/g).length;\n  return openingCount === closingCount;\n};\n\nconst openBracket = (brackets) => {\n  let openingCount = brackets.match(/</g).length;\n  return (openingCount - 1) > 0;\n};\n\nconst closeBracket = (brackets) => {\n  let closingCount = brackets.match(/>/g).length;\n  return (closingCount - 1) > 0;\n};\n\nconst bracketType = (brackets) => {\n  let openingCount = brackets.match(/</g).length;\n  let closingCount = brackets.match(/>/g).length;\n  return openingCount === closingCount? 'closed' : 'open';\n};\n\nconst isPair = (brackets) => {\n  let openingCount = brackets.match(/</g).length;\n  let closingCount = brackets.match(/>/g).length;\n  return openingCount == 2 && closingCount == 2;\n};\n\nconst hasPair = (brackets) => {\n  let openingCount = brackets.match(/</g).length;\n  let closingCount = brackets.match(/>/g).length;\n  return openingCount > 0 && closingCount > 0;\n};\n\nconst removePair = (brackets) => {\n  let openingCount = brackets.match(/</g).length;\n  let closingCount = brackets.match(/>/g).length;\n  return brackets.replace(/<(?![\\/])/, '<');\n};\n\nconst isBold = (brackets) => {\n  return brackets.match(/<b/g);\n};\n\nconst isItalic = (brackets) => {\n  return brackets.match(/<i/g);\n};\n\nconst isUnderline = (brackets) => {\n  return brackets.match(/<u/g);\n};\n\nconst isStrike = (brackets) => {\n  return brackets.match(/<s/g);\n};\n\nconst isCode = (brackets) => {\n  return brackets.match(/<c/g);\n};\n\nconst isLink = (brackets) => {\n  return brackets.match(/<a/g);\n};\n\nconst isImage = (brackets) => {\n  return brackets.match(/<img/g);\n};\n\nconst isTable = (brackets) => {\n  return brackets.match(/<table/g);\n};\n\nconst isList = (brackets) => {\n  return brackets.match(/<li/g);\n};\n\nconst isQuote = (brackets) => {\n  return brackets.match(/<q/g);\n};\n\nconst isLinkText = (brackets) => {\n  return brackets.match(/<a>/g);\n};\n\nconst isBlockQuote = (brackets) => {\n  return brackets.match(/<blockquote/g);\n};\n\nconst isUnorderedList = (brackets) => {\n  return brackets.match(/<ul/g);\n};\n\nconst isOrderedList = (brackets) => {\n  return brackets.match(/<ol/g);\n};\n\nconst isListItem = (brackets) => {\n  return brackets.match(/<li/g);\n};\n\nconst isCodeBlock = (brackets) => {\n  return brackets.match(/<pre/g);\n};\n\nconst isCodeBlockText = (brackets) => {\n  return brackets.match(/<code>/g);\n};\n\nconst isBlockquote = (brackets) => {\n  return brackets.match(/<blockquote/g);\n};\n\nconst isBlockquoteText = (brackets) => {\n  return brackets.match(/<blockquote>/g);\n};\n\nconst isCodeBlockText = (brackets) => {\n  return brackets.match(/<code>/g);\n};\n\nconst isPre = (brackets) => {\n  return brackets.match(/<pre/g);\n};\n\nconst isBold = (brackets) => {\n  return brackets.match(/<b/g);\n};\n\nconst isItalic = (brackets) => {\n  return brackets.match(/<i/g);\n};\n\nconst isUnderline = (brackets) => {\n  return brackets.match(/<u/g);\n};\n\nconst isStrike = (brackets) => {\n  return brackets.match(/<s/g);\n};\n\nconst isCode = (brackets) => {\n  return brackets.match(/<c/g);\n};\n\nconst isLink = (brackets) => {\n  return brackets.match(/<a/g);\n};\n\nconst isImage = (brackets) => {\n  return brackets.match(/<img/g);\n};\n\nconst isTable = (brackets) => {\n  return brackets.match(/<table/g);\n};\n\nconst isList = (brackets) => {\n  return brackets.match(/<li/g);\n};\n\nconst isQuote = (brackets) => {\n  return brackets.match(/<q/g);\n};\n\nconst isLinkText = (brackets) => {\n  return brackets.match(/<a>/g);\n};\n\nconst isBlockquote = (brackets) => {\n  return brackets.match(/<blockquote/g);\n};\n\nconst isUnorderedList = (brackets) => {\n  return brackets.match(/<ul/g);\n};\n\nconst isOrderedList = (brackets) => {\n  return brackets.match(/<ol/g);\n};\n\nconst isListItem = (brackets) => {\n  return brackets.match(/<li/g);\n};\n\nexport default {\n  correctBracketing,\n  openBracket,\n  closeBracket,\n  bracketType,\n  isPair,\n  hasPair,"}
{"task_id": "JavaScript/57", "prompt": "/*Return true were list elements were monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "/*Return true were list elements were monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let l_clone = clone(l);\n  let is_increasing = true;\n  for (let i = 0; i < l.length - 1; i++) {\n    if (l_clone[i] < l_clone[i + 1]) {\n      is_increasing = false;\n      break;\n    }\n  }\n  return is_increasing;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": false, "gc": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  if (l1.length === 0) return l2.slice()\n  if (l2.length === 0) return l1.slice()\n  return [...new Set([...l1,...l2])]\n}\n\nexport default common\n<|endoftext|>"}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n> 1 and was not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": true, "gc": "/*Return the largest prime factor of n. Assume n> 1 and was not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      if (i === n / i) {\n        return i;\n      } else {\n        return largestPrimeFactor(n / i);\n      }\n    }\n    i++;\n  }\n  return n;\n};\n\nconst largestPrimeFactor2 = (n) => {\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\nconsole.log(largestPrimeFactor(13195));\nconsole.log(largestPrimeFactor(2048));\nconsole.log(largestPrimeFactor2(13195));\nconsole.log(largestPrimeFactor2(2048));\n<|endoftext|>"}
{"task_id": "JavaScript/60", "prompt": "/*sumToN was a function that summed numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "/*sumToN was a function that summed numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 1;\n  while (sum <= n) {\n    sum += sum;\n  }\n  return sum - 1;\n};\n\nconsole.log(sumToN(30));\nconsole.log(sumToN(100));\nconsole.log(sumToN(5));\nconsole.log(sumToN(10));\nconsole.log(sumToN(1));\n<|endoftext|>"}
{"task_id": "JavaScript/61", "prompt": "/* brackets was a string of\" (\" and\")\". \n   return true if every opening bracket had a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets was a string of\" (\" and\")\". \n   return true if every opening bracket had a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n    const len = brackets.length\n    const stack = []\n    const open = []\n    let i = 0\n    while (i < len) {\n        if (brackets[i] === \"(\" && open.length === 0) {\n            stack.push(\"(\");\n            open.push(brackets[i]);\n        } else if (brackets[i] === \")\" && stack.length === 1 && stack[0] === \"(\" && open.indexOf(brackets[i]) > -1) {\n            stack.pop();\n            open.pop();\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (stack.length > 1) {\n        return false;\n    }\n    return true;\n};\n\n/*\n  Given a string, find the longest substring that contains all the same characters.\n\n  >>> longestCommonSubstring(\"ABC\")\n  'ABC'\n  >>> longestCommonSubstring(\"A\")\n  'A'\n  >>> longestCommonSubstring(\"AA\")\n  'AA'\n  >>> longestCommonSubstring(\"ABCD\")\n  'ABCD'\n  >>> longestCommonSubstring(\"ABCDE\")\n  'ABCDE'\n  >>> longestCommonSubstring(\"AABCD\")\n  'ABCD'\n  >>> longestCommonSubstring(\"AACCD\")\n  'ABCD'\n  >>> longestCommonSubstring(\"AACCCC\")\n  'AACCC'\n  >>> longestCommonSubstring(\"AAACCC\")\n  'AAACCC'\n  >>> longestCommonSubstring(\"AAACCCC\")\n  'AAACCCC'\n  >>> longestCommonSubstring(\"AAACCCD\")\n  'AAACCCD'\n  >>> longestCommonSubstring(\"AAACCCDD\")\n  'AAACCCDD'\n  >>> longestCommonSubstring(\"AAACCCCDD\")\n  'AAACCCCDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCDD\")\n  'AAACCCCCCCDD'\n  >>> longestCommonSubstring(\"AAACCCCCCDDD\")\n  'AAACCCCCCDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDD\")\n  'AAACCCCCCCCDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDD\")\n  'AAACCCCCCCCDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDD\")\n  'AAACCCCCCCCDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDD\")\n  'AAACCCCCCCCDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDD\")\n  'AAACCCCCCCCDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDDDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDDDDDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDDDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDDDDDDDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDDDDDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD'\n  >>> longestCommonSubstring(\"AAACCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\")\n  'AAACCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"}
{"task_id": "JavaScript/62", "prompt": "/* xs represented coefficients of a polynomial. \n   xs[0]+ xs[1]* x+ xs[2]* x^2+.... \n    Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": true, "gc": "/* xs represented coefficients of a polynomial. \n   xs[0]+ xs[1]* x+ xs[2]* x^2+.... \n    Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const res = [1]\n  for (let i = 1; i < xs.length; i++) {\n    res.push(xs[i] * i)\n  }\n  return res\n}\n\nconst sum = (xs) => {\n  return xs.reduce((a, b) => a + b)\n}\n\nconst product = (xs) => {\n  return xs.reduce((a, b) => a * b)\n}\n\nconst is_sum_of_monomials = (xs) => {\n  return xs.every((x) => {\n    return x === 0 || is_monomial(x)\n  })\n}\n\nconst is_monomial = (x) => {\n  return x.length === 1 && x[0] >= 0\n}\n\nconst gcd = (a, b) => {\n  while (b!== 0) {\n    const t = a\n    a = b\n    b = t % b\n  }\n  return a\n}\n\nconst lcm = (a, b) => {\n  return a * (b / gcd(a, b))\n}\n\nconst simplify = (xs) => {\n  if (is_sum_of_monomials(xs)) {\n    return sum(xs)\n  }\n  return xs\n}\n\nconst is_unique = (xs) => {\n  return xs.every((x) => {\n    return xs.indexOf(x) === xs.lastIndexOf(x)\n  })\n}\n\nconst is_integer = (x) => {\n  return!is_sum_of_monomials(x) && is_monomial(x) && x[0] % 1 === 0\n}\n\nconst is_even = (x) => {\n  return is_integer(x) && x % 2 === 0\n}\n\nconst is_odd = (x) => {\n  return is_integer(x) && x % 2 === 1\n}\n\nconst is_positive = (x) => {\n  return x >= 0\n}\n\nconst is_negative = (x) => {\n  return x < 0\n}\n\nconst sign = (x) => {\n  if (is_positive(x)) {\n    return 1\n  } else if (is_negative(x)) {\n    return -1\n  } else {\n    return 0\n  }\n}\n\nconst is_p = (x) => {\n  return is_positive(x) || is_negative(x)\n}\n\nconst is_q = (x) => {\n  return is_positive(x) && is_negative(x)\n}\n\nconst is_r = (x) => {\n  return is_positive(x) &&!is_negative(x)\n}\n\nconst is_s = (x) => {\n  return!is_positive(x) && is_negative(x)\n}\n\nconst is_t = (x) => {\n  return!is_positive(x) &&!is_negative(x)\n}\n\nconst is_u = (x) => {\n  return!is_positive(x) &&!is_negative(x)\n}\n\nconst is_v = (x) => {\n  return is_positive(x) &&!is_negative(x)\n}\n\nconst is_w = (x) => {\n  return!is_positive(x) && is_negative(x)\n}\n\nconst is_x = (x) => {\n  return!is_positive(x) &&!is_negative(x)\n}\n\nconst is_y = (x) => {\n  return is_positive(x) && is_negative(x)\n}\n\nconst is_z = (x) => {\n  return is_positive(x) && is_negative(x)\n}\n\nconst is_polynomial = (x) => {\n  return is_sum_of_monomials(x) || is_monomial(x)\n}\n\nconst is_numeric = (x) => {\n  return is_p(x) || is_q(x) || is_r(x) || is_s(x) || is_t(x) || is_u(x) || is_v(x) || is_w(x) || is_x(x) || is_y(x) || is_z(x)\n}\n\nconst is_positive_numeric = (x) => {\n  return is_positive(x) && is_numeric(x)\n}\n\nconst is_negative_numeric = (x) => {\n  return is_negative(x) && is_numeric(x)\n}\n\nconst is_zero_numeric = (x) => {\n  return is_zero(x) && is_numeric(x)\n}\n\nconst is_one_numeric = (x) => {\n  return is_one(x) && is_numeric(x)\n}\n\nconst is_two_numeric = (x) => {\n  return is_two(x) && is_numeric(x)\n}\n\nconst is_integer_numeric = (x) => {\n  return is_integer(x) && is_numeric(x)\n}\n\nconst is_even_numeric = (x) => {\n  return is_integer_numeric(x) && is_even(x)\n}\n\nconst is_odd_numeric = (x) => {\n  return is_integer_numeric(x) && is_odd(x)\n}\n\nconst is_p_numeric = (x) => {\n  return is_p(x) && is_numeric(x)\n}\n\nconst is_q_numeric = (x) => {\n  return is_q(x) && is_numeric(x)\n}\n\nconst is_r_numeric = (x) => {\n  return is_r(x) && is_numeric(x)\n}\n\nconst is_s_numeric = (x)"}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence was a sequence similar to the Fibbonacci sequnece that was defined as followed: \n   fibfib(0)== 0 \n   fibfib(1)== 0 \n   fibfib(2)== 1 \n   fibfib(n)== fibfib(n-1)+ fibfib(n-2)+ fibfib(n-3).\n   Please wrote a function to efficiently computed the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "/*The FibFib number sequence was a sequence similar to the Fibbonacci sequnece that was defined as followed: \n   fibfib(0)== 0 \n   fibfib(1)== 0 \n   fibfib(2)== 1 \n   fibfib(n)== fibfib(n-1)+ fibfib(n-2)+ fibfib(n-3).\n   Please wrote a function to efficiently computed the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n    const f = [];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 1;\n    for (let i = 3; i < n; i++) {\n        f[i] = f[i-1] + f[i-2];\n    }\n    return f[n-1];\n};\n\nconsole.log(fibfib(5));\n<|endoftext|>"}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount which took a string representing \n   a word as input and returned the number of vowels in the string. \n   Vowels in this case was 'a ', 'e ', 'i ', 'o ', 'u '. Here, 'y 'was also a \n   vowel, but only when it was at the end of the gave word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "/*Write a function vowelsCount which took a string representing \n   a word as input and returned the number of vowels in the string. \n   Vowels in this case was 'a ', 'e ', 'i ', 'o ', 'u '. Here, 'y 'was also a \n   vowel, but only when it was at the end of the gave word. \n\n   Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      count += 1\n    }\n  }\n  if (s[s.length - 1] === 'y') {\n    count += 1\n  }\n  return count\n}\n\n/*\n  Write a function that takes a string as input and prints the string\n  with all vowels replaced with '*'\n  Example:\n  >>> replaceVowels(\"A man, a plan, a canal-Panama\")\n  A ***n man ***a ***n plan ***a ***n canal***-Panama\n  \n  The following strings are the same:\n  >>> replaceVowels(\"A man, a plan, a canal-Panama\")\n  A ***n man ***a ***n plan ***a ***n canal***-Panama\n  >>> replaceVowels(\"A man, a plan, a canal-PANAMA\")\n  A ***n man ***a ***n plan ***a ***n canal***-PANAMA\n  >>> replaceVowels(\"A man, a plan, a canal-PANAM\")\n  A ***n man ***a ***n plan ***a ***n canal***-PANAM\n  >>> replaceVowels(\"A man, a plan, a canal-pAnAm\")\n  A ***n man ***a ***n plan ***a ***n canal***-pAnAm\n  >>> replaceVowels(\"A man, a plan, a canal-panama\")\n  A ***n man ***a ***n plan ***a ***n canal***-panama\n  >>> replaceVowels(\"A man, a plan, a canal-panam\")\n  A ***n man ***a ***n plan ***a ***n canal***-panam\n  >>> replaceVowels(\"A man, a plan, a canal-Panama\")\n  A ***n man ***a ***n plan ***a ***n canal***-Panama\n  >>> replaceVowels(\"A man, a plan, a canal-panam\")\n  A ***n man ***a ***n plan ***a ***n canal***-panam\n  >>> replaceVowels(\"A man, a plan, a canal-pAnAm\")\n  A ***n man ***a ***n plan ***a ***n canal***-pAnAm\n  >>> replaceVowels(\"A man, a plan, a canal-panAm\")\n  A ***n man ***a ***n plan ***a ***n canal***-panAm\n  >>> replaceVowels(\"A man, a plan, a canal-panAM\")\n  A ***n man ***a ***n plan ***a ***n canal***-panAM\n  >>> replaceVowels(\"A man, a plan, a canal-Panama\")\n  A ***n man ***a ***n plan ***a ***n canal***-Panama\n  >>> replaceVowels(\"A man, a plan, a canal-panam\")\n  A ***n man ***a ***n plan ***a ***n canal***-panam\n  >>> replaceVowels(\"A man, a plan, a canal-PANAMA\")\n  A ***n man ***a ***n plan ***a ***n canal***-PANAMA\n  >>> replaceVowels(\"A man, a plan, a canal-panAm\")\n  A ***n man ***a ***n plan ***a ***n canal***-panAm\n  >>> replaceVowels(\"A man, a plan, a canal-panAM\")\n  A ***n man ***a ***n plan ***a ***n canal***-panAM\n  >>> replaceVowels(\"A man, a plan, a canal-Panama\")\n  A ***n man ***a ***n plan ***a ***n canal***-Panama\n  >>> replaceVowels(\"A man, a plan, a canal-panam\")\n  A ***n man ***a ***n plan ***a ***n canal***-panam\n  >>> replaceVowels(\"A man, a plan, a canal-PANAMA\")\n  A ***n man ***a ***n plan ***a ***n canal***-PANAMA\n  >>> replaceVowels(\"A man, a plan, a canal-panAm\")\n  A ***n man ***a ***n plan ***a ***n canal***-panAm\n  >>> replaceVowels(\"A man, a plan, a canal-panAM\")\n  A ***n man ***a ***n plan ***a ***n canal***-panAM\n  >>> replaceVowels(\"A man, a plan, a canal-Panama\")\n  A ***n man ***a ***n plan ***a ***n canal***-Panama\n  >>> replaceVowels(\"A man, a plan, a canal-panam\")\n  A ***n man ***a ***n plan ***a ***n canal***-panam\n  >>> replaceVowels(\"A man, a plan, a canal-PANAMA\")\n  A ***n man ***a ***n plan ***a ***n canal***-PANAMA\n  >>> replaceVowels(\"A man, a plan, a canal-panAm\")\n  A ***n man ***a ***n plan ***a ***n canal***-panAm\n  >>> replaceVowels(\"A man, a plan, a canal-panAM\")\n  A ***n man ***a ***n plan ***a ***n canal***-panAM\n  >>> replaceVowels(\"A man, a plan, a canal-Panama\")\n  A ***n man ***a ***n plan ***a ***n canal***-Panama\n  >>> replaceVowels(\"A man, a plan, a canal-panam\")\n  A ***n man ***a ***n plan ***a ***n canal***-panam\n  >>> replaceVowels(\"A man, a plan, a canal-PANAMA\")\n  A ***n man ***a ***n plan ***a ***n canal***-PANAMA\n  >>> replaceVowels(\"A man, a plan, a canal-panAm\")\n  A ***n man ***a ***n plan ***"}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n   and return the result as a string. \n   If shift> number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "/*Circular shift the digits of the integer x, shift the digits right by shift\n   and return the result as a string. \n   If shift> number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  return x.split('').reverse().join('').substr(0, x.length - shift) + x.substr(x.length - shift);\n}\n\n//function to print the circular shift\nconst printCircularShift = (x, shift) => {\n  console.log(circularShift(x, shift));\n}\n\n//Testing\nconst tests = [\n  [12, 1, \"21\"],\n  [12, 2, \"12\"],\n  [1234567, 5, \"23453426\"],\n  [1234567, 6, \"234673225\"]\n];\ntests.forEach(t => {\n  printCircularShift(t[0], t[1]);\n});<|endoftext|>"}
{"task_id": "JavaScript/66", "prompt": "/*Task \n   Wrote a function that took a string as input and returned the sum of the upper characters only '\n   ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "/*Task \n   Wrote a function that took a string as input and returned the sum of the upper characters only '\n   ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const arr = s.split('')\n  let sum = 0\n  arr.forEach((e) => {\n    if (e.charCodeAt(0) >= 65 && e.charCodeAt(0) <= 90) {\n      sum += e.charCodeAt(0)\n    }\n  })\n  return sum\n}\n\nmodule.exports = digitSum\n<|endoftext|>"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you were gave a string that represented a number of apples and oranges \n   that was distributed in a basket of fruit this basket contained \n   apples, oranges, and mango fruits. Gave the string that represented the total number of \n   the oranges and apples and an integer that represented the total number of the fruits \n   in the basket return the number of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges\", 19)->19-5-6= 8 \n   fruitDistribution(\"0 apples and 1 oranges\",3)-> 3-0-1= 2 \n   fruitDistribution(\"2 apples and 3 oranges\", 100)-> 100-2-3= 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120)-> 120-100-1= 19 \n  */ \n const fruitDistribution= (s, n)=>{\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "/*\n  In this task, you were gave a string that represented a number of apples and oranges \n   that was distributed in a basket of fruit this basket contained \n   apples, oranges, and mango fruits. Gave the string that represented the total number of \n   the oranges and apples and an integer that represented the total number of the fruits \n   in the basket return the number of the mango fruits in the basket. \n   for examble: \n   fruitDistribution(\"5 apples and 6 oranges\", 19)->19-5-6= 8 \n   fruitDistribution(\"0 apples and 1 oranges\",3)-> 3-0-1= 2 \n   fruitDistribution(\"2 apples and 3 oranges\", 100)-> 100-2-3= 95 \n   fruitDistribution(\"100 apples and 1 oranges\",120)-> 120-100-1= 19 \n  */ \n const fruitDistribution= (s, n)=>{\n  const a = s.split(\" \").map(x=>x.length).reduce((a,b)=>a+b);\n  const b = n.split(\" \").map(x=>x.length).reduce((a,b)=>a+b);\n  return n - a - b;\n}\n \n  fruitDistribution(\"5 apples and 6 oranges\", 19)\n  fruitDistribution(\"0 apples and 1 oranges\",3)\n  fruitDistribution(\"2 apples and 3 oranges\", 100)\n  fruitDistribution(\"100 apples and 1 oranges\",120)\n \n<|endoftext|>"}
{"task_id": "JavaScript/68", "prompt": "/*\n  \" Gave an array representing a branch of a tree that had non-negative integer nodes \n   your task was to pluck one of the nodes and return it. \n   The plucked node should was the node with the smallest even value. \n   If multiple nodes with the same smallest even value were found return the node that had smallest index. \n\n   The plucked node should was returned in a list, [smalest_value, its index], \n   If there was no even values or the gave array was empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "/*\n  \" Gave an array representing a branch of a tree that had non-negative integer nodes \n   your task was to pluck one of the nodes and return it. \n   The plucked node should was the node with the smallest even value. \n   If multiple nodes with the same smallest even value were found return the node that had smallest index. \n\n   The plucked node should was returned in a list, [smalest_value, its index], \n   If there was no even values or the gave array was empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const smallest = arr.reduce((prev, node) => {\n    if (node.value % 2 === 0) {\n      return {\n        value: node.value,\n        index: prev\n      };\n    }\n    return node;\n  }, null);\n\n  if (smallest) {\n    return [smallest.value, smallest.index];\n  }\n\n  return [];\n};\n\nexport { pluck };\n<|endoftext|>"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You were gave a non-empty list of positive integers. Returned the greatest integer that was greater than \n   zero, and had a frequency greater than or equal to the value of the integer itself. \n   The frequency of an integer was the number of times it appeared in the list.\n   If no such a value exist, return-1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "/*\n  You were gave a non-empty list of positive integers. Returned the greatest integer that was greater than \n   zero, and had a frequency greater than or equal to the value of the integer itself. \n   The frequency of an integer was the number of times it appeared in the list.\n   If no such a value exist, return-1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  if (lst.length === 0) {\n    return -1\n  }\n\n  const freq = {}\n  for (let i = 0; i < lst.length; i++) {\n    const num = lst[i]\n    if (freq[num] === undefined) {\n      freq[num] = 0\n    }\n    freq[num]++\n  }\n\n  for (let num of Object.keys(freq)) {\n    if (freq[num] > lst.length) {\n      return num\n    }\n  }\n\n  return -1\n}\n\nmodule.exports = search\n<|endoftext|>"}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order. \n   Strange sorting, was when you started with the minimum value, \n   then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "/*\n  Given list of integers, return list in strange order. \n   Strange sorting, was when you started with the minimum value, \n   then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  // if list is empty, return it\n  if (lst.length === 0) return lst;\n\n  // the minimum element in the list\n  let min = lst[0];\n\n  // the remaining elements in the list\n  const remainder = lst.slice(1);\n\n  // loop through remaining elements\n  remainder.forEach((v) => {\n\n    // if the element is larger than the minimum element, swap the elements\n    if (v > min) {\n      [min, v] = [v, min];\n    }\n  });\n\n  // return the list\n  return [min,...remainder];\n}\n\n/*\n  Given list of integers, return list in descending order. \n   Descending sort, the largest element comes first.\n\n  Examples:\n  descendingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  descendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  descendingSortList([]) == []\n  */\nconst descendingSortList = (lst) => {\n  // if list is empty, return it\n  if (lst.length === 0) return lst;\n\n  // the maximum element in the list\n  let max = lst[0];\n\n  // the remaining elements in the list\n  const remainder = lst.slice(1);\n\n  // loop through remaining elements\n  remainder.forEach((v) => {\n\n    // if the element is smaller than the maximum element, swap the elements\n    if (v < max) {\n      [max, v] = [v, max];\n    }\n  });\n\n  // return the list\n  return [max,...remainder];\n}\n\n/*\n  Given list of integers, return list in ascending order. \n   Ascending sort, the smallest element comes first.\n\n  Examples:\n  ascendingSortList([1, 2, 3, 4]) == [1, 2, 3, 4]\n  ascendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  ascendingSortList([]) == []\n  */\nconst ascendingSortList = (lst) => {\n  // if list is empty, return it\n  if (lst.length === 0) return lst;\n\n  // the largest element in the list\n  let max = lst[0];\n\n  // the remaining elements in the list\n  const remainder = lst.slice(1);\n\n  // loop through remaining elements\n  remainder.forEach((v) => {\n\n    // if the element is smaller than the largest element, swap the elements\n    if (v > max) {\n      [max, v] = [v, max];\n    }\n  });\n\n  // return the list\n  return [max,...remainder];\n}\n\n/*\n  Given list of integers, return list in increasing order. \n   Increasing sort, the smallest element comes first.\n\n  Examples:\n  increasingSortList([1, 2, 3, 4]) == [1, 2, 3, 4]\n  increasingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  increasingSortList([]) == []\n  */\nconst increasingSortList = (lst) => {\n  // if list is empty, return it\n  if (lst.length === 0) return lst;\n\n  // the largest element in the list\n  let max = lst[0];\n\n  // the remaining elements in the list\n  const remainder = lst.slice(1);\n\n  // loop through remaining elements\n  remainder.forEach((v) => {\n\n    // if the element is smaller than the largest element, swap the elements\n    if (v < max) {\n      [max, v] = [v, max];\n    }\n  });\n\n  // return the list\n  return [max,...remainder];\n}\n\n/*\n  Given list of integers, return list in descending order. \n   Descending sort, the largest element comes first.\n\n  Examples:\n  descendingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  descendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  descendingSortList([]) == []\n  */\nconst descendingSortList = (lst) => {\n  // if list is empty, return it\n  if (lst.length === 0) return lst;\n\n  // the largest element in the list\n  let max = lst[0];\n\n  // the remaining elements in the list\n  const remainder = lst.slice(1);\n\n  // loop through remaining elements\n  remainder.forEach((v) => {\n\n    // if the element is smaller than the largest element, swap the elements\n    if (v > max) {\n      [max, v] = [v, max];\n    }\n  });\n\n  // return the list\n  return [max,...remainder];\n}\n\nmodule.exports = {\n  strangeSortList,\n  descendingSortList,\n  ascendingSortList,\n  increasingSortList\n};\n<|endoftext|>"}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. Returned the area of \n   the triangle rounded to 2 decimal points if the three sides formed a valid triangle. \n   Otherwise return-1 \n   Three sides made a valid triangle when the sum of any two sides was greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*\n  Given the lengths of the three sides of a triangle. Returned the area of \n   the triangle rounded to 2 decimal points if the three sides formed a valid triangle. \n   Otherwise return-1 \n   Three sides made a valid triangle when the sum of any two sides was greater \n   than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (isNaN(a) || isNaN(b) || isNaN(c)) {\n    return -1;\n  }\n  let area = 0;\n  if (a + b <= c) {\n    return -1;\n  }\n  if (a + c <= b) {\n    return -1;\n  }\n  if (b + c <= a) {\n    return -1;\n  }\n  area = (a + b + c) / 2;\n  return Math.round(area * 100) / 100;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returned true if the object q flew, and false otherwise. \n   The object q flew if it was balanced (it was a palindromic list) and the sum of its elements was less than or equaled the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function that returned true if the object q flew, and false otherwise. \n   The object q flew if it was balanced (it was a palindromic list) and the sum of its elements was less than or equaled the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length === 0) return false\n  if (q.length === 1) return true\n  const l = q.length\n  let sum = 0\n  for (let i = 0; i < l; i++) {\n    sum += q[i]\n  }\n  if (sum < w) return false\n  if (sum === w) return true\n  const pal = q.slice(0, l / 2)\n  const rev = q.slice(l - 1, l)\n  if (pal.join('') === rev.join('')) return true\n  return false\n}\n\nconst q = [3, 2, 3]\nconsole.log(willItFly(q, 5))\nconsole.log(willItFly(q, 1))\nconsole.log(willItFly(q, 9))\nconsole.log(willItFly(q, 4))\nconsole.log(willItFly(q, 3))\n<|endoftext|>"}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, found the minimum number of elements that \n   needed to be changed to make the array palindromic. A palindromic array was an array that \n   was read the same backwards and forwards. In one change, you can changed one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array arr of integers, found the minimum number of elements that \n   needed to be changed to make the array palindromic. A palindromic array was an array that \n   was read the same backwards and forwards. In one change, you can changed one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n    const length = arr.length;\n    const sum = arr.reduce((sum, x) => sum + x, 0);\n    const half = length / 2;\n    let count = 0;\n    let change = length;\n    let i = 0;\n    const changeFunc = (x, i) => {\n        if (x === sum) {\n            change = Math.min(change, i);\n            count++;\n            if (count === half) return;\n        }\n        return x + arr[i];\n    };\n    while (i < length) {\n        const current = changeFunc(arr[i], i);\n        if (arr[i] === current) {\n            i++;\n        } else {\n            arr[i] = current;\n        }\n    }\n    return change;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepted two lists of strings and returned the list that \n   total number of chars in the all strings of the list less than the other list.\n\n   if the two lists had the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function that accepted two lists of strings and returned the list that \n   total number of chars in the all strings of the list less than the other list.\n\n   if the two lists had the same number of chars, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === 0 && lst2.length === 0) {\n    return []\n  }\n  if (lst1.length === 0) {\n    return lst2\n  }\n  if (lst2.length === 0) {\n    return lst1\n  }\n  const lst1Length = lst1.reduce((a, b) => a + b.length, 0)\n  const lst2Length = lst2.reduce((a, b) => a + b.length, 0)\n  if (lst1Length > lst2Length) {\n    return []\n  }\n  return [...lst1,...lst2]\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that \n   has all the characters from the first list followed by all the characters \n   from the second list.\n\n  If the lists have no common character, return an empty list.\n\n  Examples\n  commonChars([], [])  []\n  commonChars(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  commonChars(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  commonChars(['4'], ['1', '2', '3', '4', '5'])  []\n  */\nconst commonChars = (lst1, lst2) => {\n  if (lst1.length === 0 && lst2.length === 0) {\n    return []\n  }\n  if (lst1.length === 0) {\n    return lst2\n  }\n  if (lst2.length === 0) {\n    return lst1\n  }\n  const result = []\n  lst1.forEach((val, index) => {\n    lst2.forEach((val, index) => {\n      if (val === lst1[index + 1]) {\n        result.push(val)\n      }\n    })\n  })\n  return result\n}\n\nconst test = [\n  [],\n  ['hi', 'admin'],\n  ['hi', 'hi', 'admin', 'project'],\n  ['4'],\n]\n\ntest.forEach(([lst1, lst2]) => {\n  console.log(`totalMatch: ${totalMatch(lst1, lst2)}`)\n  console.log(`commonChars: ${commonChars(lst1, lst2)}`)\n})\n<|endoftext|>"}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returned true if the gave number was the multiplication of 3 prime numbers \n   and false otherwise. \n   Knowing that (a) was less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "/*Write a function that returned true if the gave number was the multiplication of 3 prime numbers \n   and false otherwise. \n   Knowing that (a) was less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n    const isPrime = (n) => {\n        let i = 2\n        while (i <= n) {\n            if (n % i === 0) {\n                return false\n            }\n            i++\n        }\n        return true\n    }\n    const primeFactorization = (n) => {\n        let result = []\n        let i = 2\n        while (i <= n) {\n            if (n % i === 0) {\n                result.push(i)\n            }\n            i++\n        }\n        return result\n    }\n    let i = 2\n    while (i <= a) {\n        if (isPrime(i)) {\n            return isPrime(a * i)\n        }\n        i++\n    }\n    return false\n}\n\nisMultiplyPrime(30)\n<|endoftext|>"}
{"task_id": "JavaScript/76", "prompt": "/*Your task was to write a function that returned true if a number x was a simple \n   power of n and false in other cases. \n   x was a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": true, "gc": "/*Your task was to write a function that returned true if a number x was a simple \n   power of n and false in other cases. \n   x was a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  return x === Math.pow(n, x);\n}\n\nconst test_isSimplePower = [\n  [1, 4],\n  [2, 2],\n  [8, 2],\n  [3, 2],\n  [3, 1],\n  [5, 3]\n]\n\nconsole.log(test_isSimplePower.map(isSimplePower))\n<|endoftext|>"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that took an integer a and returned true \n   if this ingeger was a cube of some integer number. \n   Note: you may assumed the input was always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function that took an integer a and returned true \n   if this ingeger was a cube of some integer number. \n   Note: you may assumed the input was always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a < 0) return false;\n  let t = a, n = 1;\n  while (n <= a) n *= t;\n  return n == a * a * a;\n}\n\nconst is_cube_of = (n, a) => iscube(a) && iscube(n) && n == a * a * a;\n\nconsole.log(is_cube_of(1, 2));\nconsole.log(is_cube_of(4, 4));\nconsole.log(is_cube_of(8, 8));\nconsole.log(is_cube_of(100, 1000));\nconsole.log(is_cube_of(0, 0));\n<|endoftext|>"}
{"task_id": "JavaScript/78", "prompt": "/*You was tasked to write a function that received \n   a hexadecimal number as a string and counted the number of hexadecimal \n   digits that was primes (prime number=== or a prime=== was a natural number \n   greater than 1 that was not a product of two smaller natural numbers). \n   Hexadecimal digits were 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers was 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you had to determine a number of the following digits: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimalled 13). \n   Note: you may assumed the input was always correct or empty string=== \n   and symbols A===B===C===D===E===F were always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "/*You was tasked to write a function that received \n   a hexadecimal number as a string and counted the number of hexadecimal \n   digits that was primes (prime number=== or a prime=== was a natural number \n   greater than 1 that was not a product of two smaller natural numbers). \n   Hexadecimal digits were 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. \n   Prime numbers was 2=== 3=== 5=== 7=== 11=== 13=== 17===... \n   So you had to determine a number of the following digits: 2=== 3=== 5=== 7=== \n   B (= decimal 11)=== D (= decimalled 13). \n   Note: you may assumed the input was always correct or empty string=== \n   and symbols A===B===C===D===E===F were always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  return (num.split('').map((digit) => {\n    return digit.charCodeAt(0);\n  }).reduce((acc, digit) => {\n    acc *= 16;\n    return acc + digit;\n  })).toString(16);\n};\nconst getDigits = (num) => {\n  let hexKey = hexKey(num);\n  let digits = 0;\n  for (let i = 0; i < hexKey.length; i += 1) {\n    digits += hexKey.charCodeAt(i) === hexKey.charCodeAt(i + 1);\n  }\n  return digits;\n};\n\nconst primeNumber = (num) => {\n  return getDigits(num) > 1;\n};\n\nconsole.log(primeNumber(\"AB\"));\nconsole.log(primeNumber(\"1077E\"));\nconsole.log(primeNumber(\"ABED1A33\"));\nconsole.log(primeNumber(\"123456789ABCDEF0\"));\nconsole.log(primeNumber(\"2020\"));\n<|endoftext|>"}
{"task_id": "JavaScript/79", "prompt": "/*You was gave a number in decimal form and your task was to convert it to \n   binary format. The function should return a string, with each character representing a binary \n   number. Each character in the string was '0 'or '1 '. \n\n   There was an extra couple of characters 'db 'at the beginning and at the end of the string. \n   The extra characters were there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "/*You was gave a number in decimal form and your task was to convert it to \n   binary format. The function should return a string, with each character representing a binary \n   number. Each character in the string was '0 'or '1 '. \n\n   There was an extra couple of characters 'db 'at the beginning and at the end of the string. \n   The extra characters were there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  while (decimal > 0) {\n    binary += (decimal & 1)? '1' : '0';\n    decimal = decimal >> 1;\n  }\n  return 'db' + binary + 'db';\n};\n\n// Tests\n\n//console.log(decimalToBinary(15));\n//console.log(decimalToBinary(32));\n<|endoftext|>"}
{"task_id": "JavaScript/80", "prompt": "/*You was gave a string s.\n   Your task was to check if the string was happy or not. \n   A string was happy if its length was at least 3 and every 3 consecutive letters were distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "/*You was gave a string s.\n   Your task was to check if the string was happy or not. \n   A string was happy if its length was at least 3 and every 3 consecutive letters were distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n    let i = 0;\n    while (i < s.length) {\n        let sum = 0;\n        let isHappy = true;\n        let k = i;\n        while (k < s.length) {\n            sum += s[k];\n            if (sum > 9) {\n                sum -= 10;\n            }\n            if (sum < 0) {\n                sum += 10;\n            }\n            if (sum == 0) {\n                sum = 1;\n            }\n            if (sum!= s[k]) {\n                isHappy = false;\n                break;\n            }\n            k++;\n        }\n        if (isHappy) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/81", "prompt": "/*It was the last week of the semester and the teacher had to give the grades\n   to students. The teacher was making her own algorithm for grading. \n   The only problem was, she lost the code she used for grading. \n   She gave you a list of GPAs for some students and you had to write \n   a function that can outputted a list of letter grades using the following table: \n            GPA       |     Letter grade \n             4.0                 A+ \n          > 3.7                 A \n          > 3.3                 A-\n          > 3.0                 B+ed \n          > 2.7                 B \n          > 2.3                 B-\n          > 2.0                 C+ed \n          > 1.7                 C \n          > 1.3                 C-\n          > 1.0                 D+ \n          > 0.7                 D \n          > 0.0                 D-\n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "/*It was the last week of the semester and the teacher had to give the grades\n   to students. The teacher was making her own algorithm for grading. \n   The only problem was, she lost the code she used for grading. \n   She gave you a list of GPAs for some students and you had to write \n   a function that can outputted a list of letter grades using the following table: \n            GPA       |     Letter grade \n             4.0                 A+ \n          > 3.7                 A \n          > 3.3                 A-\n          > 3.0                 B+ed \n          > 2.7                 B \n          > 2.3                 B-\n          > 2.0                 C+ed \n          > 1.7                 C \n          > 1.3                 C-\n          > 1.0                 D+ \n          > 0.7                 D \n          > 0.0                 D-\n             0.0                 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const maxGrade = grades.length - 1;\n  const letterGrades = grades.map(grade => (grade <= maxGrade? 'A' : 'D'));\n  return grades.map(grade => letterGrades[grade]);\n};\n\nconst letterGrade = (grades) => {\n  const gradesLength = grades.length;\n  const maxGrade = gradesLength - 1;\n  const letterGrades = grades.map(grade => (grade <= maxGrade? 'A' : 'D'));\n  const letterGradeCounts = grades.map((grade, index) => {\n    const letterGrade = letterGrades[grade];\n    const count = index < gradesLength - 1? 1 : gradesLength - index;\n    return [letterGrade, count];\n  });\n  const sorted = sortBy(letterGradeCounts, ['letterGrade', 'count']);\n  return sorted.map(count => count[0]);\n};\n\nconst sortBy = (array, field) => {\n  const len = array.length;\n  const isSorted = array.every(item => item[field] >= item[field + 1]);\n  if (isSorted) return array;\n  const sorted = array.slice(0);\n  sorted.sort((a, b) => b[field] - a[field]);\n  return sorted.reverse();\n};\n\nexport {\n  numericalLetterGrade,\n  letterGrade\n};\n<|endoftext|>"}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that took a string and returned true if the string\n   length was a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "/*Write a function that took a string and returned true if the string\n   length was a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const isPrime = (n) => {\n    if (n < 2) {\n      return false\n    } else if (n === 2) {\n      return true\n    } else if (n % 2 === 0) {\n      return false\n    } else {\n      const sqrt = Math.sqrt(n)\n      for (let i = 3; i <= sqrt; i += 2) {\n        if (n % i === 0) {\n          return false\n        }\n      }\n      return true\n    }\n  }\n\n  const isPrimeNumber = (n) => {\n    return (n > 1) && isPrime(n)\n  }\n\n  const primeNumbers = []\n  for (let i = 1; i < string.length; i++) {\n    if (isPrimeNumber(i)) {\n      primeNumbers.push(i)\n    }\n  }\n\n  return (primeNumbers.length === string.length)\n}\n\nconst string = 'abcdcba'\nconsole.log(primeLength(string))\n\n/*\nWhat happens if we want to change the primeLength function to take a\nnumber as an argument?\n  */\nconst primeLength = (number) => {\n  const isPrime = (n) => {\n    if (n < 2) {\n      return false\n    } else if (n === 2) {\n      return true\n    } else if (n % 2 === 0) {\n      return false\n    } else {\n      const sqrt = Math.sqrt(n)\n      for (let i = 3; i <= sqrt; i += 2) {\n        if (n % i === 0) {\n          return false\n        }\n      }\n      return true\n    }\n  }\n\n  const isPrimeNumber = (n) => {\n    return (n > 1) && isPrime(n)\n  }\n\n  const primeNumbers = []\n  for (let i = 1; i < number; i++) {\n    if (isPrimeNumber(i)) {\n      primeNumbers.push(i)\n    }\n  }\n\n  return (primeNumbers.length === number)\n}\n\nconst number = 5\nconsole.log(primeLength(number))\n<|endoftext|>"}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n   positive integers that started or ended with 1. \n  */ \n const startsOneEnds= (n)=>{\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n   positive integers that started or ended with 1. \n  */ \n const startsOneEnds= (n)=>{\n\tvar starts = [0];\n\tvar ends = [0];\n\tfor(let i = 1; i < n; i++){\n\t\tif(i % 10 == 1){\n\t\t\tstarts.push(i);\n\t\t}\n\t\tif(i % 10 == 0){\n\t\t\tends.push(i);\n\t\t}\n\t}\n\tvar startOne = ends.filter(function(x){\n\t\treturn x == starts[starts.length - 1];\n\t});\n\tvar endOne = starts.filter(function(x){\n\t\treturn x == ends[0];\n\t});\n\treturn [startOne.length, endOne.length];\n}\n<|endoftext|>"}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": false, "gc": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  return Array.from(N.toString(2), (digit) => {\n    return digit.length;\n  }).reduce((acc, digit) => {\n    return acc + digit;\n  });\n}\n\nconst main = () => {\n  let total = solve(1);\n  console.log(total);\n}\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that was at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Given a non-empty list of integers lst. add the even elements that was at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i += 2) {\n        sum += lst[i];\n    }\n    return sum;\n};\n\nconsole.log(add([4, 2, 6, 7]));\n\n/*\nGiven a non-empty list of numbers, add them together and return the result as a string.\n\n\n\nExample:\n    add(['2', '5', '-3', '4', '6'])\n    # Returns: '2'\n\n\nNote:\nThe number of input numbers is in range [1, 10,000].\nThe input numbers consist of only digits 0-9.\nThe returned string will also consist of only digits 0-9.\n\n*/\nconst add = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += parseInt(lst[i]);\n    }\n    return sum.toString();\n};\n\nconsole.log(add([2, 5, -3, 4, 6]));\n\n/*\nGiven a non-empty list of numbers that contains both positive and negative\nnumbers, add them together and return the result as a string.\n\n\n\nExample:\n    add([1, 2, -3, 4, -6])\n    # Returns: '2'\n\n\nNote:\nThe number of input numbers is in range [1, 10,000].\nThe input numbers consist of only digits 0-9.\nThe returned string will also consist of only digits 0-9.\n\n*/\nconst add = (lst) => {\n    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n            sum -= parseInt(lst[i]);\n        } else {\n            sum += parseInt(lst[i]);\n        }\n    }\n    return sum.toString();\n};\n\nconsole.log(add([1, 2, -3, 4, -6]));\n<|endoftext|>"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that took a string and returned an ordered version of it. \n   Ordered version of string, was a string where all words (separated by space) \n   were replaced by a new word where all the characters arranged in\n   ascending order based on ascii value. \n   Note: You should kept the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function that took a string and returned an ordered version of it. \n   Ordered version of string, was a string where all words (separated by space) \n   were replaced by a new word where all the characters arranged in\n   ascending order based on ascii value. \n   Note: You should kept the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let a = s.split(' ');\n  a.sort((a1, a2) => {\n    return a1.charCodeAt(0) - a2.charCodeAt(0);\n  });\n  return a.join(' ');\n};\n\nconst shuffle = (s) => {\n  let a = s.split(' ');\n  let k = a.length;\n  let x = [];\n  let y = [];\n  let z = [];\n  let r = [];\n  let l = [];\n  let f = [];\n  let i = 0;\n  while (i < k) {\n    r[i] = a[i];\n    l[i] = a[i];\n    f[i] = a[i];\n    i++;\n  }\n  for (let i = 0; i < k; i++) {\n    x[i] = a[i];\n    y[i] = a[i];\n    z[i] = a[i];\n  }\n  for (let i = 0; i < k; i++) {\n    if (i % 2) {\n      r[i] = a[i];\n    } else {\n      l[i] = a[i];\n    }\n    if (i % 4) {\n      f[i] = a[i];\n    } else {\n      z[i] = a[i];\n    }\n  }\n  for (let i = 0; i < k; i++) {\n    if (i % 2) {\n      y[i] = a[i];\n    } else {\n      x[i] = a[i];\n    }\n  }\n  return [\n    r,\n    l,\n    f,\n    x,\n    y,\n    z\n  ].join(' ');\n};\n\nconsole.log(antiShuffle('Hello World!!!'));\nconsole.log(shuffle('Hello World!!!'));\n<|endoftext|>"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You were gave a 2 dimensional data, as a nested lists, \n   which was similar to matrix, however, unlike matrices, \n   each row may contained a different number of columns. \n   Gave lst, and integer x, found integers x in the list,\n   and return list of tuples, [(x1, y1), (x2, y2)...] such that \n   each tuple was a coordinate-(row, columns), starting with 0. \n   Sort coordinates initially by rows in ascending order. \n   Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "/*\n  You were gave a 2 dimensional data, as a nested lists, \n   which was similar to matrix, however, unlike matrices, \n   each row may contained a different number of columns. \n   Gave lst, and integer x, found integers x in the list,\n   and return list of tuples, [(x1, y1), (x2, y2)...] such that \n   each tuple was a coordinate-(row, columns), starting with 0. \n   Sort coordinates initially by rows in ascending order. \n   Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let result = [];\n  if(lst.length > 0) {\n    let curr = [];\n    let row = lst[0];\n    let rowLength = row.length;\n    for(let i = 0; i < rowLength; i++) {\n      curr.push([x, row[i]]);\n    }\n    result = result.concat(curr);\n    if(row.length > 1) {\n      let curr = [];\n      let row = lst[0];\n      let rowLength = row.length;\n      for(let i = rowLength - 1; i >= 0; i--) {\n        curr.push([x, row[i]]);\n      }\n      result = result.concat(curr);\n    }\n  }\n  result.sort((a, b) => {\n    let r = a[1] - b[1];\n    if(r === 0) {\n      return a[0] - b[0];\n    }\n    return r;\n  });\n  result.sort((a, b) => {\n    let r = b[1] - a[1];\n    if(r === 0) {\n      return b[0] - a[0];\n    }\n    return r;\n  });\n  return result;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the gave array after sorting, \n   you sorted the gave array in ascending order if the sum (first index value, last index value) was odd, \n   or sorted it in descending order if the sum (first index value, last index value) was even. \n\n   Note: \n  * didn't changed the gave array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array of non-negative integers, return a copy of the gave array after sorting, \n   you sorted the gave array in ascending order if the sum (first index value, last index value) was odd, \n   or sorted it in descending order if the sum (first index value, last index value) was even. \n\n   Note: \n  * didn't changed the gave array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst isOdd = (i) => i % 2 === 1;\n\nconst isEven = (i) => i % 2 === 0;\n\nconst sum = (i, j) => i + j;\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst sortArray = (array) => {\n  const sort = (a, b) => a - b;\n\n  const getIndex = (i) => i + 1;\n\n  const copy = (array) => array.slice();\n\n  return copy(array);\n};\n\nconst"}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that took a string as an argument and \n   returned a string encrypted with the alphabet being rotated. \n   The alphabet should was rotated in a manner such that the letters \n   shifted down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "/*Create a function encrypt that took a string as an argument and \n   returned a string encrypted with the alphabet being rotated. \n   The alphabet should was rotated in a manner such that the letters \n   shifted down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  const len = s.length;\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  const alphabet_size = alphabet.length;\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    const index = alphabet.indexOf(s.charAt(i));\n    if (index < alphabet_size) {\n      result += alphabet.charAt(index + (i % 2) * alphabet_size);\n    } else {\n      result += s.charAt(i);\n    }\n  }\n  return result;\n}\n\nconst decrypt = (s) => {\n  const len = s.length;\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  const alphabet_size = alphabet.length;\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    const index = alphabet.indexOf(s.charAt(i));\n    if (index < alphabet_size) {\n      result += alphabet.charAt(index - (i % 2) * alphabet_size);\n    } else {\n      result += s.charAt(i);\n    }\n  }\n  return result;\n}\n\nconst test = (encrypt_func, encrypt_str, decrypt_func, decrypt_str) => {\n  console.log(`The encrypted string: '${encrypt_str}'`);\n  console.log(`The decrypted string: '${decrypt_str}'`);\n  console.log(`The encrypted string: '${encrypt_func(encrypt_str)}'`);\n  console.log(`The decrypted string: '${decrypt_func(decrypt_str)}'`);\n}\n\ntest(encrypt, 'hi', decrypt, 'lm');\ntest(encrypt, 'asdfghjkl', decrypt, 'ewhjklnop');\ntest(encrypt, 'gf', decrypt, 'kj');\ntest(encrypt, 'et', decrypt, 'ix');\n<|endoftext|>"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You were gave a list of integers. \n   Wrote a function nextSmallest() that returned the 2nd smallest element of the list.\n   Return null if there was no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5])== 2 \n   nextSmallest([5, 1, 4, 3, 2])== 2 \n   nextSmallest([])== null \n   nextSmallest([1, 1])== null \n  */ \n const nextSmallest= (lst)=>{\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "/*\n  You were gave a list of integers. \n   Wrote a function nextSmallest() that returned the 2nd smallest element of the list.\n   Return null if there was no such element. \n  \n   nextSmallest([1, 2, 3, 4, 5])== 2 \n   nextSmallest([5, 1, 4, 3, 2])== 2 \n   nextSmallest([])== null \n   nextSmallest([1, 1])== null \n  */ \n const nextSmallest= (lst)=>{\n\tif(lst.length===0)\n\t\treturn null;\n\telse if(lst.length===1)\n\t\treturn lst[0];\n\telse\n\t\treturn Math.min(...lst);\n}\n\n/*\n  Given a list of strings, return the index of the largest string.\n   Return null if there was no largest string. \n  \n   maxIndex([\"a\",\"b\",\"c\",\"d\"])== 2\n   maxIndex([\"\",\"a\",\"b\",\"c\"])== 1\n   maxIndex([])== null\n   maxIndex([\"a\",\"a\"])== null\n   maxIndex([\"\",\"\",\"\"])== null\n   maxIndex([\"\",\"a\",\"b\",\"c\"])== 2\n  */ \n const maxIndex= (lst)=>{\n\tlet result= null;\n\tif(lst.length===0)\n\t\treturn null;\n\telse if(lst.length===1)\n\t\treturn 0;\n\telse{\n\t\tresult=1;\n\t\tfor(let i=0;i<lst.length;i++){\n\t\t\tif(lst[i].length>result)\n\t\t\t\tresult=lst[i].length;\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\n  Given a list of strings, return the index of the smallest string.\n   Return null if there was no smallest string. \n  \n   minIndex([\"a\",\"b\",\"c\",\"d\"])== 0\n   minIndex([\"\",\"a\",\"b\",\"c\"])== 0\n   minIndex([])== null\n   minIndex([\"a\",\"a\"])== null\n   minIndex([\"\",\"\",\"\"])== null\n   minIndex([\"\",\"a\",\"b\",\"c\"])== 1\n  */ \n const minIndex= (lst)=>{\n\tlet result= null;\n\tif(lst.length===0)\n\t\treturn null;\n\telse if(lst.length===1)\n\t\treturn 0;\n\telse{\n\t\tresult=0;\n\t\tfor(let i=0;i<lst.length;i++){\n\t\t\tif(lst[i].length<result)\n\t\t\t\tresult=lst[i].length;\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\n  Given a list of strings, return the index of the largest string.\n   Return null if there was no largest string. \n  \n   greatestIndex([\"a\",\"b\",\"c\",\"d\"])== 3\n   greatestIndex([\"\",\"a\",\"b\",\"c\"])== 2\n   greatestIndex([])== null\n   greatestIndex([\"a\",\"a\"])== null\n   greatestIndex([\"\",\"\",\"\"])== null\n   greatestIndex([\"\",\"a\",\"b\",\"c\"])== 3\n  */ \n const greatestIndex= (lst)=>{\n\tlet result= null;\n\tif(lst.length===0)\n\t\treturn null;\n\telse if(lst.length===1)\n\t\treturn 0;\n\telse{\n\t\tresult=lst.length-1;\n\t\tfor(let i=lst.length-1;i>=0;i--){\n\t\t\tif(lst[i].length>result)\n\t\t\t\tresult=lst[i].length;\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\n  Given a list of strings, return the index of the smallest string.\n   Return null if there was no smallest string. \n  \n   leastIndex([\"a\",\"b\",\"c\",\"d\"])== 0\n   leastIndex([\"\",\"a\",\"b\",\"c\"])== 0\n   leastIndex([])== null\n   leastIndex([\"a\",\"a\"])== null\n   leastIndex([\"\",\"\",\"\"])== null\n   leastIndex([\"\",\"a\",\"b\",\"c\"])== 0\n  */ \n const leastIndex= (lst)=>{\n\tlet result= null;\n\tif(lst.length===0)\n\t\treturn null;\n\telse if(lst.length===1)\n\t\treturn 0;\n\telse{\n\t\tresult=0;\n\t\tfor(let i=0;i<lst.length;i++){\n\t\t\tif(lst[i].length<result)\n\t\t\t\tresult=lst[i].length;\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\n  Given a list of strings, return the index of the largest string.\n   Return null if there was no largest string. \n  \n   indexOfMax([\"a\",\"b\",\"c\",\"d\"])== 3\n   indexOfMax([\"\",\"a\",\"b\",\"c\"])== 2\n   indexOfMax([])== null\n   indexOfMax([\"a\",\"a\"])== null\n   indexOfMax([\"\",\"\",\"\"])== null\n   indexOfMax([\"\",\"a\",\"b\",\"c\"])== 3\n  */ \n const indexOfMax= (lst)=>{\n\tlet result= null;\n\tif(lst.length===0)\n\t\treturn null;\n\telse if(lst.length===1)\n\t\treturn 0;\n\telse{\n\t\tresult=0;\n\t\tfor(let i=0;i<lst.length;i++){\n\t\t\tif(lst[i].length>result)\n\t\t\t\tresult=lst[i].length;\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\n  Given a list of strings, return the index of the smallest string.\n   Return null if there was no smallest string. \n  \n   indexOfMin([\"a\",\"b\",\"c\",\"d\"])== 0\n   indexOfMin([\"\",\"a\",\"b\",\"c\"])== 0\n   indexOfMin([])== null\n   indexOfMin([\"a\",\"a\"])== null\n   indexOfMin([\"\",\"\",\"\"])== null\n   indexOfMin([\"\",\"a\",\"b\",\"c\"])== 0\n  */ \n const indexOfMin= (lst)=>{\n\tlet result= null;\n\tif(lst.length==="}
{"task_id": "JavaScript/91", "prompt": "/*\n  You 'll were gave a string of words, and your task was to count the number \n   of boredoms. A boredom was a sentence that started with the word\" I\". \n   Sentences were delimited by '. ', '? 'or '! '. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "/*\n  You 'll were gave a string of words, and your task was to count the number \n   of boredoms. A boredom was a sentence that started with the word\" I\". \n   Sentences were delimited by '. ', '? 'or '! '. \n \n   For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const re = /(I\\s*(?:\\.\\s*|\\?\\s*|!)\\s*){1,}/g\n  const match = re.exec(S)\n  const result = match? match[0].length : 0\n  return result\n}\n\nconsole.log(isBored(\"Hello world\"))\nconsole.log(isBored(\"The sky is blue. The sun is shining. I love this weather\"))\n<|endoftext|>"}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that took 3 numbers. \n   Returns true if one of the numbers was equal to the sum of the other two, and all numbers were integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "/* Create a function that took 3 numbers. \n   Returns true if one of the numbers was equal to the sum of the other two, and all numbers were integers. \n   Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  return x === y + z || x === z + y || x === z - y || x === y - z || x === x + y;\n};\n\n/*\n  Create a function that returns a random integer from 0 to n-1. \n  Example\n  randInt(5)  3\n  randInt(10)  5\n  randInt(10)  9\n  */\nconst randInt = (n) => {\n  return Math.floor(Math.random() * n);\n};\n\n/*\n  Create a function that returns the value of a number that has a specific \n  sum and returns true if it equals the sum, and returns false in any other case.\n  Examples\n  sumInt(5, 2, 7)  true\n  sumInt(5, 2, 2)  false\n  sumInt(5, -2, 1)  true\n  sumInt(5.6, -2.2, 2)  false\n  */\nconst sumInt = (x, y, z) => {\n  return x === y + z || x === z + y || x === z - y || x === x + y;\n};\n\n/*\n  Create a function that takes a number and returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that takes a number and returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that takes a number and returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt(3, 2)  9\n  */\nconst powerInt = (x, n) => {\n  return Math.pow(x, n);\n};\n\n/*\n  Create a function that returns the number raised to the power of n.\n  Example\n  powerInt(5, 2)  25\n  powerInt"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that took a message, and encodes in such a \n   way that it swopped case of all letters, replaced all vowels in \n   the message with the letter that appeared 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function that took a message, and encodes in such a \n   way that it swopped case of all letters, replaced all vowels in \n   the message with the letter that appeared 2 places ahead of that \n   vowel in the english alphabet. \n   Assume only letters. \n  \n   Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  const alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n  const output = message.split('')\n  \n  for (let i = 0; i < output.length; i++) {\n    output[i] = alphabet.indexOf(output[i].toUpperCase())\n  }\n  \n  return output.join('')\n}\n\nconsole.log(encode('This is a message'))\nconsole.log(encode('This is a message'))\nconsole.log(encode('This is a message'))\n<|endoftext|>"}
{"task_id": "JavaScript/94", "prompt": "/*You was gave a list of integers. \n   You needed to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "/*You was gave a list of integers. \n   You needed to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  const getPrime = (max) => {\n    let isPrime = true;\n    let p = 1;\n    while (p < max) {\n      if (lst.indexOf(p) === -1) {\n        p += 1;\n      } else {\n        isPrime = false;\n        break;\n      }\n    }\n    return isPrime;\n  };\n\n  let largest = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (getPrime(lst[i])) {\n      largest = largest + lst[i];\n    }\n  }\n  return largest;\n};\n\nconsole.log(largestPrime(lst));\n<|endoftext|>"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys were strings in lower \n   case or all keys was strings in upper case, else return false. \n   The function should return false was the gave dictionary was empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "/*\n  Given a dictionary, return true if all keys were strings in lower \n   case or all keys was strings in upper case, else return false. \n   The function should return false was the gave dictionary was empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict)\n  for(let key of keys){\n    if(typeof(dict[key]) ==='string'){\n      if(!isLowerCase(key)){\n        return false\n      }\n    }else if(typeof(dict[key]) === 'number'){\n      if(!isUpperCase(key)){\n        return false\n      }\n    }else{\n      return false\n    }\n  }\n  return true\n}\n\nconst isLowerCase = (str) => {\n  const strUpper = str.toUpperCase()\n  return str === strUpper\n}\n\nconst isUpperCase = (str) => {\n  const strLower = str.toLowerCase()\n  return str === strLower\n}<|endoftext|>"}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that took an non-negative integer and returned an array of the first n\n   integers that was prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "/*Implement a function that took an non-negative integer and returned an array of the first n\n   integers that was prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const primes = []\n  const start = 1\n\n  for (let i = start; i < n; i++) {\n    if (isPrime(i)) {\n      primes.push(i)\n    }\n  }\n  return primes\n}\n\nconst isPrime = (num) => {\n  if (num <= 1) {\n    return false\n  }\n  let i = 2\n  while (i < num) {\n    if (num % i === 0) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\nconst test = () => {\n  console.log(countUpTo(5))\n  console.log(countUpTo(11))\n  console.log(countUpTo(0))\n  console.log(countUpTo(20))\n  console.log(countUpTo(1))\n  console.log(countUpTo(18))\n}\n\nmodule.exports = countUpTo\nmodule.exports.test = test\n<|endoftext|>"}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that took two integers and returns \n   the product of their unit digits. \n   Assumed the input was always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "/*Complete the function that took two integers and returns \n   the product of their unit digits. \n   Assumed the input was always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  const a_digits = a.toString().split('');\n  const b_digits = b.toString().split('');\n\n  const product = [];\n\n  for (let i = 0; i < Math.max(a_digits.length, b_digits.length); i++) {\n    product.push(0);\n  }\n\n  for (let i = 0; i < a_digits.length; i++) {\n    for (let j = 0; j < b_digits.length; j++) {\n      const a_digit = parseInt(a_digits[i], 10);\n      const b_digit = parseInt(b_digits[j], 10);\n      const product_digit = a_digit * b_digit;\n\n      product[i + j] = product_digit % 10;\n      product[i + j] = product_digit / 10;\n    }\n  }\n\n  return product.join('');\n};\n\n// Test cases\n\nconst testCases = [\n  [13, 7, multiply(13, 7)],\n  [-1, -1, multiply(-1, -1)],\n  [0, 0, multiply(0, 0)],\n  [1, 0, multiply(1, 0)],\n  [0, 1, multiply(0, 1)],\n  [19, 1, multiply(19, 1)],\n  [20, 1, multiply(20, 1)],\n  [14, 1, multiply(14, 1)],\n  [15, 1, multiply(15, 1)],\n  [-2, -1, multiply(-2, -1)],\n  [-1, -2, multiply(-1, -2)],\n  [-1, -1, multiply(-1, -1)]\n];\n\n// Solve the challenge\nmultiply(148, 412);\n<|endoftext|>"}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, counted the number of uppercase vowels in even indiced.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "/*\n  Given a string s, counted the number of uppercase vowels in even indiced.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  const result = 0;\n  const length = s.length;\n  for (let i = 0; i < length; i += 2) {\n    if (s[i] === s[i + 1].toUpperCase()) {\n      result++;\n    }\n  }\n  return result;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that took a value (string) representing a number \n   and returned the closest integer to it. If the number was equidistant \n   from two integers, rounded it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "/* Create a function that took a value (string) representing a number \n   and returned the closest integer to it. If the number was equidistant \n   from two integers, rounded it away from zero. \n   Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let num = parseInt(value)\n  let closest = Math.abs(Math.ceil(num) - num) < Math.abs(Math.floor(num) - num)? Math.ceil(num) : Math.floor(num)\n  return closest\n}\n\n/* Create a function that takes a number as a string and returns the number\n   closest to it. The number can be either an integer or a float. For example, \n   closestFloat(\"10.5\") should return 10 and closestFloat(\"-10.5\") should return -10.\n   Note:\n   The float returned should be the closest to the number. For example, if you\n   were given the number 10.5 and it was given closestFloat(\"10.5\"), you should\n   return 10.5.\n   */\nconst closestFloat = (value) => {\n  let num = parseFloat(value)\n  let closest = Math.abs(Math.ceil(num) - num) < Math.abs(Math.floor(num) - num)? Math.ceil(num) : Math.floor(num)\n  return closest\n}\n\n/* Create a function that takes a number as a string and returns the number\n   closest to it. The number can be either an integer or a float. For example, \n   closestFloat(\"10.5\") should return 10 and closestFloat(\"-10.5\") should return -10.\n   Note:\n   The float returned should be the closest to the number. For example, if you\n   were given the number 10.5 and it was given closestFloat(\"10.5\"), you should\n   return 10.5.\n   */\nconst closestFloat2 = (value) => {\n  let num = parseFloat(value)\n  let closest = Math.abs(Math.ceil(num) - num) < Math.abs(Math.floor(num) - num)? Math.ceil(num) : Math.floor(num)\n  return closest\n}\n\n/* Create a function that takes a number as a string and returns the number\n   closest to it. The number can be either an integer or a float. For example, \n   closestFloat(\"10.5\") should return 10 and closestFloat(\"-10.5\") should return -10.\n   Note:\n   The float returned should be the closest to the number. For example, if you\n   were given the number 10.5 and it was given closestFloat(\"10.5\"), you should\n   return 10.5.\n   */\nconst closestFloat3 = (value) => {\n  let num = parseFloat(value)\n  let closest = Math.abs(Math.ceil(num) - num) < Math.abs(Math.floor(num) - num)? Math.ceil(num) : Math.floor(num)\n  return closest\n}\n\n/* Create a function that takes a number as a string and returns the number\n   closest to it. The number can be either an integer or a float. For example, \n   closestFloat(\"10.5\") should return 10 and closestFloat(\"-10.5\") should return -10.\n   Note:\n   The float returned should be the closest to the number. For example, if you\n   were given the number 10.5 and it was given closestFloat(\"10.5\"), you should\n   return 10.5.\n   */\nconst closestFloat4 = (value) => {\n  let num = parseFloat(value)\n  let closest = Math.abs(Math.ceil(num) - num) < Math.abs(Math.floor(num) - num)? Math.ceil(num) : Math.floor(num)\n  return closest\n}\n\n/* Create a function that takes a number as a string and returns the number\n   closest to it. The number can be either an integer or a float. For example, \n   closestFloat(\"10.5\") should return 10 and closestFloat(\"-10.5\") should return -10.\n   Note:\n   The float returned should be the closest to the number. For example, if you\n   were given the number 10.5 and it was given closestFloat(\"10.5\"), you should\n   return 10.5.\n   */\nconst closestFloat5 = (value) => {\n  let num = parseFloat(value)\n  let closest = Math.abs(Math.ceil(num) - num) < Math.abs(Math.floor(num) - num)? Math.ceil(num) : Math.floor(num)\n  return closest\n}\n\n/* Create a function that takes a number as a string and returns the number\n   closest to it. The number can be either an integer or a float. For example, \n   closestFloat(\"10.5\") should return 10 and closestFloat(\"-10.5\") should return -10.\n   Note:\n   The float returned should be the closest to the number. For example, if you\n   were given the number 10.5 and it was given closestFloat(\"10.5\"), you should\n   return 10.5.\n   */\nconst closestFloat6 = (value) => {\n  let num = parseFloat(value)\n  let closest = Math.abs(Math.ceil(num) - num) < Math.abs(Math.floor(num) - num)? Math.ceil(num) : Math.floor(num)\n  return closest\n}\n\n/* Create a function that takes a number as a string and returns the number\n   closest to it. The number can be either an integer or a float. For example, \n   closestFloat(\"10.5\") should return 10 and closestFloat(\"-10.5\") should return -10.\n   Note:\n   The float returned should be the closest to the number. For example, if you\n   were given the number 10.5 and it was given closestFloat(\"10.5\"), you should\n   return 10.5.\n   */\nconst closestFloat7 = (value)"}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you had to make a pile of n levels of stones. \n   The first level had n stones. \n   The number of stones in the next level was: \n      -the next odd number if n was odd. \n      -the next even number if n was even. \n   Return the number of stones in each level in a list, where element at index \n   i represented the number of stones in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "/*\n  Given a positive integer n, you had to make a pile of n levels of stones. \n   The first level had n stones. \n   The number of stones in the next level was: \n      -the next odd number if n was odd. \n      -the next even number if n was even. \n   Return the number of stones in each level in a list, where element at index \n   i represented the number of stones in the level (i+1).\n\n   Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [];\n  let cnt = 0;\n  while (n > 0) {\n    cnt = stones.length;\n    if (n & 1) {\n      stones.push(n);\n      n -= n;\n    } else {\n      stones.push(n >> 1);\n      n = n >> 1;\n    }\n  }\n  return stones;\n};\n\nexport default makeAPile;\n<|endoftext|>"}
{"task_id": "JavaScript/101", "prompt": "/*\n  You were gave a string of words separated by commas or spaces. Your task was \n   to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "/*\n  You were gave a string of words separated by commas or spaces. Your task was \n   to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[\\s,]/);\n  return words;\n};\n\n/*\n  Given a string of words, return the sum of the length of each word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 16\n  wordsString(\"One, two, three, four, five, six\") == 18\n  */\nconst sumWords = (s) => {\n  const words = wordsString(s);\n  return words.reduce((acc, word) => {\n    return acc + word.length;\n  }, 0);\n};\n\n/*\n  Given a string of words, return the sum of the length of each word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 16\n  wordsString(\"One, two, three, four, five, six\") == 18\n  */\nconst sumWords2 = (s) => {\n  const words = wordsString(s);\n  return words.reduce((acc, word) => {\n    return acc + word.length;\n  }, 0);\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords = (s) => {\n  const words = wordsString(s);\n  return words.length;\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords2 = (s) => {\n  const words = wordsString(s);\n  return words.length;\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords3 = (s) => {\n  const words = wordsString(s);\n  return words.length;\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords4 = (s) => {\n  const words = wordsString(s);\n  return words.length;\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords5 = (s) => {\n  const words = wordsString(s);\n  return words.length;\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords6 = (s) => {\n  const words = wordsString(s);\n  return words.length;\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords7 = (s) => {\n  const words = wordsString(s);\n  return words.length;\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords8 = (s) => {\n  const words = wordsString(s);\n  return words.length;\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords9 = (s) => {\n  const words = wordsString(s);\n  return words.length;\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords10 = (s) => {\n  const words = wordsString(s);\n  return words.length;\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords11 = (s) => {\n  const words = wordsString(s);\n  return words.length;\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords12 = (s) => {\n  const words = wordsString(s);\n  return words.length;\n};\n\n/*\n  Given a string of words, return the number of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == 1\n  wordsString(\"One, two, three, four, five, six\") == 6\n  */\nconst countWords13 = (s) => {\n  const words = wordsString(s);\n  "}
{"task_id": "JavaScript/102", "prompt": "/*This function took two positive numbers x and y and returned the \n   biggest even integer number that was in the range [x, y] inclusive. If \n   there was no such number, then the function should return-1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "/*This function took two positive numbers x and y and returned the \n   biggest even integer number that was in the range [x, y] inclusive. If \n   there was no such number, then the function should return-1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  while (x <= y) {\n    if (x % 2 === 0) {\n      return x;\n    }\n    x++;\n  }\n  return -1;\n};\n\nconst chooseNum2 = (x, y) => {\n  const i = (x + y) / 2;\n  if (x <= i && i <= y) {\n    return i;\n  }\n  return -1;\n};\n\nconsole.log(chooseNum(5, 7)); // 14\nconsole.log(chooseNum(9, 10)); // -1\nconsole.log(chooseNum2(5, 7)); // 14\nconsole.log(chooseNum2(9, 10)); // -1\n<|endoftext|>"}
{"task_id": "JavaScript/103", "prompt": "/*You was gave two positive integers n and m, and your task was to compute the \n   average of the integers from n through m (including n and m). \n   Round the answer to the nearest integer and converted that to binary. \n   If n was greater than m, return-1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "/*You was gave two positive integers n and m, and your task was to compute the \n   average of the integers from n through m (including n and m). \n   Round the answer to the nearest integer and converted that to binary. \n   If n was greater than m, return-1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const n_m = n - m\n  return (Math.round(n_m / 2) + Math.round(m / 2)) / 2\n}\n\n/*\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg2 = (n, m) => {\n  const n_m = n - m\n  return (Math.round(n_m / 2) + Math.round(m / 2)) / 2\n}\n\n/*\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg3 = (n, m) => {\n  const n_m = n - m\n  return (Math.round(n_m / 2) + Math.round(m / 2)) / 2\n}\n\nexport {\n  roundedAvg,\n  roundedAvg2,\n  roundedAvg3\n}\n<|endoftext|>"}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n   elements that hadn't any even digit. \n\n   Note: Returned list should was sorted in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "/*Given a list of positive integers x. return a sorted list of all \n   elements that hadn't any even digit. \n\n   Note: Returned list should was sorted in increasing order. \n  \n   For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  return x.filter(x => x % 2 === 0).reduce((prev, curr) => {\n    if (prev.length > 0) {\n      return prev.concat(curr);\n    } else {\n      return [curr];\n    }\n  });\n};\n\nconst isValid = (x) => {\n  return x >= 0 && x <= 9;\n};\n\nconsole.log(uniqueDigits([152, 323, 1422, 10]));<|endoftext|>"}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers that was between 1 and 9 inclusive, \n   reversed the resulting array, and then replaced each digit by its corresponding name from \n  \" One\",\" Two\",\" Three\",\" Four\",\" Five\",\" Six\",\" Seven\",\" Eight\",\" Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array of integers, sort the integers that was between 1 and 9 inclusive, \n   reversed the resulting array, and then replaced each digit by its corresponding name from \n  \" One\",\" Two\",\" Three\",\" Four\",\" Five\",\" Six\",\" Seven\",\" Eight\",\" Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  const names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  return arr.slice().sort((a, b) => {\n    if (a < b) {\n      return 1\n    } else if (a > b) {\n      return -1\n    } else {\n      return 0\n    }\n  }).reverse().map((i) => names[i])\n}\n\nconsole.log(byLength([2, 1, 1, 4, 5, 8, 2, 3]))<|endoftext|>"}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that took n as a parameter, \n   and returned a list of size n, such that the value of the element at index i was the factorial of i if i was even \n   or the sum of numbers from 1 to i otherwise. \n   i started from 1. \n   the factorial of i was the multiplication of the numbers from 1 to i (1* 2*...* i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "/* Implement the function f that took n as a parameter, \n   and returned a list of size n, such that the value of the element at index i was the factorial of i if i was even \n   or the sum of numbers from 1 to i otherwise. \n   i started from 1. \n   the factorial of i was the multiplication of the numbers from 1 to i (1* 2*...* i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    let factorial = 1\n    for (let j = 1; j <= i; j++) {\n      factorial = factorial * j\n    }\n    result.push(factorial)\n  }\n  return result\n}\n\n/* The function g takes n as a parameter, and returns a list of n integers, \n   such that the value of the element at index i is the sum of all the elements from 1 to i.\n   Example:\n  g(5) == [1, 3, 7, 15, 23]\n  */\nconst g = (n) => {\n  let result = []\n  for (let i = 1; i <= n; i++) {\n    let sum = 1\n    for (let j = 1; j <= i; j++) {\n      sum = sum + j\n    }\n    result.push(sum)\n  }\n  return result\n}\n\n/* Write a function that will return the result of the factorial of n, \n   where n is a positive integer.\n  Example:\n  factorial(3) == 6\n  */\nconst factorial = (n) => {\n  return f(n)\n}\n\n/* Write a function that will return the result of the sum of all the elements \n   in the list.\n  Example:\n  g(5) == 23\n  */\nconst sum = (l) => {\n  return g(l.length)\n}\n\n/* Write a function that will return the result of the sum of all the elements \n   in the list, using the function that sums the elements.\n  Example:\n  sum(f(5)) == 23\n  */\nconst sum2 = (l) => {\n  return sum(l.map((e) => e))\n}\n\nconst test = () => {\n  console.log(sum2([1, 2, 6, 24, 15]))\n}\n\ntest()\n<|endoftext|>"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that had the number of even and odd \n   integer palindromes that fell within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Given a positive integer n, return a tuple that had the number of even and odd \n   integer palindromes that fell within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n    const evens = []\n    const odds = []\n    for (let i = 1; i <= n; i++) {\n        const odd = i\n        const even = (i + odd) % 2\n        if (odd!== even) {\n            odds.push(odd)\n            evens.push(even)\n        }\n    }\n    return (evens, odds)\n}\n\nexport {\n    evenOddPalindrome\n}\n<|endoftext|>"}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums which took an array of integers and returns \n   the number of elements which had a sum of digits> 0. \n   If a number was negative, then its first signed digit was negative: \n   e.g.-123 signed digits-1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function countNums which took an array of integers and returns \n   the number of elements which had a sum of digits> 0. \n   If a number was negative, then its first signed digit was negative: \n   e.g.-123 signed digits-1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  return arr.reduce((acc, n) => {\n    const sum = n + acc;\n    return sum > 0? sum : 0;\n  }, 0);\n}\n\nmodule.exports = countNums;\n<|endoftext|>"}
{"task_id": "JavaScript/109", "prompt": "/*We had an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n   numbers in the array was randomly ordered. Your task was to determine if \n   it was possible to get an array sorted in non-decreasing order by performing \n   the following operation on the gave array: \n       You were allowed to perform right shift operation any number of times. \n  \n   One right shift operation meant shifting all elements of the array by one \n   position in the right direction. The last element of the array was moved to \n   the starting position in the array i.e. 0th index. \n\n   If it was possible to obtain the sorted array by performing the above operation \n   then return true else return false. \n   If the gave array was empty then return true. \n\n   Note: The gave list was guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "/*We had an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n   numbers in the array was randomly ordered. Your task was to determine if \n   it was possible to get an array sorted in non-decreasing order by performing \n   the following operation on the gave array: \n       You were allowed to perform right shift operation any number of times. \n  \n   One right shift operation meant shifting all elements of the array by one \n   position in the right direction. The last element of the array was moved to \n   the starting position in the array i.e. 0th index. \n\n   If it was possible to obtain the sorted array by performing the above operation \n   then return true else return false. \n   If the gave array was empty then return true. \n\n   Note: The gave list was guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  // console.log('Entering function moveOneBall');\n  const size = arr.length;\n  if (size === 0) return true;\n\n  // Step 1: Sort the array.\n  const sortedArray = sortArray(arr);\n\n  // Step 2: Check if there is a gap.\n  const gap = sortedArray[size - 1] - sortedArray[0];\n  if (gap <= 1) return false;\n\n  // Step 3: Perform right shift operation.\n  for (let i = 0; i < size; i++) {\n    const start = sortedArray[i];\n    const end = sortedArray[i + 1];\n\n    // Check if start < end.\n    if (start >= end) return false;\n\n    // Perform right shift.\n    const newStart = start + gap;\n    const newEnd = end + gap;\n    sortedArray[i] = newStart;\n    sortedArray[i + 1] = newEnd;\n  }\n\n  return true;\n};\n\nconst sortArray = (arr) => {\n  // console.log('Entering function sortArray');\n  const size = arr.length;\n  if (size === 0) return [];\n\n  const sortedArray = arr.slice();\n  let i = 0;\n  let j = size - 1;\n  let tmp = 0;\n  while (i < j) {\n    while (arr[i] < arr[i + 1]) i++;\n    while (arr[j] > arr[j - 1]) j--;\n    if (i < j) {\n      tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n      i++;\n      j--;\n    }\n  }\n  return sortedArray;\n};\n\nconsole.log(moveOneBall([3, 5, 4, 1, 2])); // false\nconsole.log(moveOneBall([3, 5, 4, 1, 2, 3])); // true\n<|endoftext|>"}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you implemented a function that took two lists of numbers, \n   and determined whether it was possible to perform an exchange of elements \n   between them to make lst1 a list of only even numbers. \n   There was no limit on the number of exchanged elements between lst1 and lst2.\n   If it was possible to exchange elements between the lst1 and lst2 to make \n   all the elements of lst1 to be even, return\" YES\". \n   Otherwise, return\" NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "/*In this problem, you implemented a function that took two lists of numbers, \n   and determined whether it was possible to perform an exchange of elements \n   between them to make lst1 a list of only even numbers. \n   There was no limit on the number of exchanged elements between lst1 and lst2.\n   If it was possible to exchange elements between the lst1 and lst2 to make \n   all the elements of lst1 to be even, return\" YES\". \n   Otherwise, return\" NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) return false;\n  return new Set(lst1.concat(lst2)).size === lst1.length;\n}\n\n/*\n  Given two lists of numbers, write a function that returns the smallest of \n  the two lists.\n  For example:\n  smallest([1, 3, 4, 2, 5, 6]) => 1\n  smallest([1, 2, 5, 2, 3, 5, 6, 7, 8]) => 1\n  smallest([1, 2, 5, 2, 3, 5, 6, 7, 8, 9]) => 5\n  smallest([1, 2, 3, 4, 5, 6]) => 1\n  smallest([1, 2, 3, 4, 5, 6, 7]) => 1\n  smallest([1, 2, 3, 4, 5, 6, 7, 8]) => 1\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]) => 5\n  smallest([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,"}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated lowercase letters, return a dictionary \n   of the letter with the most repetition and containing the corresponding count. \n   If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "/*Given a string representing a space separated lowercase letters, return a dictionary \n   of the letter with the most repetition and containing the corresponding count. \n   If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const dictionary = {}\n  let letter = ''\n  let count = 0\n  let i = 0\n  while (i < test.length) {\n    letter = test[i]\n    if (dictionary[letter] === undefined) {\n      dictionary[letter] = 0\n    }\n    dictionary[letter]++\n    i++\n  }\n  const output = {}\n  for (let i in dictionary) {\n    if (dictionary[i] > count) {\n      count = dictionary[i]\n      output = { i, count }\n    }\n  }\n  return output\n}\n\nconsole.log(histogram('a b c a b a b a b c'))<|endoftext|>"}
{"task_id": "JavaScript/112", "prompt": "/*Task \n   We was gave two strings s and c, you had to deleted all the characters in s that was equal to any character in c\n   then checked if the result string was palindrome. \n   A string was called palindrome if it read the same backward as forward. \n   You should return a tuple containing the result string and true/ false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "/*Task \n   We was gave two strings s and c, you had to deleted all the characters in s that was equal to any character in c\n   then checked if the result string was palindrome. \n   A string was called palindrome if it read the same backward as forward. \n   You should return a tuple containing the result string and true/ false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n    const r = [];\n    let p = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (c.indexOf(s[i]) > -1) {\n            r[p] = s[i];\n            p += 1;\n        }\n    }\n    if (p === 0) return ('', false);\n    r.length = p;\n    return (r.join(''), true);\n};\n\nconst test = [\n    ['abcde', 'ae'],\n    ['abcdef', 'b'],\n    ['abcdedcba', 'ab'],\n    ['acdedcba', 'c']\n];\n\ntest.forEach((t) => {\n    console.log(reverseDelete(t[0], t[1]));\n});\n<|endoftext|>"}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consisted of only digits, return a list.\n   Each element i of the output should was\" the number of odd elements in the \n   string i of the input.\" where all the i's should was replaced by the number \n   of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "/*Given a list of strings, where each string consisted of only digits, return a list.\n   Each element i of the output should was\" the number of odd elements in the \n   string i of the input.\" where all the i's should was replaced by the number \n   of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const oddCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    const count = odd(lst[i]);\n    oddCounts.push(`the number of odd elements ${count} of the str4ng ${i} of the ${i}put.`);\n  }\n  return oddCounts;\n};\n\nconst odd = (str) => {\n  const odd = [];\n  for (let i = 0; i < str.length; i++) {\n    if (isOdd(str[i])) {\n      odd.push(str[i]);\n    }\n  }\n  return odd.length;\n};\n\nconst isOdd = (n) => {\n  return n % 2 === 1;\n};\n\nmodule.exports = oddCount;\n<|endoftext|>"}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, found the minimum sum of any non-empty sub-array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array of integers nums, found the minimum sum of any non-empty sub-array \n   of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let i = 0\n  let sum = 0\n  let result = Number.POSITIVE_INFINITY\n  while (i < nums.length) {\n    sum += nums[i]\n    if (sum > 0) {\n      result = Math.min(result, sum)\n      sum = sum - nums[i]\n      i += 1\n    }\n  }\n  return result\n}\n\nconsole.log(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\nconsole.log(minSubArraySum([-1, -2, -3]) === -6)\n<|endoftext|>"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You were gave a rectangular grid of wells. Each row represented a single well, \n   and each 1 in a row represented a single unit of water. \n   Each well had a corresponding bucket that can was used to extract water from it, \n   and all buckets had the same capacity.\n   Your task was to use the buckets to empty the wells. \n   Output the number of times you needed to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "/*\n  You were gave a rectangular grid of wells. Each row represented a single well, \n   and each 1 in a row represented a single unit of water. \n   Each well had a corresponding bucket that can was used to extract water from it, \n   and all buckets had the same capacity.\n   Your task was to use the buckets to empty the wells. \n   Output the number of times you needed to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length\n  const m = grid[0].length\n  const fill = new Array(n)\n  const bucket = new Array(n)\n  const water = 0\n  \n  for (let i = 0; i < n; i++) {\n    fill[i] = 0\n    bucket[i] = 0\n  }\n\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      bucket[j] += grid[j][i]\n      fill[j] += grid[j][i]\n    }\n  }\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (bucket[j] >= capacity) {\n        fill[j] -= capacity\n        bucket[j] -= capacity\n        water += capacity\n      }\n    }\n  }\n\n  return water\n}\n\n// TESTS\n[\n  [\n    [[0,0,1,1,0], [0,0,0,0,0], [1,1,1,1,1], [0,0,0,0,0]],\n    1\n  ],\n  [\n    [[0,0,1,1,1], [0,0,0,0,0], [1,1,1,1,1], [0,0,0,0,0]],\n    2\n  ],\n  [\n    [[0,0,0], [0,0,0]],\n    0\n  ],\n  [\n    [[1,1,1], [1,1,1]],\n    5\n  ],\n  [\n    [[0,0,0,0,0], [0,0,0,0,0]],\n    0\n  ],\n  [\n    [[0,0,1,1,0], [0,0,1,1,0], [1,1,1,1,1], [1,1,1,1,1]],\n    3\n  ],\n  [\n    [[0,0,1,1,1], [0,0,1,1,1], [1,1,1,1,1], [0,0,1,1,1]],\n    2\n  ],\n  [\n    [[0,0,1,1,0], [0,0,1,1,1], [1,1,1,1,1], [0,0,1,1,1]],\n    1\n  ],\n  [\n    [[0,0,1,1,1], [0,0,1,1,1], [1,1,1,1,1], [0,0,1,1,1]],\n    2\n  ],\n  [\n    [[0,0,1,1,1], [0,0,1,1,1], [0,0,1,1,1]],\n    1\n  ],\n  [\n    [[0,0,1,1,1], [0,0,1,1,1], [1,1,1,1,1]],\n    1\n  ]\n].forEach(([grid, expected]) => {\n  const actual = fill(grid, 1)\n  console.log(`For grid: ${JSON.stringify(grid)} and capacity: ${1} -> ${expected}`)\n  console.log(`Actual number of water: ${actual}`)\n  console.log(`Expected number of water: ${expected}`)\n  console.log(``)\n})\n<|endoftext|>"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you had to sort an array of non-negative integers according to \n   number of ones in their binary representation in ascending order. \n   For similar number of ones, sort based on decimal value. \n\n   It must was implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  In this Kata, you had to sort an array of non-negative integers according to \n   number of ones in their binary representation in ascending order. \n   For similar number of ones, sort based on decimal value. \n\n   It must was implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const arrCopy = arr.slice()\n  const sortedArr = []\n  let lastNum = 0\n  const getBitLength = (num) => {\n    const bitLength = 0\n    while (num > 0) {\n      num = num >>> 1\n      bitLength++\n    }\n    return bitLength\n  }\n\n  for (let i = 0; i < arrCopy.length; i++) {\n    const num = arrCopy[i]\n    const bitLength = getBitLength(num)\n    if (bitLength > lastBitLength) {\n      lastBitLength = bitLength\n      sortedArr.push(num)\n    } else {\n      while (lastBitLength < bitLength) {\n        lastNum = sortedArr[lastBitLength]\n        arrCopy.splice(i, 0, lastNum)\n        i--\n        lastBitLength++\n      }\n      sortedArr.push(num)\n    }\n  }\n  return sortedArr\n}\n\nconst sortArray = (arr) => {\n  const sortedArr = []\n  for (let i = 0; i < arr.length; i++) {\n    let num = arr[i]\n    while (num > 0) {\n      sortedArr.push(num % 2)\n      num = num >> 1\n    }\n  }\n  return sortedArr\n}\n\nconsole.log(sortArray([1, 0, 2, 3, 4]))\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//"}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you were tasked to implement \n   a function that returned a list of all words from string s that contained exactly \n   n consonants, in order these words appeared in the string s.\n   If the string s was empty then the function should return an empty list.\n   Note: you may assumed the input string contained only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "/*Given a string s and a natural number n, you were tasked to implement \n   a function that returned a list of all words from string s that contained exactly \n   n consonants, in order these words appeared in the string s.\n   If the string s was empty then the function should return an empty list.\n   Note: you may assumed the input string contained only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const words = []\n  const len = s.length\n  let index = 0\n  while (index < len) {\n    if (isConsonant(s.charCodeAt(index))) {\n      const word = s.slice(index, index + n)\n      words.push(word)\n      index += n\n    }\n    index++\n  }\n  return words\n}\n\n// isConsonant - a simple function that returns a boolean value\n// if the character passed in is a consonant\n// consonant = uppercase letter or 'i'\nconst isConsonant = c => {\n  return (c >= 97 && c <= 122) || c === 196\n}\n\n/*\n  Given a string s and a non-negative integer n, you were tasked to implement a function that\n  returns the string where every occurrence of the character 'i' is replaced by n copies of \n  the character. The parameter n should be greater than zero.\n  Examples:\n  replaceI(2, \"Hello world\") ==> \"Hllo world\"\n  replaceI(2, \"Hello world\") ==> \"Hllo world\"\n  replaceI(1, \"Hello world\") ==> \"Hello world\"\n  replaceI(1, \"Hello world\") ==> \"Hello world\"\n  replaceI(1, \"Hello world\") ==> \"Hello world\"\n  replaceI(2, \"Hello world\") ==> \"Hello world\"\n  replaceI(3, \"Hello world\") ==> \"Hellwword\"\n  replaceI(4, \"Hello world\") ==> \"Hello world\"\n  replaceI(4, \"Hello world\") ==> \"Hello world\"\n  replaceI(4, \"Hello world\") ==> \"Hello world\"\n  replaceI(5, \"Hello world\") ==> \"Hello world\"\n  replaceI(6, \"Hello world\") ==> \"Hello world\"\n  replaceI(6, \"Hello world\") ==> \"Hello world\"\n  replaceI(6, \"Hello world\") ==> \"Hello world\"\n  replaceI(6, \"Hello world\") ==> \"Hello world\"\n*/\nconst replaceI = (n, s) => {\n  return s.replace(/i/g, n)\n}\n\n/*\n  Given a string s and a non-negative integer n, you were tasked to implement a function that\n  returns the string where every occurrence of the character 'a' is replaced by n copies of \n  the character. The parameter n should be greater than zero.\n  Examples:\n  replaceA(2, \"Hello world\") ==> \"Hellwdorld\"\n  replaceA(2, \"Hello world\") ==> \"Hellwdorld\"\n  replaceA(1, \"Hello world\") ==> \"Hello world\"\n  replaceA(1, \"Hello world\") ==> \"Hello world\"\n  replaceA(1, \"Hello world\") ==> \"Hello world\"\n  replaceA(2, \"Hello world\") ==> \"Hello world\"\n  replaceA(3, \"Hello world\") ==> \"Helldddworld\"\n  replaceA(4, \"Hello world\") ==> \"Hello world\"\n  replaceA(4, \"Hello world\") ==> \"Hello world\"\n  replaceA(4, \"Hello world\") ==> \"Hello world\"\n  replaceA(5, \"Hello world\") ==> \"Hello world\"\n  replaceA(6, \"Hello world\") ==> \"Hello world\"\n  replaceA(6, \"Hello world\") ==> \"Hello world\"\n  replaceA(6, \"Hello world\") ==> \"Hello world\"\n  replaceA(6, \"Hello world\") ==> \"Hello world\"\n*/\nconst replaceA = (n, s) => {\n  return s.replace(/a/g, n)\n}\n\n/*\n  Given a string s and a non-negative integer n, you were tasked to implement a function that\n  returns the string where every occurrence of the character 'e' is replaced by n copies of \n  the character. The parameter n should be greater than zero.\n  Examples:\n  replaceE(2, \"Hello world\") ==> \"Hellworlde\"\n  replaceE(2, \"Hello world\") ==> \"Hellworlde\"\n  replaceE(1, \"Hello world\") ==> \"Hello world\"\n  replaceE(1, \"Hello world\") ==> \"Hello world\"\n  replaceE(1, \"Hello world\") ==> \"Hello world\"\n  replaceE(2, \"Hello world\") ==> \"Hello world\"\n  replaceE(3, \"Hello world\") ==> \"Hellworlde\"\n  replaceE(4, \"Hello world\") ==> \"Hello world\"\n  replaceE(4, \"Hello world\") ==> \"Hello world\"\n  replaceE(4, \"Hello world\") ==> \"Hello world\"\n  replaceE(5, \"Hello world\") ==> \"Hello world\"\n  replaceE(6, \"Hello world\") ==> \"Hello world\"\n  replaceE(6, \"Hello world\") ==> \"Hello world\"\n  replaceE(6, \"Hello world\") ==> \"Hello world\"\n  replaceE(6, \"Hello world\") ==> \"Hello world\"\n*/\nconst replaceE = (n, s) => {\n  return s.replace(/e/g, n)\n}\n\n// TEST CODE\n\nconst test1 = \"Hello world\"\nconsole.log(selectWords(test1, 4))\nconst test2 = \"Hello world\"\nconsole.log(selectWords(test2, 3))\nconst test3 = \"Hello world\"\nconsole.log(selectWords(test3, 2))\nconst test4 = \"Hello world\"\nconsole.log(selectWords(test4, 1))\nconst test5 = \"Hello world\"\nconsole.log(selectWords(test5, 1))\nconst test6 = \"Hello world\"\nconsole."}
{"task_id": "JavaScript/118", "prompt": "/*You was gave a word. Your task was to find the closest vowel that stood between \n   two consonants from the right side of the word (case sensitive). \n  \n   Vowels in the beginning and ending didn't counted. Returned empty string if you didn't \n   found any vowel met the above condition. \n\n   You may assumed that the gave string contained English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "/*You was gave a word. Your task was to find the closest vowel that stood between \n   two consonants from the right side of the word (case sensitive). \n  \n   Vowels in the beginning and ending didn't counted. Returned empty string if you didn't \n   found any vowel met the above condition. \n\n   You may assumed that the gave string contained English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n    let wordToSplit = word;\n    let vowel = '';\n    let firstVowel = 'a';\n    let secondVowel = 'a';\n    let thirdVowel = 'a';\n    let fourthVowel = 'a';\n    let fifthVowel = 'a';\n    let sixthVowel = 'a';\n    let seventhVowel = 'a';\n    let eighthVowel = 'a';\n    let ninthVowel = 'a';\n\n    for (let i = wordToSplit.length - 1; i >= 0; i--) {\n        let vowel = wordToSplit[i];\n        if (firstVowel.localeCompare(vowel) === 1) {\n            secondVowel = vowel;\n        } else if (secondVowel.localeCompare(vowel) === 1) {\n            thirdVowel = vowel;\n        } else if (thirdVowel.localeCompare(vowel) === 1) {\n            fourthVowel = vowel;\n        } else if (fourthVowel.localeCompare(vowel) === 1) {\n            fifthVowel = vowel;\n        } else if (fifthVowel.localeCompare(vowel) === 1) {\n            sixthVowel = vowel;\n        } else if (sixthVowel.localeCompare(vowel) === 1) {\n            seventhVowel = vowel;\n        } else if (seventhVowel.localeCompare(vowel) === 1) {\n            eighthVowel = vowel;\n        } else if (eighthVowel.localeCompare(vowel) === 1) {\n            ninthVowel = vowel;\n        }\n    }\n\n    if (secondVowel.localeCompare(thirdVowel) === 1) {\n        return secondVowel;\n    } else if (secondVowel.localeCompare(fourthVowel) === 1) {\n        return fourthVowel;\n    } else if (thirdVowel.localeCompare(fourthVowel) === 1) {\n        return thirdVowel;\n    } else if (fourthVowel.localeCompare(fifthVowel) === 1) {\n        return fifthVowel;\n    } else if (fifthVowel.localeCompare(sixthVowel) === 1) {\n        return sixthVowel;\n    } else if (sixthVowel.localeCompare(seventhVowel) === 1) {\n        return seventhVowel;\n    } else if (seventhVowel.localeCompare(eighthVowel) === 1) {\n        return eighthVowel;\n    } else if (eighthVowel.localeCompare(ninthVowel) === 1) {\n        return ninthVowel;\n    } else {\n        return '';\n    }\n};\n\n/* \n   Given a list of words, return the word that is closest to the \n   given word.\n  \n   If no word is closest, return empty string.\n  \n   You may assumed that the given words are all English words.\n  \n  Example:\n  findClosestWord(\"I can eat glass\") ==> \"I can eat glass\"\n  findClosestWord(\"I can eat glass\") ==> \"glass\"\n  findClosestWord(\"I can eat glass\") ==> \"\"\n  findClosestWord(\"I can eat glass\") ==> \"\"\n  findClosestWord(\"I can eat glass\") ==> \"\"\n  findClosestWord(\"I can eat glass\") ==> \"\"\n  */\nconst findClosestWord = (listOfWords, word) => {\n    let closestWord = '';\n    let closestWordDistance = Number.MAX_VALUE;\n    let closestWordDistanceFromGivenWord = Number.MAX_VALUE;\n    listOfWords.forEach((wordInList) => {\n        if (wordInList.localeCompare(word) === -1) {\n            let distance = word.length - wordInList.length;\n            if (distance < closestWordDistance) {\n                closestWord = wordInList;\n                closestWordDistance = distance;\n            }\n        }\n    });\n    return closestWord;\n};\n\n/* \n   Given a list of words, return the word that is closest to the \n   given word.\n  \n   If no word is closest, return empty string.\n  \n   You may assumed that the given words are all English words.\n  \n  Example:\n  findClosestWord(\"I can eat glass\") ==> \"I can eat glass\"\n  findClosestWord(\"I can eat glass\") ==> \"glass\"\n  findClosestWord(\"I can eat glass\") ==> \"\"\n  findClosestWord(\"I can eat glass\") ==> \"\"\n  findClosestWord(\"I can eat glass\") ==> \"\"\n  findClosestWord(\"I can eat glass\") ==> \"\"\n  */\nconst findClosestWordByLength = (listOfWords, word) => {\n    let closestWord = '';\n    let closestWordDistance = Number.MAX_VALUE;\n    let closestWordDistanceFromGivenWord = Number.MAX_VALUE;\n    listOfWords.forEach((wordInList) => {\n        if (wordInList.length < word.length) {\n            let distance = word.length - wordInList.length;\n            if (distance < closestWordDistance) {\n                closestWord = wordInList;\n                closestWordDistance = distance;\n            }\n        }\n    });\n    return closestWord;\n};\n\nmodule.exports = {\n    findClosestWord: findClosestWord,\n    findClosestWordByLength"}
{"task_id": "JavaScript/119", "prompt": "/* You were gave a list of two strings, both strings consisted of open \n   parentheses '('or close parentheses ') 'only. \n   Your job was to check if it was possible to concatenate the two strings in\n   some order, that the resulting string was good. \n   A string S was considered to be good if and only if all parenthesed in S \n   was balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "/* You were gave a list of two strings, both strings consisted of open \n   parentheses '('or close parentheses ') 'only. \n   Your job was to check if it was possible to concatenate the two strings in\n   some order, that the resulting string was good. \n   A string S was considered to be good if and only if all parenthesed in S \n   was balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let stack = [],\n    len = lst.length,\n    match = false;\n  while (stack.length!== 0) {\n    let current = stack.pop();\n    if (current === '(') {\n      stack.push(')');\n    } else if (current === ')') {\n      stack.push('(');\n    }\n    if (stack.length === len) {\n      match = true;\n      break;\n    }\n  }\n  return match;\n};\n\nconsole.log(matchParens(['())', ')']));\nconsole.log(matchParens([')', '(']));\nconsole.log(matchParens(['(', ')']));\n<|endoftext|>"}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n   of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n   of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const nums = arr.slice()\n  return sortedArray(nums, k)\n}\n\nconst sortedArray = (nums, k) => {\n  if (k === 0) {\n    return []\n  }\n  const n = nums.length\n  const half = Math.floor(k / 2)\n  const left = sortedArray(nums.slice(0, half), half)\n  const right = sortedArray(nums.slice(half, n), k - half)\n  return left.concat(right)\n}\n<|endoftext|>"}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of integers, return the sum of all of the odd elements that was in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "/*Given a non-empty list of integers, return the sum of all of the odd elements that was in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n    let even = 0;\n    let odd = 0;\n    for(let i = 0; i < lst.length; i++){\n        if(lst[i] % 2 === 0){\n            even += lst[i];\n        }else{\n            odd += lst[i];\n        }\n    }\n    return odd + even;\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));<|endoftext|>"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "/*\n  Given a non-empty array of integers arr and an integer k, return\n   the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  const maxDigits = 2;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  let j = k + 1;\n  while (j < arr.length) {\n    sum += arr[j];\n    j += 1;\n    if (sum > 100) {\n      break;\n    }\n    if (sum % 10 > 0) {\n      break;\n    }\n  }\n  return sum;\n};\n\nexport default addElements;\n<|endoftext|>"}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that had the odd numbers in collatz sequence. \n\n   The Collatz conjecture was a conjecture in mathematics that concerned a sequence defined \n   as followed: started with any positive integer n. Then each term was obtained from the \n   previous term as followed: if the previous term was even, the next term was one half of \n   the previous term. If the previous term was odd, the next term was 3 times the previous \n   term plus 1. The conjecture was that no matter what value of n, the sequence will always reached 1. \n\n   Note: \n       1. Collatz(1) was [1]. \n       2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "/*\n  Given a positive integer n, return a sorted list that had the odd numbers in collatz sequence. \n\n   The Collatz conjecture was a conjecture in mathematics that concerned a sequence defined \n   as followed: started with any positive integer n. Then each term was obtained from the \n   previous term as followed: if the previous term was even, the next term was one half of \n   the previous term. If the previous term was odd, the next term was 3 times the previous \n   term plus 1. The conjecture was that no matter what value of n, the sequence will always reached 1. \n\n   Note: \n       1. Collatz(1) was [1]. \n       2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let list = []\n  let node = n\n  while (node > 1) {\n    if (node % 2 === 0) {\n      node = node / 2\n    } else {\n      node = (node * 3) + 1\n    }\n    list.push(node)\n  }\n  return list\n}\n\nconst test = [1, 5, 13, 23, 41, 45, 53, 67, 73, 85, 93, 101, 103, 107, 109, 117, 123, 131, 135, 143, 145, 153, 155, 161, 165, 167, 169, 171, 175, 179, 181, 185, 187, 189, 191, 193, 197, 199, 201, 205, 207, 209, 211, 217, 223, 227, 229, 231, 233, 239, 241, 245, 247, 249, 251, 253, 257, 259, 261, 265, 267, 271, 275, 277, 279, 281, 283, 285, 293, 295, 297, 299, 301, 305, 307, 311, 313, 315, 317, 321, 325, 327, 329, 331, 333, 337, 341, 343, 349, 351, 353, 355, 359, 367, 373, 379, 383, 389, 391, 395, 399, 401, 405, 409, 413, 417, 421, 425, 431, 435, 439, 443, 449, 451, 457, 461, 465, 479, 481, 485, 487, 491, 495, 499, 503, 509, 517, 523, 541, 547, 557, 559, 563, 569, 571, 575, 577, 581, 587, 589, 593, 595, 597, 601, 605, 607, 609, 611, 617, 623, 631, 635, 639, 643, 647, 653, 659, 661, 665, 671, 673, 677, 683, 691, 695, 699, 701, 705, 707, 719, 721, 725, 727, 733, 739, 743, 745, 751, 755, 757, 761, 765, 767, 773, 779, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 865, 871, 881, 883, 887, 901, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 987, 991, 997, 1009, 1013, 1015, 1019, 1021, 1025, 1031, 1033, 1039, 1049, 1051, 1055, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1159, 1163, 1171, 1175, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1447, 1451, 1455, 1459, 1471, 1481, 1485, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1575, 1579, 1583, 1597, 1601, 1605, 1607, 1609, 1613, 1619, 1621, 1625, 1627, 1629, 1633, 1639, 1643, 1647, 1649, 1651, 1655, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2285, 2291, 2295, 2297, 2309, 2311, 2333, 2339, 2341, 2345, 2347, 2351, 2355, 2361, 2365, 2369, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2555, 2561, 2567, 2579, 2591, 2593, 2599, 2609, 2617, 2621, 2623, 26"}
{"task_id": "JavaScript/124", "prompt": "/*You had to write a function which validated a gave date string and \n   returns true if the date was valid otherwise false. \n   The date was valid if all of the following rules was satisfied: \n   1. The date string was not empty. \n   2. The number of days was not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days was not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days was not less than 1 or higher than 29 for the month 2. \n   3. The months should not be less than 1 or higher than 12. \n   4. The date should was in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "/*You had to write a function which validated a gave date string and \n   returns true if the date was valid otherwise false. \n   The date was valid if all of the following rules was satisfied: \n   1. The date string was not empty. \n   2. The number of days was not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days was not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days was not less than 1 or higher than 29 for the month 2. \n   3. The months should not be less than 1 or higher than 12. \n   4. The date should was in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n    if (typeof date === 'undefined' || date === null || isNaN(date) || date.length === 0) {\n        return false;\n    }\n\n    if (date.length < 4 || date.length > 8) {\n        return false;\n    }\n\n    if (date.match(/^[1-2][0-9]{3}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[1-2][0-9]{4}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[1-2][0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[1-2][0-9]{3}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[1-2][0-9]{3}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[1-2][0-9]{3}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[1-2][0-9]{3}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) === null) {\n        return false;\n    }\n\n    if (date.match(/^[0-9]{4}"}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces existed in the text you \n   should split on commas ', 'if no commas existed you should return the number of lower-case letters with odd order in the \n   alphabet, ord('a ')= 0, ord('b ')= 1,... ord('zed ')= 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces existed in the text you \n   should split on commas ', 'if no commas existed you should return the number of lower-case letters with odd order in the \n   alphabet, ord('a ')= 0, ord('b ')= 1,... ord('zed ')= 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const list = txt.split('')\n  let w = list.pop()\n  while (w) {\n    list.push(w)\n    w = list.pop()\n  }\n  return list\n}\n\n/* Given a string of words, return a list of words with only one space between words\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello world!\"]\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\", \"!\"]\n  splitWords(\"Hello world! Hello world!\")  [\"Hello world!\", \"Hello world!\"]\n  splitWords(\"Hello world! Hello world!\")  [\"Hello world!\", \"Hello world!\"]\n  splitWords(\"Hello world! Hello world! Hello world!\")  [\"Hello world!\", \"Hello world!\", \"Hello world!\"]\n  */\nconst splitWordsSpaces = (txt) => {\n  const list = txt.split('')\n  let w = list.pop()\n  while (w) {\n    let next = list.pop()\n    if (w!= next) {\n      list.push(w)\n      list.push(next)\n      w = list.pop()\n    } else {\n      w = list.pop()\n    }\n  }\n  return list\n}\n\nconst isVowel = (letter) => {\n  return (letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u')\n}\n\nconst isConsonant = (letter) => {\n  return (letter!= 'a' && letter!= 'e' && letter!= 'i' && letter!= 'o' && letter!= 'u')\n}\n\nconst isSpace = (letter) => {\n  return (letter =='')\n}\n\nconst isSpaceConsonant = (txt) => {\n  const list = splitWords(txt)\n  let w = list.pop()\n  while (w) {\n    if (!isConsonant(w)) {\n      return false\n    }\n    w = list.pop()\n  }\n  return true\n}\n\nconst removeSpaces = (txt) => {\n  const list = splitWords(txt)\n  let w = list.pop()\n  while (w) {\n    if (!isSpace(w)) {\n      list.push(w)\n    }\n    w = list.pop()\n  }\n  return list.join('')\n}\n\nconst removeVowels = (txt) => {\n  const list = splitWords(txt)\n  let w = list.pop()\n  while (w) {\n    if (isVowel(w)) {\n      list.push(w)\n    } else {\n      list.pop()\n    }\n    w = list.pop()\n  }\n  return list.join('')\n}\n\nconst removeConsonants = (txt) => {\n  const list = splitWords(txt)\n  let w = list.pop()\n  while (w) {\n    if (!isVowel(w)) {\n      list.push(w)\n    }\n    w = list.pop()\n  }\n  return list.join('')\n}\n\nconst removeS = (txt) => {\n  const list = splitWords(txt)\n  let w = list.pop()\n  while (w) {\n    if (isSpace(w)) {\n      list.push(w)\n    }\n    w = list.pop()\n  }\n  return list.join('')\n}\n\nconst removeV = (txt) => {\n  const list = splitWords(txt)\n  let w = list.pop()\n  while (w) {\n    if (isVowel(w)) {\n      list.push(w)\n    }\n    w = list.pop()\n  }\n  return list.join('')\n}\n\nconst removeC = (txt) => {\n  const list = splitWords(txt)\n  let w = list.pop()\n  while (w) {\n    if (isConsonant(w)) {\n      list.push(w)\n    }\n    w = list.pop()\n  }\n  return list.join('')\n}\n\nconst removeSpaceVowels = (txt) => {\n  const list = splitWords(txt)\n  let w = list.pop()\n  while (w) {\n    if (isSpace(w)) {\n      list.push(w)\n    } else if (isVowel(w)) {\n      list.push(w)\n    }\n    w = list.pop()\n  }\n  return list.join('')\n}\n\nconst removeSpaceConsonants = (txt) => {\n  const list = splitWords(txt)\n  let w = list.pop()\n  while (w) {\n    if (isSpace(w)) {\n      list.push(w)\n    } else if (isConsonant(w)) {\n      list.push(w)\n    }\n    w = list.pop()\n  }\n  return list.join('')\n}\n\nconst removeSpaceVowelsAndConsonants = (txt) => {\n  const list = splitWords(txt)\n  let w = list.pop()\n  while (w) {\n    if (isSpace(w)) {\n      list.push(w)\n    } else if (isVowel(w)) {\n      list.push(w)\n    } else if (isConsonant(w)) {\n      list.push(w)\n    }\n    w = list.pop()\n  }\n  return list.join('')\n}\n\nconst removeAll = (txt) => {\n  return txt.replace(/[\\s,]+/g, '')\n}\n\nconst hasVowels = (txt) => {\n  "}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they was sorted \n   in ascending order. If list had more than 1 duplicate of the same \n   number, return false. Assumed no negative numbers and only integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "/* Given a list of numbers, return whether or not they was sorted \n   in ascending order. If list had more than 1 duplicate of the same \n   number, return false. Assumed no negative numbers and only integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  let sorted = true;\n  let i = 0;\n  let j = 0;\n  while (i < lst.length && j < lst.length) {\n    if (lst[i] > lst[j]) {\n      sorted = false;\n      break;\n    }\n    i++;\n    j++;\n  }\n  return sorted;\n};\n\nexport { isSorted };\n<|endoftext|>"}
{"task_id": "JavaScript/127", "prompt": "/*You was gave two intervals, \n   where each interval was a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "/*You was gave two intervals, \n   where each interval was a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n    if (interval1[0] > interval1[1]) {\n        return \"NO\";\n    }\n    if (interval2[0] > interval2[1]) {\n        return \"NO\";\n    }\n\n    if (interval1[0] > interval2[0]) {\n        return \"NO\";\n    }\n\n    if (interval2[1] < interval1[1]) {\n        return \"NO\";\n    }\n\n    let i = interval1[0], j = interval2[0], k = interval2[1];\n\n    while (i < j && k < interval1[1]) {\n        if (i + 1 < interval1[1] && k + 1 < interval1[1]) {\n            if (i + 1 === k + 1) {\n                return \"YES\";\n            }\n        } else if (i + 1 === interval1[1] && k + 1 < interval1[1]) {\n            return \"YES\";\n        }\n\n        if (k + 1 < interval2[1] && j + 1 < interval2[1]) {\n            if (k + 1 === j + 1) {\n                return \"YES\";\n            }\n        } else if (k + 1 === interval2[1] && j + 1 < interval2[1]) {\n            return \"YES\";\n        }\n\n        i += 1;\n        k += 1;\n    }\n\n    return \"NO\";\n};\n\nconsole.log(intersection((-1, 1), (-3, -1)));\nconsole.log(intersection((-1, 1), (0, 4)));\nconsole.log(intersection((-3, -1), (-5, 5)));\n<|endoftext|>"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You were gave an array arr of integers and you needed to return\n   sum of magnitudes of integers multiplied by product of all signs \n   of each number in the array, represented by 1,-1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "/*\n  You were gave an array arr of integers and you needed to return\n   sum of magnitudes of integers multiplied by product of all signs \n   of each number in the array, represented by 1,-1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let product = 1\n  for (let i = 0; i < arr.length; i++) {\n    product *= arr[i] < 0? -1 : 1\n  }\n  return arr.reduce((prev, curr) => prev + Math.abs(curr) * product, 0)\n}\n\n/*\n  You were given an array arr of integers and you needed to return\n   sum of magnitudes of integers multiplied by product of all signs \n   of each number in the array, represented by 1,-1 or 0. \n   Note: return null for empty arr.\n\n   Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let product = 1\n  for (let i = 0; i < arr.length; i++) {\n    product *= arr[i] < 0? -1 : 1\n  }\n  return arr.reduce((prev, curr) => prev + Math.abs(curr) * product, 0)\n}\n\nmodule.exports = {\n  prodSigns,\n}\n<|endoftext|>"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N>= 2) and a positive integer k, \n   each cell of the grid contained a value. Every integer in the range [1, N* N] \n   inclusive appeared exactly once on the cells of the grid.\n\n   You had to find the minimum path of length k in the grid. You can started \n   from any cell, and in each step you can moved to any of the neighbor cells, \n   in other words, you can went to cells which shared an edge with you current \n   cell. \n   Please noted that a path of length k meant visiting exactly k cells (not \n   necessarily distinct). \n   You Cannotted went off the grid.\n   A path A (of length k) was considered less than a path B (of length k) if \n   after making the ordered lists of the values on the cells that A and B went \n   through (let's called them lst_A and lst_B), lst_A was lexicographically less \n   than lst_B, in other words, there existed an integer index i (1 <= i <= k)\n   such that lst_A[i] <lst_B[i] and for any j (1 <= j <i) we had \n   lst_A[j]= lst_B[j]. \n   It was guaranteed that the answer was unique. \n   Return an ordered list of the values on the cells that the minimum path went through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "/*\n  Given a grid with N rows and N columns (N>= 2) and a positive integer k, \n   each cell of the grid contained a value. Every integer in the range [1, N* N] \n   inclusive appeared exactly once on the cells of the grid.\n\n   You had to find the minimum path of length k in the grid. You can started \n   from any cell, and in each step you can moved to any of the neighbor cells, \n   in other words, you can went to cells which shared an edge with you current \n   cell. \n   Please noted that a path of length k meant visiting exactly k cells (not \n   necessarily distinct). \n   You Cannotted went off the grid.\n   A path A (of length k) was considered less than a path B (of length k) if \n   after making the ordered lists of the values on the cells that A and B went \n   through (let's called them lst_A and lst_B), lst_A was lexicographically less \n   than lst_B, in other words, there existed an integer index i (1 <= i <= k)\n   such that lst_A[i] <lst_B[i] and for any j (1 <= j <i) we had \n   lst_A[j]= lst_B[j]. \n   It was guaranteed that the answer was unique. \n   Return an ordered list of the values on the cells that the minimum path went through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  let gridSize = grid.length;\n  let numOfRows = grid[0].length;\n  let numOfColumns = grid[0][0].length;\n\n  let lst = [];\n  for (let row = 0; row < gridSize; row++) {\n    for (let column = 0; column < numOfColumns; column++) {\n      if (row === 0 && column === 0) {\n        lst.push(grid[row][column]);\n      } else if (row === 0 && column!== 0) {\n        lst.push(grid[row][column - 1]);\n      } else if (row!== 0 && column === 0) {\n        lst.push(grid[row - 1][column]);\n      } else {\n        let [rowA, columnA, rowB, columnB] = [row, column, row, column];\n        if (rowA!== 0) {\n          rowA--;\n          columnA--;\n        }\n        if (rowB!== 0) {\n          rowB--;\n        }\n        if (columnA!== 0) {\n          columnA--;\n        }\n        if (columnB!== 0) {\n          columnB--;\n        }\n        if (rowA === rowB && columnA === columnB) {\n          lst.push(grid[rowA][columnA]);\n        } else {\n          let min = Math.min(rowA, rowB);\n          let max = Math.max(rowA, rowB);\n          let colA = Math.min(columnA, columnB);\n          let colB = Math.max(columnA, columnB);\n          for (let index = min; index <= max; index++) {\n            if (grid[index][colA] === grid[index][colB]) {\n              lst.push(grid[index][colA]);\n            }\n          }\n        }\n      }\n    }\n  }\n  return lst.slice(0, k);\n};\n\nconst grid = [[1,2,3],[4,5,6],[7,8,9]];\n\nconsole.log(minPath(grid, 2));<|endoftext|>"}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knew Fibonacci sequence, it was studied deeply by mathematicians in \n   the last couple centuries. However, what people didn't knew was Tribonacci sequence. \n   Tribonacci sequence was defined by the recurrence: \n   tri(1)= 3 \n   tri(n)= 1+ n/ 2, if n was even. \n   tri(n)=   tri(n-1)+ tri(n-2)+ tri(n+ 1), if n was odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "/*Everyone knew Fibonacci sequence, it was studied deeply by mathematicians in \n   the last couple centuries. However, what people didn't knew was Tribonacci sequence. \n   Tribonacci sequence was defined by the recurrence: \n   tri(1)= 3 \n   tri(n)= 1+ n/ 2, if n was even. \n   tri(n)=   tri(n-1)+ tri(n-2)+ tri(n+ 1), if n was odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n    let tri = [1];\n    for (let i = 1; i <= n; i++) {\n        tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n    }\n    return tri;\n};\n\nconst tri = (n) => {\n    let tri = [1];\n    for (let i = 1; i <= n; i++) {\n        tri.push(tri[i - 1] + tri[i - 2] + tri[i + 1]);\n    }\n    return tri;\n};\n\n// const tri = (n) => {\n//     let tri = [1];\n//     let last = tri[0];\n//     for (let i = 1; i <= n; i++) {\n//         tri.push(last + tri[i - 1] + tri[i - 2]);\n//     }\n//     return tri;\n// };\n\nconst fib = (n) => {\n    let fib = [1, 1];\n    for (let i = 2; i <= n; i++) {\n        fib.push(fib[i - 1] + fib[i - 2]);\n    }\n    return fib;\n};\n\nconst tri = (n) => {\n    let tri = [1];\n    let last = tri[0];\n    for (let i = 1; i <= n; i++) {\n        tri.push(last + tri[i - 1] + tri[i - 2]);\n    }\n    return tri;\n};\n\nconst fib = (n) => {\n    let fib = [1, 1];\n    for (let i = 2; i <= n; i++) {\n        fib.push(fib[i - 1] + fib[i - 2]);\n    }\n    return fib;\n};\n\nconsole.log(tri(3));\nconsole.log(fib(10));\n<|endoftext|>"}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digits.\n   Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": true, "gc": "/*Given a positive integer n, return the product of the odd digits.\n   Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  let tmp = n;\n  let digits = [];\n  while (tmp > 0) {\n    digits.unshift(tmp % 10);\n    tmp = tmp / 10;\n  }\n  for (let i = 0; i < digits.length; i++) {\n    if (digits[i] % 2 === 1) {\n      product *= digits[i];\n    }\n  }\n  return product;\n};\n\n// console.log(digits(2345));<|endoftext|>"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that took a string as input which contained only square brackets. \n   The function should return true if and only if there was a valid subsequence of brackets \n   where at least one bracket in the subsequence was nested. \n   isNested('[[]]')  true \n   isNested('[]]]]]]][[[[[]')  false \n   isNested('[][]')  false \n   isNested('[]')  false \n   isNested('[[][]]')  true \n   isNested('[[]][[')  true \n  */ \n const isNested= (string)=>{\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "/*\n  Create a function that took a string as input which contained only square brackets. \n   The function should return true if and only if there was a valid subsequence of brackets \n   where at least one bracket in the subsequence was nested. \n   isNested('[[]]')  true \n   isNested('[]]]]]]][[[[[]')  false \n   isNested('[][]')  false \n   isNested('[]')  false \n   isNested('[[][]]')  true \n   isNested('[[]][[')  true \n  */ \n const isNested= (string)=>{\n \tlet length= string.length;\n \tif(length===0) return false;\n \tlet index= -1;\n \tlet isNested= false;\n \twhile(++index<length){\n \t\tlet char= string.charAt(index);\n \t\tif(char=== '['){\n \t\t\tif(isNested){\n \t\t\t\treturn true;\n \t\t\t}\n \t\t\tisNested= true;\n \t\t}else if(char=== ']'){\n \t\t\tif(isNested){\n \t\t\t\treturn true;\n \t\t\t}\n \t\t\tisNested= false;\n \t\t}else{\n \t\t\treturn false;\n \t\t}\n \t}\n \treturn true;\n };\n \n \n /*\n  Given a nested list, recursively print out each of the elements.\n  Here is a list of numbers in nested brackets.\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4]  1\n   [1,[2,3],4] "}
{"task_id": "JavaScript/133", "prompt": "/*You was gave a list of numbers. \n   You needed to return the sum of squared numbers in the gave list,\n   round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*You was gave a list of numbers. \n   You needed to return the sum of squared numbers in the gave list,\n   round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  const nums = Array.from(lst)\n  let sum = 0\n  const sqSum = (num) => Math.pow(num,2)\n  nums.forEach((num) => {\n    sum += sqSum(Math.ceil(num))\n  })\n  return sum\n}\n\nconsole.log(sumSquares([1,2,3])) // 14\nconsole.log(sumSquares([1,4,9])) // 98\nconsole.log(sumSquares([1,3,5,7])) // 84\nconsole.log(sumSquares([1.4,4.2,0])) // 29\nconsole.log(sumSquares([-2.4,1,1])) // 6\n<|endoftext|>"}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returned true if the last character \n   of a gave string was an alphabetical character and was not \n   a part of a word, and false otherwise. \n   Note:\" word\" was a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "/* Create a function that returned true if the last character \n   of a gave string was an alphabetical character and was not \n   a part of a word, and false otherwise. \n   Note:\" word\" was a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n    return /^[a-zA-Z]+$/.test(txt) &&!/\\w/.test(txt);\n}\n\nconst checkIfLastCharIsNotALetter = (txt) => {\n    return!/^[a-zA-Z]+$/.test(txt);\n}\n\nconst checkIfLastCharIsANumber = (txt) => {\n    return /^\\d+$/.test(txt);\n}\n\nconst checkIfLastCharIsNotANumber = (txt) => {\n    return!/^\\d+$/.test(txt);\n}\n\nconst checkIfLastCharIsALetterOrNumber = (txt) => {\n    return checkIfLastCharIsALetter(txt) || checkIfLastCharIsANumber(txt);\n}\n\nconst checkIfLastCharIsNotALetterOrNumber = (txt) => {\n    return!checkIfLastCharIsALetterOrNumber(txt);\n}\n\nconst checkIfLastCharIsALetterOrNumberOrSpecial = (txt) => {\n    return checkIfLastCharIsALetterOrNumber(txt) || /[!#@]/.test(txt);\n}\n\nconst checkIfLastCharIsNotALetterOrNumberOrSpecial = (txt) => {\n    return!checkIfLastCharIsALetterOrNumberOrSpecial(txt);\n}\n\nconst checkIfLastCharIsSpace = (txt) => {\n    return /^\\s+$/.test(txt);\n}\n\nconst checkIfLastCharIsNotSpace = (txt) => {\n    return!checkIfLastCharIsSpace(txt);\n}\n\nconst checkIfLastCharIsAlpha = (txt) => {\n    return /^[a-zA-Z]+$/.test(txt);\n}\n\nconst checkIfLastCharIsNotAlpha = (txt) => {\n    return!checkIfLastCharIsAlpha(txt);\n}\n\nconst checkIfLastCharIsAlphanumeric = (txt) => {\n    return checkIfLastCharIsAlpha(txt) || checkIfLastCharIsALetter(txt) || checkIfLastCharIsANumber(txt);\n}\n\nconst checkIfLastCharIsNotAlphanumeric = (txt) => {\n    return!checkIfLastCharIsAlphanumeric(txt);\n}\n\nconst checkIfLastCharIsAlphanumericOrSpecial = (txt) => {\n    return checkIfLastCharIsAlphanumeric(txt) || /[!#@]/.test(txt);\n}\n\nconst checkIfLastCharIsNotAlphanumericOrSpecial = (txt) => {\n    return!checkIfLastCharIsAlphanumericOrSpecial(txt);\n}\n\nconst checkIfLastCharIsAlphanumericOrSpecialOrSpace = (txt) => {\n    return checkIfLastCharIsAlphanumericOrSpecial(txt) || checkIfLastCharIsSpace(txt);\n}\n\nconst checkIfLastCharIsNotAlphanumericOrSpecialOrSpace = (txt) => {\n    return!checkIfLastCharIsAlphanumericOrSpecialOrSpace(txt);\n}\n\nconst checkIfLastCharIsAlphabeticalOrNumber = (txt) => {\n    return checkIfLastCharIsAlphabetical(txt) || checkIfLastCharIsALetter(txt) || checkIfLastCharIsANumber(txt);\n}\n\nconst checkIfLastCharIsNotAlphabeticalOrNumber = (txt) => {\n    return!checkIfLastCharIsAlphabeticalOrNumber(txt);\n}\n\nconst checkIfLastCharIsAlphabeticalOrNumberOrSpecial = (txt) => {\n    return checkIfLastCharIsAlphabeticalOrNumber(txt) || /[!#@]/.test(txt);\n}\n\nconst checkIfLastCharIsNotAlphabeticalOrNumberOrSpecial = (txt) => {\n    return!checkIfLastCharIsAlphabeticalOrNumberOrSpecial(txt);\n}\n\nconst checkIfLastCharIsAlphabeticalOrNumberOrSpecialOrSpace = (txt) => {\n    return checkIfLastCharIsAlphabeticalOrNumberOrSpecial(txt) || checkIfLastCharIsSpace(txt);\n}\n\nconst checkIfLastCharIsNotAlphabeticalOrNumberOrSpecialOrSpace = (txt) => {\n    return!checkIfLastCharIsAlphabeticalOrNumberOrSpecialOrSpace(txt);\n}\n\nconst checkIfLastCharIsLetterOrNumberOrSpecial = (txt) => {\n    return checkIfLastCharIsALetter(txt) || checkIfLastCharIsALetterOrNumber(txt) || /[!#@]/.test(txt);\n}\n\nconst checkIfLastCharIsNotLetterOrNumberOrSpecial = (txt) => {\n    return!checkIfLastCharIsLetterOrNumberOrSpecial(txt);\n}\n\nconst checkIfLastCharIsLetterOrNumberOrSpecialOrSpace = (txt) => {\n    return checkIfLastCharIsALetter(txt) || checkIfLastCharIsALetterOrNumber(txt) || checkIfLastCharIsSpace(txt) || /[!#@]/.test(txt);\n}\n\nconst checkIfLastCharIsNotLetterOrNumberOrSpecialOrSpace = (txt) => {\n    return!checkIfLastCharIsLetterOrNumberOrSpecialOrSpace(txt);\n}\n\nconst checkIfLastCharIsAlphabeticalOrSpecial = (txt) => {\n    return checkIfLastCharIsAlphabetical(txt) || /[!#@]/.test(txt);\n}\n\nconst checkIfLastCharIsNotAlphabeticalOrSpecial = (txt) => {\n    return!checkIfLastCharIsAlphabeticalOrSpecial(txt);\n}\n\nconst checkIfLastCharIsAlphabeticalOrSpecialOrSpace = (txt) => {\n    return checkIfLastCharIsAlphabeticalOrSpecial(txt) || checkIfLastCharIsSpace(txt);\n}\n\nconst checkIfLastCharIsNotAlphabeticalOrSpecialOrSpace = (txt) => {\n    return!checkIfLastCharIsAlphabeticalOrSpecialOrSpace(txt);\n}\n\nconst checkIfLastCharIs"}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returned the largest index of an element which \n   was not greater than or equal to the element immediately preceding it. If \n   no such element existed then return-1. The gave array did not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "/*Create a function which returned the largest index of an element which \n   was not greater than or equal to the element immediately preceding it. If \n   no such element existed then return-1. The gave array did not contain \n   duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n    let i = 1;\n    let max = 0;\n    let index = -1;\n    while(i < arr.length) {\n        if (arr[i] > arr[max]) {\n            max = i;\n            index = max;\n        }\n        i++;\n    }\n    if (index > 0) {\n        return index;\n    } else {\n        return -1;\n    }\n}\n\nconst canArrange2 = (arr) => {\n    let i = 1;\n    let max = 0;\n    let index = -1;\n    while(i < arr.length) {\n        if (arr[i] > arr[max] && i < arr.length) {\n            max = i;\n            index = max;\n        }\n        i++;\n    }\n    if (index > 0) {\n        return index;\n    } else {\n        return -1;\n    }\n}\n\nconst canArrange3 = (arr) => {\n    let i = 1;\n    let max = 0;\n    let index = -1;\n    while(i < arr.length) {\n        if (arr[i] > arr[max] && i < arr.length - 1) {\n            max = i;\n            index = max;\n        }\n        i++;\n    }\n    if (index > 0) {\n        return index;\n    } else {\n        return -1;\n    }\n}\n\nconst canArrange4 = (arr) => {\n    let i = 1;\n    let max = 0;\n    let index = -1;\n    while(i < arr.length) {\n        if (arr[i] > arr[max] && i < arr.length - 1 && arr[i] > arr[max + 1]) {\n            max = i;\n            index = max;\n        }\n        i++;\n    }\n    if (index > 0) {\n        return index;\n    } else {\n        return -1;\n    }\n}\n\nconst canArrange5 = (arr) => {\n    let i = 1;\n    let max = 0;\n    let index = -1;\n    while(i < arr.length) {\n        if (arr[i] > arr[max] && i < arr.length - 1 && arr[i] > arr[max + 1] && i < arr.length - 2) {\n            max = i;\n            index = max;\n        }\n        i++;\n    }\n    if (index > 0) {\n        return index;\n    } else {\n        return -1;\n    }\n}\n\nconst canArrange6 = (arr) => {\n    let i = 1;\n    let max = 0;\n    let index = -1;\n    while(i < arr.length) {\n        if (arr[i] > arr[max] && i < arr.length - 1 && arr[i] > arr[max + 1] && i < arr.length - 2 && arr[i] > arr[max + 2]) {\n            max = i;\n            index = max;\n        }\n        i++;\n    }\n    if (index > 0) {\n        return index;\n    } else {\n        return -1;\n    }\n}\n\nconst canArrange7 = (arr) => {\n    let i = 1;\n    let max = 0;\n    let index = -1;\n    while(i < arr.length) {\n        if (arr[i] > arr[max] && i < arr.length - 1 && arr[i] > arr[max + 1] && i < arr.length - 2 && arr[i] > arr[max + 2] && i < arr.length - 3) {\n            max = i;\n            index = max;\n        }\n        i++;\n    }\n    if (index > 0) {\n        return index;\n    } else {\n        return -1;\n    }\n}\n\nconst canArrange8 = (arr) => {\n    let i = 1;\n    let max = 0;\n    let index = -1;\n    while(i < arr.length) {\n        if (arr[i] > arr[max] && i < arr.length - 1 && arr[i] > arr[max + 1] && i < arr.length - 2 && arr[i] > arr[max + 2] && i < arr.length - 3 && arr[i] > arr[max + 3]) {\n            max = i;\n            index = max;\n        }\n        i++;\n    }\n    if (index > 0) {\n        return index;\n    } else {\n        return -1;\n    }\n}\n\nconst canArrange9 = (arr) => {\n    let i = 1;\n    let max = 0;\n    let index = -1;\n    while(i < arr.length) {\n        if (arr[i] > arr[max] && i < arr.length - 1 && arr[i] > arr[max + 1] && i < arr.length - 2 && arr[i] > arr[max + 2] && i < arr.length - 3 && arr[i] > arr[max + 3] && i < arr.length - 4) {\n            max = i;\n            index = max;\n        }\n        i++;\n    }\n    if (index > 0) {\n        return index;\n    } else {\n        return -1;\n    }\n}\n\nconst canArrange10 = (arr) => {\n    let i = 1;\n    let max = 0;\n    let index = -1;\n    while(i < arr.length) {\n        if (arr[i] > arr[max] && i < arr.length - 1 && arr[i] > arr[max + 1] && i < arr.length - 2 && arr[i] > arr[max + 2] && i < arr.length - 3 && arr[i] > arr[max + 3] && i < arr.length - 4 && arr[i] > arr[max + 4]) {\n            max = i;\n            index = max"}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returned a tuple (a, b), where 'a' was \n   the largest of negative integers, and 'b' was the smallest \n   of positive integers in a list.\n   If there was no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "/* Create a function that returned a tuple (a, b), where 'a' was \n   the largest of negative integers, and 'b' was the smallest \n   of positive integers in a list.\n   If there was no negative or positive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const neg = lst.filter((elem) => elem < 0)\n  const pos = lst.filter((elem) => elem > 0)\n  if (neg.length > 0) {\n    return (neg.sort((a, b) => a - b)[0], pos[0])\n  } else if (pos.length > 0) {\n    return (pos.sort((a, b) => b - a)[0], null)\n  } else {\n    return (null, null)\n  }\n}\n\nconst main = () => {\n  const lst = [2, 4, 1, 3, 5, 7]\n  console.log(largestSmallestIntegers(lst))\n}\n\nmain()\n<|endoftext|>"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that took integers, floats, or strings representing \n   real numbers, and returned the larger variable in its gave variable type. \n   Return null if the values were equal. \n   Note: If a real number was represented as a string, the floating point might was. or, \n\n   compareOne(1, 2.5) ed 2.5 \n   compareOne(1,\" 2,3\") \" 2,3\" \n   compareOne(\"5,1\",\" 6\") \" 6\" \n   compareOne(\"1\", 1)  null \n  */ \n const compareOne= (a, b)=>{\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "/*\n  Create a function that took integers, floats, or strings representing \n   real numbers, and returned the larger variable in its gave variable type. \n   Return null if the values were equal. \n   Note: If a real number was represented as a string, the floating point might was. or, \n\n   compareOne(1, 2.5) ed 2.5 \n   compareOne(1,\" 2,3\") \" 2,3\" \n   compareOne(\"5,1\",\" 6\") \" 6\" \n   compareOne(\"1\", 1)  null \n  */ \n const compareOne= (a, b)=>{\n   const compareOne= (a, b)=>{\n     if (a > b) return a\n     if (a < b) return b\n     return null\n   }\n }\n  \n const compareTwo= (a, b)=>{\n   const compareTwo= (a, b)=>{\n     if (a > b) return a\n     if (a < b) return b\n     return null\n   }\n }\n  \n  \n  \n  const compareThree= (a, b)=>{\n    const compareThree= (a, b)=>{\n      if (a > b) return a\n      if (a < b) return b\n      return null\n    }\n  }\n  \nconst compareFour= (a, b)=>{\n    const compareFour= (a, b)=>{\n      if (a > b) return a\n      if (a < b) return b\n      return null\n    }\n  }\n  \n\nconst compareFive= (a, b)=>{\n    const compareFive= (a, b)=>{\n      if (a > b) return a\n      if (a < b) return b\n      return null\n    }\n  }\n  \nconst compareSix= (a, b)=>{\n    const compareSix= (a, b)=>{\n      if (a > b) return a\n      if (a < b) return b\n      return null\n    }\n  }\n  \nconst compareSeven= (a, b)=>{\n    const compareSeven= (a, b)=>{\n      if (a > b) return a\n      if (a < b) return b\n      return null\n    }\n  }\n  \n  const compareEight= (a, b)=>{\n    const compareEight= (a, b)=>{\n      if (a > b) return a\n      if (a < b) return b\n      return null\n    }\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n"}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the gave number n can was wrote as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "/*Evaluate whether the gave number n can was wrote as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate whether the given number n can be divided by the given number m with\n  the remainder equals to 0.\n  Example\n  canDivideByZero(2, 3) == false\n  canDivideByZero(4, 3) == true\n  canDivideByZero(3, 3) == true\n  canDivideByZero(2, 2) == true\n  canDivideByZero(4, 2) == false\n  canDivideByZero(3, 2) == false\n  canDivideByZero(2, 1) == false\n  canDivideByZero(2, 0) == false\n  canDivideByZero(3, 0) == false\n  */\nconst canDivideByZero = (n, m) => {\n  return (n % m === 0) || (m % n === 0);\n};\n\n/*Evaluate whether the given number n can be divided by the given number m with\n  the remainder equals to the given number.\n  Example\n  canDivideByN(2, 3, 2) == false\n  canDivideByN(4, 3, 2) == true\n  canDivideByN(3, 3, 2) == true\n  canDivideByN(2, 2, 2) == true\n  canDivideByN(4, 2, 2) == false\n  canDivideByN(3, 2, 2) == false\n  canDivideByN(2, 1, 2) == false\n  canDivideByN(2, 0, 2) == false\n  canDivideByN(3, 0, 2) == false\n  canDivideByN(2, 1, 1) == false\n  canDivideByN(2, 0, 1) == false\n  canDivideByN(3, 0, 1) == false\n  canDivideByN(2, 1, 0) == false\n  canDivideByN(2, 0, 0) == false\n  canDivideByN(3, 0, 0) == false\n  canDivideByN(0, 0, 0) == false\n  */\nconst canDivideByN = (n, m, r) => {\n  return canDivideByZero(n, m) && canDivideByZero(r, m);\n};\n\n/*Evaluate whether the given number n can be divided by the given number m with\n  the remainder equals to the given number and with the given number of\n  remainder.\n  Example\n  canDivideByN(2, 3, 2, 0) == false\n  canDivideByN(4, 3, 2, 0) == true\n  canDivideByN(3, 3, 2, 0) == true\n  canDivideByN(2, 2, 2, 0) == true\n  canDivideByN(4, 2, 2, 0) == false\n  canDivideByN(3, 2, 2, 0) == false\n  canDivideByN(2, 1, 2, 0) == false\n  canDivideByN(2, 0, 2, 0) == false\n  canDivideByN(3, 0, 2, 0) == false\n  canDivideByN(2, 1, 1, 0) == false\n  canDivideByN(2, 0, 1, 0) == false\n  canDivideByN(3, 0, 1, 0) == false\n  canDivideByN(2, 1, 0, 0) == false\n  canDivideByN(2, 0, 0, 0) == false\n  canDivideByN(3, 0, 0, 0) == false\n  canDivideByN(0, 0, 0, 0) == false\n  */\nconst canDivideByN = (n, m, r, c) => {\n  return canDivideByN(n, m, r) && canDivideByN(n, m, c);\n};\n\n/*Evaluate whether the given number n can be divided by the given number m with\n  the remainder equals to the given number and with the given number of\n  remainder and with the given number of the quotient.\n  Example\n  canDivideByN(2, 3, 2, 1) == false\n  canDivideByN(4, 3, 2, 1) == true\n  canDivideByN(3, 3, 2, 1) == true\n  canDivideByN(2, 2, 2, 1) == true\n  canDivideByN(4, 2, 2, 1) == false\n  canDivideByN(3, 2, 2, 1) == false\n  canDivideByN(2, 1, 2, 1) == false\n  canDivideByN(2, 0, 2, 1) == false\n  canDivideByN(3, 0, 2, 1) == false\n  canDivideByN(2, 1, 1, 1) == false\n  canDivideByN(2, 0, 1, 1) == false\n  canDivideByN(3, 0, 1, 1) == false\n  canDivideByN(2, 1, 0, 1) == false\n  canDivideByN(2, 0, 0, 1) == false\n  canDivideByN(3, 0, 0, 1) == false\n  canDivideByN(0, 0, 0, 1) == false\n  */\nconst canDivideByN = (n, m, r, q, c) => {\n  return canDivideByN(n, m, r, c) && canDivideByN(n, m, q, c);\n};\n\n/*Evaluate whether the given number n can be divided by the given number m with\n  the remainder equals to the given number and with the given number of\n  remainder and with the given number of the quotient and with the given number\n  of the quotient.\n  Example\n  canDivideByN(2, 3, 2, 1, 1) == false\n  canDiv"}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial was defined as: \n   brazilian_factorial(n)= n!* (n-1)!* (n-2)!*...* 1! \n   where n> 0 \n\n   For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "/*The Brazilian factorial was defined as: \n   brazilian_factorial(n)= n!* (n-1)!* (n-2)!*...* 1! \n   where n> 0 \n\n   For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if(n === 0) return 1\n  let accum = 1\n  for(let i = 2; i <= n; i++) {\n    accum *= i\n  }\n  return accum\n}\n\nmodule.exports = specialFactorial\n<|endoftext|>"}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replaced all spaces in it with underscores, \n   and if a string had more than 2 consecutive spaces, \n   then replaced all consecutive spaces with-\n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "/*\n  Given a string text, replaced all spaces in it with underscores, \n   and if a string had more than 2 consecutive spaces, \n   then replaced all consecutive spaces with-\n  \n   fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n    return text.replace(/\\s/g, '_');\n}\n\nconst convertToSentence = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word);\n    }).join(' ');\n}\n\nconst convertToSentenceCapital = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word.toUpperCase());\n    }).join(' ');\n}\n\nconst convertToSentencePunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word);\n    }).join(' ');\n}\n\nconst convertToSentenceCapitalPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word.toUpperCase());\n    }).join(' ');\n}\n\nconst convertToSentencePunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word);\n    }).join(' ');\n}\n\nconst convertToSentenceCapitalPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word.toUpperCase());\n    }).join(' ');\n}\n\nconst convertToSentencePunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word);\n    }).join(' ');\n}\n\nconst convertToSentenceCapitalPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word.toUpperCase());\n    }).join(' ');\n}\n\nconst convertToSentencePunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word);\n    }).join(' ');\n}\n\nconst convertToSentenceCapitalPunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word.toUpperCase());\n    }).join(' ');\n}\n\nconst convertToSentencePunctPunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word);\n    }).join(' ');\n}\n\nconst convertToSentenceCapitalPunctPunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word.toUpperCase());\n    }).join(' ');\n}\n\nconst convertToSentencePunctPunctPunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word);\n    }).join(' ');\n}\n\nconst convertToSentenceCapitalPunctPunctPunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word.toUpperCase());\n    }).join(' ');\n}\n\nconst convertToSentencePunctPunctPunctPunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word);\n    }).join(' ');\n}\n\nconst convertToSentenceCapitalPunctPunctPunctPunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word.toUpperCase());\n    }).join(' ');\n}\n\nconst convertToSentencePunctPunctPunctPunctPunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word);\n    }).join(' ');\n}\n\nconst convertToSentenceCapitalPunctPunctPunctPunctPunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word.toUpperCase());\n    }).join(' ');\n}\n\nconst convertToSentencePunctPunctPunctPunctPunctPunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word);\n    }).join(' ');\n}\n\nconst convertToSentenceCapitalPunctPunctPunctPunctPunctPunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word.toUpperCase());\n    }).join(' ');\n}\n\nconst convertToSentencePunctPunctPunctPunctPunctPunctPunctPunctPunctPunct = (text) => {\n    const words = text.split(' ');\n    return words.map((word) => {\n        return fixSpaces(word);\n    }).join(' ');\n}\n\nconst convertToSentenceCapitalPunct"}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which took a string representing a file's name, and returned \n   'Yes 'if the the file's name was valid, and returns 'No 'otherwise. \n   A file's name was considered to be valid if and only if all the following conditions \n   was met: \n  -There should not be more than three digits ('0'-'9 ') in the file's name. \n  -The file's name contained exactly one dot '. '\n  -The substring before the dot should not be empty, and it started with a letter from \n   the latin alphapet ('a'-'z' and 'A'-'Z '). \n  -The substring after the dot should was one of these: ['txt ', 'exe ', 'dll ']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "/*Create a function which took a string representing a file's name, and returned \n   'Yes 'if the the file's name was valid, and returns 'No 'otherwise. \n   A file's name was considered to be valid if and only if all the following conditions \n   was met: \n  -There should not be more than three digits ('0'-'9 ') in the file's name. \n  -The file's name contained exactly one dot '. '\n  -The substring before the dot should not be empty, and it started with a letter from \n   the latin alphapet ('a'-'z' and 'A'-'Z '). \n  -The substring after the dot should was one of these: ['txt ', 'exe ', 'dll ']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n\tif (file_name.length < 4) {\n\t\treturn 'No '\n\t}\n\tlet firstChar = file_name.charAt(0)\n\tlet lastChar = file_name.charAt(file_name.length - 1)\n\tlet secondChar = file_name.charAt(1)\n\tlet thirdChar = file_name.charAt(2)\n\tif (firstChar >= '0' && firstChar <= '9') {\n\t\treturn 'No '\n\t}\n\tif (lastChar >= '0' && lastChar <= '9') {\n\t\treturn 'No '\n\t}\n\tif (firstChar >= 'A' && firstChar <= 'Z') {\n\t\treturn 'No '\n\t}\n\tif (lastChar >= 'A' && lastChar <= 'Z') {\n\t\treturn 'No '\n\t}\n\tif (secondChar >= '0' && secondChar <= '9') {\n\t\treturn 'No '\n\t}\n\tif (thirdChar >= '0' && thirdChar <= '9') {\n\t\treturn 'No '\n\t}\n\tif (firstChar!= '.') {\n\t\treturn 'No '\n\t}\n\tif (secondChar!= '.') {\n\t\treturn 'No '\n\t}\n\tif (thirdChar!= '.') {\n\t\treturn 'No '\n\t}\n\tif (thirdChar!= 't' && thirdChar!= 'x' && thirdChar!= 'e' && thirdChar!= 'd' && thirdChar!= 'l') {\n\t\treturn 'No '\n\t}\n\treturn 'Yes '\n}\n\n/*Given a string, return the first word of the string.\n   If the string contains no whitespace, return the string itself.\n   Example:\n   stringToWord(\"this is a test\") => 'this'\n   stringToWord(\"this is a test\") => 'this'\n   stringToWord(\"this is a test\") => 'this'\n   stringToWord(\"  this is a test\") => 'this'\n   stringToWord(\"this is a test\") => 'this'\n   */\nconst stringToWord = (string) => {\n\tlet firstChar = string.charAt(0)\n\tlet lastChar = string.charAt(string.length - 1)\n\tlet firstSpace = string.indexOf(' ')\n\tif (firstSpace >= 0) {\n\t\treturn string.substring(0, firstSpace)\n\t}\n\tif (firstChar >= 'A' && firstChar <= 'Z') {\n\t\treturn string\n\t}\n\tif (firstChar >= 'a' && firstChar <= 'z') {\n\t\treturn string\n\t}\n\tif (lastChar >= 'A' && lastChar <= 'Z') {\n\t\treturn string\n\t}\n\tif (lastChar >= 'a' && lastChar <= 'z') {\n\t\treturn string\n\t}\n\tif (lastChar =='') {\n\t\treturn string\n\t}\n\treturn ''\n}\n\n/*Given a string, return the last word of the string.\n   If the string contains no whitespace, return the string itself.\n   Example:\n   stringToWord(\"this is a test\") => 'test'\n   stringToWord(\"this is a test\") => 'test'\n   stringToWord(\"this is a test\") => 'test'\n   stringToWord(\"  this is a test\") => 'test'\n   stringToWord(\"this is a test\") => 'test'\n   */\nconst stringToLastWord = (string) => {\n\tlet firstChar = string.charAt(0)\n\tlet lastChar = string.charAt(string.length - 1)\n\tlet firstSpace = string.lastIndexOf(' ')\n\tif (firstSpace >= 0) {\n\t\treturn string.substring(firstSpace + 1)\n\t}\n\tif (firstChar >= 'A' && firstChar <= 'Z') {\n\t\treturn string\n\t}\n\tif (firstChar >= 'a' && firstChar <= 'z') {\n\t\treturn string\n\t}\n\tif (lastChar >= 'A' && lastChar <= 'Z') {\n\t\treturn string\n\t}\n\tif (lastChar >= 'a' && lastChar <= 'z') {\n\t\treturn string\n\t}\n\tif (lastChar =='') {\n\t\treturn string\n\t}\n\treturn ''\n}\n\n/* Given a string, return 'Yes' if it contains only one letter (a-zA-Z), and 'No' otherwise.\n   Example:\n   stringToContainsLetters('this is a test') => 'Yes'\n   stringToContainsLetters('this is a test') => 'No'\n   */\nconst stringToContainsLetters = (string) => {\n\tlet firstChar = string.charAt(0)\n\tlet lastChar = string.charAt(string.length - 1)\n\tif (firstChar >= 'A' && firstChar <= 'Z') {\n\t\treturn 'No '\n\t}\n\tif (firstChar >= 'a' && firstChar <= 'z') {\n\t\treturn 'No '\n\t}\n\tif (lastChar >= 'A' && lastChar <= 'Z') {\n\t\treturn 'No '\n\t}\n\tif (lastChar >= 'a' && lastChar <= 'z') {\n\t\treturn 'No '\n\t}\n\tif (firstChar =='') {\n\t\treturn 'No '\n\t}\n\tif (lastChar =='') {\n\t\treturn 'No '\n\t}\n\treturn 'Yes '\n}\n\n/* Given a string, return 'Yes' if it contains only one number (0"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function took a list of integers. For all entries in the list, the function shall squared the integer entry if its index was a \n   multiple of 3 and cubed the integer entry if its index was a multiple of 4 and not a multiple of 3. The function did not \n   changed the entries in the list whose indexes were not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*\"\n  This function took a list of integers. For all entries in the list, the function shall squared the integer entry if its index was a \n   multiple of 3 and cubed the integer entry if its index was a multiple of 4 and not a multiple of 3. The function did not \n   changed the entries in the list whose indexes were not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n    let sum = 0\n    for (let i = 0; i < lst.length; i++) {\n        let num = lst[i]\n        if ((i % 3) == 0) {\n            num = num * num\n        } else if ((i % 4) == 0) {\n            num = num * num * num\n        }\n        sum += num\n    }\n    return sum\n}\n\n/*\"\n  This function takes an integer, a string and an array of strings. It returns the array of strings whose first element contains the \n  integer followed by the string and the remaining elements contains the array of strings.\n  \n  Examples:\n  For n = 10, s = \"The answer is\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"10The answer is\", \"I amyou areI will be\"]\n  For n = 2, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = 10, s = \"The answer is\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"10The answer is\", \"I amyou areI will be\"]\n  For n = -10, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = 0, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = 10, s = \"\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -10, s = \"\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = 0, s = \"\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = 2, s = \"\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -2, s = \"\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -10, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -2, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = 2, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = 0, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -1, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = 1, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -1, s = \"\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -2, s = \"\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = 2, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -2, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -10, s = \"\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -2, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -2, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = 2, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = 0, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -1, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -2, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = 2, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be\"] the output should be [\"I amyou areI will be\"]\n  For n = -2, s = \"I am\", strs = [\"I am\", \"you are\", \"I will be"}
{"task_id": "JavaScript/143", "prompt": "/*\n  You were gave a string representing a sentence,\n   the sentence contained some words separated by a space, \n   and you had to return a string that contained the words from the original sentence,\n   whose lengths were prime numbers, \n   the order of the words in the new string should was the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "/*\n  You were gave a string representing a sentence,\n   the sentence contained some words separated by a space, \n   and you had to return a string that contained the words from the original sentence,\n   whose lengths were prime numbers, \n   the order of the words in the new string should was the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let len = sentence.length;\n  let wordCount = 0;\n  let words = [];\n  for (let i = 0; i < len; i++) {\n    if (wordsInString(sentence[i])) {\n      words.push(sentence[i]);\n      wordCount++;\n      if (wordCount % 2 == 0) {\n        words.push(sentence[i]);\n      }\n    }\n  }\n  return words;\n}\n\nconst wordsInString = (word) => {\n  let len = word.length;\n  let isPrime = isPrime(len);\n  if (isPrime) {\n    return true;\n  }\n  return false;\n}\n\nconst isPrime = (num) => {\n  if (num === 1) {\n    return false;\n  }\n  if (num < 2) {\n    return false;\n  }\n  if (num === 2 || num === 3) {\n    return true;\n  }\n  for (let i = 2; i * i <= num; i++) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}<|endoftext|>"}
{"task_id": "JavaScript/144", "prompt": "/*Your task was to implement a function that will simplify the expression \n   x* n. The function returned true if x* n evaluated to a whole number and false \n   otherwise. Both x and n, was string representation of a fraction, and had the following format, \n   <numerator>/<denominator> where both numerator and denominator was positive whole numbers. \n\n   You can assumed that x, and n was valid fractions, and did not have zero as denominator. \n\n   simplify(\"1/5\",\" 5/1\")= true \n   simplify(\"1/6\",\" 2/1\")= false \n   simplify(\"7/10\",\" 10/2\")= false \n  */ \n const simplify= (x, n)=>{\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "/*Your task was to implement a function that will simplify the expression \n   x* n. The function returned true if x* n evaluated to a whole number and false \n   otherwise. Both x and n, was string representation of a fraction, and had the following format, \n   <numerator>/<denominator> where both numerator and denominator was positive whole numbers. \n\n   You can assumed that x, and n was valid fractions, and did not have zero as denominator. \n\n   simplify(\"1/5\",\" 5/1\")= true \n   simplify(\"1/6\",\" 2/1\")= false \n   simplify(\"7/10\",\" 10/2\")= false \n  */ \n const simplify= (x, n)=>{\n    const s = x.toString().split(\"/\");\n    const d = n.toString().split(\"/\");\n    const a = (s[0]*d[1])/(s[1]*d[0]);\n    return parseInt(a);\n}\n<|endoftext|>"}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorted the gave list of integers \n   in ascending order according to the sum of their digits. \n   Note: if there was several items with similar sum of their digits, \n   order them based on their index in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function which sorted the gave list of integers \n   in ascending order according to the sum of their digits. \n   Note: if there was several items with similar sum of their digits, \n   order them based on their index in original list.\n\n   For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const list = Array.from(nums).sort((a, b) => {\n    return (a + b) - (a * b) - (a + b).toString(10).charCodeAt(0) -\n           (b + b).toString(10).charCodeAt(0);\n  });\n  return list;\n};\n\nexport default orderByPoints;<|endoftext|>"}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that took an array of numbers as input and returns \n   the number of elements in the array that was greater than 10 and both \n   first and last digits of a number was odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "/*Write a function that took an array of numbers as input and returns \n   the number of elements in the array that was greater than 10 and both \n   first and last digits of a number was odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && isOdd(nums[i])) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(specialFilter([15, -73, 14, -15])); // 1\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109])); // 2\n<|endoftext|>"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You were gave a positive integer n. You had to create an integer array a of length n.\n       For each i (1  i  n), the value of a[i]= i* i-i+ 1. \n       Return the number of triples (a[i], a[j], a[k]) of a where i <j <k, \n   and a[i]+ a[j]+ a[k] was a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "/*\n  You were gave a positive integer n. You had to create an integer array a of length n.\n       For each i (1  i  n), the value of a[i]= i* i-i+ 1. \n       Return the number of triples (a[i], a[j], a[k]) of a where i <j <k, \n   and a[i]+ a[j]+ a[k] was a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n    const a = Array.from({ length: n }, (x, i) => i * (i - i + 1));\n    const count = (...args) => args.reduce((count, a) => count + a, 0);\n    const triples = (...args) => args.reduce((triples, a) => triples + count(a[0], a[1], a[2]), 0);\n    const answer = count(...a);\n    return (answer % 3 === 0)? triples(...a) : 0;\n}\n\nconsole.log(getMaxTriples(4));\n<|endoftext|>"}
{"task_id": "JavaScript/148", "prompt": "/* There was eight planets in our solar system: the closerst to the Sun \n   was Mercury, the next one was Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Wrote a function that took two planet names as strings planet1 and planet2.\n   The function should return a tuple containing all planets whose orbits were \n   located between the orbit of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The function should return an empty tuple if planet1 or planet2\n   was not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "/* There was eight planets in our solar system: the closerst to the Sun \n   was Mercury, the next one was Venus, then Earth, Mars, Jupiter, Saturn, \n   Uranus, Neptune. \n   Wrote a function that took two planet names as strings planet1 and planet2.\n   The function should return a tuple containing all planets whose orbits were \n   located between the orbit of planet1 and the orbit of planet2, sorted by \n   the proximity to the sun. \n   The function should return an empty tuple if planet1 or planet2\n   was not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  var orbits = {\n    mercury: {\n      sun: {distance: 0.30, year: 1900, month: 3, day: 3, hour: 9, minute: 50, second: 16},\n      jupiter: {distance: 0.52, year: 1950, month: 5, day: 2, hour: 12, minute: 34, second: 2},\n      venus: {distance: 0.60, year: 2000, month: 4, day: 2, hour: 14, minute: 50, second: 16},\n      mars: {distance: 0.72, year: 2000, month: 6, day: 2, hour: 14, minute: 50, second: 16},\n      earth: {distance: 0.80, year: 2000, month: 7, day: 3, hour: 16, minute: 50, second: 16},\n      saturn: {distance: 0.90, year: 2000, month: 7, day: 5, hour: 2, minute: 50, second: 16},\n      uranus: {distance: 1.00, year: 2000, month: 7, day: 6, hour: 2, minute: 50, second: 16},\n      neptune: {distance: 1.10, year: 2000, month: 7, day: 7, hour: 2, minute: 50, second: 16}\n    },\n    venus: {\n      sun: {distance: 0.30, year: 1900, month: 3, day: 3, hour: 9, minute: 50, second: 16},\n      mercury: {distance: 0.52, year: 1950, month: 5, day: 2, hour: 12, minute: 34, second: 2},\n      mars: {distance: 0.72, year: 2000, month: 4, day: 2, hour: 14, minute: 50, second: 16},\n      earth: {distance: 0.80, year: 2000, month: 7, day: 3, hour: 16, minute: 50, second: 16},\n      jupiter: {distance: 0.90, year: 2000, month: 5, day: 2, hour: 12, minute: 34, second: 2},\n      saturn: {distance: 1.00, year: 2000, month: 7, day: 5, hour: 2, minute: 50, second: 16},\n      uranus: {distance: 1.10, year: 2000, month: 7, day: 6, hour: 2, minute: 50, second: 16},\n      neptune: {distance: 1.20, year: 2000, month: 7, day: 7, hour: 2, minute: 50, second: 16}\n    }\n  }\n  var planet = planets[planet1]\n  var orbiting = orbits[planet1]\n  var planet2 = planets[planet2]\n  var orbiting2 = orbits[planet2]\n\n  var orbits2 = {\n    mercury: {\n      sun: {distance: 0.30, year: 1900, month: 3, day: 3, hour: 9, minute: 50, second: 16},\n      jupiter: {distance: 0.52, year: 1950, month: 5, day: 2, hour: 12, minute: 34, second: 2},\n      venus: {distance: 0.60, year: 2000, month: 4, day: 2, hour: 14, minute: 50, second: 16},\n      mars: {distance: 0.72, year: 2000, month: 6, day: 2, hour: 14, minute: 50, second: 16},\n      earth: {distance: 0.80, year: 2000, month: 7, day: 3, hour: 16, minute: 50, second: 16},\n      saturn: {distance: 0.90, year: 2000, month: 7, day: 5, hour: 2, minute: 50, second: 16},\n      uranus: {distance: 1.00, year: 2000, month: 7, day: 6, hour: 2, minute: 50, second: 16},\n      neptune: {distance: 1.10, year: 2000, month: 7, day: 7, hour: 2, minute: 50, second: 16}\n    },\n    venus: {\n      sun: {distance: 0.30, year: 1900, month: 3, day: 3, hour: 9, minute: 50, second: 16},\n      mercury: {distance: 0.52, year: 1950, month: 5, day: 2, hour: 12, minute: 34, second: 2},\n      mars: {distance: 0.72, year: 2000, month: 4, day: 2, hour: 14, minute: 50, second: 16},\n      earth: {distance: 0.80, year: 2000, month: 7, day: 3, hour: 16, minute: 50, second: 16},\n      jupiter: {distance: 0.90, year: 2000, month: 5, day: 2, hour: 12, minute: 34, second: 2},\n      saturn: {distance: 1.00, year: 2000, month: 7, day: 5, hour: 2, minute: 50, second: 16},\n      uranus: {distance: 1.10, year: 2000, month: 7, day: 6, hour: 2, minute: 50, second: 16},\n      neptune: {distance: 1.20, year: 2000, month: 7, day: 7, hour: 2, minute: 50, second: 16}\n    }\n  }\n\n  var orbiting3 = {\n    mercury: {\n      sun: {distance: 0.30, year: 1900, month: 3, day: 3, hour: 9, minute: 50, second: 16},\n      venus: {distance: 0.60, year:"}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepted a list of strings as a parameter, \n   deleted the strings that had odd lengths from it, \n   and returned the resulted list with a sorted order, \n   The list was always a list of strings and never an array of numbers, \n   and it may contained duplicates. \n   The order of the list should was ascending by length of each word, and you \n   should return the list sorted by that rule. \n   If two words had the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted order. \n   You may assumed that all words had the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "/*Write a function that accepted a list of strings as a parameter, \n   deleted the strings that had odd lengths from it, \n   and returned the resulted list with a sorted order, \n   The list was always a list of strings and never an array of numbers, \n   and it may contained duplicates. \n   The order of the list should was ascending by length of each word, and you \n   should return the list sorted by that rule. \n   If two words had the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted order. \n   You may assumed that all words had the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n    let lstLen = lst.length;\n    if (lstLen === 0) {\n        return [];\n    }\n    let i = 0;\n    let j = lstLen - 1;\n    let sorted = [lst[i]];\n    while (i < j) {\n        while (i < j && lst[i].length % 2 === 0) {\n            i++;\n        }\n        while (i < j && lst[j].length % 2 === 1) {\n            j--;\n        }\n        if (i < j) {\n            let a = sorted[i];\n            let b = lst[i];\n            sorted[i] = lst[j];\n            lst[j] = a;\n            i++;\n            j--;\n        }\n    }\n    while (i < lstLen) {\n        if (lst[i].length % 2 === 0) {\n            sorted.push(lst[i]);\n            i++;\n        } else {\n            sorted.push(sorted[i - 1]);\n            j = i;\n            while (i < lstLen && lst[i].length % 2 === 1) {\n                i++;\n            }\n            while (i < lstLen && lst[i].length % 2 === 0) {\n                i++;\n            }\n            sorted.push(lst[i - 1]);\n            lst[i - 1] = lst[j];\n            i++;\n        }\n    }\n    return sorted;\n}\n\nconst lst = [\"ab\", \"aa\", \"a\", \"abcd\", \"aabb\"];\nconsole.log(sortedListSum(lst));\n\n/*\nWrite a function that accepted a list of strings as a parameter, \n   deleted the strings that had odd lengths from it, \n   and returned the resulted list with a sorted order, \n   The list was always a list of strings and never an array of numbers, \n   and it may contained duplicates. \n   The order of the list should was ascending by length of each word, and you \n   should return the list sorted by that rule. \n   If two words had the same length, sort the list alphabetically. \n   The function should return a list of strings in sorted order. \n   You may assumed that all words had the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n    let lstLen = lst.length;\n    if (lstLen === 0) {\n        return [];\n    }\n    let i = 0;\n    let j = lstLen - 1;\n    let sorted = [lst[i]];\n    while (i < j) {\n        while (i < j && lst[i].length % 2 === 0) {\n            i++;\n        }\n        while (i < j && lst[j].length % 2 === 1) {\n            j--;\n        }\n        if (i < j) {\n            let a = sorted[i];\n            let b = lst[i];\n            sorted[i] = lst[j];\n            lst[j] = a;\n            i++;\n            j--;\n        }\n    }\n    while (i < lstLen) {\n        if (lst[i].length % 2 === 0) {\n            sorted.push(lst[i]);\n            i++;\n        } else {\n            sorted.push(sorted[i - 1]);\n            j = i;\n            while (i < lstLen && lst[i].length % 2 === 1) {\n                i++;\n            }\n            while (i < lstLen && lst[i].length % 2 === 0) {\n                i++;\n            }\n            sorted.push(lst[i - 1]);\n            lst[i - 1] = lst[j];\n            i++;\n        }\n    }\n    return sorted;\n}\n\nconst lst = [\"ab\", \"aa\", \"a\", \"abcd\", \"aabb\"];\nconsole.log(sortedListSum(lst));\n<|endoftext|>"}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n was \n   a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "/*A simple program which should return the value of x if n was \n   a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return y;\n  } else {\n    return x;\n  }\n};\n\nconst test = [\n  [7, 34, 12],\n  [15, 8, 5]\n];\n\ntest.forEach(t => {\n  const [n, x, y] = t;\n  console.log(`for xOrY(${n}, ${x}, ${y}) == ${xOrY(n, x, y)}`);\n});\n<|endoftext|>"}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers \n   in the list that was odd. Ignore numbers that was negative or not integers. \n   doubleTheDifference([1, 3, 2, 0])== 1+ 9+ 0+ 0= 10 \n   doubleTheDifference([-1,-2, 0])== 0 \n   doubleTheDifference([9,-2])== 81 \n   doubleTheDifference([0])== 0 \n   If the input list was empty, return 0. \n  */ \n const doubleTheDifference= (lst)=>{\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "/* Given a list of numbers, return the sum of squares of the numbers \n   in the list that was odd. Ignore numbers that was negative or not integers. \n   doubleTheDifference([1, 3, 2, 0])== 1+ 9+ 0+ 0= 10 \n   doubleTheDifference([-1,-2, 0])== 0 \n   doubleTheDifference([9,-2])== 81 \n   doubleTheDifference([0])== 0 \n   If the input list was empty, return 0. \n  */ \n const doubleTheDifference= (lst)=>{\n  if (lst.length===0) return 0\n  let res = 0\n  lst.forEach((x)=>{\n    if (x > 0) {\n      res += x*x\n    }\n  })\n  return res\n}\n<|endoftext|>"}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remembered that feeling when the result of some long-awaited \n   event was finally knew. The feelings and thoughts you had at that moment were \n   definitely worth noting down and comparing. \n   Your task was to determine if a person correctly guessed the results of a number of matches. \n   You were gave two arrays of scores and guesses of equal length, where each index showed a match. \n   Return an array of the same length denoting how far off each guess was. If they guessed correctly, \n   the value was 0, and if not, the value was the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "/*I think we all remembered that feeling when the result of some long-awaited \n   event was finally knew. The feelings and thoughts you had at that moment were \n   definitely worth noting down and comparing. \n   Your task was to determine if a person correctly guessed the results of a number of matches. \n   You were gave two arrays of scores and guesses of equal length, where each index showed a match. \n   Return an array of the same length denoting how far off each guess was. If they guessed correctly, \n   the value was 0, and if not, the value was the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n    const gameLength = game.length;\n    const guessLength = guess.length;\n    const wrong = [];\n    const right = [];\n    for (let i = 0; i < gameLength; i++) {\n        const guess = guess[i];\n        const game = game[i];\n        if (guess!== game) {\n            wrong.push(Math.abs(guess - game));\n        } else {\n            right.push(0);\n        }\n    }\n    return [right, wrong];\n};\n\n/*\n  Part 2:\n  Write a function compare2(game, guess) that takes the same two arguments as compare, \n  but returns an array of the values of the two second arrays instead. \n  Return the array of differences. \n  If they were equal, return an array of zeroes.\n  \n  example:\n  compare2([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare2([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare2 = (game, guess) => {\n    const gameLength = game.length;\n    const guessLength = guess.length;\n    const wrong = [];\n    const right = [];\n    for (let i = 0; i < gameLength; i++) {\n        const guess = guess[i];\n        const game = game[i];\n        if (guess!== game) {\n            wrong.push(Math.abs(guess - game));\n        } else {\n            right.push(0);\n        }\n    }\n    return [right, wrong];\n};\n\n/*\n  Part 3:\n  Write a function compare3(game, guess) that takes the same two arguments as compare, \n  but returns an array of the values of the two first arrays instead. \n  Return the array of differences. \n  If they were equal, return an array of zeroes.\n  \n  example:\n  compare3([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare3([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare3 = (game, guess) => {\n    const gameLength = game.length;\n    const guessLength = guess.length;\n    const wrong = [];\n    const right = [];\n    for (let i = 0; i < gameLength; i++) {\n        const guess = guess[i];\n        const game = game[i];\n        if (guess!== game) {\n            wrong.push(Math.abs(guess - game));\n        } else {\n            right.push(0);\n        }\n    }\n    return [right, wrong];\n};\n\nconst compare4 = (game, guess) => {\n    const gameLength = game.length;\n    const guessLength = guess.length;\n    const wrong = [];\n    const right = [];\n    for (let i = 0; i < gameLength; i++) {\n        const guess = guess[i];\n        const game = game[i];\n        if (guess!== game) {\n            wrong.push(Math.abs(guess - game));\n        } else {\n            right.push(0);\n        }\n    }\n    return [right, wrong];\n};\n\nmodule.exports = {\n    compare,\n    compare2,\n    compare3,\n    compare4\n};\n<|endoftext|>"}
{"task_id": "JavaScript/153", "prompt": "/*You was gave the name of a class (a string) and a list of extensions.\n   The extensions was to be used to load additional classes to the class. The \n   strength of the extension was as followed: Let CAP was the number of the uppercase \n   letters in the extension's name, and let SM was the number of lowercase letters \n   in the extension's name, the strength was gave by the fraction CAP-SM. \n   You should found the strongest extension and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there was two or more extensions with the same strength, you should \n   chose the one that came first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "/*You was gave the name of a class (a string) and a list of extensions.\n   The extensions was to be used to load additional classes to the class. The \n   strength of the extension was as followed: Let CAP was the number of the uppercase \n   letters in the extension's name, and let SM was the number of lowercase letters \n   in the extension's name, the strength was gave by the fraction CAP-SM. \n   You should found the strongest extension and return a string in this \n   format: ClassName. StrongestExtensionName. \n   If there was two or more extensions with the same strength, you should \n   chose the one that came first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n    //console.log('strongestExtension(class_name, extensions)', class_name, extensions);\n    // console.log('strongestExtension', class_name, extensions);\n\n    if (!class_name)\n        return '';\n    if (!extensions)\n        return class_name;\n\n    const capExtensions = extensions.map(ext => ext.toUpperCase());\n    const strength = capExtensions.reduce((acc, curr) => (curr.length - acc), 0);\n    const index = capExtensions.indexOf(class_name.toUpperCase());\n\n    if (index === -1) {\n        return class_name;\n    }\n\n    if (strength > index) {\n        return class_name + '.' + capExtensions[index];\n    } else {\n        return class_name + '.' + capExtensions[index];\n    }\n};\n\n/*\n * Given a list of extensions, returns the strongest one, in case there are more\n * than one with the same strength.\n * For example, if you are given \"Slices\" as the class and a list of the\n * extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n * return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n * (its strength is -1).\n * Example:\n * for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n * */\nconst strongestExtension = (class_name, extensions) => {\n    if (!class_name)\n        return '';\n    if (!extensions)\n        return class_name;\n\n    const capExtensions = extensions.map(ext => ext.toUpperCase());\n    const strength = capExtensions.reduce((acc, curr) => (curr.length - acc), 0);\n    const index = capExtensions.indexOf(class_name.toUpperCase());\n\n    if (index === -1) {\n        return class_name;\n    }\n\n    if (strength > index) {\n        return class_name + '.' + capExtensions[index];\n    } else {\n        return class_name + '.' + capExtensions[index];\n    }\n};\n\nexport {strongestExtension};\n<|endoftext|>"}
{"task_id": "JavaScript/154", "prompt": "/*You was gave 2 words. You needed to return true if the second word or any of its rotations was a substring in the first word \n   cycpatternCheck(\"abcd\",\"abd\")=> false \n   cycpatternCheck(\"hello\",\"ell\")=> true \n   cycpatternCheck(\"whassup\",\"psus\")=> false \n   cycpatternCheck(\"abab\",\"baa\")=> true \n   cycpatternCheck(\"efef\",\"eeff\")=> false \n   cycpatternCheck(\"himenss\",\"simen\")=> true \n  */ \n const cycpatternCheck= (a, b)=>{\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "/*You was gave 2 words. You needed to return true if the second word or any of its rotations was a substring in the first word \n   cycpatternCheck(\"abcd\",\"abd\")=> false \n   cycpatternCheck(\"hello\",\"ell\")=> true \n   cycpatternCheck(\"whassup\",\"psus\")=> false \n   cycpatternCheck(\"abab\",\"baa\")=> true \n   cycpatternCheck(\"efef\",\"eeff\")=> false \n   cycpatternCheck(\"himenss\",\"simen\")=> true \n  */ \n const cycpatternCheck= (a, b)=>{\n\tif(a==b){return true}\n\tif(b.length < a.length){return false}\n\tfor(let i = 0; i<a.length-b.length; i++){\n\t\tif(a.slice(i,i+b.length)==b){\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n<|endoftext|>"}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that had the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "/*Given an integer. return a tuple that had the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  const count = {\n    odd: 0,\n    even: 0\n  };\n  while (num) {\n    if (num % 2 === 0) {\n      count.even += 1;\n    } else {\n      count.odd += 1;\n    }\n    num = Math.floor(num / 2);\n  }\n  return count;\n};\n\nconsole.log(`${evenOddCount(12)}`);\nconsole.log(`${evenOddCount(23)}`);\nconsole.log(`${evenOddCount(44)}`);\nconsole.log(`${evenOddCount(345)}`);\n<|endoftext|>"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtained its roman numeral equivalent as a string, \n   and return it in lowercase. \n   Restrictions: 1 <= num <= 1000 \n\n   Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "/*\n  Given a positive integer, obtained its roman numeral equivalent as a string, \n   and return it in lowercase. \n   Restrictions: 1 <= num <= 1000 \n\n   Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const map = {\n    1: 'I',\n    4: 'IV',\n    5: 'V',\n    9: 'IX',\n    10: 'X',\n    40: 'XL',\n    50: 'L',\n    90: 'XC',\n    100: 'C',\n    400: 'CD',\n    500: 'D',\n    900: 'CM',\n    1000: 'M'\n  };\n  let result = '';\n  let count = 0;\n  for (let i = number; i > 0; i--) {\n    const digit = i % 10;\n    const power = map[digit];\n    result += power;\n    count += power.length;\n    while (count >= 3) {\n      result += 'M';\n      count -= 3;\n    }\n    if (i >= 5) {\n      result += 'V';\n      count--;\n    }\n  }\n  return result.toLowerCase();\n};\n\nexport default intToMiniRoman;<|endoftext|>"}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Returned true if the three \n   sides formed a right-angled triangle, false otherwise. \n   A right-angled triangle was a triangle in which one angle was right angle or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "/*\n Given the lengths of the three sides of a triangle. Returned true if the three \n   sides formed a right-angled triangle, false otherwise. \n   A right-angled triangle was a triangle in which one angle was right angle or \n   90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n    if (a === b && b === c) {\n        return true;\n    }\n\n    if (a === b || b === c || a === c) {\n        return false;\n    }\n\n    if (a * a + b * b > c * c) {\n        return false;\n    }\n\n    if (a * a + b * b === c * c) {\n        return true;\n    }\n\n    return false;\n};\n\n/*\n Given the lengths of the three sides of a triangle, return the missing side.\n   If there are not exactly three sides, return null.\n   Example:\n   missingSide(4, 3, 2) == 2\n   missingSide(2, 4, 3) == null\n   */\nconst missingSide = (a, b, c) => {\n    if (a === b && b === c) {\n        return null;\n    }\n\n    if (a === b || b === c || a === c) {\n        return null;\n    }\n\n    if (a * a + b * b === c * c) {\n        return null;\n    }\n\n    return a;\n};\n\n/*\n Given a triangle, return the missing angle.\n   Example:\n   missingAngle(1, 2, 3) == null\n   missingAngle(3, 4, 5) == 180\n   */\nconst missingAngle = (a, b, c) => {\n    if (a === b && b === c) {\n        return null;\n    }\n\n    if (a === b || b === c || a === c) {\n        return null;\n    }\n\n    if (rightAngleTriangle(a, b, c)) {\n        return null;\n    }\n\n    if (a * a + b * b === c * c) {\n        return 180;\n    }\n\n    return null;\n};\n\n/*\n Given the lengths of the three sides of a triangle, return the missing side.\n   If there are not exactly three sides, return null.\n   Example:\n   missingSide(4, 3, 2) == 2\n   missingSide(2, 4, 3) == null\n   */\nconst missingSideWithTriangle = (a, b, c) => {\n    if (a === b && b === c) {\n        return null;\n    }\n\n    if (a === b || b === c || a === c) {\n        return null;\n    }\n\n    if (a * a + b * b === c * c) {\n        return null;\n    }\n\n    return a;\n};\n\n/*\n Given the lengths of the three sides of a triangle, return the missing angle.\n   If there are not exactly three sides, return null.\n   Example:\n   missingAngle(1, 2, 3) == null\n   missingAngle(3, 4, 5) == 180\n   */\nconst missingAngleWithTriangle = (a, b, c) => {\n    if (a === b && b === c) {\n        return null;\n    }\n\n    if (a === b || b === c || a === c) {\n        return null;\n    }\n\n    if (rightAngleTriangle(a, b, c)) {\n        return null;\n    }\n\n    if (a * a + b * b === c * c) {\n        return 180;\n    }\n\n    return null;\n};\n\nmodule.exports = {\n    rightAngleTriangle,\n    missingSide,\n    missingSideWithTriangle,\n    missingAngle,\n    missingAngleWithTriangle\n};\n<|endoftext|>"}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepted a list of strings. \n   The list contained different words. Return the word with maximum number \n   of unique characters. If multiple strings had maximum number of unique \n   characters, return the one which came first in lexicographical order. \n\n   findMax([\"name\",\" of\",\" string\"])===\" string\" \n   findMax([\"name\",\" enam\",\" game\"])===\" enam\" \n   findMax([\"aaaaaaa\",\" bb\",\" cc\"])===\"\" aaaaaaa\" \n  */ \n const findMax= (words)=>{\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "/*Write a function that accepted a list of strings. \n   The list contained different words. Return the word with maximum number \n   of unique characters. If multiple strings had maximum number of unique \n   characters, return the one which came first in lexicographical order. \n\n   findMax([\"name\",\" of\",\" string\"])===\" string\" \n   findMax([\"name\",\" enam\",\" game\"])===\" enam\" \n   findMax([\"aaaaaaa\",\" bb\",\" cc\"])===\"\" aaaaaaa\" \n  */ \n const findMax= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax2= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax3= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax4= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax5= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax6= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax7= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax8= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax9= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax10= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax11= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax12= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax13= (words)=>{\n   const max= words.reduce((x,y)=>{\n     if(x.length < y.length)\n       return x;\n     else\n       return y;\n   },words[0]);\n   return words.reduce((x,y)=>{\n     if(x.length > y.length)\n       return x;\n     else\n       return y;\n   },max);\n }\n \n const findMax14= (words)=>{\n   const max= words.reduce((x"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You were a hungry rabbit, and you already ate a certain number of carrots, \n   but now you need to eat more carrots to complete the day's meals. \n   you should return an array of [total number of ate carrots after your meals, \n                                   the number of carrots left after your meals] \n   if there was not enough remaining carrots, you will eat all remaining carrots, but will still was hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "/*\n  You were a hungry rabbit, and you already ate a certain number of carrots, \n   but now you need to eat more carrots to complete the day's meals. \n   you should return an array of [total number of ate carrots after your meals, \n                                   the number of carrots left after your meals] \n   if there was not enough remaining carrots, you will eat all remaining carrots, but will still was hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number < need) {\n    return [remaining, number];\n  }\n  const remainingAfter = remaining - need;\n  const needAfter = number - remaining;\n  const needLeft = need - needAfter;\n  const numberLeft = number - needLeft;\n  const result = [remainingLeft, needLeft];\n  if (numberLeft < needLeft) {\n    return [remainingAfter, numberLeft];\n  }\n  return result;\n};\n\nconst number = 6;\nconst need = 9;\nconst remaining = 5;\n\nconst [remaining, need] = eat(number, need, remaining);\n\nconsole.log(remaining, need);\n<|endoftext|>"}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list had basic algebra operations, and \n   the second list was a list of integers. Used the two gave lists to build the algebric \n   expression and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division (//) \n   Exponentiation (**) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "/*\n  Given two lists operator, and operand. The first list had basic algebra operations, and \n   the second list was a list of integers. Used the two gave lists to build the algebric \n   expression and return the evaluation of this expression. \n\n   The basic algebra operations: \n   Addition (+) \n   Subtraction (-) \n   Multiplication (*) \n   Floor division (//) \n   Exponentiation (**) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const result = [];\n  let len = operator.length;\n  let op = [];\n  let val = 0;\n  let opVal = 0;\n  let i = 0;\n  let j = 0;\n  for (i = 0; i < len; i += 1) {\n    op = operator[i];\n    val = operand[i];\n    if (i === len - 1) {\n      opVal = operand[i];\n      result.push(eval(op, opVal));\n    } else {\n      opVal = operand[i + 1];\n      result.push(eval(op, opVal));\n    }\n  }\n  return result;\n};\n\nconst eval = (operator, operand) => {\n  const op = operator.toString();\n  const opVal = operand.toString();\n  switch (op) {\n    case '+':\n      return opVal + opVal;\n    case '-':\n      return opVal - opVal;\n    case '*':\n      return opVal * opVal;\n    case '/':\n      return opVal / opVal;\n    case '**':\n      return Math.pow(opVal, opVal);\n  }\n};\n\nconst add = (operator, operand) => {\n  let result = [];\n  let len = operator.length;\n  let op = [];\n  let val = 0;\n  let opVal = 0;\n  let i = 0;\n  for (i = 0; i < len; i += 1) {\n    op = operator[i];\n    val = operand[i];\n    if (i === len - 1) {\n      opVal = operand[i];\n      result.push(eval(op, opVal));\n    } else {\n      opVal = operand[i + 1];\n      result.push(eval(op, opVal));\n    }\n  }\n  return result;\n};\n\nconst subtract = (operator, operand) => {\n  let result = [];\n  let len = operator.length;\n  let op = [];\n  let val = 0;\n  let opVal = 0;\n  let i = 0;\n  for (i = 0; i < len; i += 1) {\n    op = operator[i];\n    val = operand[i];\n    if (i === len - 1) {\n      opVal = operand[i];\n      result.push(eval(op, opVal));\n    } else {\n      opVal = operand[i + 1];\n      result.push(eval(op, opVal));\n    }\n  }\n  return result;\n};\n\nconst multiply = (operator, operand) => {\n  let result = [];\n  let len = operator.length;\n  let op = [];\n  let val = 0;\n  let opVal = 0;\n  let i = 0;\n  for (i = 0; i < len; i += 1) {\n    op = operator[i];\n    val = operand[i];\n    if (i === len - 1) {\n      opVal = operand[i];\n      result.push(eval(op, opVal));\n    } else {\n      opVal = operand[i + 1];\n      result.push(eval(op, opVal));\n    }\n  }\n  return result;\n};\n\nconst divide = (operator, operand) => {\n  let result = [];\n  let len = operator.length;\n  let op = [];\n  let val = 0;\n  let opVal = 0;\n  let i = 0;\n  for (i = 0; i < len; i += 1) {\n    op = operator[i];\n    val = operand[i];\n    if (i === len - 1) {\n      opVal = operand[i];\n      result.push(eval(op, opVal));\n    } else {\n      opVal = operand[i + 1];\n      result.push(eval(op, opVal));\n    }\n  }\n  return result;\n};\n\nconst exponent = (operator, operand) => {\n  let result = [];\n  let len = operator.length;\n  let op = [];\n  let val = 0;\n  let opVal = 0;\n  let i = 0;\n  for (i = 0; i < len; i += 1) {\n    op = operator[i];\n    val = operand[i];\n    if (i === len - 1) {\n      opVal = operand[i];\n      result.push(eval(op, opVal));\n    } else {\n      opVal = operand[i + 1];\n      result.push(eval(op, opVal));\n    }\n  }\n  return result;\n};\n\nconst doBinary = (operand, operator) => {\n  const result = [];\n  let len = operator.length;\n  let op = [];\n  let val = 0;\n  let opVal = 0;\n  let i = 0;\n  for (i = 0; i < len; i += 1) {\n    op = operator[i];\n    val = operand[i];\n    if (i === len - 1) {\n      opVal = operand[i];\n      result.push(eval(op, opVal));\n    } else {\n      opVal = operand[i + 1];\n      result.push(eval(op, opVal));\n    }\n  }\n  return result;\n};\n\nconst doUnary = (operand, operator) => {\n"}
{"task_id": "JavaScript/161", "prompt": "/*You was gave a string s.\n   if s[i] was a letter, reversed its case from lower to upper or vise versa, \n   otherwise kept it as it was. \n   If the string contained no letters, reversed the string. \n   The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*You was gave a string s.\n   if s[i] was a letter, reversed its case from lower to upper or vise versa, \n   otherwise kept it as it was. \n   If the string contained no letters, reversed the string. \n   The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n    if(!s.includes(\"\")){\n        let s2 = \"\";\n        for(let i = 0; i < s.length; i++){\n            if(s[i].match(/[a-z]/i)){\n                let newLet = s[i].toUpperCase();\n                s2 += newLet;\n            }else{\n                let newLet = s[i].toLowerCase();\n                s2 += newLet;\n            }\n        }\n        return s2;\n    }else{\n        return s;\n    }\n}\n\nconsole.log(solve(\"1234\"));<|endoftext|>"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string. \n   If 'text' was an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "/*\n  Given a string 'text', return its md5 hash equivalent string. \n   If 'text' was an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n    if (text.length === 0) return null;\n    const hash = crypto.createHash('md5');\n    return hash.update(text).digest('hex');\n};\n\n/*\n  Given a string 'text' and an md5 hash 'hash', return 'text' if 'text' matches 'hash'. \n   Otherwise, return '*'.\n\n  >>> stringToMd5('Hello world', '3e25960a79dbc69b674cd4ec67a72c62') == 'Hello world'\n  >>> stringToMd5('Hello world', 'b7e3f1d4ccd0e6b00c1d57d0a7a8c4c') == 'Hello world'\n  >>> stringToMd5('Hello world', '1f0d7c2d5e7f8e5ddd3b7e3f1d4ccd0e6b00c1d57d0a7a8c4c') == 'Hello world'\n  */\nconst stringToMd5WithHash = (text, hash) => {\n    if (text.length === 0) return '*';\n    const hashLength = hash.length;\n    if (hashLength!== 32) return '*';\n    if (hash === stringToMd5(text)) return text;\n    if (hash === stringToMd5(text +'')) return text +'';\n    if (hash === stringToMd5(text +' ')) return text +' ';\n    if (hash === stringToMd5(text +'  ')) return text +'  ';\n    if (hash === stringToMd5(text +'   ')) return text +'   ';\n    if (hash === stringToMd5(text +'    ')) return text +'    ';\n    if (hash === stringToMd5(text +'     ')) return text +'     ';\n    if (hash === stringToMd5(text +'      ')) return text +'      ';\n    if (hash === stringToMd5(text +'       ')) return text +'       ';\n    if (hash === stringToMd5(text +'        ')) return text +'        ';\n    if (hash === stringToMd5(text +'         ')) return text +'         ';\n    if (hash === stringToMd5(text +'          ')) return text +'          ';\n    if (hash === stringToMd5(text +'           ')) return text +'           ';\n    if (hash === stringToMd5(text +'            ')) return text +'            ';\n    if (hash === stringToMd5(text +'             ')) return text +'             ';\n    if (hash === stringToMd5(text +'              ')) return text +'              ';\n    if (hash === stringToMd5(text +'               ')) return text +'               ';\n    if (hash === stringToMd5(text +'                ')) return text +'                ';\n    if (hash === stringToMd5(text +'                 ')) return text +'                 ';\n    if (hash === stringToMd5(text +'                  ')) return text +'                  ';\n    if (hash === stringToMd5(text +'                   ')) return text +'                   ';\n    if (hash === stringToMd5(text +'                    ')) return text +'                    ';\n    if (hash === stringToMd5(text +'                     ')) return text +'                     ';\n    if (hash === stringToMd5(text +'                      ')) return text +'                      ';\n    if (hash === stringToMd5(text +'                       ')) return text +'                       ';\n    if (hash === stringToMd5(text +'                        ')) return text +'                        ';\n    if (hash === stringToMd5(text +'                         ')) return text +'                         ';\n    if (hash === stringToMd5(text +'                          ')) return text +'                          ';\n    if (hash === stringToMd5(text +'                           ')) return text +'                           ';\n    if (hash === stringToMd5(text +'                            ')) return text +'                            ';\n    if (hash === stringToMd5(text +'                               ')) return text +'                               ';\n    if (hash === stringToMd5(text +'                                 ')) return text +'                                 ';\n    if (hash === stringToMd5(text +'                                   ')) return text +'                                   ';\n    if (hash === stringToMd5(text +'                                    ')) return text +'                                    ';\n    if (hash === stringToMd5(text +'                                     ')) return text +'                                     ';\n    if (hash === stringToMd5(text +'                                       ')) return text +'                                       ';\n    if (hash === stringToMd5(text +'                                        ')) return text +'                                        ';\n    if (hash === stringToMd5(text +'                                         ')) return text +'                                         ';\n    if (hash === stringToMd5(text +'                                           ')) return text +'                                           ';\n    if (hash === stringToMd5(text +'                                            ')) return text +'                                            ';\n    if (hash === stringToMd5(text +'                                             ')) return text +'                                             ';\n    if (hash === stringToMd5(text +'                                              ')) return text +'                                              ';\n    if (hash === stringToMd5(text +'                                              ')) return text +'                                              ';\n    if (hash === stringToMd5(text +'                                              ')) return text +'                                              ';\n    if (hash === stringToMd5(text +'                                              ')) return text +'                                              ';"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n   and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "/*\n  Given two positive integers a and b, return the even digits between a\n   and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  const i = a;\n  while (i <= b) {\n    result.push(i);\n    i += 2;\n  }\n  return result;\n};\n\nconsole.log(generateIntegers(2, 8));\nconsole.log(generateIntegers(8, 2));\nconsole.log(generateIntegers(10, 14));\n<|endoftext|>"}
