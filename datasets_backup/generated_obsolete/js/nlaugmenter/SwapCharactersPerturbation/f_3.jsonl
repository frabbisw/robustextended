{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each otehr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "/* Check if in given list of numbers, are any two numbers closer to each otehr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  return _.every(numbers, (num) => {\n    let next = numbers.slice(numbers.indexOf(num) + 1);\n    return _.some(next, (num2) => {\n      return (Math.abs(num - num2) < threshold);\n    });\n  });\n};\n\n/* Check if a number is a prime number\n  >>> isPrime(1)\n  false\n  >>> isPrime(2)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(8)\n  true\n  >>> isPrime(16)\n  true\n  >>> isPrime(21)\n  false\n  >>> isPrime(23)\n  false\n  >>> isPrime(33)\n  false\n  >>> isPrime(101)\n  true\n  */\nconst isPrime = (number) => {\n  return _.every(range(2, number + 1), (num) => {\n    return _.some(range(2, number), (num2) => {\n      return (num % num2 === 0);\n    });\n  });\n};\n\n/* Check if a number is an even number\n  >>> isEven(1)\n  false\n  >>> isEven(2)\n  true\n  >>> isEven(4)\n  true\n  >>> isEven(8)\n  false\n  >>> isEven(21)\n  false\n  >>> isEven(23)\n  false\n  >>> isEven(33)\n  false\n  >>> isEven(101)\n  true\n  */\nconst isEven = (number) => {\n  return (number % 2 === 0);\n};\n\n/* Check if a number is a power of 2\n  >>> isPowerOf2(1)\n  false\n  >>> isPowerOf2(2)\n  true\n  >>> isPowerOf2(4)\n  false\n  >>> isPowerOf2(8)\n  true\n  >>> isPowerOf2(16)\n  false\n  >>> isPowerOf2(21)\n  false\n  >>> isPowerOf2(23)\n  false\n  >>> isPowerOf2(33)\n  false\n  >>> isPowerOf2(101)\n  true\n  */\nconst isPowerOf2 = (number) => {\n  return (number === Math.pow(2, Math.ceil(Math.log(number) / Math.log(2))));\n};\n\n/* Check if a number is prime\n  >>> isPrime(0)\n  false\n  >>> isPrime(1)\n  false\n  >>> isPrime(2)\n  true\n  >>> isPrime(3)\n  false\n  >>> isPrime(4)\n  false\n  >>> isPrime(5)\n  false\n  >>> isPrime(6)\n  false\n  >>> isPrime(7)\n  false\n  >>> isPrime(8)\n  true\n  >>> isPrime(9)\n  false\n  >>> isPrime(10)\n  false\n  >>> isPrime(11)\n  false\n  >>> isPrime(12)\n  false\n  >>> isPrime(13)\n  false\n  >>> isPrime(14)\n  false\n  >>> isPrime(15)\n  false\n  >>> isPrime(16)\n  false\n  >>> isPrime(17)\n  false\n  >>> isPrime(18)\n  false\n  >>> isPrime(19)\n  false\n  >>> isPrime(20)\n  false\n  >>> isPrime(21)\n  false\n  >>> isPrime(22)\n  false\n  >>> isPrime(23)\n  false\n  >>> isPrime(24)\n  false\n  >>> isPrime(25)\n  false\n  >>> isPrime(26)\n  false\n  >>> isPrime(27)\n  false\n  >>> isPrime(28)\n  false\n  >>> isPrime(29)\n  false\n  >>> isPrime(30)\n  false\n  >>> isPrime(31)\n  false\n  >>> isPrime(32)\n  false\n  >>> isPrime(33)\n  false\n  >>> isPrime(34)\n  false\n  >>> isPrime(35)\n  false\n  >>> isPrime(36)\n  false\n  >>> isPrime(37)\n  false\n  >>> isPrime(38)\n  false\n  >>> isPrime(39)\n  false\n  >>> isPrime(40)\n  false\n  >>> isPrime(41)\n  false\n  >>> isPrime(42)\n  false\n  >>> isPrime(43)\n  false\n  >>> isPrime(44)\n  false\n  >>> isPrime(45)\n  false\n  >>> isPrime(46)\n  false\n  >>> isPrime(47)\n  false\n  >>> isPrime(48)\n  false\n  >>> isPrime(49)\n  false\n  >>> isPrime(50)\n  false\n  >>> isPrime(51)\n  false\n  >>> isPrime(52)\n  false\n  >>> isPrime(53)\n  false\n  >>> isPrime(54)\n  false\n  >>> isPrime(55)\n  false\n  >>> isPrime(56)\n  false\n  >>> isPrime(57)\n  false\n  >>> isPrime(58)\n  false\n  >>> isPrime(59)\n  false\n  >>> isPrime(60)\n  false\n  >>> isPrime(61)\n  false\n  >>> isPrime(62)\n  false\n  >>> isPrime(63)\n  false\n  >>> isPrime(64)\n  false\n  >>> isPrime(65)\n  false\n  >>> isPrime(66)\n  false\n  >>> isPrime(67)\n  false\n  >>> isPrime(68)\n  false\n  >>> isPrime(69)\n  false\n  >>> isPrime(70)\n  false\n  >>> isPrime(71)\n  false\n  >>> isPrime(72)\n  false\n  >>> isPrime(73)\n  false\n  >>> isPrime(74)\n  false\n  >>> isPrime(75)\n  false\n  >>> isPrime(76)\n  false\n  >>> isPrime(77)\n  false\n  >>>"}
{"task_id": "JavaScript/1", "prompt": "/* Input to this functoin is a string cotnainnig multiple groups of entsed parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each opne brace is properly clsoed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "/* Input to this functoin is a string cotnainnig multiple groups of entsed parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each opne brace is properly clsoed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const result = [];\n  const stack = [];\n  const current_string = '';\n  const current_index = 0;\n  const is_opening_paren = true;\n  let current_char = paren_string[current_index];\n  while (current_index < paren_string.length) {\n    if (current_char === '(') {\n      if (is_opening_paren) {\n        stack.push(current_string);\n      }\n      current_string = paren_string.slice(current_index, paren_string.length);\n      current_index = paren_string.length;\n    } else if (current_char === ')') {\n      if (is_opening_paren) {\n        if (stack.length > 0) {\n          stack.pop();\n          result.push(stack.join(''));\n          stack = [];\n        }\n      } else {\n        stack.push(current_string);\n      }\n      current_string = paren_string.slice(current_index, paren_string.length);\n      current_index = paren_string.length;\n    } else if (current_char === '(') {\n      stack.push(current_string);\n      current_string = '';\n      current_index++;\n    } else if (current_char === ')') {\n      if (stack.length > 0) {\n        stack.pop();\n        current_string = stack.join('');\n      } else {\n        current_string = paren_string.slice(current_index, paren_string.length);\n        current_index = paren_string.length;\n      }\n    } else {\n      current_string += current_char;\n      current_index++;\n    }\n    current_char = paren_string[current_index];\n  }\n  if (stack.length > 0) {\n    result.push(stack.join(''));\n  }\n  return result;\n};\n\nconsole.log(separateParenGroups('( ) (( )) (( )( ))'));\n<|endoftext|>"}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "/* Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n    const intPart = Math.floor(number);\n    const decPart = number - intPart;\n    return decPart;\n};\n\n/** Given a number, it can be decomposed into an integer part and a decimal part\n  (decimal part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateDecimal(3.5)\n  3.0\n  >>> truncateDecimal(3.05)\n  3.0\n  */\nconst truncateDecimal = (number) => {\n    const intPart = Math.floor(number);\n    const decPart = number - intPart;\n    return intPart;\n};\n\n/** Given a number, it can be decomposed into an integer part and a decimal part\n  (decimal part always smaller than 1).\n\n  Return the number in scientific notation.\n  >>> truncateScientific(3.5)\n  3.5e+0\n  >>> truncateScientific(3.05)\n  3.0e+0\n  >>> truncateScientific(0.5)\n  0.5e+0\n  >>> truncateScientific(-3.5)\n  -3.5e+0\n  >>> truncateScientific(-3.05)\n  -3.0e+0\n  >>> truncateScientific(0.05)\n  5.0e-1\n  >>> truncateScientific(0.0005)\n  5.0e-3\n  */\nconst truncateScientific = (number) => {\n    const intPart = Math.floor(number);\n    const decPart = number - intPart;\n    if (decPart < 0.1) {\n        return intPart.toString();\n    } else if (decPart < 0.01) {\n        return intPart.toString() + 'e+0';\n    } else if (decPart < 0.001) {\n        return intPart.toString() + 'e+1';\n    } else if (decPart < 0.0001) {\n        return intPart.toString() + 'e+2';\n    } else {\n        return intPart.toString() + 'e+3';\n    }\n};\n\n// Export module\nmodule.exports = {\n    truncateNumber,\n    truncateDecimal,\n    truncateScientific\n};\n<|endoftext|>"}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n\n  operations.forEach((op) => {\n    if (op.amount < 0) {\n      balance -= op.amount;\n    } else {\n      balance += op.amount;\n    }\n  });\n\n  return balance < 0;\n};\n\nexport default belowZero;\n<|endoftext|>"}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const sum = numbers.reduce((sum, x) => sum + x, 0);\n  const mean = sum / numbers.length;\n  const diffs = numbers.map((x) => Math.abs(x - mean));\n  return (diffs.reduce((sum, d) => sum + d, 0) / numbers.length) / mean;\n};\n\nmodule.exports = meanAbsoluteDeviation;\n<|endoftext|>"}
{"task_id": "JavaScript/5", "prompt": "/* Insetr a number 'delimeter' bteween every two conescutive eelments of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": true, "gc": "/* Insetr a number 'delimeter' bteween every two conescutive eelments of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  return [...new Array(Math.floor((numbers.length - 1) / 2)).map((_, i) => numbers[i * 2])].concat(\n    [...new Array(Math.floor((numbers.length - 1) / 2)).map((_, i) => numbers[i * 2 + 1])].reverse()\n  );\n};\n<|endoftext|>"}
{"task_id": "JavaScript/6", "prompt": "/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let levels = [1];\n  let last_level = 1;\n  let current_level = 1;\n  let levels_seen = 0;\n  paren_string.split(' ').forEach((item) => {\n    if (item === '(') {\n      levels.push(current_level);\n      levels_seen += 1;\n    } else if (item === ')') {\n      current_level -= 1;\n      last_level -= 1;\n    }\n  });\n  return levels.sort(function(a, b) {\n    return b - a;\n  });\n};\n\nmodule.exports = parseNestedParens;\n<|endoftext|>"}
{"task_id": "JavaScript/7", "prompt": "/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\nexport default filterBySubstring;\n<|endoftext|>"}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "/* For a given list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0\n  const product = 1\n\n  for (let i = 0; i < numbers.length; i++) {\n    const sumPlusNumber = sum + numbers[i]\n    const productTimesNumber = product * numbers[i]\n    sum = sumPlusNumber\n    product = productTimesNumber\n  }\n\n  return [sum, product]\n}\n\nexport default sumProduct\n<|endoftext|>"}
{"task_id": "JavaScript/9", "prompt": "/* From a gievn list of nitegers, genearte a list of rolling maximum elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "/* From a gievn list of nitegers, genearte a list of rolling maximum elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = _.max(numbers)\n  const min = _.min(numbers)\n  let result = []\n  let current = max\n  let last = -Infinity\n  while (current!== min) {\n    result.push(current)\n    last = current\n    current = _.max(_.takeRight(numbers, 1))\n  }\n  result.push(last)\n  return result\n}\n\nmodule.exports = rollingMax\n<|endoftext|>"}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Fnid the sohertst aplindrome that begins with a supplied string.\n  Algorithm idae si simple:\n  - iFnd the longset postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before hte plaindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Fnid the sohertst aplindrome that begins with a supplied string.\n  Algorithm idae si simple:\n  - iFnd the longset postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before hte plaindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const palindrome = isPalindrome(string);\n  if (!palindrome) {\n    return '';\n  }\n  return string + string.substring(0, string.length - palindrome.length)\n   .split('').reverse().join('');\n}\n\nmodule.exports = makePalindrome;\n<|endoftext|>"}
{"task_id": "JavaScript/11", "prompt": "/* Inptu are two strings a and b consisting only of 1s and 0s.\n  ePrform binary XOR on these inputs and return reuslt also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "/* Inptu are two strings a and b consisting only of 1s and 0s.\n  ePrform binary XOR on these inputs and return reuslt also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const a_length = a.length;\n  const b_length = b.length;\n  const length = a_length + b_length;\n  const result = new Array(length);\n  let result_index = 0;\n  for (let i = 0; i < a_length; i++) {\n    for (let j = 0; j < b_length; j++) {\n      result[result_index] = a[i] ^ b[j];\n      result_index++;\n    }\n  }\n  return result.join('');\n};\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings.\n  >>> concat('ab', 'cde')\n  'abcde'\n  */\nconst concat = (a, b) => a + b;\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, in reverse order.\n  >>> revconcat('ab', 'cde')\n  'cdeab'\n  */\nconst revconcat = (a, b) => b + a;\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, with a space in between.\n  >>> spaceconcat('ab', 'cde')\n  'ab cde'\n  */\nconst spaceconcat = (a, b) => a +'' + b;\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, in reverse order, with a space in between.\n  >>> revspaceconcat('ab', 'cde')\n  'cdeab '\n  */\nconst revspaceconcat = (a, b) => b +'' + a;\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, with spaces removed.\n  >>> spaceconcat('ab', 'cde')\n  'abcd'\n  */\nconst spaceconcat = (a, b) => a + b.replace(/ /g, '');\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, with spaces removed, in reverse order.\n  >>> revspaceconcat('ab', 'cde')\n  'cdedb'\n  */\nconst revspaceconcat = (a, b) => b + a.replace(/ /g, '');\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, with spaces removed, in reverse order, with a space in between.\n  >>> revspaceconcat('ab', 'cde')\n  'cdeab '\n  */\nconst revspaceconcat = (a, b) => b +'' + a.replace(/ /g, '');\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, with spaces removed, in reverse order, with a space in between,\n  with a different length of space added after the second string.\n  >>> spaceconcat('ab', 'cde')\n  'ab cde'\n  */\nconst spaceconcat = (a, b) => a +'' + b.replace(/ /g, '');\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, with spaces removed, in reverse order, with a space in between,\n  with a different length of space added after the second string.\n  >>> revspaceconcat('ab', 'cde')\n  'cdeab '\n  */\nconst revspaceconcat = (a, b) => b +'' + a.replace(/ /g, '');\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, with spaces removed, in reverse order, with a space in between,\n  with a different length of space added after the second string, in reverse\n  order.\n  >>> revspaceconcat('ab', 'cde')\n  'cdeab '\n  */\nconst revspaceconcat = (a, b) => b +'' + a.replace(/ /g, '');\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, with spaces removed, in reverse order, with a space in between,\n  with a different length of space added after the second string, in reverse\n  order.\n  >>> revspaceconcat('ab', 'cde')\n  'cdeab '\n  */\nconst revspaceconcat = (a, b) => b +'' + a.replace(/ /g, '');\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, with spaces removed, in reverse order, with a space in between,\n  with a different length of space added after the second string, in reverse\n  order, with a different length of space added after the second string.\n  >>> spaceconcat('ab', 'cde')\n  'ab cde'\n  */\nconst spaceconcat = (a, b) => a +'' + b.replace(/ /g, '');\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, with spaces removed, in reverse order, with a space in between,\n  with a different length of space added after the second string, in reverse\n  order, with a different length of space added after the second string, in\n  reverse order.\n  >>> revspaceconcat('ab', 'cde')\n  'cdeab '\n  */\nconst revspaceconcat = (a, b) => b +'' + a.replace(/ /g, '');\n\n/*\n  Given two strings a and b, return the result of the concatenation of these\n  two strings, with spaces removed, in reverse order, with a space in between,\n  with a different length of space added after the second string, in reverse\n  order, with a different length of space added after the second string, in\n  reverse order.\n  >>> revspaceconcat('ab', 'cde')\n  'c"}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Retrun the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "/* Out of list of strings, return the longest one. Retrun the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longestStr = strings[0]\n  strings.forEach((str) => {\n    if (str.length > longestStr.length) {\n      longestStr = str\n    }\n  })\n  return longestStr\n}\n\nmodule.exports = longest\n<|endoftext|>"}
{"task_id": "JavaScript/13", "prompt": "/* Return a gretaest common divisor of two integesr a nad b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "/* Return a gretaest common divisor of two integesr a nad b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  const l = Math.abs(a)\n  const r = Math.abs(b)\n  const d = 1\n  while (r > 0) {\n    const t = r\n    r = l % r\n    l = t\n  }\n  return l\n}\n\n/* Return a gretaest common divisor of two integesr a nad b\n  >>> greatestCommonDivisor(3, -5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisorNeg = (a, b) => {\n  const l = Math.abs(a)\n  const r = Math.abs(b)\n  const d = 1\n  while (r > 0) {\n    const t = r\n    r = l % r\n    l = t\n  }\n  return l\n}\n\nconst gcd = (a, b) => {\n  const gcd = greatestCommonDivisor(a, b)\n  if (gcd > 1) return gcd\n  return greatestCommonDivisorNeg(a, b)\n}\n\n/* Return a gretaest common multiple of two integesr a nad b\n  >>> greatestCommonMultiple(3, 5)\n  15\n  >>> greatestCommonMultiple(25, 15)\n  50\n  */\nconst greatestCommonMultiple = (a, b) => {\n  const l = Math.abs(a)\n  const r = Math.abs(b)\n  const m = gcd(l, r)\n  return (l * r) / m\n}\n\nconst lcm = (a, b) => {\n  const l = greatestCommonMultiple(a, b)\n  return a * b / l\n}\n\nconst mod = (a, b) => {\n  const m = a % b\n  return m\n}\n\nconst mod2 = (a, b) => {\n  const m = mod(a, b)\n  return m % b\n}\n\n/* Return the sum of two integers\n  >>> sum(1, 2)\n  3\n  >>> sum(0, 2)\n  2\n  */\nconst sum = (a, b) => {\n  return a + b\n}\n\nconst sumNeg = (a, b) => {\n  return a - b\n}\n\n/* Return the difference of two integers\n  >>> difference(1, 2)\n  -1\n  >>> difference(0, 2)\n  2\n  */\nconst difference = (a, b) => {\n  return a - b\n}\n\nconst differenceNeg = (a, b) => {\n  return a + b\n}\n\n/* Return the product of two integers\n  >>> product(1, 2)\n  2\n  >>> product(0, 2)\n  0\n  */\nconst product = (a, b) => {\n  return a * b\n}\n\nconst productNeg = (a, b) => {\n  return a / b\n}\n\n/* Return the quotient of two integers\n  >>> quotient(1, 2)\n  1\n  >>> quotient(0, 2)\n  0\n  */\nconst quotient = (a, b) => {\n  return a / b\n}\n\nconst quotientNeg = (a, b) => {\n  return a * b\n}\n\n/* Return the remainder of two integers\n  >>> remainder(1, 2)\n  1\n  >>> remainder(0, 2)\n  0\n  */\nconst remainder = (a, b) => {\n  return a % b\n}\n\nconst remainderNeg = (a, b) => {\n  return a - b\n}\n\n/* Return the absolute value of an integer\n  >>> absoluteValue(1)\n  1\n  >>> absoluteValue(-1)\n  1\n  */\nconst absoluteValue = (a) => {\n  return a > 0? a : -a\n}\n\n/* Return the absolute value of an integer\n  >>> absoluteValue(1)\n  1\n  >>> absoluteValue(-1)\n  1\n  */\nconst absoluteValueNeg = (a) => {\n  return a < 0? a : -a\n}\n\n/* Return the bitwise and of two integers\n  >>> bitwiseAnd(1, 2)\n  2\n  >>> bitwiseAnd(0, 2)\n  0\n  */\nconst bitwiseAnd = (a, b) => {\n  return a & b\n}\n\n/* Return the bitwise or of two integers\n  >>> bitwiseOr(1, 2)\n  3\n  >>> bitwiseOr(0, 2)\n  2\n  */\nconst bitwiseOr = (a, b) => {\n  return a | b\n}\n\n/* Return the bitwise xor of two integers\n  >>> bitwiseXor(1, 2)\n  3\n  >>> bitwiseXor(0, 2)\n  2\n  */\nconst bitwiseXor = (a, b) => {\n  return a ^ b\n}\n\n/* Return the bitwise not of an integer\n  >>> bitwiseNot(1)\n  0\n  >>> bitwiseNot(0)\n  1\n  */\nconst bitwiseNot = (a) => {\n  return ~a\n}\n\n/* Return the bitwise shift left of an integer\n  >>> bitwiseShiftLeft(1, 1)\n  2\n  >>> bitwiseShiftLeft(0, 1)\n  0\n  >>> bitwiseShiftLeft(1, 0)\n  1\n  */\nconst bitwiseShiftLeft = (a, b) => {\n  return a << b\n}\n\n/* Return the bitwise shift right of an integer\n  >>> bitwiseShiftRight(1, 1)\n  1\n  >>> bitwiseShiftRight(0, 1)\n  0\n  >>> bitwiseShiftRight(1, 0)\n  1\n  */\nconst bitwiseShiftRight = (a, b) => {\n  return a >> b\n}\n\n/* Return the logical shift left of an integer\n  >>> logicalShiftLeft(1, 1)\n  2\n  >>> logicalShiftLeft(0, 1)\n  0\n  >>> logicalShiftLeft(1, 0)\n  1\n  */\nconst logicalShiftLeft = (a, b) => {\n  return a << b\n}\n\n/* Return the logical shift right of an"}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all preifxes frmo shortest to loengst of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "/* Return list of all preifxes frmo shortest to loengst of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes;\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string) => {\n  let prefixes = [string];\n  while (string.length > 1) {\n    prefixes = prefixes.concat(allPrefixes(string.slice(1)));\n  }\n  return prefixes.concat(string);\n};\n\n// Return list of all prefixes frmo shortest to longtst of the input string\nconst allPrefixesLongest = (string)"}
{"task_id": "JavaScript/15", "prompt": "/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/*\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`;\n  }\n  return str;\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i <= n; i++) {\n    str += `${i}`"}
{"task_id": "JavaScript/16", "prompt": "/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n    return string.split('').reduce((a, b) => {\n        if (a.indexOf(b)!== -1) {\n            return a.replace(b, '') + 1;\n        }\n        else {\n            return a;\n        }\n    });\n}\n\n// BEGIN SOLUTION\n/*\nconst countDistinctCharacters = (string) => {\n    const arr = new Set(string);\n    return arr.size;\n}\n*/\n// END SOLUTION\n\ndescribe('Test countDistinctCharacters', () => {\n    it('Test countDistinctCharacters', () => {\n        expect(countDistinctCharacters('xyzXYZ')).toEqual(3);\n        expect(countDistinctCharacters('Jerry')).toEqual(4);\n    });\n});\n\n/*\nconst countDistinctCharacters = (string) => {\n    const arr = new Set(string);\n    return arr.size;\n}\n*/\n// END SOLUTION\n<|endoftext|>"}
{"task_id": "JavaScript/17", "prompt": "/* Inupt to thsi function is a strnig represenitng musical notes in a special ASCII fromat.\n  Your taks is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, alsst two beats\n  '.|' - quaetr note, lasts oen beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "/* Inupt to thsi function is a strnig represenitng musical notes in a special ASCII fromat.\n  Your taks is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, alsst two beats\n  '.|' - quaetr note, lasts oen beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_list = music_string.split(\" \");\n  const result = [];\n  for (let i = 0; i < music_list.length; i++) {\n    const beat_list = music_list[i].split(\"|\");\n    const note_list = beat_list[0].split(\" \");\n    const num_of_beats = beat_list[1];\n    const beat_num = 1;\n    for (let j = 0; j < num_of_beats; j++) {\n      result.push(beat_num);\n      beat_num += 1;\n    }\n  }\n  return result;\n};\n\n/*\n  * Inupt to thsi function is a string representing a song. The function will return a list of all the\n  * tracks in the song.\n\n  Here is a legend:\n  'o o|.| o o|.| o o|.| o o|.| o o' - first track\n  'o o|.| o o|.| o o|.| o o|.| o o' - second track\n ...\n  'o o|.| o o|.| o o|.| o o|.| o o' - last track\n\n  >>> parseMusic('o o|.| o o|.| o o|.| o o|.| o o')\n  ['o o|.| o o|.| o o|.| o o|.| o o', 'o o|.| o o|.| o o',..., 'o o|.| o o|.| o o|.| o o']\n  */\nconst parseTracks = (song_string) => {\n  const tracks_list = song_string.split(\" \");\n  const result = [];\n  for (let i = 0; i < tracks_list.length; i++) {\n    result.push(tracks_list[i]);\n  }\n  return result;\n};\n\nconst parse = (music_string) => {\n  const tracks = parseTracks(music_string);\n  const beats = parseMusic(music_string);\n  const track_length = tracks.length;\n  const total_beats = beats.length;\n\n  // for every track in the song\n  for (let i = 0; i < track_length; i++) {\n    const beats_to_track = beats[i];\n    const beat_length = beats_to_track.length;\n    const track_beats = [];\n    for (let j = 0; j < beat_length; j++) {\n      const beat = beats_to_track[j];\n      // for every beat in the track\n      for (let k = 0; k < beat; k++) {\n        const note_string = parseNote(tracks[i][j]);\n        const beat_note = note_string.length;\n        track_beats.push(beat_note);\n      }\n    }\n    const total_notes = track_beats.length;\n    // for every beat in the track\n    for (let j = 0; j < beat_length; j++) {\n      const beat = beats_to_track[j];\n      // for every note in the beat\n      for (let k = 0; k < total_notes; k++) {\n        const note = track_beats[k];\n        // for every note in the track\n        for (let l = 0; l < note; l++) {\n          const note_number = parseNote(tracks[i][j]);\n          const beat_number = parseBeat(beat);\n          console.log(`${beat_number}:${note_number}`);\n        }\n      }\n    }\n  }\n};\n\nconst song = `o o|.| o o|.| o o|.| o o|.| o o`;\n\nparse(song);\n<|endoftext|>"}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n    let count = 0;\n    for (let i = 0; i < string.length; i++) {\n        count += string.indexOf(substring, i)!== -1? 1 : 0;\n    }\n    return count;\n};\n\n/**\n  * @name getCharAt\n  * @description\n  * Returns the char at the given index. If index is out of bounds, returns undefined.\n  * @example\n  * const string = 'abc';\n  * getCharAt(0)  // returns 'a'\n  * getCharAt(1)  // returns 'b'\n  * getCharAt(2)  // returns 'c'\n  * getCharAt(3)  // returns undefined\n  */\nconst getCharAt = (index) => {\n    if (index < 0 || index > string.length - 1) {\n        return undefined;\n    }\n    return string.charAt(index);\n};\n\n/**\n  * @name insert\n  * @description\n  * Inserts a character at the given index. If index is out of bounds, inserts the character at the end of the string.\n  * @example\n  * const string = 'abc';\n  * insert(1, 'x');  // returns 'axbc'\n  * insert(1, 'x', 1);  // returns 'axxbc'\n  * insert(1, 'x', 3);  // returns 'axxxbc'\n  * insert(1, 'x', 5);  // returns 'axxxxxbc'\n  * insert(1, 'x', 6);  // returns 'axxxxxxbc'\n  */\nconst insert = (index, character, fromIndex = 0) => {\n    if (index < 0 || index > string.length) {\n        index = string.length;\n    }\n    const newString = string.slice(0, fromIndex) + character + string.slice(fromIndex);\n    return newString;\n};\n\n/**\n  * @name reverse\n  * @description\n  * Reverses the string.\n  * @example\n  * reverse('abc');  // returns 'cba'\n  * reverse('abcdefg');  // returns 'gfedcba'\n  */\nconst reverse = (string) => {\n    const newString = string.split('').reverse().join('');\n    return newString;\n};\n\n/**\n  * @name remove\n  * @description\n  * Removes a character at the given index. If index is out of bounds, does nothing.\n  * @example\n  * const string = 'abc';\n  * remove(1);  // returns 'abc'\n  * remove(2);  // returns 'abc'\n  * remove(3);  // does nothing\n  */\nconst remove = (index) => {\n    if (index < 0 || index > string.length - 1) {\n        return string;\n    }\n    return string.slice(0, index) + string.slice(index + 1);\n};\n\n/**\n  * @name repeat\n  * @description\n  * Repeats a character count times. If count is negative, repeats infinitely.\n  * @example\n  * const string = 'abc';\n  * repeat('x', 2)  // returns 'xxxxx'\n  * repeat('x', -2)  // returns 'xxxxx'\n  * repeat('x', 3)  // returns 'xxxxxxx'\n  * repeat('x', -3)  // returns 'xxxxxxx'\n  * repeat('x', 4)  // returns 'xxxxxxxx'\n  * repeat('x', -4)  // returns 'xxxxxxxx'\n  */\nconst repeat = (character, count) => {\n    if (count < 0) {\n        return repeat(character, Math.abs(count));\n    }\n    let newString = character;\n    for (let i = 0; i < count; i++) {\n        newString += character;\n    }\n    return newString;\n};\n\n/**\n  * @name startsWith\n  * @description\n  * Tests if a string starts with a given prefix.\n  * @example\n  * startsWith('abc', 'abc')  // returns true\n  * startsWith('abc', 'a')  // returns false\n  * startsWith('abc', 'ab')  // returns false\n  */\nconst startsWith = (string, prefix) => {\n    return string.indexOf(prefix) === 0;\n};\n\n/**\n  * @name trim\n  * @description\n  * Removes leading and trailing whitespaces from a string.\n  * @example\n  * trim('    abc')  // returns 'abc'\n  */\nconst trim = (string) => {\n    return string.replace(/^\\s+|\\s+$/g, '');\n};\n\n/**\n  * @name toLowerCase\n  * @description\n  * Converts a string to lower case.\n  * @example\n  * toLowerCase('ABC')  // returns 'abc'\n  */\nconst toLowerCase = (string) => {\n    return string.toLowerCase();\n};\n\n/**\n  * @name toUpperCase\n  * @description\n  * Converts a string to upper case.\n  * @example\n  * toUpperCase('abc')  // returns 'ABC'\n  */\nconst toUpperCase = (string) => {\n    return string.toUpperCase();\n};\n\nexport {\n    all,\n    any,\n    concat,\n    equals,\n    getCharAt,\n    insert,\n    isEmpty,\n    isNumeric,\n    isPresent,\n    isString,\n    length,\n    repeat,\n    remove,\n    reverse,\n    startsWith,\n    trim,\n    toLowerCase,\n    toUpperCase\n};\n<|endoftext|>"}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choicse are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string wtih numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choicse are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string wtih numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  return new Promise((resolve, reject) => {\n    if (numbers.length === 0) {\n      resolve('')\n    }\n    const numbersArr = numbers.split(' ')\n    const numbersArrLen = numbersArr.length\n    let sortedArr = []\n    let sortedArrIndex = 0\n    for (let i = 0; i < numbersArrLen; i++) {\n      sortedArr[i] = parseInt(numbersArr[i])\n    }\n    sortedArr.sort((a, b) => {\n      if (a > b) return 1\n      if (a < b) return -1\n      return 0\n    })\n    for (let i = 0; i < sortedArrLen; i++) {\n      sortedArr[i] = sortedArr[i].toString()\n    }\n    sortedArr = sortedArr.join(' ')\n    resolve(sortedArr)\n  })\n}\n<|endoftext|>"}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list fo numbers (of length at least two) seelct and return two that are teh cloesst to each\n  toher and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "/* From a supplied list fo numbers (of length at least two) seelct and return two that are teh cloesst to each\n  toher and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const numbersLength = numbers.length;\n  const closestNumberToEachOther = (number1, number2) => {\n    const difference = number1 - number2;\n    if (Math.abs(difference) < Math.abs(numbers[0] - numbers[1])) {\n      return number1;\n    } else {\n      return number2;\n    }\n  };\n  return [\n    closestNumberToEachOther(numbers[0], numbers[1]),\n    closestNumberToEachOther(numbers[1], numbers[2]),\n  ];\n};\n\n// Find closest number to given number\nconst closestNumber = (numbers, number) => {\n  const numbersLength = numbers.length;\n  if (numbersLength < 2) {\n    return numbers[0];\n  }\n  const closestNumberToEachOther = (number1, number2) => {\n    const difference = number1 - number2;\n    if (Math.abs(difference) < Math.abs(numbers[0] - numbers[1])) {\n      return number1;\n    } else {\n      return number2;\n    }\n  };\n  return closestNumberToEachOther(number, numbers[0]);\n};\n\n// Find closest number to given number\nconst closestNumber2 = (numbers, number) => {\n  const numbersLength = numbers.length;\n  if (numbersLength < 2) {\n    return numbers[0];\n  }\n  const closestNumberToEachOther = (number1, number2) => {\n    const difference = number1 - number2;\n    if (Math.abs(difference) < Math.abs(numbers[0] - numbers[1])) {\n      return number1;\n    } else {\n      return number2;\n    }\n  };\n  return closestNumberToEachOther(number, numbers[1]);\n};\n\nconst closestNumber3 = (numbers, number) => {\n  const numbersLength = numbers.length;\n  if (numbersLength < 3) {\n    return numbers[0];\n  }\n  const closestNumberToEachOther = (number1, number2) => {\n    const difference = number1 - number2;\n    if (Math.abs(difference) < Math.abs(numbers[0] - numbers[1])) {\n      return number1;\n    } else {\n      return number2;\n    }\n  };\n  return closestNumberToEachOther(number, numbers[1]);\n};\n\nconst closestNumber4 = (numbers, number) => {\n  const numbersLength = numbers.length;\n  if (numbersLength < 3) {\n    return numbers[0];\n  }\n  const closestNumberToEachOther = (number1, number2) => {\n    const difference = number1 - number2;\n    if (Math.abs(difference) < Math.abs(numbers[0] - numbers[1])) {\n      return number1;\n    } else {\n      return number2;\n    }\n  };\n  return closestNumberToEachOther(number, numbers[2]);\n};\n\n// Find closest number to given number\nconst closestNumber5 = (numbers, number) => {\n  const numbersLength = numbers.length;\n  if (numbersLength < 3) {\n    return numbers[0];\n  }\n  const closestNumberToEachOther = (number1, number2) => {\n    const difference = number1 - number2;\n    if (Math.abs(difference) < Math.abs(numbers[0] - numbers[1])) {\n      return number1;\n    } else {\n      return number2;\n    }\n  };\n  return closestNumberToEachOther(number, numbers[1]);\n};\n\nconst closestNumber6 = (numbers, number) => {\n  const numbersLength = numbers.length;\n  if (numbersLength < 3) {\n    return numbers[0];\n  }\n  const closestNumberToEachOther = (number1, number2) => {\n    const difference = number1 - number2;\n    if (Math.abs(difference) < Math.abs(numbers[0] - numbers[1])) {\n      return number1;\n    } else {\n      return number2;\n    }\n  };\n  return closestNumberToEachOther(number, numbers[2]);\n};\n\nconst closestNumber7 = (numbers, number) => {\n  const numbersLength = numbers.length;\n  if (numbersLength < 3) {\n    return numbers[0];\n  }\n  const closestNumberToEachOther = (number1, number2) => {\n    const difference = number1 - number2;\n    if (Math.abs(difference) < Math.abs(numbers[0] - numbers[1])) {\n      return number1;\n    } else {\n      return number2;\n    }\n  };\n  return closestNumberToEachOther(number, numbers[2]);\n};\n\nconst closestNumber8 = (numbers, number) => {\n  const numbersLength = numbers.length;\n  if (numbersLength < 3) {\n    return numbers[0];\n  }\n  const closestNumberToEachOther = (number1, number2) => {\n    const difference = number1 - number2;\n    if (Math.abs(difference) < Math.abs(numbers[0] - numbers[1])) {\n      return number1;\n    } else {\n      return number2;\n    }\n  };\n  return closestNumberToEachOther(number, numbers[1]);\n};\n\nconst closestNumber9 = (numbers, number) => {\n  const numbersLength = numbers.length;\n  if (numbersLength < 3) {\n    return numbers[0];\n  }\n  const closestNumberToEachOther = (number1, number2) => {\n    const difference = number1 - number2;\n    if"}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": false, "gc": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const sortedNums = numbers.slice().sort()\n  return sortedNums.map((num) => num / sortedNums[sortedNums.length - 1])\n}\n\nconst applyTransform = (numbers, transform) => {\n  return numbers.map((num) => transform(num))\n}\n\nconst findNearest = (numbers, value) => {\n  const closest = numbers.filter((num) => num < value)\n  return closest.length > 0? closest[0] : numbers[0]\n}\n\nconst transform = (value, min, max) => {\n  return (value - min) / (max - min)\n}\n\nconst findNearestIndex = (numbers, value) => {\n  const closest = numbers.filter((num) => num < value)\n  return closest.length > 0? closest[0] : 0\n}\n\nconst findNearestInRange = (numbers, min, max) => {\n  const closest = numbers.filter((num) => num < min)\n  return closest.length > 0? closest[0] : numbers[0]\n}\n\nconst findNearestInRangeIndex = (numbers, min, max) => {\n  const closest = numbers.filter((num) => num < min)\n  return closest.length > 0? closest[0] : 0\n}\n\nconst scale = (numbers, min, max, transform) => {\n  return applyTransform(numbers, transform)\n}\n\nconst scaleToUnit = (numbers, min, max, transform) => {\n  return applyTransform(numbers, transform)\n}\n\nconst getNearest = (numbers, value) => {\n  const closest = numbers.filter((num) => num < value)\n  return closest.length > 0? closest[0] : numbers[0]\n}\n\nconst getNearestIndex = (numbers, value) => {\n  const closest = numbers.filter((num) => num < value)\n  return closest.length > 0? closest[0] : 0\n}\n\nconst getNearestInRange = (numbers, min, max) => {\n  const closest = numbers.filter((num) => num < min)\n  return closest.length > 0? closest[0] : numbers[0]\n}\n\nconst getNearestInRangeIndex = (numbers, min, max) => {\n  const closest = numbers.filter((num) => num < min)\n  return closest.length > 0? closest[0] : 0\n}\n\nconst getNearestInRangeTransform = (numbers, min, max, transform) => {\n  const closest = numbers.filter((num) => num < min)\n  return closest.length > 0? closest[0] : transform(min, min, max)\n}\n\nconst getNearestInRangeTransformIndex = (numbers, min, max, transform) => {\n  const closest = numbers.filter((num) => num < min)\n  return closest.length > 0? closest[0] : 0\n}\n\nconst getNearestInRangeTransformInverse = (numbers, min, max, transform) => {\n  const closest = numbers.filter((num) => num > max)\n  return closest.length > 0? closest[0] : transform(max, min, max)\n}\n\nconst getNearestInRangeTransformInverseIndex = (numbers, min, max, transform) => {\n  const closest = numbers.filter((num) => num > max)\n  return closest.length > 0? closest[0] : 0\n}\n\nconst getNearestInRangeTransformInverseInverse = (numbers, min, max, transform) => {\n  const closest = numbers.filter((num) => num > min)\n  return closest.length > 0? closest[0] : transform(min, min, max)\n}\n\nconst getNearestInRangeTransformInverseInverseIndex = (numbers, min, max, transform) => {\n  const closest = numbers.filter((num) => num > min)\n  return closest.length > 0? closest[0] : 0\n}\n\nconst getNearestInRangeTransformInverseInverseInverse = (numbers, min, max, transform) => {\n  const closest = numbers.filter((num) => num < min)\n  return closest.length > 0? closest[0] : transform(min, min, max)\n}\n\nconst getNearestInRangeTransformInverseInverseInverseIndex = (numbers, min, max, transform) => {\n  const closest = numbers.filter((num) => num < min)\n  return closest.length > 0? closest[0] : 0\n}\n\nconst getNearestInRangeTransformInverseInverseInverseInverse = (numbers, min, max, transform) => {\n  const closest = numbers.filter((num) => num > max)\n  return closest.length > 0? closest[0] : transform(max, min, max)\n}\n\nconst getNearestInRangeTransformInverseInverseInverseInverseIndex = (numbers, min, max, transform) => {\n  const closest = numbers.filter((num) => num > max)\n  return closest.length > 0? closest[0] : 0\n}\n<|endoftext|>"}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of nay python values only for integres\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "/* Filter given list of nay python values only for integres\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter((val) => {\n    return isInteger(val)\n  })\n}\n\nexport default {\n  isInteger,\n  filterIntegers\n}\n<|endoftext|>"}
{"task_id": "JavaScript/23", "prompt": "/* Return lnegth of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "/* Return lnegth of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/** Return index of given string\n  >>> strindex('abcdefg', 'a')\n  0\n  >>> strindex('abcdefg', 'z')\n  -1\n  */\nconst strindex = (string, substr) => {\n  let index = string.indexOf(substr)\n  return index < 0? -1 : index\n}\n\n/** Return last index of given string\n  >>> strlastindex('abcdefg', 'a')\n  4\n  >>> strlastindex('abcdefg', 'z')\n  -1\n  */\nconst strlastindex = (string, substr) => {\n  let index = string.lastIndexOf(substr)\n  return index < 0? -1 : index\n}\n\n/** Return all strings of given string\n  >>> strsplit('abcdefg', 'a')\n  ['b', 'c', 'd', 'efg']\n  >>> strsplit('abcdefg', 'z')\n  []\n  */\nconst strsplit = (string, substr) => {\n  let split = []\n  let index = 0\n  let length = strlen(string)\n  while (index < length) {\n    let indexOfSubstr = strindex(string, substr, index)\n    if (indexOfSubstr < 0) {\n      break\n    }\n    let substrStr = string.substr(index, indexOfSubstr)\n    split.push(substrStr)\n    index = indexOfSubstr + 1\n  }\n  return split\n}\n\n/** Return all strings of given string\n  >>> strsubstr('abcdefg', 'a')\n  ['b', 'c', 'd', 'efg']\n  >>> strsubstr('abcdefg', 'z')\n  []\n  */\nconst strsubstr = (string, substr) => {\n  let split = strsplit(string, substr)\n  let result = []\n  for (let i = 0; i < split.length; i++) {\n    let index = strlastindex(string, substr)\n    result.push(string.substr(index))\n  }\n  return result\n}\n\n/** Return all strings of given string\n  >>> strregex('')\n  []\n  >>> strregex('abcdefg')\n  ['abcdefg']\n  >>> strregex('abcdefg')\n  ['abcdefg']\n  >>> strregex('abcdefg')\n  ['abcdefg']\n  >>> strregex('abcdefg')\n  ['abcdefg']\n  >>> strregex('abcdefg')\n  ['abcdefg']\n  */\nconst strregex = (string, regex) => {\n  let reg = new RegExp(regex)\n  let result = []\n  let index = 0\n  let length = strlen(string)\n  while (index < length) {\n    let match = reg.exec(string)\n    if (match == null) {\n      break\n    }\n    let substr = string.substr(index, match.index)\n    result.push(substr)\n    index = match.index + match[0].length\n  }\n  return result\n}\n\n/** Return all strings of given string\n  >>> strregex('')\n  []\n  >>> strregex('abcdefg')\n  ['abcdefg']\n  >>> strregex('abcdefg')\n  ['abcdefg']\n  >>> strregex('abcdefg')\n  ['abcdefg']\n  >>> strregex('abcdefg')\n  ['abcdefg']\n  >>> strregex('abcdefg')\n  ['abcdefg']\n  */\nconst strregex = (string, regex) => {\n  let reg = new RegExp(regex)\n  let result = []\n  let index = 0\n  let length = strlen(string)\n  while (index < length) {\n    let match = reg.exec(string)\n    if (match == null) {\n      break\n    }\n    let substr = string.substr(index, match.index)\n    result.push(substr)\n    index = match.index + match[0].length\n  }\n  return result\n}\n\n/** Return all strings of given string\n  >>> strfind('abcdefg', 'a')\n  0\n  >>> strfind('abcdefg', 'z')\n  -1\n  */\nconst strfind = (string, substr) => {\n  let index = strindex(string, substr)\n  return index < 0? -1 : index\n}\n\n/** Return all strings of given string\n  >>> strfindall('abcdefg', 'a')\n  ['b', 'c', 'd', 'efg']\n  >>> strfindall('abcdefg', 'z')\n  []\n  */\nconst strfindall = (string, substr) => {\n  let split = strsplit(string, substr)\n  let result = []\n  for (let i = 0; i < split.length; i++) {\n    let index = strfind(string, substr)\n    result.push(string.substr(index))\n  }\n  return result\n}\n\n/** Return all strings of given string\n  >>> strfindall('abcdefg', 'a')\n  ['b', 'c', 'd', 'efg']\n  >>> strfindall('abcdefg', 'z')\n  []\n  */\nconst strfindall = (string, substr) => {\n  let reg = new RegExp(substr)\n  let result = []\n  let index = 0\n  let length = strlen(string)\n  while (index < length) {\n    let match = reg.exec(string)\n    if (match == null) {\n      break\n    }\n    let substr = string.substr(index, match.index)\n    result.push(substr)\n    index = match.index + match[0].length\n  }\n  return result\n}\n\n/** Return all strings of given string\n  >>> strfindall('abcdefg', 'a')\n  ['b', 'c', 'd', 'efg']\n  >>> strfindall('abcdefg', 'z')\n  []\n  */\nconst strfindall = (string, substr) => {\n  let reg = new RegExp(substr)\n  let result = []\n  let index = 0\n"}
{"task_id": "JavaScript/24", "prompt": "/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let i = 1\n  let res = 1\n  while (n % i!== 0) {\n    i += 1\n  }\n  return i\n}\n\n// For a given number n, find the greatest prime factor\nconst greatestPrimeFactor = (n) => {\n  let p = 1\n  while (p * p <= n) {\n    if (n % p === 0) {\n      return p\n    }\n    p += 1\n  }\n  return n\n}\n\n// For a given number n, find the smallest prime factor\nconst smallestPrimeFactor = (n) => {\n  let p = 1\n  while (p * p <= n) {\n    if (n % p === 0) {\n      return p\n    }\n    p += 1\n  }\n  return n\n}\n\n// For a given number n, find the greatest prime factor\nconst largestPrimeFactor = (n) => {\n  let p = 1\n  while (p * p <= n) {\n    if (n % p === 0) {\n      return p\n    }\n    p += 1\n  }\n  return n\n}\n\n// Given two numbers, find the largest prime factor common to both\nconst largestPrimeFactorCommon = (a, b) => {\n  let p = 1\n  while (p * p <= a) {\n    if (a % p === 0 && b % p === 0) {\n      return p\n    }\n    p += 1\n  }\n  return a\n}\n\n// Given two numbers, find the smallest prime factor common to both\nconst smallestPrimeFactorCommon = (a, b) => {\n  let p = 1\n  while (p * p <= a) {\n    if (a % p === 0 && b % p === 0) {\n      return p\n    }\n    p += 1\n  }\n  return a\n}\n\n// Given two numbers, find the greatest prime factor common to both\nconst greatestPrimeFactorCommon = (a, b) => {\n  let p = 1\n  while (p * p <= a) {\n    if (a % p === 0 && b % p === 0) {\n      return p\n    }\n    p += 1\n  }\n  return a\n}\n\n// Given two numbers, find the largest prime factor common to both\nconst smallestPrimeFactorCommon = (a, b) => {\n  let p = 1\n  while (p * p <= a) {\n    if (a % p === 0 && b % p === 0) {\n      return p\n    }\n    p += 1\n  }\n  return a\n}\n\n/*\n  Given two numbers, find the largest prime factor common to both\n  >>> largestPrimeFactorCommon(5, 12)\n  2\n  >>> largestPrimeFactorCommon(12, 5)\n  2\n  >>> largestPrimeFactorCommon(5, 6)\n  2\n  >>> largestPrimeFactorCommon(6, 5)\n  2\n  >>> largestPrimeFactorCommon(13, 7)\n  5\n  >>> largestPrimeFactorCommon(7, 13)\n  5\n  >>> largestPrimeFactorCommon(1, 2)\n  1\n  >>> largestPrimeFactorCommon(2, 1)\n  1\n  >>> largestPrimeFactorCommon(0, 0)\n  0\n  >>> largestPrimeFactorCommon(12, 18)\n  2\n  >>> largestPrimeFactorCommon(9, 12)\n  3\n  >>> largestPrimeFactorCommon(12, 9)\n  3\n  >>> largestPrimeFactorCommon(9, 18)\n  3\n  >>> largestPrimeFactorCommon(12, 18)\n  2\n  >>> largestPrimeFactorCommon(18, 12)\n  2\n  >>> largestPrimeFactorCommon(12, 9)\n  3\n  >>> largestPrimeFactorCommon(18, 9)\n  3\n  >>> largestPrimeFactorCommon(3, 4)\n  3\n  >>> largestPrimeFactorCommon(4, 3)\n  3\n  >>> largestPrimeFactorCommon(15, 6)\n  3\n  >>> largestPrimeFactorCommon(6, 15)\n  3\n  >>> largestPrimeFactorCommon(15, 18)\n  5\n  >>> largestPrimeFactorCommon(18, 15)\n  5\n  >>> largestPrimeFactorCommon(15, 9)\n  3\n  >>> largestPrimeFactorCommon(18, 9)\n  3\n  >>> largestPrimeFactorCommon(9, 18)\n  3\n  >>> largestPrimeFactorCommon(9, 15)\n  3\n  >>> largestPrimeFactorCommon(18, 15)\n  5\n  >>> largestPrimeFactorCommon(15, 12)\n  3\n  >>> largestPrimeFactorCommon(18, 12)\n  3\n  >>> largestPrimeFactorCommon(12, 18)\n  3\n  >>> largestPrimeFactorCommon(18, 12)\n  5\n  >>> largestPrimeFactorCommon(12, 9)\n  3\n  >>> largestPrimeFactorCommon(18, 9)\n  3\n  >>> largestPrimeFactorCommon(9, 18)\n  3\n  >>> largestPrimeFactorCommon(18, 9)\n  3\n  >>> largestPrimeFactorCommon(9, 12)\n  3\n  >>> largestPrimeFactorCommon(12, 9)\n  3\n  >>> largestPrimeFactorCommon(3, 4)\n  3\n  >>> largestPrimeFactorCommon(4, 3)\n  3\n  >>> largestPrimeFactorCommon(15, 18)\n  5\n  >>> largestPrimeFactorCommon(9, 15)\n  3\n  >>> largestPrimeFactorCommon(15, 9)\n  3\n  >>> largestPrimeFactorCommon(18, 9)\n  3\n  >>> largestPrimeFactorCommon(9, 18)\n  3\n  >>> largestPrimeFactorCommon(18, 15)\n  5\n  >>> largestPrimeFactorCommon(15, 12)\n  3\n  >>> largestPrimeFactorCommon(18, 12)\n  3\n  >>> largestPrimeFactorCommon(12, 18)\n  3\n  >>> largestPrimeFactorCommon(18, 12)\n  5\n  >>> largestPrimeFactorCommon(12, 9)\n  3\n  >>> largestPrimeFactorCommon(18, 9)\n  3\n  >>> largestPrimeFactorCommon(9, 18)\n  3\n  >>> largestPrimeFactorCommon(18, 9)\n  3\n  >>> largestPrimeFactorCommon(9, 12)\n  3\n  >>> largestPrimeFactorCommon(12, 9)\n  3\n  >>> largestPrimeFactorCommon(3, 4)\n  3\n  >>> largestPrimeFactorCommon(4, 3)\n  3\n  "}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  if (n === 1) {\n    return [1]\n  }\n\n  if (n % 2 === 0) {\n    return [n, 2]\n  }\n\n  const list = []\n\n  for (let i = 3; i <= Math.sqrt(n); i += 2) {\n    if (n % i === 0) {\n      list.push([i, n / i])\n    }\n  }\n\n  return list\n}\n\n/* Return all factors of a given integer\n  >>> factorize(4)\n  [2, 2]\n  >>> factorize(10)\n  [2, 3, 5]\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst allFactors = (n) => {\n  let factors = factorize(n)\n  let results = []\n\n  for (let i = 0; i < factors.length; i++) {\n    let p = factors[i][0]\n    let q = factors[i][1]\n\n    results = results.concat([p, q])\n  }\n\n  return results\n}\n\nmodule.exports = {\n  factorize,\n  allFactors\n}\n<|endoftext|>"}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, reomve all elemenst that occur more than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "/* From a list of integers, reomve all elemenst that occur more than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  return new Set(numbers)\n   .filter(x => numbers.indexOf(x) === -1)\n   .values();\n};\n\n// From a list of strings, remove all strings that start with an upper case letter\nconst removeUpperCaseLetters = (strings) => {\n  return strings.filter(x => x[0]!== x[0].toUpperCase());\n};\n\nconst removeLowerCaseLetters = (strings) => {\n  return strings.filter(x => x[0]!== x[0].toLowerCase());\n};\n\n// Remove all numbers from the string\nconst removeNumbers = (string) => {\n  return string.replace(/\\d/g, '');\n};\n\n// Remove all non-alphanumeric characters from the string\nconst removeNonAlphanumeric = (string) => {\n  return string.replace(/\\W/g, '');\n};\n\n// Remove all spaces\nconst removeSpaces = (string) => {\n  return string.replace(/\\s/g, '');\n};\n\n// Remove all whitespace\nconst removeWhitespaces = (string) => {\n  return string.replace(/\\s+/g, '');\n};\n\n// Remove all whitespaces and non-alphanumeric characters\nconst removeNonAlphanumericAndSpaces = (string) => {\n  return string.replace(/\\W/g, '').replace(/\\s+/g, '');\n};\n\n// Remove all non-alphanumeric characters\nconst removeNonAlphanumeric = (string) => {\n  return string.replace(/\\W/g, '');\n};\n\n// Remove all non-alphanumeric characters and spaces\nconst removeNonAlphanumericAndSpaces = (string) => {\n  return string.replace(/\\W/g, '').replace(/\\s+/g, '');\n};\n\n// Remove all spaces and non-alphanumeric characters\nconst removeSpacesAndNonAlphanumeric = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\W/g, '');\n};\n\n// Remove all non-alphanumeric characters and spaces\nconst removeNonAlphanumericAndSpaces = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\W/g, '');\n};\n\n// Remove all non-alphanumeric characters\nconst removeNonAlphanumeric = (string) => {\n  return string.replace(/\\W/g, '');\n};\n\n// Remove all non-alphanumeric characters and spaces\nconst removeNonAlphanumericAndSpaces = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\W/g, '');\n};\n\n// Remove all spaces and non-alphanumeric characters\nconst removeSpacesAndNonAlphanumeric = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\W/g, '');\n};\n\n// Remove all non-alphanumeric characters and spaces\nconst removeNonAlphanumericAndSpaces = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\W/g, '');\n};\n\n// Remove all spaces and numbers\nconst removeSpacesAndNumbers = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\d/g, '');\n};\n\n// Remove all non-alphanumeric characters and spaces\nconst removeNonAlphanumericAndSpaces = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\W/g, '');\n};\n\n// Remove all non-alphanumeric characters and spaces\nconst removeNonAlphanumericAndNumbers = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\W/g, '').replace(/\\d/g, '');\n};\n\n// Remove all spaces and non-alphanumeric characters\nconst removeSpacesAndNonAlphanumeric = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\W/g, '');\n};\n\n// Remove all non-alphanumeric characters and spaces\nconst removeNonAlphanumericAndSpaces = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\W/g, '');\n};\n\n// Remove all non-alphanumeric characters and spaces\nconst removeNonAlphanumericAndNumbers = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\W/g, '').replace(/\\d/g, '');\n};\n\n// Remove all spaces and numbers\nconst removeSpacesAndNumbers = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\d/g, '');\n};\n\n// Remove all spaces and numbers\nconst removeNonAlphanumericAndSpacesAndNumbers = (string) => {\n  return string.replace(/\\s+/g, '').replace(/\\W/g, '').replace(/\\d/g, '');\n};\n\nmodule.exports = {\n  removeDuplicates,\n  removeUpperCaseLetters,\n  removeLowerCaseLetters,\n  removeNumbers,\n  removeNonAlphanumeric,\n  removeNonAlphanumericAndSpaces,\n  removeNonAlphanumericAndNumbers,\n  removeSpaces,\n  removeSpacesAndNonAlphanumeric,\n  removeSpacesAndNumbers,\n  removeSpacesAndNonAlphanumeric,\n  removeSpacesAndNumbers,\n  removeNonAlphanumericAndSpaces,\n  removeNonAlphanumericAndNumbers,\n  removeNonAlphanumericAndSpaces,\n  removeNonAlphanumericAndNumbers,\n  removeSpacesAndNumbers,\n  removeSpacesAndNonAlphanumeric,\n  removeSpacesAndNumbers,\n  removeNonAlphanumericAndSpaces,\n  removeNonAlphanumericAndNumbers,\n  removeNonAlphanumericAndSpaces,\n  removeNonAlphanumericAndNumbers\n};\n"}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lwoecrase characters to uppecrase and upprecase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "/* For a given string, flip lwoecrase characters to uppecrase and upprecase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.replace(/[a-z]/g, (c) => {\n    const flip = c.toUpperCase();\n    return flip.toLowerCase();\n  });\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> flipCase('Hello')\n  'olleH'\n  */\nconst reverseCase = (string) => {\n  return string.split('').reverse().join('');\n};\n\n/*\n  Given a string, return the string with each letter in lowercase.\n  >>> lowerCase('Hello')\n  'hello'\n  >>> lowerCase('HELLO')\n  'hello'\n  */\nconst lowerCase = (string) => {\n  return string.toLowerCase();\n};\n\n/*\n  Given a string, return the string with each letter in uppercase.\n  >>> upperCase('Hello')\n  'HELLO'\n  >>> upperCase('hello')\n  'HELLO'\n  */\nconst upperCase = (string) => {\n  return string.toUpperCase();\n};\n\n/*\n  Given a string, return the string with every letter in lowercase and every letter in uppercase.\n  >>> bothCase('Hello')\n  'helloHELLO'\n  */\nconst bothCase = (string) => {\n  return upperCase(lowerCase(string));\n};\n\nmodule.exports = {\n  lowerCase,\n  upperCase,\n  bothCase,\n  flipCase,\n  reverseCase\n};\n<|endoftext|>"}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": false, "gc": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  const result = [];\n  for (const i in strings) {\n    result.push(strings[i]);\n  }\n  return result.join('');\n};\n\n/*\n  Test of concatenate function\n  >>> concatenate([1,2,3,4])\n  '123'\n  >>> concatenate([1,2,3])\n  '123'\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst test = () => {\n  const strings = [1,2,3,4];\n  console.log(concatenate(strings));\n  console.log(concatenate(strings, true));\n};\n\n// Test\ntest();\n<|endoftext|>"}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list fo strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "/* Filter an input list fo strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n    return [...new Set(strings.map((s) => prefix + s))];\n};\n\n/**\n  * Convert an object to a list of key-value pairs.\n  * @param {object} obj - The object to convert\n  * @return {Array} - A list of key-value pairs\n  */\nconst toPairs = (obj) => {\n    const pairs = [];\n    Object.keys(obj).forEach((key) => {\n        pairs.push([key, obj[key]]);\n    });\n    return pairs;\n};\n\nmodule.exports = {\n    filterByPrefix,\n    toPairs\n};\n<|endoftext|>"}
{"task_id": "JavaScript/30", "prompt": "/*Return onyl positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": true, "gc": "/*Return onyl positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(x => x > 0);\n};\n\n/*\n  Return the sum of the numbers in the list.\n  >>> getSum([3, 4, 5])\n  13\n  >>> getSum([3, 4, -5])\n  -1\n  >>> getSum([3, 4, -5, -3])\n  0\n  >>> getSum([1, 2, 3, 4, 5])\n  15\n  >>> getSum([1, 2, 3, 4, -5])\n  -5\n  >>> getSum([-1, 2, -4, 5, 6])\n  0\n  >>> getSum([-1, 2, -4, 5, 6, -9])\n  0\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8])\n  8\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5])\n  0\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5, 4])\n  4\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5, 4, 3])\n  3\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5, 4, 3, 2])\n  2\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5, 4, 3, 2, 1])\n  1\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5, 4, 3, 2, 1, -6])\n  0\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5, 4, 3, 2, 1, -6, 3])\n  0\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4])\n  4\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3])\n  4\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9])\n  -9\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8])\n  -9\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5])\n  -9\n  >>> getSum([-1, 2, -4, 5, 6, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3, -9, 8, -5, 4, 3, 2, 1, -6, 3, 4, -3"}
{"task_id": "JavaScript/31", "prompt": "/*Return ture if a given number is prime, and aflse otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "/*Return ture if a given number is prime, and aflse otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if(n === 1) return false\n  if(n === 2) return true\n  if(n <= 3) return false\n  if(n % 2 === 0) return false\n  let x = Math.floor(Math.sqrt(n))\n  for(let i = 3; i < x; i+=2) {\n    if(n % i === 0) return false\n  }\n  return true\n}\n\n/* Return true iff n is a perfect square */\nconst isPerfectSquare = (n) => {\n  return (n * n) === n\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (n * n * n) === n\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (n * n * n * n) === n\n}\n\n/* Return true iff n is a prime number */\nconst isPrimeNumber = (n) => {\n  return (isPrime(n)) && (n > 1)\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectSquare(n)) && (isPerfectNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPerfectNumber(n))\n}\n\n/* Return true iff n is a prime number */\nconst isPrimeNumber = (n) => {\n  return (isPrime(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectNumber(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectNumber(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectNumber(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectNumber(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectNumber(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectNumber(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectNumber(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectNumber(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectNumber(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectNumber(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectNumber(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect cube */\nconst isPerfectCube = (n) => {\n  return (isPerfectCube(n)) && (isPrimeNumber(n))\n}\n\n/* Return true iff n is a perfect number */\nconst isPerfectNumber = (n) => {\n  return (isPerfectNumber(n"}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polyonmial with ocefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are ceofficients of a polynoimal.\n  findZero find x such that poly(x) = 0.\n  findZero returns only onyl zero point, even fi teher are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coeffciient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "/*\n  Evaluates polyonmial with ocefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are ceofficients of a polynoimal.\n  findZero find x such that poly(x) = 0.\n  findZero returns only onyl zero point, even fi teher are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coeffciient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  if (xs.length % 2!== 0) {\n    throw new Error(\"Expect even number of coefficents\");\n  }\n  let x = 0;\n  let n = xs.length - 1;\n  while (x === 0) {\n    x = ((n * (n + 1)) / 2) - (poly(xs, x));\n    n--;\n  }\n  return x;\n}\n\n/*\n  xs are ceofficients of a polynoimal.\n  findParetoFindParetoFindPareto find x such that poly(x) = 0.\n  findParetoFindPareto returns only one zero point, even there are many.\n  >>> round(findPareto([1, 2]), 2) # f(x) = 1 + 2x\n  0.0\n  >>> round(findPareto([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findPareto = (xs) => {\n  if (xs.length % 2!== 0) {\n    throw new Error(\"Expect even number of coefficents\");\n  }\n  let x = 0;\n  let n = xs.length - 1;\n  while (x === 0) {\n    x = ((n * (n + 1)) / 2) - (poly(xs, x));\n    n--;\n  }\n  return x;\n}\n\n/*\n  xs are ceofficients of a polynoimal.\n  findMaximum find x such that poly(x) is maximum.\n  findMaximum returns only one zero point, even there are many.\n  >>> round(findMaximum([1, 2]), 2) # f(x) = 1 + 2x\n  0.0\n  >>> round(findMaximum([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findMaximum = (xs) => {\n  if (xs.length % 2!== 0) {\n    throw new Error(\"Expect even number of coefficents\");\n  }\n  let x = 0;\n  let n = xs.length - 1;\n  while (x === 0) {\n    x = ((n * (n + 1)) / 2) - (poly(xs, x));\n    n--;\n  }\n  return x;\n}\n\n/*\n  xs are ceofficients of a polynoimal.\n  findMinimum find x such that poly(x) is minimum.\n  findMinimum returns only one zero point, even there are many.\n  >>> round(findMinimum([1, 2]), 2) # f(x) = 1 + 2x\n  0.0\n  >>> round(findMinimum([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findMinimum = (xs) => {\n  if (xs.length % 2!== 0) {\n    throw new Error(\"Expect even number of coefficents\");\n  }\n  let x = 0;\n  let n = xs.length - 1;\n  while (x === 0) {\n    x = ((n * (n + 1)) / 2) - (poly(xs, x));\n    n--;\n  }\n  return x;\n}\n\n/*\n  xs are ceofficients of a polynoimal.\n  findRoot find x such that poly(x) = 0.\n  findRoot returns only one zero point, even there are many.\n  >>> round(findRoot([1, 2]), 2) # f(x) = 1 + 2x\n  0.0\n  >>> round(findRoot([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findRoot = (xs) => {\n  if (xs.length % 2!== 0) {\n    throw new Error(\"Expect even number of coefficents\");\n  }\n  let x = 0;\n  let n = xs.length - 1;\n  while (x === 0) {\n    x = ((n * (n + 1)) / 2) - (poly(xs, x));\n    n--;\n  }\n  return x;\n}\n\n/*\n  xs are ceofficients of a polynoimal.\n  findParetoFindParetoFindPareto find x such that poly(x) is maximum.\n  findParetoFindPareto returns only one zero point, even there are many.\n  >>> round(findParetoFindPareto([1, 2]), 2) # f(x) = 1 + 2x\n  0.0\n  >>> round(findParetoFindPareto([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6"}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by three, while its values at the idnicies that are divisible by three are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by three, while its values at the idnicies that are divisible by three are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const sorted = [];\n  let start = 0;\n  for(let i = 0; i < l.length; i++) {\n    if(l[i] % 3 === 0) {\n      sorted.push(l[i]);\n      start++;\n    } else {\n      sorted.push(l[i]);\n      if(start) {\n        for(let j = start; j < i; j++) {\n          sorted.push(l[j]);\n        }\n        start = 0;\n      }\n    }\n  }\n  if(start) {\n    for(let j = start; j < l.length; j++) {\n      sorted.push(l[j]);\n    }\n  }\n  return sorted;\n};\n\n//export\nmodule.exports = sortThird;\n<|endoftext|>"}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": false, "gc": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let unique = [];\n  return l.reduce((a, b) => {\n    if (a.indexOf(b) === -1) {\n      unique.push(b);\n    }\n    return unique;\n  }, []);\n};\n\nmodule.exports = {\n  unique\n};\n<|endoftext|>"}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum leement in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": true, "gc": "/*Return maximum leement in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let i = 0\n  let max = l[i]\n  for (let j = 1; j < l.length; j++) {\n    if (l[j] > max) {\n      max = l[j]\n    }\n  }\n  return max\n}\n\n/* Return sum of the elements in the list.\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst sum = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n  }\n  return sum\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst randElement = (l) => {\n  let random = Math.floor(Math.random() * l.length)\n  return l[random]\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst randElementInList = (l) => {\n  let random = Math.floor(Math.random() * l.length)\n  return l[random]\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst randElementInList = (l) => {\n  let random = Math.floor(Math.random() * l.length)\n  return l[random]\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst randElementInList = (l) => {\n  let random = Math.floor(Math.random() * l.length)\n  return l[random]\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst randElementInList = (l) => {\n  let random = Math.floor(Math.random() * l.length)\n  return l[random]\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst randElementInList = (l) => {\n  let random = Math.floor(Math.random() * l.length)\n  return l[random]\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst randElementInList = (l) => {\n  let random = Math.floor(Math.random() * l.length)\n  return l[random]\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst randElementInList = (l) => {\n  let random = Math.floor(Math.random() * l.length)\n  return l[random]\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst randElementInList = (l) => {\n  let random = Math.floor(Math.random() * l.length)\n  return l[random]\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst randElementInList = (l) => {\n  let random = Math.floor(Math.random() * l.length)\n  return l[random]\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst randElementInList = (l) => {\n  let random = Math.floor(Math.random() * l.length)\n  return l[random]\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst randElementInList = (l) => {\n  let random = Math.floor(Math.random() * l.length)\n  return l[random]\n}\n\n/* Return a random element in the list.\n  >>> randElement([1, 2, 3])\n  2\n  >>> randElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1"}
{"task_id": "JavaScript/36", "prompt": "/*Reutrn the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "/*Reutrn the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let res = 0;\n  for (let i = 1; i <= n; i++) {\n    if ((i % 11 === 0) || (i % 13 === 0)) {\n      res++;\n    }\n  }\n  return res;\n};\n\nmodule.exports = fizzBuzz;\n<|endoftext|>"}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the odd indicise, while tis avlues ta the even indicies are equal\n  to the values of the even idnicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the odd indicise, while tis avlues ta the even indicies are equal\n  to the values of the even idnicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const d = {};\n  for (let i = 0; i < l.length; i += 2) {\n    d[l[i]] = l[i + 1];\n  }\n  return Object.keys(d).sort();\n};\n\nconst testSortEven = (l) => {\n  const d = {};\n  for (let i = 0; i < l.length; i += 2) {\n    d[l[i]] = l[i + 1];\n  }\n  const sorted = sortEven(l);\n  console.log(`${l.length} elements sorted:`);\n  console.log(sorted);\n  console.log(``);\n  console.log(`${d.length} elements in the dictionary:`);\n  console.log(d);\n  console.log(``);\n  return d;\n};\n\nconst testSortEven2 = (l) => {\n  const d = {};\n  for (let i = 0; i < l.length; i += 2) {\n    d[l[i]] = l[i + 1];\n  }\n  const sorted = sortEven(l);\n  const sorted2 = sortEven2(l);\n  console.log(`${l.length} elements sorted:`);\n  console.log(sorted);\n  console.log(``);\n  console.log(`${d.length} elements in the dictionary:`);\n  console.log(d);\n  console.log(``);\n  console.log(`${sorted.length} elements in the sorted dictionary:`);\n  console.log(sorted2);\n  console.log(``);\n  return d;\n};\n\n// TEST\nconst test = () => {\n  const l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n  testSortEven(l);\n  testSortEven2(l);\n  return l;\n};\n\n// MAIN\nconsole.log(`Testing sortEven`);\nconst sorted = test();\n\nconsole.log(`Testing sortEven2`);\nconst sorted2 = test();\n<|endoftext|>"}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoedd string by cycling groups of htree characters.\n  */\nconts encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string enocded with encode_cyclci functino. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "/*\n  returns encoedd string by cycling groups of htree characters.\n  */\nconts encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string enocded with encode_cyclci functino. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(2));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  generates a random string of length n.\n  */\nconst genRandStr = (n) => {\n  var letters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n      string = '',\n      i;\n\n  for (i = 0; i < n; i++) {\n    string += letters[Math.floor(Math.random() * 62)];\n  }\n\n  return string;\n}\n\n/*\n  generates a random string of length n,\n  which is the same as genRandStr(n).\n  */\nconst genRandStrSameLength = (n) => {\n  return genRandStr(n);\n}\n\nconst generateRandStr = () => {\n  return genRandStrSameLength(10);\n}\n\nconst generateRandStrSameLength = () => {\n  return genRandStrSameLength(10);\n}\n\n/*\n  generates a random string of length n,\n  which is longer than genRandStr(n).\n  */\nconst generateRandStrLonger = (n) => {\n  return genRandStr(n + 10);\n}\n\nconst generateRandStrLonger = () => {\n  return genRandStrLonger(10);\n}\n\n/*\n  generates a random string of length n,\n  which is shorter than genRandStr(n).\n  */\nconst generateRandStrShorter = (n) => {\n  return genRandStr(n - 10);\n}\n\nconst generateRandStrShorter = () => {\n  return generateRandStrShorter(10);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\nconst generateRandStrSameLength = () => {\n  return generateRandStrSameLength(10);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*\n  generates a random string of length n,\n  which is the same as generateRandStr(n).\n  */\nconst generateRandStrSameLength = (n) => {\n  return genRandStrSameLength(n);\n}\n\n/*"}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number taht is a Fbionacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "/*\n  primeFib returns n-th number taht is a Fbionacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n    let f = 2;\n    let nthPrime = 2;\n\n    while (f < n) {\n        let isPrime = false;\n        for (let i = 2; i < nthPrime; i++) {\n            if (nthPrime % i === 0) {\n                isPrime = true;\n                break;\n            }\n        }\n\n        if (isPrime) {\n            nthPrime = nthPrime + 1;\n        }\n        f = f + 1;\n    }\n\n    return nthPrime;\n};\n\nconsole.log(primeFib(10));\n<|endoftext|>"}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to zero, nad false toherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  triplesSumToZero takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to zero, nad false toherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n    const l2 = l.slice();\n    const result = [];\n    let s = 0;\n    for (let i = 0; i < l.length - 2; i++) {\n        s += l2[i];\n        if (s === 0) {\n            result.push([l2[i], l2[i + 1], l2[i + 2]]);\n        }\n    }\n    return result;\n};\n\n/*\n  findAllTriples takes a list of ints as an input.\n  it returns an array of arrays.\n  each array has three elements.\n  the first element is the number of a leement in the list,\n  the second element is the number of the next leement,\n  and the third element is the number of the next leement.\n\n  >>> findAllTriples([1, 3, 5, 0])\n  [ [1, 3, 5], [1, 3, 0], [1, 0, 5], [1, 5, 3], [3, 5, 0], [3, 0, 5] ]\n  >>> findAllTriples([1, 3, -2, 1])\n  [ [1, 3, -2], [1, 3, 1], [1, -2, 3], [1, 3, -2], [3, -2, 1], [3, 1, -2] ]\n  >>> findAllTriples([1, 2, 3, 7])\n  []\n  >>> findAllTriples([2, 4, -5, 3, 9, 7])\n  [ [2, 4, -5], [2, 4, 3], [2, 3, -5], [2, 3, 4], [4, 3, -5], [4, 3, -5] ]\n  >>> findAllTriples([1])\n  []\n  */\nconst findAllTriples = (l) => {\n    const result = [];\n    let s = 0;\n    for (let i = 0; i < l.length - 2; i++) {\n        s += l[i];\n        if (s === 0) {\n            result.push([l[i], l[i + 1], l[i + 2]]);\n        }\n    }\n    return result;\n};\n\n/*\n  findTriplesSumToZero takes a list of ints as an input.\n  it returns an array of arrays.\n  each array has three elements.\n  the first element is the number of a leement in the list,\n  the second element is the number of the next leement,\n  and the third element is the number of the next leement.\n\n  >>> findTriplesSumToZero([1, 3, 5, 0])\n  [ [1, 3, 5], [1, 3, 0], [1, 0, 5], [1, 5, 3], [3, 5, 0], [3, 0, 5] ]\n  >>> findTriplesSumToZero([1, 3, -2, 1])\n  [ [1, 3, -2], [1, 3, 1], [1, -2, 3], [1, 3, -2], [3, -2, 1], [3, 1, -2] ]\n  >>> findTriplesSumToZero([1, 2, 3, 7])\n  []\n  >>> findTriplesSumToZero([2, 4, -5, 3, 9, 7])\n  [ [2, 4, -5], [2, 4, 3], [2, 3, -5], [2, 3, 4], [4, 3, -5], [4, 3, -5] ]\n  >>> findTriplesSumToZero([1])\n  []\n  */\nconst findTriplesSumToZero = (l) => {\n    const result = [];\n    let s = 0;\n    for (let i = 0; i < l.length - 2; i++) {\n        s += l[i];\n        if (s === 0) {\n            result.push([l[i], l[i + 1], l[i + 2]]);\n        }\n    }\n    return result;\n};\n\n/*\n  main takes an array of ints as an input.\n  it returns an array of arrays.\n  each array has three elements.\n  the first element is the number of a leement in the list,\n  the second element is the number of the next leement,\n  and the third element is the number of the next leement.\n\n  >>> main([1, 3, 5, 0])\n  [ [1, 3, 5], [1, 3, 0], [1, 0, 5], [1, 5, 3], [3, 5, 0], [3, 0, 5] ]\n  >>> main([1, 3, -2, 1])\n  [ [1, 3, -2], [1, 3, 1], [1, -2, 3], [1, 3, -2], [3, -2, 1], [3, 1, -2] ]\n  >>> main([1, 2, 3, 7])\n  [ [1, 2, 3], [2, 3, 7], [3, 2, 7] ]\n  >>> main([2, 4, -5, 3, 9, 7])\n  [ [2, 4, -5], [2, 4, 3], [2, 3, -5], [2, 3, 4], [4, 3, -5], [4, 3, -5] ]\n  >>> main([1])\n  [ [1, 1] ]\n  */\nconst main = (l) => {\n    const result = [];\n    for (let i = 0; i < l.length - 2; i++) {\n        result.push([l[i], l[i + 1], l[i + 2]]);\n    }\n    return result;\n};\n\n/*\n  test takes an array of ints as an input.\n  it returns true if all elements in the array are the same.\n  false otherwise"}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly tsraight infinitely long line.\n  n cars are driving left to rigth;  simutlaneously, a different set of n acrs\n  are driivng right to left.   The two sets of cars start out being very far rfom\n  each other.  All casr move in the same speed.  Two cars are said to colilde\n  when a car thta's moving left to right hits a car that's moving right ot left.\n  However, the cars are infinitely sturyd and strong; as a result, they continue omving\n  in their trajectory as if htey did not colldie.\n\n  This ufnction outputs teh number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "/*\n  Imagine a road that's a perfectly tsraight infinitely long line.\n  n cars are driving left to rigth;  simutlaneously, a different set of n acrs\n  are driivng right to left.   The two sets of cars start out being very far rfom\n  each other.  All casr move in the same speed.  Two cars are said to colilde\n  when a car thta's moving left to right hits a car that's moving right ot left.\n  However, the cars are infinitely sturyd and strong; as a result, they continue omving\n  in their trajectory as if htey did not colldie.\n\n  This ufnction outputs teh number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let counter = 0;\n  let car0 = 0;\n  let car1 = 0;\n  for (let i = 0; i < n; i++) {\n    car0 = i;\n    car1 = n - i - 1;\n    if (car0 < car1) {\n      counter += carRaceCollision(car1 - car0);\n    }\n  }\n  return counter;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": false, "gc": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let newList = [...l];\n  newList.push(...l);\n  return newList;\n};\n\n/*\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([1, 2, 3, 4])\n  [2, 3, 4, 5]\n  >>> incrList([1, 2, 3, 4, 5])\n  [2, 3, 4, 5, 6]\n  >>> incrList([1, 2, 3, 4, 5, 6])\n  [2, 3, 4, 5, 6, 7]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7])\n  [2, 3, 4, 5, 6, 7, 8]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8])\n  [2, 3, 4, 5, 6, 7, 8, 9]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]\n  >>> incrList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  [2, 3, 4, 5"}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  return l.every((e) => (e + l.indexOf(e) === 0));\n};\n\nexport default pairsSumToZero;\n<|endoftext|>"}
{"task_id": "JavaScript/44", "prompt": "/*Change numecrial base of ipnut number x to base.\n  return string representation after the conversion.\n  base numbers are lses than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "/*Change numecrial base of ipnut number x to base.\n  return string representation after the conversion.\n  base numbers are lses than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let result = ''\n  if (base < 10) {\n    while (x > 0) {\n      result = (x % base) + result\n      x = Math.floor(x / base)\n    }\n  } else {\n    while (x > 0) {\n      result = (x % base) + result\n      x = Math.floor(x / base)\n    }\n  }\n  return result\n}\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************\n\n// **************\n// **************\n// **************"}
{"task_id": "JavaScript/45", "prompt": "/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea2 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea3 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea4 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea5 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea6 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea7 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea8 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea9 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea10 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea11 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea12 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea13 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea14 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea15 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n\n/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(4, 3)\n  7.0\n  >>> triangleArea(4, 4)\n  9.0\n  */\nconst triangleArea16 = (a, h) => {\n  return (Math.pow(h, 2) - Math.pow(a, 2)) / 2\n}\n<|endoftext|>"}
{"task_id": "JavaScript/46", "prompt": "/*The Fbi4 number seuqence si a sqeuence similar to the Fibbonacci sequnece taht's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "/*The Fbi4 number seuqence si a sqeuence similar to the Fibbonacci sequnece taht's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0\n  if (n === 1) return 0\n  if (n === 2) return 2\n  if (n === 3) return 0\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nexport {fib4}\n<|endoftext|>"}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": false, "gc": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n    if (!l || l.length === 0) {\n        throw new Error(\"median of empty list\");\n    }\n    let left = 0;\n    let right = l.length - 1;\n    while (left < right) {\n        const mid = (left + right) / 2;\n        if (l[mid] < l[right]) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return (l[left] + l[right]) / 2.0;\n};\n\nexport default median;\n<|endoftext|>"}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a apilndrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Checks if given string is a apilndrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return new RegExp(text.split('').reverse().join(''), 'i').test(text);\n};\n\nmodule.exports = isPalindrome;\n<|endoftext|>"}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n moudlo p (be aware of numreics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": true, "gc": "/*Return 2^n moudlo p (be aware of numreics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n === 0) {\n    return 1\n  }\n  return (n % p === 0)? n / p : modp(n, p)\n}\n\nmodule.exports = modp\n<|endoftext|>"}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chraCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns deocded stirng.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chraCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns deocded stirng.\n  */\nconst decodeShift = (s) => {\n  let decoded = \"\";\n  for(let i = 0; i < s.length; i++) {\n    decoded += String.fromCharCode(\n      ((s.charCodeAt(i) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chraCodeAt(0)\n    );\n  }\n  return decoded;\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns string\n  that is decoded by decode_shift function.\n  */\nconst decode = (s) => decodeShift(encodeShift(s));\n\n/*\n  takes as input string encoded with encode_shift function. Returns string\n  that is decoded by decode_shift function.\n  */\nconst encode = (s) => encodeShift(decode(s));\n\nconst test = () => {\n  console.log(decode(\"a\"));\n  console.log(decode(\"aa\"));\n  console.log(decode(\"aaa\"));\n  console.log(decode(\"aaaa\"));\n  console.log(decode(\"aaaaa\"));\n  console.log(decode(\"aaaaaa\"));\n  console.log(decode(\"aaaaaaa\"));\n  console.log(decode(\"aaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n  console.log(decode(\"aaaaaaaaaaaaaaaaaaaaaaaa"}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string and rteurns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "/*\n  removeVowels is a function that takes string and rteurns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  return text.replace(/[AEIOU]/g, vowel => {\n    return vowel === 'a' || vowel === 'e' || vowel === 'i' || vowel === 'o' || vowel === 'u'? '' : vowel;\n  });\n}\n\n/*\n  replaceVowels is a function that takes string and rteurns string without vowels.\n  >>> replaceVowels('')\n  ''\n  >>> replaceVowels(\"abcdef\\nghijklm\")\n  'Abcdef\\nGhijklm'\n  >>> replaceVowels('abcdef')\n  'Abcdef'\n  >>> replaceVowels('aaaaa')\n  ''\n  >>> replaceVowels('aaBAA')\n  'B'\n  >>> replaceVowels('zbcd')\n  'zbcd'\n  */\nconst replaceVowels = (text) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  return text.replace(/[AEIOU]/g, vowel => {\n    return vowels.indexOf(vowel) >= 0? vowel : '';\n  });\n}\n\n/*\n  translateWord is a function that takes a word and returns translated word\n  >>> translateWord('')\n  ''\n  >>> translateWord(\"abcdef\")\n  'Abcdef'\n  >>> translateWord(\"abcdefg\")\n  'Abcdefg'\n  >>> translateWord(\"aBcdef\")\n  'Abcdef'\n  >>> translateWord(\"aBcdefg\")\n  'Abcdefg'\n  >>> translateWord(\"aaBAA\")\n  'B'\n  >>> translateWord(\"zBcdef\")\n  'zBcdef'\n  >>> translateWord(\"zzzBcdef\")\n  'zzzBcdef'\n  */\nconst translateWord = (text) => {\n  return text.replace(/\\w+/g, word => {\n    return word.replace(/[aeiou]/g, vowel => {\n      return vowel === 'a' || vowel === 'e' || vowel === 'i' || vowel === 'o' || vowel === 'u'? vowel : 'z';\n    });\n  });\n}\n\n/*\n  main is the main function that runs the program.\n  >>> main()\n  ''\n  >>> main(\"\")\n  ''\n  >>> main(\"abcdef\")\n  'Abcdef'\n  >>> main(\"aBcdef\")\n  'Abcdef'\n  >>> main(\"aBcdefg\")\n  'Abcdefg'\n  >>> main(\"aBcdefg\")\n  'Abcdefg'\n  >>> main(\"aaBAA\")\n  'B'\n  >>> main(\"zBcdef\")\n  'zBcdef'\n  >>> main(\"zzzBcdef\")\n  'zzzBcdef'\n  */\nconst main = (text) => {\n  let removeVowels = removeVowels(text);\n  let replaceVowels = replaceVowels(removeVowels);\n  let translateWord = translateWord(replaceVowels);\n  console.log(translateWord);\n}\n\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\"\");\nmain(\""}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are boelw threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "/*Return true if all numbers in the list l are boelw threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  let i, len;\n  if (l.length === 0) return false;\n  len = l.length;\n  for (i = 0; i < len; i += 1) {\n    if (l[i] < t) return false;\n  }\n  return true;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x nad y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Add two numbers x nad y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\nexport default add;\n<|endoftext|>"}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": false, "gc": "/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  let charMatch = 0;\n  for (let i = 0; i < s0.length; i++) {\n    charMatch += s0[i] === s1[i]? 1 : 0;\n  }\n  return charMatch === s0.length;\n};\n\n/*\n  Find the longest substring of s that has the same characters as s.\n  >>> longestSubstring(abcd)\n  'abcd'\n  >>> longestSubstring('abcd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'\n  >>> longestSubstring('abcd', 'ab', 'cd')\n  'abcd'"}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fiobnacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": true, "gc": "/*Return n-th Fiobnacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 2\n  return fib(n-1) + fib(n-2)\n}\n\n/*Return n-th Fibonacci number with base b.\n  >>> fib(10, base=2)\n  11\n  >>> fib(8, base=3)\n  27\n  >>> fib(1, base=3)\n  1\n  >>> fib(8, base=10)\n  28\n  */\nconst fib = (n, base) => {\n  if (n === 1) return 1\n  if (n === 2) return 2\n  return fib(n-1, base) + fib(n-2, base)\n}\n\n/*Return n-th Catalan number.\n  >>> catalan(2)\n  1\n  >>> catalan(3)\n  5\n  >>> catalan(10)\n  14696\n  */\nconst catalan = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 2\n  return catalan(n-1) + catalan(n-2)\n}\n\n/*Return n-th Harmonic number.\n  >>> harmonic(3)\n  4\n  >>> harmonic(8)\n  7\n  >>> harmonic(1)\n  1\n  >>> harmonic(10)\n  10\n  */\nconst harmonic = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return harmonic(n-1) + harmonic(n-2)\n}\n\n/*Return n-th Riemann zeta value.\n  >>> riemann(3)\n  1\n  >>> riemann(4)\n  1\n  >>> riemann(1)\n  1\n  >>> riemann(10)\n  30\n  */\nconst riemann = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 0\n  return riemann(n-1) + riemann(n-2)\n}\n\n/*Return n-th Riemann zeta value for base b.\n  >>> riemann(3, base=2)\n  2\n  >>> riemann(4, base=2)\n  4\n  >>> riemann(1, base=2)\n  1\n  >>> riemann(10, base=2)\n  24\n  */\nconst riemann = (n, base) => {\n  if (n === 1) return 1\n  if (n === 2) return 0\n  return riemann(n-1, base) + riemann(n-2, base)\n}\n\n/*Return n-th Euler constant.\n  >>> euler(1)\n  0\n  >>> euler(2)\n  0\n  >>> euler(3)\n  0\n  >>> euler(10)\n  1\n  */\nconst euler = (n) => {\n  if (n === 1) return 0\n  if (n === 2) return 0\n  return euler(n-1) + euler(n-2)\n}\n\n/*Return n-th Euler constant for base b.\n  >>> euler(1, base=2)\n  1\n  >>> euler(2, base=2)\n  2\n  >>> euler(3, base=2)\n  2\n  >>> euler(10, base=2)\n  22\n  */\nconst euler = (n, base) => {\n  if (n === 1) return 1\n  if (n === 2) return base\n  return euler(n-1, base) + euler(n-2, base)\n}\n\n/*Return n-th Catalan number for base b.\n  >>> catalan(1, base=2)\n  1\n  >>> catalan(2, base=2)\n  4\n  >>> catalan(3, base=2)\n  7\n  >>> catalan(10, base=2)\n  68\n  */\nconst catalan = (n, base) => {\n  if (n === 1) return 1\n  if (n === 2) return base\n  return catalan(n-1, base) + catalan(n-2, base)\n}\n\n/*Return n-th Harmonic number for base b.\n  >>> harmonic(1, base=2)\n  1\n  >>> harmonic(2, base=2)\n  2\n  >>> harmonic(3, base=2)\n  4\n  >>> harmonic(10, base=2)\n  32\n  */\nconst harmonic = (n, base) => {\n  if (n === 1) return 1\n  if (n === 2) return base\n  return harmonic(n-1, base) + harmonic(n-2, base)\n}\n\n/*Return n-th Riemann zeta value for base b.\n  >>> riemann(1, base=2)\n  1\n  >>> riemann(2, base=2)\n  3\n  >>> riemann(3, base=2)\n  5\n  >>> riemann(10, base=2)\n  64\n  */\nconst riemann = (n, base) => {\n  if (n === 1) return 1\n  if (n === 2) return base\n  return riemann(n-1, base) + riemann(n-2, base)\n}\n\n/*Return n-th Euler constant for base b.\n  >>> euler(1, base=2)\n  1\n  >>> euler(2, base=2)\n  2\n  >>> euler(3, base=2)\n  3\n  >>> euler(10, base=2)\n  18\n  */\nconst euler = (n, base) => {\n  if (n === 1) return 1\n  if (n === 2) return base\n  return euler(n-1, base) + euler(n-2, base)\n}\n\n/*Return n-th Fibonacci number for base b.\n  >>> fib(1, base=2)\n  1\n  >>> fib(2, base=2)\n  2\n  >>> fib(3, base=2)\n  4\n  >>> fib(10, base=2)\n  32\n  */\nconst fib = (n, base) =>"}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresonpding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresonpding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n    let stack = [];\n    let brackets_pos = 0;\n    while (brackets_pos < brackets.length) {\n        let character = brackets[brackets_pos];\n        if (character === \"<\") {\n            stack.push(character);\n        } else if (character === \">\") {\n            if (stack.length > 0 && stack[stack.length - 1] === \"<\") {\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n        brackets_pos++;\n    }\n    return stack.length === 0;\n}\n\n/*\n  Given a string, return the string where every opening bracket is closed,\n  and every closing bracket is open.\n\n  >>> bracketInversion(\"<>\")\n  \"<>\"\n  >>> bracketInversion(\"<><>\")\n  \"<><>\"\n  >>> bracketInversion(\"<<><>\")\n  \"<><>\"\n  >>> bracketInversion(\"<<><><><>\")\n  \"<><><><>\"\n  >>> bracketInversion(\"<<<><>\")\n  \"<><><>\"\n  >>> bracketInversion(\"<<<><<<<><>\")\n  \"<><><>\"\n  >>> bracketInversion(\"<><><>\")\n  \"<><><>\"\n  >>> bracketInversion(\"<><><><><><><>\")\n  \"<><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><><><><><><><><><><><><><><><><><><>\")\n  \"<><><><><>\"\n  >>> bracketInversion(\"<><><><><><><><><"}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are omnotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "/*Return true is list elements are omnotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let isIncreasing = true\n  let i = 0\n  while (i < l.length - 1) {\n    if (l[i] >= l[i + 1]) {\n      isIncreasing = false\n      break\n    }\n    i++\n  }\n  return isIncreasing\n}\n\n/*Return true if a list contains an increasing subsequence.\n  >>> increasing([1, 2, 4, 20])\n  false\n  >>> increasing([1, 2, 4, 10])\n  true\n  >>> increasing([4, 1, 0, -10])\n  false\n  >>> increasing([1, 4, 0, -10])\n  true\n  >>> increasing([4, 1, 0, -10, 1])\n  true\n  */\nconst increasing = (l) => {\n  let index = 0\n  let i = 0\n  while (i < l.length) {\n    if (index > 0) {\n      if (l[i] >= l[index - 1]) {\n        return true\n      }\n    }\n    index++\n    i++\n  }\n  return false\n}\n\n/*Return true if a list contains a decreasing subsequence.\n  >>> decreasing([1, 2, 4, 20])\n  true\n  >>> decreasing([1, 2, 4, 10])\n  false\n  >>> decreasing([4, 1, 0, -10])\n  true\n  >>> decreasing([1, 4, 0, -10])\n  false\n  >>> decreasing([4, 1, 0, -10, 1])\n  false\n  */\nconst decreasing = (l) => {\n  let index = l.length - 1\n  let i = l.length - 1\n  while (i >= 0) {\n    if (index < l.length - 1) {\n      if (l[i] <= l[index + 1]) {\n        return true\n      }\n    }\n    index--\n    i--\n  }\n  return false\n}\n\n/*Return true if a list contains an increasing subsequence.\n  >>> increasing([1, 2, 4, 20])\n  false\n  >>> increasing([1, 2, 4, 10])\n  true\n  >>> increasing([4, 1, 0, -10])\n  false\n  >>> increasing([1, 4, 0, -10])\n  true\n  >>> increasing([4, 1, 0, -10, 1])\n  true\n  */\nconst increasing2 = (l) => {\n  let index = 0\n  let i = 0\n  while (i < l.length) {\n    if (index > 0) {\n      if (l[i] <= l[index - 1]) {\n        return true\n      }\n    }\n    index++\n    i++\n  }\n  return false\n}\n\n/*Return true if a list contains a decreasing subsequence.\n  >>> decreasing([1, 2, 4, 20])\n  true\n  >>> decreasing([1, 2, 4, 10])\n  false\n  >>> decreasing([4, 1, 0, -10])\n  true\n  >>> decreasing([1, 4, 0, -10])\n  false\n  >>> decreasing([4, 1, 0, -10, 1])\n  false\n  */\nconst decreasing2 = (l) => {\n  let index = l.length - 1\n  let i = l.length - 1\n  while (i >= 0) {\n    if (index < l.length - 1) {\n      if (l[i] >= l[index + 1]) {\n        return true\n      }\n    }\n    index--\n    i--\n  }\n  return false\n}\n\n/*Return true if a list contains an increasing subsequence.\n  >>> increasing([1, 2, 4, 20])\n  false\n  >>> increasing([1, 2, 4, 10])\n  true\n  >>> increasing([4, 1, 0, -10])\n  false\n  >>> increasing([1, 4, 0, -10])\n  true\n  >>> increasing([4, 1, 0, -10, 1])\n  true\n  */\nconst increasing3 = (l) => {\n  let index = 0\n  let i = 0\n  while (i < l.length) {\n    if (index > 0) {\n      if (l[i] < l[index - 1]) {\n        return true\n      }\n    }\n    index++\n    i++\n  }\n  return false\n}\n\n/*Return true if a list contains a decreasing subsequence.\n  >>> decreasing([1, 2, 4, 20])\n  true\n  >>> decreasing([1, 2, 4, 10])\n  false\n  >>> decreasing([4, 1, 0, -10])\n  true\n  >>> decreasing([1, 4, 0, -10])\n  false\n  >>> decreasing([4, 1, 0, -10, 1])\n  false\n  */\nconst decreasing3 = (l) => {\n  let index = l.length - 1\n  let i = l.length - 1\n  while (i >= 0) {\n    if (index < l.length - 1) {\n      if (l[i] > l[index + 1]) {\n        return true\n      }\n    }\n    index--\n    i--\n  }\n  return false\n}\n\nexport {\n  monotonic,\n  increasing,\n  decreasing,\n  increasing2,\n  decreasing2,\n  increasing3,\n  decreasing3\n}\n<|endoftext|>"}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": false, "gc": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  if (l1.length === 0 || l2.length === 0) {\n    return []\n  }\n\n  const result = []\n  const d1 = new Set(l1)\n  const d2 = new Set(l2)\n  const s1 = d1.size\n  const s2 = d2.size\n  const diff = s1 > s2? s1 - s2 : s2 - s1\n  let minIndex = 0\n  while (diff--) {\n    const value = d1.has(d2.values()[minIndex])? d1.values()[minIndex] : d2.values()[minIndex]\n    result.push(value)\n    minIndex++\n  }\n\n  return result\n}\n\n/*\n  Given a list of numbers, return the largest index of the largest number\n  >>> largest([1, 2, 3, 4, 5])\n  4\n  >>> largest([1, 2, 3, 4, 5, 6, 7])\n  7\n  >>> largest([1, 2, 3, 4, 5, 6, 7, 8])\n  8\n\n  */\nconst largest = (nums) => {\n  const max = Math.max.apply(Math, nums)\n  const index = nums.indexOf(max)\n  return index\n}\n\n/*\n  Given a list of numbers, return the smallest index of the smallest number\n  >>> smallest([1, 2, 3, 4, 5])\n  0\n  >>> smallest([1, 2, 3, 4, 5, 6, 7])\n  0\n  >>> smallest([1, 2, 3, 4, 5, 6, 7, 8])\n  0\n\n  */\nconst smallest = (nums) => {\n  const min = Math.min.apply(Math, nums)\n  const index = nums.indexOf(min)\n  return index\n}\n\n/*\n  Given a list of numbers, return the index of the first number\n  >>> index([1, 2, 3, 4, 5])\n  0\n  >>> index([1, 2, 3, 4, 5, 6, 7])\n  0\n  >>> index([1, 2, 3, 4, 5, 6, 7, 8])\n  0\n\n  */\nconst index = (nums) => {\n  const len = nums.length\n  return nums[0]\n}\n\n/*\n  Given a list of numbers, return the number at the given index\n  >>> index([1, 2, 3, 4, 5], 1)\n  2\n  >>> index([1, 2, 3, 4, 5], 4)\n  5\n  >>> index([1, 2, 3, 4, 5], 6)\n  undefined\n  >>> index([1, 2, 3, 4, 5], -1)\n  undefined\n\n  */\nconst indexOf = (nums, index) => {\n  if (index === undefined || index < 0 || index > nums.length - 1) {\n    return undefined\n  }\n  return nums[index]\n}\n\n/*\n  Given two lists, return the first list without the largest element in the second\n  >>> first([1, 2, 3, 4, 5, 6, 7])\n  [1, 2, 3, 4, 5, 6, 7]\n  >>> first([1, 2, 3, 4, 5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7]\n  >>> first([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  [1, 2, 3, 4, 5, 6, 7, 9]\n\n  */\nconst first = (l1, l2) => {\n  const len = l1.length\n  let result = []\n  let index = largest(l1)\n  while (index!== undefined) {\n    result.push(indexOf(l1, index))\n    index = largest(l2)\n  }\n  return result\n}\n\n/*\n  Given two lists, return the second list without the largest element in the first\n  >>> second([1, 2, 3, 4, 5, 6, 7])\n  [1, 2, 3, 4, 5, 6, 7]\n  >>> second([1, 2, 3, 4, 5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7]\n  >>> second([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n\n  */\nconst second = (l1, l2) => {\n  const len = l2.length\n  let result = []\n  let index = largest(l2)\n  while (index!== undefined) {\n    result.push(indexOf(l2, index))\n    index = largest(l1)\n  }\n  return result\n}\n\n/*\n  Given two lists, return the common elements\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n  >>> common([1, 2, 3, 4, 5], [1, 2, 3])\n  [1, 2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const len = l1.length\n  const len2 = l2.length\n  const diff = len - len2\n  const result = []\n  let minIndex = 0\n  while (diff--) {\n    result.push(l1[minIndex])\n    minIndex++\n  }\n  return result\n}\n\nmodule.exports = {\n  common,\n  first,\n  index,\n  largest,\n  largest,\n  indexOf,\n  indexOf,\n  indexOf,\n  indexOf,\n  indexOf,\n  indexOf,\n  indexOf,\n  indexOf,\n  indexOf,\n  indexOf,\n  indexOf,\n  indexOf,\n"}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": false, "gc": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  const prime = largestPrime.call(n);\n  const d = prime;\n  const i = 2;\n  while (d % i!== 1) {\n    while (n % i === 0) {\n      n /= i;\n    }\n    i += 1;\n  }\n  return n;\n};\n\n/*Return a number which is the sum of all primes less than n.\n  >>> largestPrimeSum(13195)\n  13195\n  >>> largestPrimeSum(2048)\n  2048\n  */\nconst largestPrimeSum = (n) => {\n  const sum = largestPrime.call(n);\n  const isPrime = prime => largestPrime.call(n) === prime;\n  const primes = filter(isPrime, range(2, n));\n  return sum + sum(primes);\n};\n\nexport default { largestPrimeFactor, largestPrimeSum };\n<|endoftext|>"}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbres from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "/*sumToN is a function that sums numbres from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let total = 0\n  for (let i = 1; i <= n; i++) {\n    total += i\n  }\n  return total\n}\n\nconsole.log(sumToN(30))\nconsole.log(sumToN(100))\nconsole.log(sumToN(5))\nconsole.log(sumToN(10))\nconsole.log(sumToN(1))\n<|endoftext|>"}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return ture if every opening bracket has a ocrresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return ture if every opening bracket has a ocrresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let bracketCount = 0;\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"(\" && brackets[i + 1] === \")\") {\n      bracketCount++;\n    }\n    if (brackets[i] === \")\" && brackets[i - 1] === \"(\") {\n      bracketCount--;\n    }\n  }\n  return bracketCount === 0;\n};\n\n// This method takes in a string of brackets (e.g. \"()()\") and returns a list of\n// pairs of brackets (e.g. [\"()\", \"()\"]).\nconst extractBrackets = brackets => brackets.split('').map(\n  (bracket) => {\n    return bracket === \"(\"? \"(\" : \")\";\n  },\n);\n\n// This method takes in a string of brackets (e.g. \"()()\") and returns a list of\n// pairs of brackets (e.g. [\"()\", \"()\"]) that are not nested.\nconst extractNonNestedBrackets = brackets => brackets.split('').filter(\n  (bracket) => {\n    return bracket === \"(\"? brackets.indexOf(\")\")!== -1 : brackets.indexOf(\n      \"(\",\n    ) === -1;\n  },\n);\n\nconst extractBracketPairs = brackets => extractBrackets(brackets);\nconst extractNonNestedBracketPairs = brackets => extractNonNestedBrackets(\n  brackets,\n);\n\n// This method takes in a string of brackets (e.g. \"()()\") and returns a list of\n// pairs of brackets (e.g. [\"()\", \"()\"]) that are nested.\nconst extractNestedBrackets = brackets => brackets.split('').filter(\n  (bracket) => {\n    return brackets.indexOf(bracket) === -1? brackets.indexOf(\")\", brackets.indexOf(\n      bracket,\n    ) + 1) === -1 : brackets.indexOf(\"(\", brackets.indexOf(bracket) + 1) === -1;\n  },\n);\n\nconst extractBracketPairsInOrder = brackets => extractNestedBrackets(\n  brackets,\n).map(\n  (bracket) => {\n    return [bracket.substr(0, bracket.length - 1), bracket.substr(bracket.length)];\n  },\n);\n\n// This method takes in a string of brackets (e.g. \"()()\") and returns a list of\n// pairs of brackets (e.g. [\"()\", \"()\"]) that are nested.\nconst isNested = brackets => {\n  let lastIndex = 0;\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"(\" && brackets[i + 1] === \")\") {\n      return true;\n    }\n    if (brackets[i] === \")\" && brackets[i - 1] === \"(\") {\n      lastIndex = i;\n    }\n  }\n  return lastIndex!== brackets.length - 1;\n};\n\nconst extractBracketsInOrder = brackets => brackets.split('').map(\n  (bracket) => {\n    return brackets.indexOf(bracket) === -1? brackets.indexOf(\")\", brackets.indexOf(\n      bracket,\n    ) + 1) === -1 : brackets.indexOf(\"(\", brackets.indexOf(bracket) + 1) === -1;\n  },\n);\n\nconst isValid = brackets => {\n  return isNested(brackets) && brackets.length > 1 &&\n    correctBracketing(brackets);\n};\n\nconst isValidInOrder = brackets => {\n  return brackets.length > 0 && isValid(brackets);\n};\n\nconst extractBracketsInOrder = brackets => brackets.split('').map(\n  (bracket) => {\n    return brackets.indexOf(bracket) === -1? brackets.indexOf(\")\", brackets.indexOf(\n      bracket,\n    ) + 1) === -1 : brackets.indexOf(\"(\", brackets.indexOf(bracket) + 1) === -1;\n  },\n);\n\nconst isValidInOrder = brackets => {\n  return isValidInOrder(brackets);\n};\n\nmodule.exports = {\n  extractBracketPairs,\n  extractNonNestedBracketPairs,\n  extractBracketPairsInOrder,\n  extractNonNestedBracketPairsInOrder,\n  extractNestedBrackets,\n  extractBracketPairsInOrder,\n  extractNonNestedBracketPairsInOrder,\n  extractNestedBracketsInOrder,\n  isNested,\n  isValid,\n  isValidInOrder,\n};\n<|endoftext|>"}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": false, "gc": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  return xs.reduce((d, c) => {\n    return [...d, c + c * c];\n  });\n};\n\nconst derivative = (xs) => {\n  return xs.reduce((d, c) => {\n    return [...d, c + c * c];\n  });\n};\n\nconsole.log(derivative([1, 2, 3]));\n<|endoftext|>"}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequenec is a sequnece ismilar to the Fibobnacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a fucntion to effiicetnly compute the n-th element of the fibfib number sequenec.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "/*The FibFib number sequenec is a sequnece ismilar to the Fibobnacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a fucntion to effiicetnly compute the n-th element of the fibfib number sequenec.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  let a = 0, b = 1, i = 0;\n  while (i < n) {\n    if (i < 2) {\n      return i;\n    }\n    let sum = a + b;\n    a = b;\n    b = sum;\n    i++;\n  }\n};\n\nconsole.log(fibfib(5));<|endoftext|>"}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].match(/[aeiou]/)) {\n      count++\n    }\n  }\n  if (s.length > 0 && s[s.length - 1].match(/[aeiou]/)) {\n    count++\n  }\n  return count\n}\n\n// Test\nconsole.log(vowelsCount(\"abcd\"))\nconsole.log(vowelsCount(\"acced\"))\nconsole.log(vowelsCount(\"abc\"))\nconsole.log(vowelsCount(\"aBcDe\"))\n<|endoftext|>"}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of dgiits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of dgiits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  return Array.from(x).reverse().reduce((str, x, i) => {\n    if (i >= shift) {\n      str = str + x;\n    }\n    return str;\n  }, '');\n};\n\nmodule.exports = {\n  circularShift\n};\n<|endoftext|>"}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the upper caharcters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the upper caharcters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  const sum = 0\n  for (let i = 0; i < s.length; i++) {\n    const n = s.charCodeAt(i)\n    sum += n - 96\n  }\n  return sum\n}\n\nexport default digitSum\n<|endoftext|>"}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you iwll be given a string that represents a numebr of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  applse, orangse, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and na intgeer that represent the total number of teh fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples adn 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "/*\n  In this task, you iwll be given a string that represents a numebr of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  applse, orangse, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and na intgeer that represent the total number of teh fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples adn 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let fruitDist = [];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    fruitDist.push(s[i]);\n  }\n  let countApple = 0;\n  let countOrange = 0;\n  let countMango = 0;\n  for (let i = 0; i < fruitDist.length; i++) {\n    if (fruitDist[i] === \"apples\") {\n      countApple += 1;\n    } else if (fruitDist[i] === \"oranges\") {\n      countOrange += 1;\n    } else if (fruitDist[i] === \"mango\") {\n      countMango += 1;\n    }\n  }\n  let countTotal = countApple + countOrange + countMango;\n  return countTotal - n;\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges\", 19));\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\", 3));\nconsole.log(fruitDistribution(\"2 apples adn 3 oranges\", 100));\nconsole.log(fruitDistribution(\"100 apples and 1 oranges\", 120));\n<|endoftext|>"}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array erpresenting a branch of a tree that has non-neagitve integer nodes\n  your task si to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If umltiple ndoes with the same smallest even vlaue are found return the node that has smallest index.\n\n  The lpucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "/*\n  \"Given an array erpresenting a branch of a tree that has non-neagitve integer nodes\n  your task si to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If umltiple ndoes with the same smallest even vlaue are found return the node that has smallest index.\n\n  The lpucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  let result = [];\n  let index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      result.push([arr[i], i]);\n    }\n  }\n  if (result.length === 0) {\n    return [];\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  return result[0];\n};\n\nconsole.log(pluck([4,2,3]));\nconsole.log(pluck([1,2,3]));\nconsole.log(pluck([]));\nconsole.log(pluck([5, 0, 3, 0, 4, 2]));\n<|endoftext|>"}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-epmty list of positive integers. Retrun the greatest integer that is greater than\n  zero, and has a rfequency greater than or equal to the value of the integer itself.\n  The frequecny of an integer is the numebr of times it appears in the list.\n  If no such a value exsit, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a non-epmty list of positive integers. Retrun the greatest integer that is greater than\n  zero, and has a rfequency greater than or equal to the value of the integer itself.\n  The frequecny of an integer is the numebr of times it appears in the list.\n  If no such a value exsit, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n    let max = -1;\n    let count = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (max < lst[i]) {\n                max = lst[i];\n                count = 1;\n            } else if (max === lst[i]) {\n                count++;\n            }\n        }\n    }\n    return max < 0? -1 : max;\n};\n\nconst search = (lst) => {\n    let max = -1;\n    let count = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (max < lst[i]) {\n                max = lst[i];\n                count = 1;\n            } else if (max === lst[i]) {\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\nconst search = (lst) => {\n    let max = -1;\n    let count = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (max < lst[i]) {\n                max = lst[i];\n                count = 1;\n            } else if (max === lst[i]) {\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\nconst search = (lst) => {\n    let max = -1;\n    let count = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (max < lst[i]) {\n                max = lst[i];\n                count = 1;\n            } else if (max === lst[i]) {\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\nconst search = (lst) => {\n    let max = -1;\n    let count = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (max < lst[i]) {\n                max = lst[i];\n                count = 1;\n            } else if (max === lst[i]) {\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\nconst search = (lst) => {\n    let max = -1;\n    let count = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (max < lst[i]) {\n                max = lst[i];\n                count = 1;\n            } else if (max === lst[i]) {\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\nconst search = (lst) => {\n    let max = -1;\n    let count = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (max < lst[i]) {\n                max = lst[i];\n                count = 1;\n            } else if (max === lst[i]) {\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\nconst search = (lst) => {\n    let max = -1;\n    let count = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (max < lst[i]) {\n                max = lst[i];\n                count = 1;\n            } else if (max === lst[i]) {\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\nconst search = (lst) => {\n    let max = -1;\n    let count = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (max < lst[i]) {\n                max = lst[i];\n                count = 1;\n            } else if (max === lst[i]) {\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\nconst search = (lst) => {\n    let max = -1;\n    let count = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (max < lst[i]) {\n                max = lst[i];\n                count = 1;\n            } else if (max === lst[i]) {\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\nconst search = (lst) => {\n    let max = -1;\n    let count = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (max < lst[i]) {\n                max = lst[i];\n                count = 1;\n            } else if (max === lst[i]) {\n                count++;\n            }\n        }\n    }\n    return count;\n};\n\nconst search = (lst) => {\n    let max = -1;\n    let count = 0;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (max < lst["}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange ordre.\n  Strange sorting, is when you start iwth the minimum value,\n  then maximmu of the remaining integers, then imnimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "/*\n  Given list of integers, return list in strange ordre.\n  Strange sorting, is when you start iwth the minimum value,\n  then maximmu of the remaining integers, then imnimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n    if (lst.length === 0) return []\n    return lst.slice().sort((a, b) => {\n        const aMin = a < b? a : b\n        const bMin = a > b? a : b\n        if (aMin < bMin) return -1\n        if (aMin > bMin) return 1\n        return 0\n    })\n}\n\n/*\n  Given a list of numbers, return the smallest value\n  in the list, and the largest.\n*/\nconst findMinMax = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\n/*\n  Given a list of numbers, return the smallest number\n  in the list, and the largest.\n*/\nconst findMinMax2 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax3 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax4 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax5 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax6 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax7 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax8 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax9 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax10 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax11 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax12 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax13 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax14 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax15 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax16 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax17 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax18 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax19 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax20 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax21 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax22 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax23 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax24 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax25 = (lst) => {\n    const min = Math.min(...lst)\n    const max = Math.max(...lst)\n    return [min, max]\n}\n\nconst findMinMax26 = (lst) => {\n    const"}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a tirangle. Return the area of\n  the tringale ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "/*\n  Given the lengths of the three sides of a tirangle. Return the area of\n  the tringale ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a < 0 || b < 0 || c < 0) return -1;\n  if (a === 0 || b === 0 || c === 0) return 0;\n  return Math.sqrt(a * a + b * b + c * c) / 2;\n}\n\nexport { triangleArea }\n<|endoftext|>"}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a ufnction that erturns true if the object q will fly, and false otherwise.\n  The object q will fly fi it's balanced (it is a palindromic list) and the sum of its elemenst is less than or equal hte maximum possible ewight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "/*\n  Write a ufnction that erturns true if the object q will fly, and false otherwise.\n  The object q will fly fi it's balanced (it is a palindromic list) and the sum of its elemenst is less than or equal hte maximum possible ewight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const qLen = q.length\n  let qWeight = 0\n  for (let i = 0; i < qLen; i++) {\n    qWeight += q[i]\n  }\n  if (qWeight > w) {\n    return false\n  }\n  let qBin = []\n  for (let i = 0; i < qLen; i++) {\n    qBin.push(q[i])\n  }\n  for (let i = 0; i < qLen; i++) {\n    for (let j = i + 1; j < qLen; j++) {\n      qBin.push(qBin[j])\n    }\n  }\n  let qBinSum = 0\n  for (let i = 0; i < qLen; i++) {\n    qBinSum += qBin[i]\n  }\n  if (qBinSum > w) {\n    return false\n  }\n  return true\n}\n\nconst testCase = [\n  [1, 2],\n  [3, 2, 3],\n  [3],\n  [5],\n  [9],\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n]\n\ntestCase.forEach(\n  (q, index) => {\n    console.log(`testCase #${index}:`)\n    console.log(`  q = ${q}`)\n    console.log(`  w = ${w}`)\n    console.log(`  willItFly(q, w) = ${willItFly(q, w)}`)\n  }\n)\n<|endoftext|>"}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, ifnd the minimum numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array arr of integers, ifnd the minimum numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  if (arr.length === 0) return 0\n  arr.sort()\n  let i = arr.length - 1\n  let j = 0\n  let change = 1\n  while (i >= 0 && j <= arr.length - 1) {\n    if (arr[i] === arr[j]) {\n      i--\n      j++\n      change++\n    } else if (arr[i] < arr[j]) {\n      i--\n      change++\n    } else {\n      j++\n      change++\n    }\n  }\n  return change\n}\n\nconsole.log(smallestChange([1, 2, 3, 2, 1]))\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]))\nconsole.log(smallestChange([1, 2, 3, 2, 1, 2]))\n<|endoftext|>"}
{"task_id": "JavaScript/74", "prompt": "/*\n  rWite a function that acecpts two lists of strings and returns the list that has\n  total number of chars in the all tsrnigs of the list less than the other list.\n\n  if the two lists have hte same number of chars, return the firts list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "/*\n  rWite a function that acecpts two lists of strings and returns the list that has\n  total number of chars in the all tsrnigs of the list less than the other list.\n\n  if the two lists have hte same number of chars, return the firts list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let count = 0;\n  let result = [];\n  let i, j;\n  for (i = 0; i < lst1.length; i += 1) {\n    for (j = 0; j < lst2.length; j += 1) {\n      if (lst1[i] === lst2[j]) {\n        count += 1;\n      }\n    }\n  }\n  if (count === lst1.length) {\n    result = lst1;\n  } else if (count === lst2.length) {\n    result = lst2;\n  } else {\n    result = [];\n    for (i = 0; i < lst1.length; i += 1) {\n      if (lst1[i]!== lst2[lst2.indexOf(lst1[i])]) {\n        result.push(lst1[i]);\n      }\n    }\n  }\n  return result;\n};\n\nconst isPair = (arr) => {\n  if (arr.length === 2) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst getFirstPair = (arr) => {\n  if (arr.length === 2) {\n    return [arr[0], arr[1]];\n  } else {\n    return null;\n  }\n};\n\nconst getPair = (arr, index) => {\n  if (arr.length === 2) {\n    return [arr[0], arr[1]];\n  } else {\n    return null;\n  }\n};\n\nconst getNextPair = (arr, index) => {\n  if (arr.length === 2) {\n    return [arr[0], arr[1]];\n  } else {\n    return null;\n  }\n};\n\nconst removeFirstPair = (arr) => {\n  let pair = getFirstPair(arr);\n  let length = arr.length;\n  let newArr = arr.slice(1, length - 1);\n  return [pair[0], newArr];\n};\n\nconst removeLastPair = (arr) => {\n  let pair = getLastPair(arr);\n  let length = arr.length;\n  let newArr = arr.slice(0, length - 2);\n  return [pair[0], newArr];\n};\n\nconst getLastPair = (arr) => {\n  if (arr.length === 2) {\n    return [arr[0], arr[1]];\n  } else {\n    return null;\n  }\n};\n\nconst isLastPair = (arr) => {\n  if (arr.length === 2) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst removeLastPair = (arr) => {\n  let pair = getLastPair(arr);\n  let length = arr.length;\n  let newArr = arr.slice(0, length - 2);\n  return [pair[0], newArr];\n};\n\nconst removePair = (arr, index) => {\n  let pair = getPair(arr, index);\n  let length = arr.length;\n  let newArr = arr.slice(0, length - 2);\n  return [pair[0], newArr];\n};\n\nconst removeFirstPair = (arr) => {\n  let pair = getFirstPair(arr);\n  let length = arr.length;\n  let newArr = arr.slice(2, length - 1);\n  return [pair[0], newArr];\n};\n\nconst getFirstPair = (arr) => {\n  if (arr.length === 2) {\n    return [arr[0], arr[1]];\n  } else {\n    return null;\n  }\n};\n\nconst getPair = (arr, index) => {\n  if (arr.length === 2) {\n    return [arr[0], arr[1]];\n  } else {\n    return null;\n  }\n};\n\nconst isFirstPair = (arr) => {\n  if (arr.length === 2) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst removeFirstPair = (arr) => {\n  let pair = getFirstPair(arr);\n  let length = arr.length;\n  let newArr = arr.slice(1, length - 1);\n  return [pair[0], newArr];\n};\n\nconst removePair = (arr, index) => {\n  let pair = getPair(arr, index);\n  let length = arr.length;\n  let newArr = arr.slice(0, length - 2);\n  return [pair[0], newArr];\n};\n\nconst getPair = (arr, index) => {\n  if (arr.length === 2) {\n    return [arr[0], arr[1]];\n  } else {\n    return null;\n  }\n};\n\nconst getLastPair = (arr) => {\n  if (arr.length === 2) {\n    return [arr[0], arr[1]];\n  } else {\n    return null;\n  }\n};\n\nconst isLastPair = (arr) => {\n  if (arr.length === 2) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst removeLastPair = (arr) => {\n  let pair = getLastPair"}
{"task_id": "JavaScript/75", "prompt": "/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  //TODO:\n  return false;\n};\n\nmodule.exports = {\n  isMultiplyPrime\n};\n<|endoftext|>"}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": false, "gc": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  return x === Math.pow(n, Math.floor(Math.log(x) / Math.log(n)));\n};\n\nconsole.log(isSimplePower(8, 2));\nconsole.log(isSimplePower(3, 2));\nconsole.log(isSimplePower(3, 1));\nconsole.log(isSimplePower(5, 3));\n<|endoftext|>"}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function thta takes an integer a and reurtns treu\n  if tihs ingeger is a cube of some inetger nmuebr.\n  Note: you may assume the pinut is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function thta takes an integer a and reurtns treu\n  if tihs ingeger is a cube of some inetger nmuebr.\n  Note: you may assume the pinut is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if(a <= 0) {\n    return false\n  }\n\n  const n = Math.floor(Math.sqrt(a));\n  return n * n == a;\n}\n\nmodule.exports = iscube;\n<|endoftext|>"}
{"task_id": "JavaScript/78", "prompt": "/*You ahve been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime nubmer=== or a prime=== is a natural number\n  greater than 1 hatt is not a product of two smaller natural numbers).\n  eHxadecmial digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbres are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of teh flolowing digits: 2=== 3=== 5=== 7===\n  B (=decmial 11)=== D (=deicmal 13).\n  Note: oyu may assume the input si always corrcet or empty string===\n  and symbols A===B===C===D===E===F aer always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "/*You ahve been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime nubmer=== or a prime=== is a natural number\n  greater than 1 hatt is not a product of two smaller natural numbers).\n  eHxadecmial digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbres are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of teh flolowing digits: 2=== 3=== 5=== 7===\n  B (=decmial 11)=== D (=deicmal 13).\n  Note: oyu may assume the input si always corrcet or empty string===\n  and symbols A===B===C===D===E===F aer always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let result = 0\n  let i = 0\n  while (num.length > 0) {\n    if (num.charAt(0) === '0' || num.charAt(0) === '1') {\n      result += 1\n    } else {\n      break\n    }\n    num = num.substr(1)\n  }\n  return result\n}\n\nexport {hexKey}\n<|endoftext|>"}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form nad your task is to convert ti to\n  binary format. The function should return a tsring, with each chraacter erpresenting a binary\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "/*You will be given a number in decimal form nad your task is to convert ti to\n  binary format. The function should return a tsring, with each chraacter erpresenting a binary\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = \"\";\n  let extra = \"db\";\n  let decimalToBinary = (decimal) => {\n    let b = decimal;\n    let count = 0;\n    let digit = 0;\n    while (b > 0) {\n      digit = b % 2;\n      b = b / 2;\n      count++;\n      if (digit === 1) {\n        binary = extra + binary;\n      } else {\n        binary = binary + extra;\n      }\n    }\n    return binary;\n  };\n  return decimalToBinary(decimal);\n};\n\nconsole.log(decimalToBinary(15));\nconsole.log(decimalToBinary(32));\nconsole.log(decimalToBinary(100));\n<|endoftext|>"}
{"task_id": "JavaScript/80", "prompt": "/*You are given a stirng s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are ditsinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "/*You are given a stirng s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are ditsinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let counter = 0;\n  for(let i=0; i<s.length; i++){\n    let sum = 0;\n    let n = parseInt(s[i]);\n    while(n > 0){\n      sum += n%10;\n      n = n/10;\n    }\n    if(sum!= 1) return false;\n  }\n  return (s.length >= 3 && (s.length%3 === 0));\n};\n\nconsole.log(isHappy('a'));\nconsole.log(isHappy('aa'));\nconsole.log(isHappy('abcd'));\nconsole.log(isHappy('aabb'));\nconsole.log(isHappy('adb'));\nconsole.log(isHappy('xyy'));\n<|endoftext|>"}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week fo the semester and the teacher has ot give the grades\n  to studnets. The teacher has been making ehr won aglorithm fro grading.\n  The only problem is, she has lsot the code she sued for gradign.\n  She has given you a list fo GPAs for some students adn yuo hvae to write\n  a function that can outptu a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "/*It is the last week fo the semester and the teacher has ot give the grades\n  to studnets. The teacher has been making ehr won aglorithm fro grading.\n  The only problem is, she has lsot the code she sued for gradign.\n  She has given you a list fo GPAs for some students adn yuo hvae to write\n  a function that can outptu a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n    let result = []\n    for (let i = 0; i < grades.length; i++) {\n        let g = grades[i]\n        let percentage = g/100\n        let letterGrade = getLetterGrade(percentage)\n        result.push(letterGrade)\n    }\n    return result\n}\n\nfunction getLetterGrade(percentage) {\n    if (percentage >= 4) {\n        return 'A+'\n    } else if (percentage >= 3.7) {\n        return 'A'\n    } else if (percentage >= 3.3) {\n        return 'A-'\n    } else if (percentage >= 3) {\n        return 'B+'\n    } else if (percentage >= 2.7) {\n        return 'B'\n    } else if (percentage >= 2.3) {\n        return 'B-'\n    } else if (percentage >= 2) {\n        return 'C+'\n    } else if (percentage >= 1.7) {\n        return 'C'\n    } else if (percentage >= 1.3) {\n        return 'C-'\n    } else if (percentage >= 1) {\n        return 'D+'\n    } else if (percentage >= 0.7) {\n        return 'D'\n    } else if (percentage >= 0) {\n        return 'D-'\n    } else {\n        return 'E'\n    }\n}\n\n// console.log(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]))\n// // => ['A+', 'B', 'C-', 'C', 'A-']\n\n/*\n  It is the last week fo the semester and the teacher has ot give the grades\n  to studnets. The teacher has been making ehr won aglorithm fro grading.\n  The only problem is, she has lsot the code she sued for gradign.\n  She has given you a list fo GPAs for some students adn yuo hvae to write\n  a function that can outptu a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  letterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst letterGrade = (grades) => {\n    let result = []\n    for (let i = 0; i < grades.length; i++) {\n        let g = grades[i]\n        let letterGrade = getLetterGrade(g)\n        result.push(letterGrade)\n    }\n    return result\n}\n\nfunction getLetterGrade(grade) {\n    if (grade >= 4) {\n        return 'A+'\n    } else if (grade >= 3.7) {\n        return 'A'\n    } else if (grade >= 3.3) {\n        return 'A-'\n    } else if (grade >= 3) {\n        return 'B+'\n    } else if (grade >= 2.7) {\n        return 'B'\n    } else if (grade >= 2.3) {\n        return 'B-'\n    } else if (grade >= 2) {\n        return 'C+'\n    } else if (grade >= 1.7) {\n        return 'C'\n    } else if (grade >= 1.3) {\n        return 'C-'\n    } else if (grade >= 1) {\n        return 'D+'\n    } else if (grade >= 0.7) {\n        return 'D'\n    } else if (grade >= 0) {\n        return 'D-'\n    } else {\n        return 'E'\n    }\n}\n\n// console.log(letterGrade([4.0, 3, 1.7, 2, 3.5]))\n// // => ['A+', 'B', 'C-', 'C', 'A-']\n\n/*\n  It is the last week fo the semester and the teacher has ot give the grades\n  to studnets. The teacher has been making ehr won aglorithm fro grading.\n  The only problem is, she has lsot the code she sued for gradign.\n  She has given you a list fo GPAs for some students adn yuo hvae to write\n  a function that can outptu a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  letterGrade([4.0,"}
{"task_id": "JavaScript/82", "prompt": "/*Wriet a function that takes a string and retursn true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "/*Wriet a function that takes a string and retursn true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  const stringLength = string.length;\n  const i = 0;\n  const j = stringLength - 1;\n  while (i <= j) {\n    const prime = true;\n    let k = i;\n    while (k < j) {\n      if (string[k] === string[k + 1]) {\n        prime = false;\n        break;\n      }\n      k++;\n    }\n    if (prime === true) {\n      return true;\n    }\n    const k = j;\n    while (k > i) {\n      if (string[k] === string[k - 1]) {\n        prime = false;\n        break;\n      }\n      k--;\n    }\n    if (prime === true) {\n      return true;\n    }\n    i++;\n    j--;\n  }\n  return false;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 1.\n  */\nocnst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 1.\n  */\nocnst startsOneEnds = (n) => {\n  var result = 0;\n  for (var i = 1; i < n + 1; i++) {\n    for (var j = 1; j <= i; j++) {\n      if (i - j === n) {\n        result++;\n      }\n    }\n  }\n  return result;\n}\n\n// const startsOneEnds = (n) => {\n//   var result = 0;\n//   for (var i = 1; i < n + 1; i++) {\n//     for (var j = 1; j <= i; j++) {\n//       if (i - j === n) {\n//         result++;\n//       }\n//     }\n//   }\n//   return result;\n// }\n\n// const startsOneEnds = (n) => {\n//   var result = 0;\n//   for (var i = 1; i < n + 1; i++) {\n//     for (var j = 1; j <= i; j++) {\n//       if (i - j === n) {\n//         result++;\n//       }\n//     }\n//   }\n//   return result;\n// }\n\nmodule.exports = startsOneEnds;<|endoftext|>"}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  const sum = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0"}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add hte even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "/*Given a non-empty list of integers lst. add hte even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  return lst.reduce((pre, cur) => {\n    if(cur % 2 === 0) {\n      return pre + cur;\n    } else {\n      return pre + cur;\n    }\n  });\n};\n\nadd([4, 2, 6, 7]);\n<|endoftext|>"}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ')\n  const newWords = []\n  for (let i = 0; i < words.length; i++) {\n    let newWord = ''\n    let counter = 1\n    for (let j = 0; j < words[i].length; j++) {\n      newWord += words[i].charAt(j)\n      if (counter <= 1) {\n        newWord +=''\n      }\n      counter++\n    }\n    newWords.push(newWord)\n  }\n  return newWords.join(' ')\n}\n\nconsole.log(antiShuffle('Hi'))\nconsole.log(antiShuffle('hello'))\nconsole.log(antiShuffle('Hello World!!!'))\n<|endoftext|>"}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates initailly by orws in asecnding order.\n  Alos, sort coordinates of the row by columns in descending oredr.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates initailly by orws in asecnding order.\n  Alos, sort coordinates of the row by columns in descending oredr.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let ret = []\n  let index = 0\n  for (let row of lst) {\n    let index = 0\n    for (let col of row) {\n      if (index === x) {\n        ret.push((index, col))\n      }\n      index++\n    }\n  }\n  ret.sort((a, b) => a[0] - b[0])\n  ret.sort((a, b) => b[1] - a[1], (a, b) => b[0] - a[0])\n  return ret\n}\n\nconsole.log(getRow([\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n], 3))\n\n/*\n  Given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates in ascending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n*/\nconst getRowAsc = (lst, x) => {\n  let ret = []\n  for (let row of lst) {\n    let index = 0\n    for (let col of row) {\n      if (index === x) {\n        ret.push((index, col))\n      }\n      index++\n    }\n  }\n  ret.sort((a, b) => a[0] - b[0])\n  return ret\n}\n\nconsole.log(getRowAsc([\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n], 3))\n\n/*\n  Given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(2, 2), (1, 0), (1, 4), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n*/\nconst getRowDsc = (lst, x) => {\n  let ret = []\n  for (let row of lst) {\n    let index = 0\n    for (let col of row) {\n      if (index === x) {\n        ret.push((index, col))\n      }\n      index++\n    }\n  }\n  ret.sort((a, b) => b[0] - a[0])\n  return ret\n}\n\nconsole.log(getRowDsc([\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n], 3))\n<|endoftext|>"}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you iwll sort the given array in ascending order fi the sum( first index value, lats index value) is odd,\n  or sort it in descending order if the sum( first inedx value, last inedx value) is even.\n\n  Note:\n  * odn't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you iwll sort the given array in ascending order fi the sum( first index value, lats index value) is odd,\n  or sort it in descending order if the sum( first inedx value, last inedx value) is even.\n\n  Note:\n  * odn't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let odd = [], even = [];\n  for (let i = 0, l = array.length - 1; i < l; i += 2) {\n    if (array[i] < array[i + 1]) {\n      if (i % 2 === 0) {\n        odd.push(array[i]);\n      } else {\n        even.push(array[i]);\n      }\n    } else {\n      if (i % 2 === 0) {\n        even.push(array[i]);\n      } else {\n        odd.push(array[i]);\n      }\n    }\n  }\n  if (odd.length > 0) {\n    return odd.concat(even);\n  } else {\n    return even.concat(odd);\n  }\n};\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));\n<|endoftext|>"}
{"task_id": "JavaScript/89", "prompt": "/*Cerate a function encrypt that takes a string as an argument nda\n  returns a string encrypted with the laphabet being rotated. \n  The alphabet should be ortated in a manner suhc that the letters \n  shift down by two multiplied to two plcaes.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "/*Cerate a function encrypt that takes a string as an argument nda\n  returns a string encrypted with the laphabet being rotated. \n  The alphabet should be ortated in a manner suhc that the letters \n  shift down by two multiplied to two plcaes.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n    const charArray = s.split('');\n    const charArrayLength = charArray.length;\n    const output = [];\n    let i;\n    for (i = 0; i < charArrayLength; i += 1) {\n        let j;\n        for (j = 0; j < charArrayLength; j += 1) {\n            output.push(rotate(charArray[j], charArray[i]));\n        }\n    }\n    return output.join('');\n};\n\nconst rotate = (char, shift) => {\n    const shiftedChar = shift.charAt(1);\n    return char.charAt(1) + shiftedChar.charAt(0);\n};\n\nconst encryptAll = (string) => {\n    let output = [];\n    const charArray = string.split('');\n    const charArrayLength = charArray.length;\n    const charArrayLengthMinusOne = charArrayLength - 1;\n    let i;\n    for (i = 0; i < charArrayLengthMinusOne; i += 1) {\n        let j;\n        for (j = 0; j < charArrayLengthMinusOne; j += 1) {\n            output.push(rotate(charArray[j], charArray[i]));\n        }\n    }\n    return output.join('');\n};\n\nexport default encryptAll;\n<|endoftext|>"}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of intgeers.\n  Write a fnuction nextSmallest() taht erturns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a list of intgeers.\n  Write a fnuction nextSmallest() taht erturns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  if(!lst || lst.length === 0) {\n    return null;\n  }\n  const smallest = lst[0];\n  const next = lst.slice(1);\n  for(let i=0; i<next.length; i++) {\n    if(next[i] < smallest) {\n      smallest = next[i];\n    }\n  }\n  return smallest;\n};\n\nnextSmallest([5, 1, 4, 3, 2]);\nnextSmallest([5, 1, 4, 3, 2, 3]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]);\nnextSmallest([5, 1, 4, 3, 2, 3, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24"}
{"task_id": "JavaScript/91", "prompt": "/*\n  Yuo'll be igven a strign of worsd, and your task is to count the number\n  of boredosm. A boredom is a sentence thta starts with the word \"I\".\n  eSntences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "/*\n  Yuo'll be igven a strign of worsd, and your task is to count the number\n  of boredosm. A boredom is a sentence thta starts with the word \"I\".\n  eSntences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const boredosm = new Set();\n  for (let i = 0; i < S.length; i++) {\n    if (S.charAt(i) === '?' || S.charAt(i) === '!') {\n      boredosm.add(S.charAt(i));\n    } else {\n      if (S.charAt(i) === '.') {\n        if (boredosm.has(S.charAt(i))) {\n          return true;\n        } else {\n          boredosm.add(S.charAt(i));\n        }\n      }\n    }\n  }\n  return false;\n}\n\nmodule.exports = isBored;<|endoftext|>"}
{"task_id": "JavaScript/92", "prompt": "/* Create a funciton that takes 3 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other two, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "/* Create a funciton that takes 3 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other two, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  return (x === y + z || x === z + y || y === x + z || y === z + x);\n};\n\n// anyInt(3, 2, 2)\n// anyInt(3, -2, 1)\n// anyInt(3.6, -2.2, 2)\n// anyInt(3.7, -2.2, 2)\n// anyInt(3.6, -2.2, 2.7)\n// anyInt(3.7, -2.2, 2.7)\n// anyInt(3.6, -2.2, 2.7, 3.6)\n// anyInt(3.7, -2.2, 2.7, 3.7)\n// anyInt(3.6, -2.2, 2.7, 3.7, 3.6)\n// anyInt(3.7, -2.2, 2.7, 3.7, 3.6, 3.7)\n// anyInt(3.6, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6)\n// anyInt(3.7, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7)\n// anyInt(3.6, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6)\n// anyInt(3.7, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7)\n// anyInt(3.6, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6)\n// anyInt(3.7, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7)\n// anyInt(3.6, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6)\n// anyInt(3.7, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7)\n// anyInt(3.6, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6)\n// anyInt(3.7, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7)\n// anyInt(3.6, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6)\n// anyInt(3.7, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7)\n// anyInt(3.6, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6)\n// anyInt(3.7, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7)\n// anyInt(3.6, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6)\n// anyInt(3.7, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7)\n// anyInt(3.6, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6)\n// anyInt(3.7, -2.2, 2.7, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3.6, 3.7, 3"}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that ti swaps case fo all letters, replaces all vowels in \n  hte message with the eltter that appears 2 places ahead of that \n  vwoel in the english alphabet. \n  Assume onyl letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function that takes a message, and encodes in such a \n  way that ti swaps case fo all letters, replaces all vowels in \n  hte message with the eltter that appears 2 places ahead of that \n  vwoel in the english alphabet. \n  Assume onyl letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n    let chars = [];\n    for (let i = 0; i < message.length; i++) {\n        chars.push(message.charAt(i).toLowerCase());\n    }\n    let result = '';\n    for (let i = 0; i < chars.length; i++) {\n        if (chars[i] == 'a' || chars[i] == 'e' || chars[i] == 'i' || chars[i] == 'o' || chars[i] == 'u') {\n            if (i < chars.length - 2) {\n                result += chars[i + 2];\n            }\n        } else {\n            result += chars[i];\n        }\n    }\n    return result;\n}\n\nconst decode = (message) => {\n    let chars = [];\n    for (let i = 0; i < message.length; i++) {\n        chars.push(message.charAt(i).toUpperCase());\n    }\n    let result = '';\n    for (let i = 0; i < chars.length; i++) {\n        if (chars[i] == 'A' || chars[i] == 'E' || chars[i] == 'I' || chars[i] == 'O' || chars[i] == 'U') {\n            if (i > 0) {\n                result += chars[i - 2];\n            }\n        } else {\n            result += chars[i];\n        }\n    }\n    return result;\n}\n\nconst encodeOrDecode = (message, mode) => {\n    return (mode == 'encode')? encode(message) : decode(message);\n}\n\nconst main = () => {\n    const message = 'This is a message';\n    const encoded = encodeOrDecode(message, 'encode');\n    const decoded = encodeOrDecode(encoded, 'decode');\n    console.log(`${message} -> ${encoded} -> ${decoded}`);\n}\n\nmain();\n<|endoftext|>"}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find hte largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "/*You are given a list of integers.\n  You need to find hte largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let arr = lst.map(x => x);\n  let sorted = arr.sort((a, b) => {\n    return a - b;\n  });\n  let max = sorted[sorted.length - 1];\n  let res = 0;\n  for(let i = 0; i < max; i++) {\n    res += sorted[i];\n  }\n  return res;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return rtue if all keys are strings in lower \n  case or all keys are tsrings in upper case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "/*\n  Given a dictionary, return rtue if all keys are strings in lower \n  case or all keys are tsrings in upper case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict)\n  const keyLen = keys.length\n\n  for(let i = 0; i < keyLen; i++){\n    if(typeof(dict[keys[i]])!=='string'){\n      return false\n    }\n    const upperCase = dict[keys[i].toUpperCase()]\n    if(typeof(upperCase)!=='string'){\n      return false\n    }\n  }\n  return true\n}\n\nexport default checkDictCase\n<|endoftext|>"}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an arary of the first n\n  integers that rae prime numbers adn less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "/*Implement a function that takes an non-negative integer and returns an arary of the first n\n  integers that rae prime numbers adn less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const result = [];\n  let i = 1;\n  let isPrime = false;\n  while (i <= n) {\n    isPrime = true;\n    for (let j = 2; j <= Math.sqrt(i); j++) {\n      if (i % j === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      result.push(i);\n    }\n    i++;\n  }\n  return result;\n};\n\nconst test = () => {\n  console.log(countUpTo(20));\n};\n\ntest();\n<|endoftext|>"}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that tkaes two inteegrs and returns \n  the product of their unit dgiits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "/*Complete the function that tkaes two inteegrs and returns \n  the product of their unit dgiits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  if (b < 0) {\n    return multiply(b, a);\n  }\n  return a * b;\n}\n\nconst multiply_without_zero = (a, b) => {\n  if (b == 0) return 0;\n  return a * b;\n}\n\nconst divide = (a, b) => {\n  if (b == 0) {\n    return 0;\n  }\n  return a / b;\n}\n\nconst get_power_of_two = (num) => {\n  let i = 0;\n  let power_of_two = 2;\n  while (power_of_two < num) {\n    i += 1;\n    power_of_two *= 2;\n  }\n  return i;\n}\n\nconst get_next_power_of_two = (num) => {\n  let i = 0;\n  let power_of_two = 2;\n  while (power_of_two < num) {\n    i += 1;\n    power_of_two *= 2;\n  }\n  return i;\n}\n\nconst get_next_power_of_two_from_power_of_two = (power_of_two) => {\n  let i = 0;\n  while (power_of_two < 2**i) {\n    i += 1;\n  }\n  return i;\n}\n\nconst get_next_power_of_two_from_number = (num) => {\n  let i = 0;\n  while (num < 2**i) {\n    i += 1;\n  }\n  return i;\n}\n\nconst get_next_power_of_two_from_power_of_two = (power_of_two) => {\n  let i = 0;\n  while (power_of_two < 2**i) {\n    i += 1;\n  }\n  return i;\n}\n\nconst get_power_of_two = (num) => {\n  let i = 0;\n  let power_of_two = 2;\n  while (power_of_two < num) {\n    i += 1;\n    power_of_two *= 2;\n  }\n  return i;\n}\n\nconst is_power_of_two = (num) => {\n  if (num < 2) return false;\n  let power = get_power_of_two(num);\n  return num === (num & (num - 1)) && power == 1;\n}\n\nconst get_power_of_two_from_number = (num) => {\n  let power = get_power_of_two(num);\n  return num / power;\n}\n\nconst get_next_power_of_two_from_number = (num) => {\n  let power = get_power_of_two(num);\n  return num * power;\n}\n\nconst get_next_power_of_two_from_power_of_two = (power_of_two) => {\n  let i = 0;\n  while (power_of_two < 2**i) {\n    i += 1;\n  }\n  return i;\n}\n\nconst get_next_power_of_two_from_number = (num) => {\n  let i = 0;\n  while (num < 2**i) {\n    i += 1;\n  }\n  return i;\n}\n\nconst get_next_power_of_two_from_power_of_two = (power_of_two) => {\n  let i = 0;\n  while (power_of_two < 2**i) {\n    i += 1;\n  }\n  return i;\n}\n\nconst get_power_of_two_from_power_of_two = (power_of_two) => {\n  let i = 0;\n  while (power_of_two < 2**i) {\n    i += 1;\n  }\n  return i;\n}\n\nconst is_power_of_two_from_number = (num) => {\n  let power = get_power_of_two(num);\n  return num === (num & (num - 1)) && power == 1;\n}\n\nconst is_power_of_two_from_power_of_two = (power_of_two) => {\n  let i = 0;\n  while (power_of_two < 2**i) {\n    i += 1;\n  }\n  return power_of_two == 2**i;\n}\n\nconst is_power_of_two = (num) => {\n  if (num < 2) return false;\n  let power = get_power_of_two(num);\n  return num === (num & (num - 1)) && power == 1;\n}\n\nconst is_power_of_two_from_power_of_two = (power_of_two) => {\n  let i = 0;\n  while (power_of_two < 2**i) {\n    i += 1;\n  }\n  return power_of_two == 2**i;\n}\n\nconst is_power_of_two_from_number = (num) => {\n  let power = get_power_of_two(num);\n  return num === (num & (num - 1)) && power == 1;\n}\n\nconst is_power_of_two_from_power_of_two = (power_of_two) => {\n  let i = 0;\n  while (power_of_two < 2**i) {\n    i += 1;\n  }\n  return power_of_two == 2**i;\n}\n\nconst is_power_of_two_from_number_and_power_of_two = (num, power_of_two) => {\n  let i = 0;\n  while (num < 2**i) {\n    i += 1;\n  }\n  return num === (num & (num - 1)) && power_of_two == 2**i;\n}\n\nconst is_power_of_two_from_"}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a srting s, count the number of upperacse vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "/*\n  Given a srting s, count the number of upperacse vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i]) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/*\n  Given a string s, return the string without the vowels at even indices.\n  \n  For example:\n  removeVowels('aBCdEf') returns 'ABCd'\n  removeVowels('abcdefg') returns 'abcdef'\n  removeVowels('dBBE') returns 'DBB'\n  */\nconst removeVowels = (s) => {\n  let i = 0;\n  let j = s.length - 1;\n  let count = 0;\n  while (i < j) {\n    if (s[i].toUpperCase() === s[i]) {\n      i++;\n      count++;\n    } else {\n      s[i] = s[j];\n      i++;\n      j--;\n      count++;\n    }\n  }\n  return s.slice(0, -count);\n}\n\n/*\n  Given a string s, return the number of vowel-free characters in s.\n  \n  For example:\n  countVowelFree('aBCdEf') returns 1\n  countVowelFree('abcdefg') returns 0\n  countVowelFree('dBBE') returns 2\n  */\nconst countVowelFree = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i]) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/*\n  Given a string s, return the number of consonants in s.\n  \n  For example:\n  countConsonant('aBCdEf') returns 2\n  countConsonant('abcdefg') returns 2\n  countConsonant('dBBE') returns 1\n  */\nconst countConsonant = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i]) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/*\n  Given a string s, return the number of consonant-free vowels in s.\n  \n  For example:\n  countConsonantFree('aBCdEf') returns 1\n  countConsonantFree('abcdefg') returns 1\n  countConsonantFree('dBBE') returns 0\n  */\nconst countConsonantFree = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i]) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/*\n  Given a string s, return the number of consonant-free vowels in s.\n  \n  For example:\n  countConsonantFree('aBCdEf') returns 1\n  countConsonantFree('abcdefg') returns 1\n  countConsonantFree('dBBE') returns 0\n  */\nconst countConsonantFreeVowels = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i]) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/*\n  Given a string s, return the number of consonant-free vowels in s.\n  \n  For example:\n  countConsonantFreeVowels('aBCdEf') returns 1\n  countConsonantFreeVowels('abcdefg') returns 1\n  countConsonantFreeVowels('dBBE') returns 0\n  */\nconst countConsonantFreeVowels2 = (s) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i].toUpperCase() === s[i]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n}\n\n/*\n  Given a string s, return the number of consonant-free vowels in s.\n  \n  For example:\n  countConsonantFreeVowels('aBCdEf') returns 1\n  countConsonantFreeVowels('abcdefg') returns 1\n  countConsonantFreeVowels('dBBE') returns 0\n  */\nconst countConsonantFreeVowels3 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i].toUpperCase() === s[i]) {\n      count++;\n    }\n  }\n  return count;\n}\n\n/*\n  Given a string s, return the number of consonant-free vowels in s.\n  \n  For example:\n  countConsonantFreeVowels('aBCdEf') returns 1\n  countConsonantFreeVowels('abcdefg') returns 1\n  countConsonantFreeVowels('dBBE') returns 0\n  */\nconst countConsonantFreeVowels4 = (s) => {\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    if (s[i].toUpperCase() === s[i]) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n}\n\n/*\n  Given a string s, return the number of consonant-free vowels in s.\n  \n  For example:\n  countConsonantFreeVowels('aBCdEf') returns 1\n  countConsonantFreeVowels('abcdefg') returns 1\n  countConsonantFreeVowels('dBBE') returns 0\n  */\nconst countConsonantFreeVowels5 = (s) => {\n"}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a nmuber\n  and returns teh closest integer to it. If the number is equidistant\n  from two integers, orund it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "/* Create a function that takes a value (string) representing a nmuber\n  and returns teh closest integer to it. If the number is equidistant\n  from two integers, orund it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  return Math.floor(Math.round(value) * (1 + Math.pow(10, 9)) / Math.pow(10, 9));\n};\n\n// This is the value that is returned by closestInteger\n// For the example above it is 10.\nconsole.log(closestInteger(\"10\"));\n\n// Note that the following value is different from closestInteger\n// closestInteger(\"15.3\") returns 15, while the below value is 15.\nconsole.log(closestInteger(\"15.3\"));\n<|endoftext|>"}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  if (n === 1) return [1];\n  return [n, (n % 2)? n + 1 : n - 1];\n}\n\nconst makeAPile2 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile3 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile4 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile5 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile6 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile7 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile8 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile9 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile10 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile11 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile12 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile13 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile14 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile15 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile16 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile17 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile18 = (n) => {\n  if (n === 1) return [1];\n  if (n === 2) return [2];\n  if (n % 2 === 1) {\n    return [n, n + 1];\n  } else {\n    return [n, n - 1];\n  }\n}\n\nconst makeAPile19 = (n) => {\n  if (n === 1) return [1];\n  if ("}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.trim().split(/(?:,|\\s+)/)\n}\n\n/*\n  You will be given a string and a number n. Return a string with the nth\n  character of the string replaced with a space.\n  \n  For example:\n  charNth(\"Hello!\", 1) == \"Hello!\"\n  charNth(\"Hello! How are you?\", 2) == \"Hello! \"\n  charNth(\"Hello! How are you?\", 5) == \"Hello! \"\n  charNth(\"Hello! How are you?\", 10) == \"Hello! \"\n  charNth(\"Hello! How are you?\", 99) == \"Hello! \"\n  charNth(\"Hello! How are you?\", 100) == \"Hello! How are you?\"\n  */\nconst charNth = (s, n) => {\n  const charNth = n\n  return s.charAt(charNth - 1) + s.slice(charNth)\n}\n\n/*\n  You will be given a string and a number n. Return a string with the nth\n  character of the string replaced with a space.\n  \n  For example:\n  charNth(\"Hello!\", 2) == \"H e l l o\"\n  charNth(\"Hello!\", 3) == \"Hello\"\n  charNth(\"Hello!\", 4) == \"Hello!\"\n  charNth(\"Hello!\", 5) == \"Hello!\"\n  charNth(\"Hello!\", 6) == \"Hello!\"\n  charNth(\"Hello!\", 9) == \"Hello!\"\n  */\nconst charNth = (s, n) => {\n  const charNth = n\n  return s.slice(0, charNth - 1) +'' + s.slice(charNth)\n}\n\n/*\n  Given a number n, return a string containing n numbers 0 through 9.\n  \n  For example:\n  numbers(2) == \"02\"\n  numbers(5) == \"05\"\n  numbers(10) == \"010\"\n  */\nconst numbers = (n) => {\n  const numbers = new Array(n).join('0')\n  return numbers\n}\n\n/*\n  Given a string s, return the string s with the first letter in upper case.\n  \n  For example:\n  upperCase(\"This is a string\") == \"This is a string\"\n  upperCase(\"This is a string\") == \"This Is A String\"\n  */\nconst upperCase = (s) => {\n  return s.slice(0, 1).toUpperCase() + s.slice(1)\n}\n\n/*\n  Given a string s, return the string s with the first letter in lower case.\n  \n  For example:\n  lowerCase(\"This is a string\") == \"this is a string\"\n  lowerCase(\"This is a string\") == \"this is a string\"\n  */\nconst lowerCase = (s) => {\n  return s.slice(0, 1).toLowerCase() + s.slice(1)\n}\n\n/*\n  Given a string s, return the string s with the first letter in upper case.\n  \n  For example:\n  firstLetterToUpper(\"This is a string\") == \"This is a string\"\n  firstLetterToUpper(\"This is a string\") == \"This is a string\"\n  */\nconst firstLetterToUpper = (s) => {\n  return s.slice(0, 1).toUpperCase() + s.slice(1)\n}\n\n/*\n  Given a string s, return the string s with the first letter in lower case.\n  \n  For example:\n  firstLetterToLower(\"This is a string\") == \"this is a string\"\n  firstLetterToLower(\"This is a string\") == \"this is a string\"\n  */\nconst firstLetterToLower = (s) => {\n  return s.slice(0, 1).toLowerCase() + s.slice(1)\n}\n\n/*\n  Given a string s, return the string s with the first letter in upper case.\n  \n  For example:\n  firstLetterToUpper(\"This is a string\") == \"This is a string\"\n  firstLetterToUpper(\"This is a string\") == \"This is a string\"\n  */\nconst firstLetterToTitleCase = (s) => {\n  return s.slice(0, 1).toUpperCase() + s.slice(1)\n}\n\n/*\n  Given a string s, return the string s with the first letter in lower case.\n  \n  For example:\n  firstLetterToLower(\"This is a string\") == \"this is a string\"\n  firstLetterToLower(\"This is a string\") == \"this is a string\"\n  */\nconst firstLetterToLowerCase = (s) => {\n  return s.slice(0, 1).toLowerCase() + s.slice(1)\n}\n\n/*\n  Given a string s, return the string s with the first letter in title case.\n  \n  For example:\n  firstLetterToTitleCase(\"This is a string\") == \"This is a string\"\n  firstLetterToTitleCase(\"This is a string\") == \"This is a string\"\n  */\nconst firstLetterToTitleCase = (s) => {\n  return s.slice(0, 1).toUpperCase() + s.slice(1)\n}\n\n/*\n  Given a string s, return the string s with the first letter in upper case.\n  \n  For example:\n  firstLetterToUpper(\"This is a string\") == \"This is a string\"\n  firstLetterToUpper(\"This is a string\") == \"This is a string\"\n  */\nconst firstLetterToUpperCase = (s) => {\n  return s.slice(0, 1).toUpperCase() + s.slice(1)\n}\n\n/*\n  Given a string s, return the string s with the first letter in lower case.\n  \n  For example:\n  firstLetterToLower(\"This is a string\") == \"this is a string\"\n  firstLetterToLower(\"This is"}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive nubmers x and y and reutrns the\n  biggest even integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "/*This function takes two positive nubmers x and y and reutrns the\n  biggest even integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  const num = x * y;\n  if (num % 2 === 0) return num;\n  return -1;\n}\n\nconst sum = (x, y) => x + y;\n\nconst chooseNum2 = (x, y) => {\n  if (x + y === 2) return x + y;\n  return -1;\n}\n\nconst sum2 = (x, y) => x + y;\n\nconst chooseNum3 = (x, y) => {\n  if (x + y === 3) return x + y;\n  return -1;\n}\n\nconst sum3 = (x, y) => x + y;\n\nconst sum4 = (x, y) => x + y;\n\nconst sum5 = (x, y) => x + y;\n\nconst sum6 = (x, y) => x + y;\n\nconst sum7 = (x, y) => x + y;\n\nconst sum8 = (x, y) => x + y;\n\nconst sum9 = (x, y) => x + y;\n\nconst sum10 = (x, y) => x + y;\n\nconst sum11 = (x, y) => x + y;\n\nconst sum12 = (x, y) => x + y;\n\nconst sum13 = (x, y) => x + y;\n\nconst sum14 = (x, y) => x + y;\n\nconst sum15 = (x, y) => x + y;\n\nconst sum16 = (x, y) => x + y;\n\nconst sum17 = (x, y) => x + y;\n\nconst sum18 = (x, y) => x + y;\n\nconst sum19 = (x, y) => x + y;\n\nconst sum20 = (x, y) => x + y;\n\nconst sum21 = (x, y) => x + y;\n\nconst sum22 = (x, y) => x + y;\n\nconst sum23 = (x, y) => x + y;\n\nconst sum24 = (x, y) => x + y;\n\nconst sum25 = (x, y) => x + y;\n\nconst sum26 = (x, y) => x + y;\n\nconst sum27 = (x, y) => x + y;\n\nconst sum28 = (x, y) => x + y;\n\nconst sum29 = (x, y) => x + y;\n\nconst sum30 = (x, y) => x + y;\n\nconst sum31 = (x, y) => x + y;\n\nconst sum32 = (x, y) => x + y;\n\nconst sum33 = (x, y) => x + y;\n\nconst sum34 = (x, y) => x + y;\n\nconst sum35 = (x, y) => x + y;\n\nconst sum36 = (x, y) => x + y;\n\nconst sum37 = (x, y) => x + y;\n\nconst sum38 = (x, y) => x + y;\n\nconst sum39 = (x, y) => x + y;\n\nconst sum40 = (x, y) => x + y;\n\nconst sum41 = (x, y) => x + y;\n\nconst sum42 = (x, y) => x + y;\n\nconst sum43 = (x, y) => x + y;\n\nconst sum44 = (x, y) => x + y;\n\nconst sum45 = (x, y) => x + y;\n\nconst sum46 = (x, y) => x + y;\n\nconst sum47 = (x, y) => x + y;\n\nconst sum48 = (x, y) => x + y;\n\nconst sum49 = (x, y) => x + y;\n\nconst sum50 = (x, y) => x + y;\n\nconst sum51 = (x, y) => x + y;\n\nconst sum52 = (x, y) => x + y;\n\nconst sum53 = (x, y) => x + y;\n\nconst sum54 = (x, y) => x + y;\n\nconst sum55 = (x, y) => x + y;\n\nconst sum56 = (x, y) => x + y;\n\nconst sum57 = (x, y) => x + y;\n\nconst sum58 = (x, y) => x + y;\n\nconst sum59 = (x, y) => x + y;\n\nconst sum60 = (x, y) => x + y;\n\nconst sum61 = (x, y) => x + y;\n\nconst sum62 = (x, y) => x + y;\n\nconst sum63 = (x, y) => x + y;\n\nconst sum64 = (x, y) => x + y;\n\nconst sum65 = (x, y) => x + y;\n\nconst sum66 = (x, y) => x + y;\n\nconst sum67 = (x, y) => x + y;\n\nconst sum68 = (x, y) => x + y;\n\nconst sum69 = (x, y) => x + y;\n\nconst sum70 = (x, y) => x + y;\n\nconst sum71 = (x, y) => x + y;\n\nconst sum72 = (x, y) => x + y;\n\nconst sum73 = (x, y) => x + y;\n\nconst sum74 = (x, y) => x + y;\n\nconst sum75 = (x, y) => x + y;\n\nconst sum76 = (x, y) => x + y;\n\nconst sum77 = (x, y) => x + y;\n\nconst sum78 = (x, y) => x + y;\n\nconst sum79 = (x, y) => x + y;\n\nconst sum80 = (x, y) => x + y;\n\nconst sum81 = (x, y) => x + y;\n\nconst sum82 = (x, y) => x + y;\n\nconst sum83 = (x, y) =>"}
{"task_id": "JavaScript/103", "prompt": "/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n    let avg = 0;\n    for(let i = n; i <= m; i++) {\n        avg += i;\n    }\n    return avg / (m - n + 1);\n}\n\n//test\nconsole.log(roundedAvg(1, 5));\nconsole.log(roundedAvg(7, 5));\nconsole.log(roundedAvg(10, 20));\nconsole.log(roundedAvg(20, 33));\n<|endoftext|>"}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of poistive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "/*Given a list of poistive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const xs = x.toString().split('').filter(d =>!d.startsWith('0'))\n  const digits = xs.reduce((acc, x) => acc + parseInt(x), 0)\n  const nonUniqueDigits = xs.filter(d => d.startsWith('0'))\n  const sortedNonUniqueDigits = nonUniqueDigits.sort((a, b) => parseInt(a) - parseInt(b))\n  const uniqueDigits = xs.filter(d =>!sortedNonUniqueDigits.includes(d))\n  return uniqueDigits\n}\n\n//Test Cases\n\nconsole.log(uniqueDigits(123))\n\n//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]\nconsole.log(uniqueDigits(1122))\n\n//[]\nconsole.log(uniqueDigits(15))\n\n//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]\nconsole.log(uniqueDigits(1422))\n\n//[]\nconsole.log(uniqueDigits(152))\n\n//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]\nconsole.log(uniqueDigits(323))\n\n//[]\nconsole.log(uniqueDigits(10))\n\n//[]\nconsole.log(uniqueDigits(1))\n<|endoftext|>"}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of intgeers, sort the integers that are between 1 and 9 inculsive,\n  reverse the resulting array, and then erplace each digit by its ocrresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array of intgeers, sort the integers that are between 1 and 9 inculsive,\n  reverse the resulting array, and then erplace each digit by its ocrresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthReverse = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthSort = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthReverseSort = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLength = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLengthReverse = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthSort = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthReverseSort = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLengthByLength = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthByLengthReverse = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLengthByLengthSort = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthByLengthReverseSort = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLengthByLengthByLength = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthReverse = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthSort = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthReverseSort = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLength = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthReverse = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthSort = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthReverseSort = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthSort = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthReverseSort = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthSort = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthReverseSort = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthSort = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthReverseSort = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthSort = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthReverseSort = (arr) => {\n    return arr.sort((a, b) => {\n        return a - b;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthSort = (arr) => {\n    return arr.sort((a, b) => {\n        return b - a;\n    });\n}\n\nconst byLengthByLengthByLengthByLengthByLengthReverseSort ="}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [1];\n  for (let i = 2; i <= n; i++) {\n    result.push(result[i - 1] * i);\n  }\n  return result;\n};\n\n// f(5) == [1, 2, 6, 24, 15]\nconsole.log(f(5));\n\n// f(6) == [1, 2, 6, 12, 24, 16]\nconsole.log(f(6));\n\n// f(7) == [1, 2, 6, 12, 24, 14, 21]\nconsole.log(f(7));\n\n// f(8) == [1, 2, 6, 12, 24, 16, 28]\nconsole.log(f(8));\n\n// f(9) == [1, 2, 6, 12, 24, 18, 30, 32]\nconsole.log(f(9));\n\n// f(10) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16]\nconsole.log(f(10));\n\n// f(11) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16]\nconsole.log(f(11));\n\n// f(12) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(12));\n\n// f(13) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(13));\n\n// f(14) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(14));\n\n// f(15) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(15));\n\n// f(16) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(16));\n\n// f(17) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(17));\n\n// f(18) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(18));\n\n// f(19) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(19));\n\n// f(20) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(20));\n\n// f(21) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(21));\n\n// f(22) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(22));\n\n// f(23) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(23));\n\n// f(24) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(24));\n\n// f(25) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(25));\n\n// f(26) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(26));\n\n// f(27) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(27));\n\n// f(28) == [1, 2, 6, 12, 24, 16, 24, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]\nconsole.log(f(28));\n\n// f(29) == [1,"}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive itneger n, return a tuple that has the nmuber of even and odd\n  integer palindromes that fall wihtin the argne(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "/*\n  Given a positive itneger n, return a tuple that has the nmuber of even and odd\n  integer palindromes that fall wihtin the argne(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n    const half = Math.floor(n / 2);\n    const even = half * 2;\n    const odd = half + 1;\n\n    return [even, odd];\n};\n\nexport { evenOddPalindrome };\n<|endoftext|>"}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let result = 0;\n  for (let elem of arr) {\n    let n = Number(elem);\n    if (elem > 0) {\n      result += n;\n    }\n  }\n  return result;\n};\n\nconsole.log(countNums([]));\nconsole.log(countNums([-1, 11, -11]));\nconsole.log(countNums([1, 1, 2]));\n<|endoftext|>"}
{"task_id": "JavaScript/109", "prompt": "/*We have an arrya 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your atsk is to determine if\n  it si possibel to get an array sorted in non-decreasing order by performing \n  the flolowing operation on the given array:\n      You are allowde to perform right shift operation ayn number of times.\n  \n  Oen right shift operation means shifting all elements of the array yb one\n  position in the right direction. The last elemetn of the array will be moved ot\n  the startign position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted rarya by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Noet: The igven list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "/*We have an arrya 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your atsk is to determine if\n  it si possibel to get an array sorted in non-decreasing order by performing \n  the flolowing operation on the given array:\n      You are allowde to perform right shift operation ayn number of times.\n  \n  Oen right shift operation means shifting all elements of the array yb one\n  position in the right direction. The last elemetn of the array will be moved ot\n  the startign position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted rarya by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Noet: The igven list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  //Check for the input array\n  if(arr.length===0) {\n    return true\n  }\n\n  //Check for the valid right shift operation\n  for(let i=0;i<arr.length-1;i++) {\n    //Check for the valid right shift operation\n    if(arr[i]>arr[i+1]) {\n      //Perform the right shift operation\n      for(let j=i+1;j<arr.length;j++) {\n        arr[j-1]=arr[j]\n      }\n      arr[arr.length-1]=arr[0]\n    }\n  }\n\n  //Check for the valid right shift operation\n  if(arr[arr.length-1]>arr[0]) {\n    return false\n  }\n  \n  //Check for the valid right shift operation\n  return true\n}\n<|endoftext|>"}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implemnet a nfuction that takes two lists of numebrs,\n  and determines whether it is possbiel to perfomr an exchange of elements\n  ebtween htme to make lst1 a list of only even nubmers.\n  There is no liimt on the number of exchanged elements between lst1 and lst2.\n  If it is possilbe to exchange elmeenst between the lst1 and lst2 to maek\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "/*In this problem, you will implemnet a nfuction that takes two lists of numebrs,\n  and determines whether it is possbiel to perfomr an exchange of elements\n  ebtween htme to make lst1 a list of only even nubmers.\n  There is no liimt on the number of exchanged elements between lst1 and lst2.\n  If it is possilbe to exchange elmeenst between the lst1 and lst2 to maek\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n    const tmp = []\n    const count1 = lst1.length\n    const count2 = lst2.length\n    let i, j, k = 0\n    let count = count1\n    while (count < count2) {\n        i = count1 - 1\n        while (i >= 0) {\n            j = count2 - 1\n            while (j >= 0) {\n                if (lst1[i] < lst2[j]) {\n                    tmp.push(lst1[i])\n                    lst1[i] = lst2[j]\n                    lst2[j] = tmp[k]\n                    k++\n                    count2--\n                } else if (lst1[i] > lst2[j]) {\n                    tmp.push(lst2[j])\n                    lst2[j] = lst1[i]\n                    lst1[i] = tmp[k]\n                    k++\n                    count1--\n                } else {\n                    tmp.push(lst1[i])\n                    lst1[i] = lst2[j]\n                    lst2[j] = tmp[k]\n                    k++\n                    count1--\n                    count2--\n                }\n                j--\n            }\n            i--\n        }\n        count--\n    }\n    if (count1 == count2) {\n        if (lst1[lst1.length - 1] % 2 === 0) return \"YES\"\n        else return \"NO\"\n    }\n    return \"NO\"\n}\n\nexports.exchange = exchange\n<|endoftext|>"}
{"task_id": "JavaScript/111", "prompt": "/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n    const counts = {};\n    let testLength = test.length;\n    let maxCount = 0;\n    let letter = '';\n    let letterCount = 0;\n    let i = 0;\n    \n    while(i < testLength){\n        letter = test[i];\n        if(counts[letter] == undefined){\n            counts[letter] = 0;\n        }\n        counts[letter]++;\n        if(counts[letter] > maxCount){\n            maxCount = counts[letter];\n            letterCount = i;\n        }\n        i++;\n    }\n    return counts;\n};\n\nconst test = histogram(input);\nconsole.log(test);<|endoftext|>"}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "/*Task\n  We are given two strings s and c, you have to deleted all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n    const sLength = s.length\n    const cLength = c.length\n\n    let result = []\n    let cIndex = 0\n\n    for (let i = 0; i < sLength; i++) {\n        let sChar = s[i]\n        let cChar = c[cIndex]\n\n        if (sChar!== cChar) {\n            result.push(sChar)\n        } else {\n            cIndex += 1\n        }\n    }\n\n    return (result.reverse().join(''), result.length === sLength)\n}\n\nexport default reverseDelete\n<|endoftext|>"}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the numbre of odd elements in the\n  string i of the input.\" where all the i's should be replacde by the number\n  of odd dgiits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the numbre of odd elements in the\n  string i of the input.\" where all the i's should be replacde by the number\n  of odd dgiits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let count = 0\n  lst.forEach(el => {\n    let curCount = 0\n    for (let i = 0; i < el.length; i++) {\n      if (el[i] === '1') {\n        curCount++\n      }\n    }\n    if (curCount % 2 === 1) {\n      count += curCount\n    }\n  })\n  return [`the number of odd elements ${count} of the ${lst.length} strngs of the ${lst.length} input.`]\n}\n\nmodule.exports = oddCount\n<|endoftext|>"}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of ientgres nums, find the minimum sum of any non-epmty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "/*\n  Given an array of ientgres nums, find the minimum sum of any non-epmty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n    if (nums.length === 0) return 0;\n\n    let minSum = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i]!== 0) {\n            minSum = Math.min(minSum, nums[i]);\n        } else {\n            minSum += nums[i];\n        }\n    }\n    return minSum;\n};\n\nexport default minSubArraySum;<|endoftext|>"}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Ecah row represents a snigle well,\n  and each 1 in a row represetns a single unit of awter.\n  Each well has a corresponding bucket that can be used ot extract watre rfom it, \n  and all buckets have the saem capacity.\n  Your task is to use the buckets to mepty the wells.\n  Output the number fo times you need ot lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a rectangular grid of wells. Ecah row represents a snigle well,\n  and each 1 in a row represetns a single unit of awter.\n  Each well has a corresponding bucket that can be used ot extract watre rfom it, \n  and all buckets have the saem capacity.\n  Your task is to use the buckets to mepty the wells.\n  Output the number fo times you need ot lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  let index = [grid[0].length - 1, 0];\n  for (let i = 1; i < grid.length; i++) {\n    if (grid[i][0] === 1) {\n      index[0] = i;\n      break;\n    }\n  }\n  for (let i = 1; i < grid[0].length; i++) {\n    if (grid[0][i] === 1) {\n      index[1] = i;\n      break;\n    }\n  }\n\n  let curr = 1;\n  let ans = 0;\n  while (curr <= capacity) {\n    while (grid[index[0]][index[1]] === 0) {\n      curr++;\n      index[0]++;\n      if (index[0] === grid.length) {\n        index[0] = 0;\n        index[1]++;\n      }\n    }\n    ans += curr;\n    grid[index[0]][index[1]]--;\n    curr++;\n  }\n  return ans;\n};\n\n/*\n  You are given a rectangular grid of wells. Ecah row represents a snigle well,\n  and each 1 in a row represetns a single unit of awter.\n  Each well has a corresponding bucket that can be used ot extract watre rfom it, \n  and all buckets have the saem capacity.\n  Your task is to use the buckets to mepty the wells.\n  Output the number fo times you need ot lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n*/\nconst maxFill = (grid, capacity) => {\n  let index = [grid[0].length - 1, 0];\n  for (let i = 1; i < grid.length; i++) {\n    if (grid[i][0] === 1) {\n      index[0] = i;\n      break;\n    }\n  }\n  for (let i = 1; i < grid[0].length; i++) {\n    if (grid[0][i] === 1) {\n      index[1] = i;\n      break;\n    }\n  }\n\n  let curr = 1;\n  let ans = 0;\n  while (curr <= capacity) {\n    while (grid[index[0]][index[1]] === 0) {\n      curr++;\n      index[0]++;\n      if (index[0] === grid.length) {\n        index[0] = 0;\n        index[1]++;\n      }\n    }\n    ans += curr;\n    grid[index[0]][index[1]]--;\n    curr++;\n  }\n  return ans;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negaitve integers cacording to\n  numebr of ones in their binary repersentation in ascending order.\n  oFr similar number fo ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort an array of non-negaitve integers cacording to\n  numebr of ones in their binary repersentation in ascending order.\n  oFr similar number fo ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let sorted = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    sorted.push(arr[i]);\n  }\n\n  const arrLength = sorted.length;\n  const sortArr = sorted.slice(0);\n  const tempArr = sorted.slice(0);\n\n  for (let i = 0; i < arrLength; i++) {\n    for (let j = i + 1; j < arrLength; j++) {\n      if (arr[i] < arr[j]) {\n        const temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n\n  return sortArr;\n};\n\n/*\n  In this Kata, you have to add a value to every element in an array.\n  oFr you can't add 0 to an array, so if you want to add 3 to an array\n  with only 2 elements, you can't do it in this way:\n  >>> sortArray([1, 2]) + 3\n  'Array with elements: 1, 2'\n  oFr but you can add 3 to an array with 3 elements:\n  >>> sortArray([1, 2, 3]) + 3\n  Array with elements: 1, 2, 3\n  oFr you can add 3 to an array with 4 elements:\n  >>> sortArray([1, 2, 3, 4]) + 3\n  Array with elements: 1, 2, 3, 4\n  oFr or you can add 3 to an array with 5 elements:\n  >>> sortArray([1, 2, 3, 4, 5]) + 3\n  Array with elements: 1, 2, 3, 4, 5\n  */\nconst add = (arr, value) => {\n  let arrLength = arr.length;\n  let tempArr = [];\n\n  for (let i = 0; i < arrLength; i++) {\n    tempArr.push(arr[i] + value);\n  }\n\n  return tempArr;\n};\n\nconst sortArrayByDecimal = (arr) => {\n  const arrLength = arr.length;\n  const sorted = [];\n\n  for (let i = 0; i < arrLength; i++) {\n    sorted.push(arr[i]);\n  }\n\n  for (let i = 0; i < arrLength; i++) {\n    for (let j = i + 1; j < arrLength; j++) {\n      if (arr[i] < arr[j]) {\n        const temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n\n  return sorted;\n};\n\nconst sortArrayByDecimalWithArray = (arr) => {\n  const arrLength = arr.length;\n  const sorted = [];\n\n  for (let i = 0; i < arrLength; i++) {\n    sorted.push(arr[i]);\n  }\n\n  for (let i = 0; i < arrLength; i++) {\n    for (let j = i + 1; j < arrLength; j++) {\n      if (arr[i] < arr[j]) {\n        const temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n\n  return sorted;\n};\n\nconst sortArrayByDecimalWithArrayInArray = (arr) => {\n  const arrLength = arr.length;\n  const sorted = [];\n\n  for (let i = 0; i < arrLength; i++) {\n    sorted.push(arr[i]);\n  }\n\n  for (let i = 0; i < arrLength; i++) {\n    for (let j = i + 1; j < arrLength; j++) {\n      if (arr[i] < arr[j]) {\n        const temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n\n  return sorted;\n};\n\nexport default {\n  sortArray,\n  add,\n  sortArrayByDecimal,\n  sortArrayByDecimalWithArray,\n  sortArrayByDecimalWithArrayInArray\n};\n<|endoftext|>"}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural numbre n, you haev been tasked to imlpement \n  a fucntion that returns a list of all words from srting s that contain exactly \n  n ocnsonants, in order thees words appear in the string s.\n  If the string s is empty then the fnutcion should return an empty list.\n  Note: you may assume the input string contains only letters and spcase.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "/*Given a string s and a natural numbre n, you haev been tasked to imlpement \n  a fucntion that returns a list of all words from srting s that contain exactly \n  n ocnsonants, in order thees words appear in the string s.\n  If the string s is empty then the fnutcion should return an empty list.\n  Note: you may assume the input string contains only letters and spcase.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  if (s.length === 0) return []\n  let count = 0\n  let result = []\n  for (let i = 0; i < s.length; i++) {\n    let current = s[i]\n    if (current.match(/[a-zA-Z]/)) {\n      if (count === n) {\n        result.push(s.slice(i))\n        return result\n      }\n      count++\n    }\n  }\n}\n\n// selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\"]\n// selectWords(\"simple white space\", 2) ==> []\n// selectWords(\"Hello world\", 4) ==> [\"world\"]\n// selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n<|endoftext|>"}
{"task_id": "JavaScript/118", "prompt": "/*Yuo are given a word. Your task is ot find the closest vowel that stands between \n  two consonants from hte rihgt side of the word (case senstiiev).\n  \n  Vowels in teh beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met hte above condition. \n\n  You mya asusme that the given strign contains Egnlihs letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "/*Yuo are given a word. Your task is ot find the closest vowel that stands between \n  two consonants from hte rihgt side of the word (case senstiiev).\n  \n  Vowels in teh beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met hte above condition. \n\n  You mya asusme that the given strign contains Egnlihs letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowel = '', start = 0, end = 0, length = word.length, letter = '',\n    previous = '', vowelLength = 0, previousLetter = '',\n    previousVowel = '', vowelStart = -1, vowelEnd = -1,\n    vowelFound = false;\n\n  // Get the vowel at the start of the word\n  while (word[start]!=='') {\n    if (word[start] === 'a' || word[start] === 'e' || word[start] === 'i' || word[start] === 'o' || word[start] === 'u') {\n      if (vowelStart === -1) {\n        vowelStart = start;\n      }\n    } else if (word[start] === 'y') {\n      vowelStart = start;\n    }\n    start++;\n  }\n\n  // Get the vowel at the end of the word\n  while (word[end]!=='') {\n    if (word[end] === 'a' || word[end] === 'e' || word[end] === 'i' || word[end] === 'o' || word[end] === 'u') {\n      if (vowelEnd === -1) {\n        vowelEnd = end;\n      }\n    } else if (word[end] === 'y') {\n      vowelEnd = end;\n    }\n    end--;\n  }\n\n  // Check if the given string contains vowel only\n  if (vowelStart === -1 || vowelEnd === -1) {\n    return '';\n  }\n\n  // Get the length of the vowel\n  while (word[vowelStart]!=='') {\n    if (word[vowelStart] === 'a' || word[vowelStart] === 'e' || word[vowelStart] === 'i' || word[vowelStart] === 'o' || word[vowelStart] === 'u') {\n      vowelLength++;\n    }\n    vowelStart++;\n  }\n  while (word[vowelEnd]!=='') {\n    if (word[vowelEnd] === 'a' || word[vowelEnd] === 'e' || word[vowelEnd] === 'i' || word[vowelEnd] === 'o' || word[vowelEnd] === 'u') {\n      vowelLength++;\n    }\n    vowelEnd--;\n  }\n\n  // Go through the word and check if there is any vowel between the consonants\n  for (let i = vowelStart + 1; i <= vowelEnd - 1; i++) {\n    letter = word[i];\n\n    // If the vowel is between two consonants, the previous vowel and the vowel will be the same\n    if (i > vowelStart + 1) {\n      previousVowel = word[i - 1];\n    }\n\n    // If the previous vowel is equal to the vowel, we found a vowel\n    if (previousVowel === letter) {\n      vowelFound = true;\n      break;\n    }\n  }\n\n  // Check if there is any vowel found\n  if (!vowelFound) {\n    return '';\n  }\n\n  // Return the letter\n  return letter;\n}\n\n// Test\n// console.log(getClosestVowel(\"yogurt\")); // u\n// console.log(getClosestVowel(\"quick\")); // q\n// console.log(getClosestVowel(\"ab\")); // a\n// console.log(getClosestVowel(\"FULL\")); // U\n// console.log(getClosestVowel(\"abc\")); // a\n<|endoftext|>"}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n  Your job is ot check if it si possible to concatenate the two strings in\n  some order, that the resultnig string will be good.\n  A string S is considered to be good fi and only if all parentheses in S\n  are blaanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n  Your job is ot check if it si possible to concatenate the two strings in\n  some order, that the resultnig string will be good.\n  A string S is considered to be good fi and only if all parentheses in S\n  are blaanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let i = 0\n  let isGood = true\n  let start = 0\n\n  while (isGood && i < lst.length) {\n    if (lst[i] === '(') {\n      start = i\n      isGood = check(lst, start, i)\n    }\n    if (lst[i] === ')') {\n      if (i - start === 1) {\n        isGood = false\n      } else {\n        isGood = check(lst, start, i)\n      }\n    }\n    i++\n  }\n  return isGood\n}\n\nfunction check (lst, start, end) {\n  let leftParen = lst.slice(start, end + 1)\n  let rightParen = lst.slice(end + 1, start)\n\n  if (leftParen.length!== 1 || rightParen.length!== 1) {\n    return false\n  }\n\n  if (lst[start] === '(' && lst[end] === ')' || lst[start] === ')' && lst[end] === '(') {\n    return true\n  }\n\n  return false\n}\n<|endoftext|>"}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const len = arr.length;\n  const arr2 = [...new Array(len)].map(() => -arr[0]);\n  const max = arr.slice(1).reduce((pre, curr) => Math.max(pre, curr), -arr[0]);\n  const sorted = [...new Array(k)].map(() => max);\n  for (let i = 0; i < k; i++) {\n    sorted[i] = Math.max(arr2.pop(), sorted[i]);\n  }\n  return sorted;\n};\n\nexport { maximum };\n<|endoftext|>"}
{"task_id": "JavaScript/121", "prompt": "/*Gvien a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "/*Gvien a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  const l = lst.length;\n  let sum = 0;\n  let i = 0;\n  while (i < l) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n    i++;\n  }\n  return sum;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const arr2 = [...new Array(k)].concat(arr)\n  const arr3 = [...new Array(k)].concat(arr)\n  const arr4 = [...new Array(k)].concat(arr)\n  const arr5 = [...new Array(k)].concat(arr)\n  const arr6 = [...new Array(k)].concat(arr)\n  const arr7 = [...new Array(k)].concat(arr)\n  const arr8 = [...new Array(k)].concat(arr)\n  const arr9 = [...new Array(k)].concat(arr)\n  const arr10 = [...new Array(k)].concat(arr)\n  const arr11 = [...new Array(k)].concat(arr)\n  const arr12 = [...new Array(k)].concat(arr)\n  const arr13 = [...new Array(k)].concat(arr)\n  const arr14 = [...new Array(k)].concat(arr)\n  const arr15 = [...new Array(k)].concat(arr)\n  const arr16 = [...new Array(k)].concat(arr)\n  const arr17 = [...new Array(k)].concat(arr)\n  const arr18 = [...new Array(k)].concat(arr)\n  const arr19 = [...new Array(k)].concat(arr)\n  const arr20 = [...new Array(k)].concat(arr)\n  const arr21 = [...new Array(k)].concat(arr)\n  const arr22 = [...new Array(k)].concat(arr)\n  const arr23 = [...new Array(k)].concat(arr)\n  const arr24 = [...new Array(k)].concat(arr)\n  const arr25 = [...new Array(k)].concat(arr)\n  const arr26 = [...new Array(k)].concat(arr)\n  const arr27 = [...new Array(k)].concat(arr)\n  const arr28 = [...new Array(k)].concat(arr)\n  const arr29 = [...new Array(k)].concat(arr)\n  const arr30 = [...new Array(k)].concat(arr)\n  const arr31 = [...new Array(k)].concat(arr)\n  const arr32 = [...new Array(k)].concat(arr)\n  const arr33 = [...new Array(k)].concat(arr)\n  const arr34 = [...new Array(k)].concat(arr)\n  const arr35 = [...new Array(k)].concat(arr)\n  const arr36 = [...new Array(k)].concat(arr)\n  const arr37 = [...new Array(k)].concat(arr)\n  const arr38 = [...new Array(k)].concat(arr)\n  const arr39 = [...new Array(k)].concat(arr)\n  const arr40 = [...new Array(k)].concat(arr)\n  const arr41 = [...new Array(k)].concat(arr)\n  const arr42 = [...new Array(k)].concat(arr)\n  const arr43 = [...new Array(k)].concat(arr)\n  const arr44 = [...new Array(k)].concat(arr)\n  const arr45 = [...new Array(k)].concat(arr)\n  const arr46 = [...new Array(k)].concat(arr)\n  const arr47 = [...new Array(k)].concat(arr)\n  const arr48 = [...new Array(k)].concat(arr)\n  const arr49 = [...new Array(k)].concat(arr)\n  const arr50 = [...new Array(k)].concat(arr)\n  const arr51 = [...new Array(k)].concat(arr)\n  const arr52 = [...new Array(k)].concat(arr)\n  const arr53 = [...new Array(k)].concat(arr)\n  const arr54 = [...new Array(k)].concat(arr)\n  const arr55 = [...new Array(k)].concat(arr)\n  const arr56 = [...new Array(k)].concat(arr)\n  const arr57 = [...new Array(k)].concat(arr)\n  const arr58 = [...new Array(k)].concat(arr)\n  const arr59 = [...new Array(k)].concat(arr)\n  const arr60 = [...new Array(k)].concat(arr)\n  const arr61 = [...new Array(k)].concat(arr)\n  const arr62 = [...new Array(k)].concat(arr)\n  const arr63 = [...new Array(k)].concat(arr)\n  const arr64 = [...new Array(k)].concat(arr)\n  const arr65 = [...new Array(k)].concat(arr)\n  const arr66 = [...new Array(k)].concat(arr)\n  const arr67 = [...new Array(k)].concat(arr)\n  const arr68 = [...new Array(k)].concat(arr)\n  const arr69 = [...new Array(k)].concat(arr)\n  const arr70 = [...new Array(k)].concat(arr)\n  const arr71 = [...new Array(k)].concat(arr)\n  const arr72 = [...new Array(k)].concat(arr)\n  const arr73 = [...new Array(k)].concat(arr)\n  const arr74 = [...new Array(k)].concat(arr)\n  const arr75 = [...new Array(k)].concat(arr)\n  const arr76 = [...new Array(k)].concat(arr)\n  const arr77 = [...new Array(k)].concat(arr)\n  const arr78 = [...new Array(k)].concat(arr)\n  const arr79 = [...new Array(k)].concat(arr)"}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list htat has the odd numbres in collazt sequence.\n\n  hTe Collatz conjecture is a conjectrue in mtaheamtics that concerns a sequence defined\n  as follosw: start with any positive integer n. Then each term is obatined rfom the \n  previosu etmr as follows: if the previous term is even, the next temr is one half of \n  the previous term. If the previous term is odd, hte next term is 3 times the pervious\n  term plus 1. The conjecture is that no amtter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "/*\n  Given a positive integer n, return a sorted list htat has the odd numbres in collazt sequence.\n\n  hTe Collatz conjecture is a conjectrue in mtaheamtics that concerns a sequence defined\n  as follosw: start with any positive integer n. Then each term is obatined rfom the \n  previosu etmr as follows: if the previous term is even, the next temr is one half of \n  the previous term. If the previous term is odd, hte next term is 3 times the pervious\n  term plus 1. The conjecture is that no amtter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let sequence = []\n  let next = n\n  while (next > 1) {\n    if (next % 2 === 0) {\n      next = next / 2\n    } else {\n      next = 3 * next + 1\n    }\n    sequence.push(next)\n  }\n  sequence.push(1)\n  sequence.sort((a, b) => a - b)\n  return sequence\n}\n\nconst test = () => {\n  const n = 15\n  console.log(getOddCollatz(n))\n}\n\nmodule.exports = {\n  getOddCollatz,\n  test\n}\n<|endoftext|>"}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a fucntion which validates a given date tsring and\n  ertruns true fi the date is valid otherwise false.\n  The date si vlaid if all of the following ruels are satisfied:\n  1. The date stirng is not empty.\n  2. The numbre of days is not less than 1 ro higher htan 31 days for motnhs 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the nmuber of days si not elss than 1 or higher than 29 for the monht 2.\n  3. The months should otn be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "/*You have to write a fucntion which validates a given date tsring and\n  ertruns true fi the date is valid otherwise false.\n  The date si vlaid if all of the following ruels are satisfied:\n  1. The date stirng is not empty.\n  2. The numbre of days is not less than 1 ro higher htan 31 days for motnhs 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the nmuber of days si not elss than 1 or higher than 29 for the monht 2.\n  3. The months should otn be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if(!date){\n    return false;\n  }\n\n  // check date is not empty\n  if(!date.length){\n    return false;\n  }\n\n  // check month is not less than 1 or higher than 12\n  if(!date.match(/^\\d{2}-\\d{2}-\\d{4}$/)){\n    return false;\n  }\n\n  const dateString = date.split('-')\n\n  // check month\n  if(!dateString[1].length){\n    return false;\n  }\n\n  const month = parseInt(dateString[1])\n  if(!isNaN(month) && month > 0 && month < 13){\n    return true\n  }\n\n  return false\n}\n\nexport default validDate\n<|endoftext|>"}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1, ... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1,... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let words = txt.split(/\\s+/).map(word => word.trim());\n  if (words[0].length === 0) {\n    words.shift();\n  }\n  return words;\n};\n\n/*\n  Given a string of words, return a list of words with all the vowels of a string of consonants\n  examples\n  allVowels(\"Hello, world!\") ➞ [\"Hello\", \"world!\", \"Hello\", \"world!\", \"Hell\", \"o\", \"wo\", \"le\", \"lo\", \"ll\", \"ll\", \"wor\", \"wo\", \"world\"]\n  allVowels(\"abcdef\") ➞ [\"ab\", \"ac\", \"ad\", \"ae\", \"af\", \"ag\", \"ah\", \"ai\", \"aj\", \"ak\", \"al\", \"am\", \"an\", \"ao\", \"ap\", \"aq\", \"ar\", \"as\", \"at\", \"au\", \"av\", \"aw\", \"ax\", \"ay\", \"az\"]\n  */\nconst allVowels = (txt) => {\n  let vowels = txt.split(/[aeiou]/g);\n  return vowels.filter(v => v.length > 0);\n};\n\n/*\n  Given a string of words, return a list of words that have a consonant followed by a vowel\n  examples\n  hasVowel(\"Hello, world!\") ➞ [\"Hello\", \"world!\"]\n  hasVowel(\"abcdef\") ➞ [\"abcdef\"]\n  */\nconst hasVowel = (txt) => {\n  let consonants = txt.split(/[aeiou]/g);\n  return consonants.filter(cons => cons.length > 0);\n};\n\n/*\n  Given a string of words, return a list of words that have a consonant followed by a consonant\n  examples\n  hasVowel(\"Hello, world!\") ➞ [\"Hello\", \"world!\", \"Hello\", \"world!\", \"Hell\", \"o\", \"wo\", \"le\", \"lo\", \"ll\", \"ll\", \"wor\", \"wo\", \"world\"]\n  hasVowel(\"abcdef\") ➞ [\"abcdef\"]\n  */\nconst hasConsonant = (txt) => {\n  let consonants = txt.split(/[aeiou]/g);\n  return consonants.filter(cons => cons.length > 1);\n};\n\n/*\n  Given a string of words, return a list of words that have a vowel followed by a vowel\n  examples\n  hasVowel(\"Hello, world!\") ➞ [\"Hello\", \"world!\", \"Hello\", \"world!\", \"Hell\", \"o\", \"wo\", \"le\", \"lo\", \"ll\", \"ll\", \"wor\", \"wo\", \"world\"]\n  hasVowel(\"abcdef\") ➞ [\"abcdef\"]\n  */\nconst hasVowel2 = (txt) => {\n  let vowels = txt.split(/[aeiou]/g);\n  return vowels.filter(v => v.length > 1);\n};\n\n/*\n  Given a string of words, return a list of words that are all consonants\n  examples\n  allConsonants(\"Hello, world!\") ➞ [\"Hello\", \"world!\", \"Hello\", \"world!\", \"Hell\", \"o\", \"wo\", \"le\", \"lo\", \"ll\", \"ll\", \"wor\", \"wo\", \"world\"]\n  allConsonants(\"abcdef\") ➞ [\"abcdef\"]\n  */\nconst allConsonants = (txt) => {\n  let consonants = txt.split(/[aeiou]/g);\n  return consonants.filter(cons => cons.length > 0);\n};\n\n/*\n  Given a string of words, return a list of words that are all consonants followed by consonants\n  examples\n  allConsonants(\"Hello, world!\") ➞ [\"Hello\", \"world!\", \"Hello\", \"world!\", \"Hell\", \"o\", \"wo\", \"le\", \"lo\", \"ll\", \"ll\", \"wor\", \"wo\", \"world\"]\n  allConsonants(\"abcdef\") ➞ [\"abcdef\"]\n  */\nconst allConsonants2 = (txt) => {\n  let consonants = txt.split(/[aeiou]/g);\n  return consonants.filter(cons => cons.length > 1);\n};\n\n/*\n  Given a string of words, return a list of words that are all vowels\n  examples\n  allVowels(\"Hello, world!\") ➞ [\"Hello\", \"world!\", \"Hello\", \"world!\", \"Hell\", \"o\", \"wo\", \"le\", \"lo\", \"ll\", \"ll\", \"wor\", \"wo\", \"world\"]\n  allVowels(\"abcdef\") ➞ [\"abcdef\"]\n  */\nconst allVowels2 = (txt) => {\n  let vowels = txt.split(/[aeiou]/g);\n  return vowels.filter(v => v.length > 0);\n};\n\n/*\n  Given a string of words, return a list of words that have a vowel followed by a consonant\n  examples\n  hasVowel(\"Hello, world!\") ➞ [\"Hello\", \"world!\", \"Hello\", \"world!\", \"Hell\", \"o\", \"wo\", \"le\", \"lo\", \"ll\", \"ll\", \"wor\", \"wo\", \"world\"]\n  hasVowel(\"abcdef\") ➞ [\"abcdef\"]\n  */\nconst hasVowel3 = (txt) => {\n  let consonants = txt.split(/[aeiou]/g);\n  return consonants.filter(cons => cons.length > 1);\n};\n\n/*\n  Given a string of words, return a list of words that have a consonant followed by a vowel\n  examples\n  hasVowel(\"Hello,"}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbres, return wehhter or not they aer sorted\n  in ascending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "/* Given a list of numbres, return wehhter or not they aer sorted\n  in ascending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  if (lst.length === 0) {\n    return true;\n  }\n\n  let last = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] <= last) {\n      return false;\n    }\n    last = lst[i];\n  }\n  return true;\n};\n\nexport default isSorted;\n<|endoftext|>"}
{"task_id": "JavaScript/127", "prompt": "/*You are given wto intervals,\n  where each interval si a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "/*You are given wto intervals,\n  where each interval si a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1.start > interval2.start || interval1.end < interval2.end) return \"NO\";\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  let intersect = 0;\n  while (start1 <= end2) {\n    if (start1 >= end2) break;\n    if (start1 === start2) {\n      intersect += 1;\n      start1 += 1;\n    } else if (start1 === end2) {\n      start1 -= 1;\n    } else if (start1 < end2) {\n      intersect += 1;\n      start1 += 1;\n      end2 -= 1;\n    }\n  }\n  return intersect === 1? \"YES\" : \"NO\";\n};\n\nexport { intersection };\n<|endoftext|>"}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let result = 1\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      result *= 1\n    } else if (arr[i] < 0) {\n      result *= -1\n    }\n  }\n  return result\n}\n\nexport { prodSigns }\n<|endoftext|>"}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columsn (N >= 2) and a positive integer k, \n  each cell of the grid onctains a value. Every integer in the range [1, N * N]\n  inclusive appeasr exactly once on the eclls of the grid.\n\n  You have to find the minimum path of length k in the grid. Yuo can strat\n  rfom any cell, and in eahc tesp you can move to any of teh neighbor cells,\n  in other words, you can go to cells which sahre an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT og off the grid.\n  A path A (of length k) is conisdered less than a path B (of length k) if\n  after making the ordered lists of teh values on the clels htat A nad B go\n  through (let's call thme lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such taht lst_A[i] < lst_B[i] adn for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed taht the answer is unique.\n  Return an ordreed list of the vlaues on the cells that the minimum path go thruogh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "/*\n  Given a grid with N rows and N columsn (N >= 2) and a positive integer k, \n  each cell of the grid onctains a value. Every integer in the range [1, N * N]\n  inclusive appeasr exactly once on the eclls of the grid.\n\n  You have to find the minimum path of length k in the grid. Yuo can strat\n  rfom any cell, and in eahc tesp you can move to any of teh neighbor cells,\n  in other words, you can go to cells which sahre an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT og off the grid.\n  A path A (of length k) is conisdered less than a path B (of length k) if\n  after making the ordered lists of teh values on the clels htat A nad B go\n  through (let's call thme lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such taht lst_A[i] < lst_B[i] adn for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed taht the answer is unique.\n  Return an ordreed list of the vlaues on the cells that the minimum path go thruogh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const rowLength = grid.length\n  const colLength = grid[0].length\n  let minPath = []\n  for (let r = 1; r <= rowLength; r++) {\n    for (let c = 1; c <= colLength; c++) {\n      minPath.push(grid[r - 1][c - 1])\n      if (r === rowLength && c === colLength) {\n        if (minPath[k - 1] > grid[r][c]) {\n          minPath = [grid[r][c]]\n        }\n      } else {\n        let neighbors = getNeighbors(r, c, rowLength, colLength)\n        for (let n = 0; n < neighbors.length; n++) {\n          if (minPath[k - 1] > grid[r][c] && minPath[k - 1] <= grid[neighbors[n][0]][neighbors[n][1]]) {\n            minPath = [grid[r][c]]\n          }\n        }\n      }\n    }\n  }\n  return minPath\n}\n\nconst getNeighbors = (r, c, rowLength, colLength) => {\n  let neighbors = []\n  if (r - 1 >= 0) {\n    neighbors.push([r - 1, c])\n  }\n  if (r + 1 <= rowLength) {\n    neighbors.push([r + 1, c])\n  }\n  if (c - 1 >= 0) {\n    neighbors.push([r, c - 1])\n  }\n  if (c + 1 <= colLength) {\n    neighbors.push([r, c + 1])\n  }\n  return neighbors\n}\n\nmodule.exports = minPath<|endoftext|>"}
{"task_id": "JavaScript/130", "prompt": "/*Everyone konws Fibonacci sequneec, it was studied deeply by mathematicians in \n  the last couple centuries. Howveer, what people don't know is Tribonacci esquence.\n  Tribonacci sequence is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n si odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "/*Everyone konws Fibonacci sequneec, it was studied deeply by mathematicians in \n  the last couple centuries. Howveer, what people don't know is Tribonacci esquence.\n  Tribonacci sequence is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n si odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n <= 0) return [];\n  const nums = [];\n  let curr = 1;\n  for (let i = 0; i < n; i++) {\n    nums.push(curr);\n    curr = curr + 1;\n  }\n  return nums;\n}\n\nconst test = [1, 2, 3, 4, 5];\nconsole.log(tri(3)(test));\n<|endoftext|>"}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": false, "gc": "/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let count = 1\n  let result = 1\n  while (n > 0) {\n    result *= n % 10\n    if (result % 2 === 0) {\n      return 0\n    }\n    count += 1\n    n /= 10\n  }\n  return result\n}\n\nexport default {\n  digits\n}\n<|endoftext|>"}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ ture\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ ture\n  */\nconst isNested = (string) => {\n  const count = (string) => {\n    let brackets = 0\n    for (let i = 0; i < string.length; i++) {\n      if (string[i] === '[') brackets++\n      if (string[i] === ']') brackets--\n    }\n    return brackets > 0\n  }\n\n  const valid = (string) => {\n    let brackets = 0\n    for (let i = 0; i < string.length; i++) {\n      if (string[i] === '[') brackets++\n      if (string[i] === ']') brackets--\n    }\n    return brackets <= 0\n  }\n\n  return valid(string) && count(string) > 0\n}\n\nconsole.log(isNested('[[]]'))\nconsole.log(isNested('[]]]]]]][[[[[]'))\nconsole.log(isNested('[][]'))\nconsole.log(isNested('[]'))\nconsole.log(isNested('[[][]]'))\nconsole.log(isNested('[[]][[['))\n<|endoftext|>"}
{"task_id": "JavaScript/133", "prompt": "/*Yuo are gievn a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) frist.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*Yuo are gievn a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) frist.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  return lst.reduce((previous, current) => previous + Math.pow(current, 2), 0);\n}\n\nmodule.exports = sumSquares;<|endoftext|>"}
{"task_id": "JavaScript/134", "prompt": "/* Create a ufnction htat returns true if the last chraacter\n  of a given string is an alphaebtical character and is not\n  a part of a word, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "/* Create a ufnction htat returns true if the last chraacter\n  of a given string is an alphaebtical character and is not\n  a part of a word, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  return txt.length && /^[a-zA-Z]$/.test(txt.slice(-1));\n};\n\n// Function to create a ufnction that returns true if the last\n// characeter of a given string is a number and false othewrise.\nconst checkIfLastCharIsNumber = (txt) => {\n  return txt.length && /^\\d+$/.test(txt.slice(-1));\n};\n\n// Function to create a ufnction that returns true if the last\n// characeter of a given string is an alpha numerical character\n// and false othewrise.\nconst checkIfLastCharIsAlphaNumeric = (txt) => {\n  return txt.length && /^[0-9a-zA-Z]+$/.test(txt.slice(-1));\n};\n\n// Function to create a ufnction that returns true if the last\n// characeter of a given string is a space character.\nconst checkIfLastCharIsSpace = (txt) => {\n  return txt.length && /^\\s+$/.test(txt.slice(-1));\n};\n\n// Function to create a ufnction that returns true if the last\n// characeter of a given string is a punctuation character.\nconst checkIfLastCharIsPunctuation = (txt) => {\n  return txt.length && /^[\\.\\-\\,\\?\\!\\:\\\\\\/\\(\\)\\[\\]\\{}]$/.test(txt.slice(-1));\n};\n\n// Function to create a ufnction that returns true if the last\n// characeter of a given string is a letter.\nconst checkIfLastCharIsALetter = (txt) => {\n  return txt.length && /^[a-zA-Z]$/.test(txt.slice(-1));\n};\n\n// Function to create a ufnction that returns true if the last\n// characeter of a given string is a number.\nconst checkIfLastCharIsNumber = (txt) => {\n  return txt.length && /^\\d+$/.test(txt.slice(-1));\n};\n\n// Function to create a ufnction that returns true if the last\n// characeter of a given string is an alpha numerical character\n// and false othewrise.\nconst checkIfLastCharIsAlphaNumeric = (txt) => {\n  return txt.length && /^[0-9a-zA-Z]+$/.test(txt.slice(-1));\n};\n\n// Function to create a ufnction that returns true if the last\n// characeter of a given string is a space character.\nconst checkIfLastCharIsSpace = (txt) => {\n  return txt.length && /^\\s+$/.test(txt.slice(-1));\n};\n\n// Function to create a ufnction that returns true if the last\n// characeter of a given string is a punctuation character.\nconst checkIfLastCharIsPunctuation = (txt) => {\n  return txt.length && /^[\\.\\-\\,\\?\\!\\:\\\\\\/\\(\\)\\[\\]\\{}]$/.test(txt.slice(-1));\n};\n\n// Function to create a ufnction that returns true if the last\n// characeter of a given string is a letter.\nconst checkIfLastCharIsALetter = (txt) => {\n  return txt.length && /^[a-zA-Z]$/.test(txt.slice(-1));\n};\n\n// Function to create a ufnction that returns true if the last\n// characeter of a given string is a number.\nconst checkIfLastCharIsNumber = (txt) => {\n  return txt.length && /^\\d+$/.test(txt.slice(-1));\n};\n\n// Function to create a ufnction that returns true if the last\n// characeter of a given string is an alpha numerical character\n// and false othewrise.\nconst checkIfLastCharIsAlphaNumeric = (txt) => {\n  return txt.length && /^[0-9a-zA-Z]+$/.test(txt.slice(-1));\n};\n<|endoftext|>"}
{"task_id": "JavaScript/135", "prompt": "/*Creaet a function wihch rteurns the largest index of an element which\n  is not greater than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "/*Creaet a function wihch rteurns the largest index of an element which\n  is not greater than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1\n  for (let i = 0; i < arr.length - 1; i++) {\n    if (arr[i] <= arr[i + 1]) {\n      maxIndex = i\n      break\n    }\n  }\n  return maxIndex\n}\n\nmodule.exports = canArrange\n<|endoftext|>"}
{"task_id": "JavaScript/136", "prompt": "/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const arr = lst.slice();\n  let i = 0;\n  while (i < arr.length - 1) {\n    if (arr[i] < 0) {\n      i++;\n    } else if (arr[i] > 0) {\n      return (arr.splice(i + 1, arr.length - i - 1), arr[i]);\n    } else {\n      i++;\n    }\n  }\n  return (arr.length === 1 && arr[0] === 0)? (null, null) : (null, arr[0]);\n};\n\nconst largestSmallestIntegers = (lst) => {\n  const arr = lst.slice();\n  let i = 0;\n  while (i < arr.length - 1) {\n    if (arr[i] < 0) {\n      i++;\n    } else if (arr[i] > 0) {\n      return (arr.splice(i + 1, arr.length - i - 1), arr[i]);\n    } else {\n      i++;\n    }\n  }\n  return (arr.length === 1 && arr[0] === 0)? (null, null) : (null, arr[0]);\n};\n\n/*\n  Creates an array of primes.\n  Returned array has one element per prime.\n  If no primes, return an empty array.\n  If two or more primes, return null.\n  Example:\n  primes(8) == [2, 3, 5, 7]\n  primes(4) == [2, 3, 5]\n  primes(3) == [3, 5, 7]\n  */\nconst primes = (n) => {\n  let primeArr = [2];\n  let i = 3;\n  while (primeArr.length < n) {\n    let j = 0;\n    while (primeArr[j] * primeArr[j] <= i) {\n      j++;\n    }\n    primeArr.push(i);\n    i += 2;\n  }\n  return primeArr;\n};\n\n/*\n  Returns the first (max) and last (min) elements of a list.\n  If the list is empty, return the empty list.\n  If the list is empty or has only one element, return null.\n  */\nconst firstLast = (lst) => {\n  const arr = lst.slice();\n  if (arr.length === 0) {\n    return [null, null];\n  }\n  if (arr.length === 1) {\n    return [arr[0], arr[0]];\n  }\n  return [arr[0], arr[arr.length - 1]];\n};\n\n/*\n  Returns the sum of the numbers in a list.\n  If the list is empty, return null.\n  */\nconst sum = (lst) => {\n  const arr = lst.slice();\n  if (arr.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst sum = (lst) => {\n  const arr = lst.slice();\n  if (arr.length === 0) {\n    return null;\n  }\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n);\n};\n\nconst isPrime = (n) => {\n  const arr = primes(n);\n  return arr.includes(n"}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the larger variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconts compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "/*\n  Create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the larger variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconts compareOne = (a, b) => {\n  if (typeof a === typeof b) {\n    return a > b? a : b;\n  }\n  if (a === b) {\n    return null;\n  }\n  if (isNaN(a)) {\n    return b;\n  }\n  if (isNaN(b)) {\n    return a;\n  }\n  if (typeof a ==='string') {\n    if (a.indexOf(',') > -1) {\n      return parseFloat(a);\n    }\n    return a;\n  }\n  if (typeof b ==='string') {\n    if (b.indexOf(',') > -1) {\n      return parseFloat(b);\n    }\n    return b;\n  }\n  return null;\n};\n\n/*\n  create a function that takes 2 variable type, and returns the larger\n  variable in that type.\n  Return null fi the values are equal.\n  */\nconts compareTwo = (a, b) => {\n  if (a === b) {\n    return null;\n  }\n  if (isNaN(a)) {\n    return b;\n  }\n  if (isNaN(b)) {\n    return a;\n  }\n  if (typeof a ==='string') {\n    if (a.indexOf(',') > -1) {\n      return parseFloat(a);\n    }\n    return a;\n  }\n  if (typeof b ==='string') {\n    if (b.indexOf(',') > -1) {\n      return parseFloat(b);\n    }\n    return b;\n  }\n  return null;\n};\n\nconts isEmpty = (str) => {\n  if (str === undefined) {\n    return true;\n  }\n  return false;\n};\n\nconts isNotEmpty = (str) => {\n  if (str === undefined) {\n    return false;\n  }\n  return true;\n};\n\nconts isTrue = (bool) => {\n  if (bool === true) {\n    return true;\n  }\n  return false;\n};\n\nconts isNotTrue = (bool) => {\n  if (bool === true) {\n    return false;\n  }\n  return true;\n};\n\nconts isFinite = (num) => {\n  if (isNaN(num) === false && isFinite(num) === true) {\n    return true;\n  }\n  return false;\n};\n\nconts isNotFinite = (num) => {\n  if (isNaN(num) === true && isFinite(num) === false) {\n    return true;\n  }\n  return false;\n};\n\nconts isNaN = (num) => {\n  if (isNaN(num) === true) {\n    return true;\n  }\n  return false;\n};\n\nconts isNotNaN = (num) => {\n  if (isNaN(num) === false) {\n    return true;\n  }\n  return false;\n};\n\nconts contains = (str, substr) => {\n  if (str.indexOf(substr) > -1) {\n    return true;\n  }\n  return false;\n};\n\nconts startsWith = (str, substr) => {\n  if (str.indexOf(substr) === 0) {\n    return true;\n  }\n  return false;\n};\n\nconts endsWith = (str, substr) => {\n  if (str.lastIndexOf(substr) === str.length - substr.length) {\n    return true;\n  }\n  return false;\n};\n\nconts isInt = (num) => {\n  return parseInt(num) === num;\n};\n\nconts isFloat = (num) => {\n  return parseFloat(num) === num;\n};\n\nconts isNumber = (num) => {\n  return parseInt(num) === num || parseFloat(num) === num;\n};\n\nconts isNotInt = (num) => {\n  return!isInt(num);\n};\n\nconts isNotFloat = (num) => {\n  return!isFloat(num);\n};\n\nconts isNotNumber = (num) => {\n  return!isNumber(num);\n};\n\nconts containsAll = (str, subList) => {\n  if (subList.every(s => contains(str, s))) {\n    return true;\n  }\n  return false;\n};\n\nconts startsWithAll = (str, subList) => {\n  if (subList.every(s => startsWith(str, s))) {\n    return true;\n  }\n  return false;\n};\n\nconts endsWithAll = (str, subList) => {\n  if (subList.every(s => endsWith(str, s))) {\n    return true;\n  }\n  return false;\n};\n\nconts containsAllRegex = (str, regex) => {\n  let pattern = new RegExp(regex);\n  if (pattern.test(str)) {\n    return true;\n  }\n  return false;\n};\n\nconts startsWithAllRegex = (str, regex) => {\n  let pattern = new RegExp(regex);\n  if (pattern.test(str)) {\n    return true;\n  }\n  return false;\n};\n\nconts endsWithAllRegex = (str, regex) => {\n  let pattern = new RegExp(regex);\n  if (pattern.test(str)) {\n    return true;\n  }\n  return false;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "/*Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i += 2) {\n    sum += i;\n  }\n  return sum === n;\n}\n\nexport default isEqualToSumEven;<|endoftext|>"}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorila(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "/*The Brazilian factorial is defined as:\n  brazilian_factorila(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*The function is defined as:\n  factorial(n) = n!\n  where n is a positive integer\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorial = (n) => {\n  return (Math.pow(n, n));\n};\n\n/*The function is defined as:\n  factorial(n) = n!\n  where n is a positive integer\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorial2 = (n) => {\n  return (n);\n};\n\n/*The function is defined as:\n  nth_prime(n) = the nth prime number\n  where n is a positive integer\n\n  For example:\n  >>> nth_prime(4)\n  4\n\n  The function will receive an integer as input and should return the nth prime\n  number of this integer.\n  */\nconst nthPrime = (n) => {\n  let isPrime = false;\n  let i = 2;\n  while (!isPrime && i <= n) {\n    if (n % i === 0) {\n      isPrime = true;\n    }\n    i++;\n  }\n  return i;\n};\n\n/*The function is defined as:\n  nth_prime(n) = the nth prime number\n  where n is a positive integer\n\n  For example:\n  >>> nth_prime(4)\n  4\n\n  The function will receive an integer as input and should return the nth prime\n  number of this integer.\n  */\nconst nthPrime2 = (n) => {\n  let isPrime = false;\n  let i = 2;\n  while (!isPrime && i <= n) {\n    if (n % i === 0) {\n      isPrime = true;\n    }\n    i++;\n  }\n  return i;\n};\n\n/*The function is defined as:\n  factorial(n) = n!\n  where n is a positive integer\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  } else if (n === 1) {\n    return 1;\n  } else {\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  }\n};\n\n/*The function is defined as:\n  factorial(n) = n!\n  where n is a positive integer\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst fibonacci2 = (n) => {\n  if (n === 0) {\n    return 0;\n  } else if (n === 1) {\n    return 1;\n  } else {\n    return fibonacci(n - 1) + fibonacci(n - 2);\n  }\n};\n\n/*The function is defined as:\n  nth_prime(n) = the nth prime number\n  where n is a positive integer\n\n  For example:\n  >>> nth_prime(4)\n  4\n\n  The function will receive an integer as input and should return the nth prime\n  number of this integer.\n  */\nconst nth_prime3 = (n) => {\n  let isPrime = false;\n  let i = 2;\n  while (!isPrime && i <= n) {\n    if (n % i === 0) {\n      isPrime = true;\n    }\n    i++;\n  }\n  return i;\n};\n\n/*The function is defined as:\n  factorial(n) = n!\n  where n is a positive integer\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst nth_prime4 = (n) => {\n  let isPrime = false;\n  let i = 2;\n  while (!isPrime && i <= n) {\n    if (n % i === 0) {\n      isPrime = true;\n    }\n    i++;\n  }\n  return i;\n};\n\n/*The function is defined as:\n  nth_prime(n) = the nth prime number\n  where n is a positive integer\n\n  For example:\n  >>> nth_prime(4)\n  4\n\n  The function will receive an integer as input and should return the nth prime\n  number of this integer.\n  */\nconst nth_prime5 = (n) => {\n  let isPrime = false;\n  let i = 2;\n  while (!isPrime && i <= n) {\n    if (n % i === 0) {\n      isPrime = true;\n    }\n    i++;\n  }\n  return i;\n};\n\nmodule.exports = {\n  factorial,\n  factorial2,\n  nthPrime,\n  nthPrime2,\n  fibonacci,\n  fibonacci2,\n  nth_prime3,\n  nth_prime4,\n  nth_prime5\n};\n<|endoftext|>"}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more htan 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more htan 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n    const re = /\\s+/g;\n    return text.replace(re, '_');\n};\n\n/*\n  Given a string text, replace all underscores in it with spaces, \n  and if a string has more htan 2 consecutive underscores, \n  then replace all consecutive underscores with - \n  \n  unFixSpaces(\"Example_1\") == \"Example 1\"\n  unFixSpaces(\"Example-2\") == \"Example 2\"\n  unFixSpaces(\"Example 3\") == \"Example 3\"\n  unFixSpaces(\"Example-4\") == \"Example 4\"\n  unFixSpaces(\"Example_5\") == \"Example 5\"\n  */\nconst unFixSpaces = (text) => {\n    const re = /_+/g;\n    return text.replace(re,'');\n};\n\n/*\n  Given a string text, replace all underscores in it with dashes, \n  and if a string has more htan 2 consecutive underscores, \n  then replace all consecutive underscores with - \n  \n  unFixSpaces(\"Example_1\") == \"Example1\"\n  unFixSpaces(\"Example-2\") == \"Example2\"\n  unFixSpaces(\"Example 3\") == \"Example3\"\n  unFixSpaces(\"Example-4\") == \"Example4\"\n  unFixSpaces(\"Example_5\") == \"Example5\"\n  */\nconst unFixDashes = (text) => {\n    const re = /(_+)+/g;\n    return text.replace(re, '-');\n};\n\nconst unFixAll = (text) => {\n    const re = /(_+)+/g;\n    return text.replace(re, '-');\n};\n\nconst strip = (text) => {\n    return text.replace(/^\\s+|\\s+$/g, '');\n};\n\n/*\n  Given a string text, replace all dashes in it with underscores, \n  and if a string has more htan 2 consecutive dashes, \n  then replace all consecutive dashes with - \n  \n  unFixDashes(\"Example1\") == \"Example 1\"\n  unFixDashes(\"Example2\") == \"Example 2\"\n  unFixDashes(\"Example3\") == \"Example 3\"\n  unFixDashes(\"Example4\") == \"Example 4\"\n  unFixDashes(\"Example5\") == \"Example 5\"\n  */\nconst unFixDashes2 = (text) => {\n    const re = /-/g;\n    return text.replace(re, '_');\n};\n\nconst unFixAll2 = (text) => {\n    const re = /-/g;\n    return text.replace(re, '_');\n};\n\nconst strip2 = (text) => {\n    return text.replace(/^\\s+|\\s+$/g, '');\n};\n\nexport default {\n    fixSpaces,\n    unFixSpaces,\n    unFixDashes,\n    unFixAll,\n    unFixDashes2,\n    unFixAll2,\n    strip,\n    strip2\n};<|endoftext|>"}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which tkaes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, adn returns 'No' ohtewrise.\n  A file's name is considered to be valid if adn only if all the following conditions \n  are met:\n  - Theer should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, nad it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the odt shoudl be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "/*Create a function which tkaes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, adn returns 'No' ohtewrise.\n  A file's name is considered to be valid if adn only if all the following conditions \n  are met:\n  - Theer should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, nad it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the odt shoudl be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n    const reg = /^[a-zA-Z][a-zA-Z0-9_\\.]*$/;\n    return reg.test(file_name);\n}\n\n// function that checks if a string is a valid email address.\nconst isEmail = (email) => {\n    const reg = /^([a-zA-Z0-9_\\.-]+@[a-zA-Z0-9_\\.-]+\\.[a-zA-Z]{2,4})$/;\n    return reg.test(email);\n}\n\n// function that checks if a string is a valid phone number.\nconst isPhone = (phone_num) => {\n    const reg = /^(\\d{3})\\s?\\d{3}-\\s?\\d{4}$/;\n    return reg.test(phone_num);\n}\n\n// function that checks if a string is a valid ipv4 address.\nconst isIPv4 = (ip) => {\n    const reg = /^(1\\d{2}|2[0-4]\\d|25[0-5]|[3-9]\\d)\\..*$/;\n    return reg.test(ip);\n}\n\n// function that checks if a string is a valid date.\nconst isDate = (date) => {\n    const reg = /^\\d{4}-\\d{2}-\\d{2}$/;\n    return reg.test(date);\n}\n\n// function that checks if a string is a valid decimal number.\nconst isDecimal = (decimal) => {\n    const reg = /^-?\\d+\\.?\\d*$/;\n    return reg.test(decimal);\n}\n\n// function that checks if a string is a valid integer.\nconst isInteger = (integer) => {\n    const reg = /^-?\\d+$/;\n    return reg.test(integer);\n}\n\n// function that checks if a string is a valid float number.\nconst isFloat = (float) => {\n    const reg = /^-?\\d+\\.?\\d*$/;\n    return reg.test(float);\n}\n\n// function that checks if a string is a valid currency.\nconst isCurrency = (currency) => {\n    const reg = /^[A-Za-z\\s]+$/;\n    return reg.test(currency);\n}\n\n// function that checks if a string is a valid positive integer.\nconst isPosInt = (integer) => {\n    const reg = /^\\d+$/;\n    return reg.test(integer);\n}\n\n// function that checks if a string is a valid positive float.\nconst isPosFloat = (float) => {\n    const reg = /^\\d+\\.?\\d*$/;\n    return reg.test(float);\n}\n\n// function that checks if a string is a valid positive decimal number.\nconst isPosDecimal = (decimal) => {\n    const reg = /^\\d+\\.?\\d*$/;\n    return reg.test(decimal);\n}\n\n// function that checks if a string is a valid positive integer.\nconst isNegInt = (integer) => {\n    const reg = /^-\\d+$/;\n    return reg.test(integer);\n}\n\n// function that checks if a string is a valid positive float.\nconst isNegFloat = (float) => {\n    const reg = /^-\\d+\\.?\\d*$/;\n    return reg.test(float);\n}\n\n// function that checks if a string is a valid positive decimal number.\nconst isNegDecimal = (decimal) => {\n    const reg = /^-\\d+\\.?\\d*$/;\n    return reg.test(decimal);\n}\n<|endoftext|>"}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This fucntion will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if tis index si a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list hwose indexes are not a multiple of 3 or 4. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "/*\"\n  This fucntion will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if tis index si a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list hwose indexes are not a multiple of 3 or 4. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares2 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares3 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares4 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares5 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares6 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares7 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares8 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares9 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares10 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares11 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares12 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares13 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares14 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares15 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares16 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares17 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares18 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares19 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares20 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares21 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares22 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares23 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares24 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares25 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares26 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares27 = (lst) => {\n  const total = lst.reduce((previous, current, index) => (previous + current * current), 0);\n  return total;\n}\n\nconst sumSquares28 = (lst) => {\n  const total = lst."}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are gievn a strnig representign a sentence,\n  the sentence contains some words separtaed by a space,\n  and oyu hvae to return a string that contains the words from the oirginal sentence,\n  wohse lengths are pirme numbesr,\n  the order fo the wrods in the new strnig should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "/*\n  You are gievn a strnig representign a sentence,\n  the sentence contains some words separtaed by a space,\n  and oyu hvae to return a string that contains the words from the oirginal sentence,\n  wohse lengths are pirme numbesr,\n  the order fo the wrods in the new strnig should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  // Write your code here\n}\n\nconst isValid = (word, index) => {\n  // Write your code here\n}\n\nmodule.exports = {\n  wordsInSentence,\n  isValid\n}\n<|endoftext|>"}
{"task_id": "JavaScript/144", "prompt": "/*Your tsak is to impleemnt a function that will simplify the epxression\n  x * n. The function retunrs true if x * n evaluatse to a whole number and false\n  toherwise. Both x and n, are string represnetation of a fraction, and have the following format,\n  <unmertaor>/<denominator> where both numertaor and denominator are positive whole numbers.\n\n  You can assume that x, adn n rae valid farctions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = flase\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "/*Your tsak is to impleemnt a function that will simplify the epxression\n  x * n. The function retunrs true if x * n evaluatse to a whole number and false\n  toherwise. Both x and n, are string represnetation of a fraction, and have the following format,\n  <unmertaor>/<denominator> where both numertaor and denominator are positive whole numbers.\n\n  You can assume that x, adn n rae valid farctions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = flase\n  */\nconst simplify = (x, n) => {\n  let d = n.split(\"/\");\n  let a = x.split(\"/\");\n  if (a[1] == d[1]) {\n    if (a[0] > d[0]) return false;\n    else return true;\n  } else {\n    return false;\n  }\n};\n\nexport default simplify;\n<|endoftext|>"}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n    const sorted = nums.sort((a, b) => a - b);\n    const sortedPoints = sorted.map(num => Math.abs(num));\n    const pointsSum = sortedPoints.reduce((a, b) => a + b, 0);\n    const sortedPointsBySum = sortedPoints.sort((a, b) => pointsSum - a - b);\n    return sortedPointsBySum;\n};\n\n/*\n  Write a function that takes a list of words and returns the\n  longest word in the list. (If there are several longest words,\n  return the one that comes first in the list)\n\n  For example:\n  >>> longestWord([])\n  []\n  >>> longestWord(['hello', 'hi'])\n  'hi'\n  >>> longestWord(['hi', 'hello'])\n  'hi'\n  */\nconst longestWord = (words) => {\n    let max = words[0];\n    for (let i = 1; i < words.length; i++) {\n        if (words[i].length > max.length) {\n            max = words[i];\n        }\n    }\n    return max;\n};\n\n/*\n  Write a function that takes a list of words and returns the\n  longest word in the list. (If there are several longest words,\n  return the one that comes first in the list)\n\n  For example:\n  >>> longestWord([])\n  []\n  >>> longestWord(['hello', 'hi'])\n  'hi'\n  >>> longestWord(['hi', 'hello'])\n  'hi'\n  */\nconst longestWord = (words) => {\n    let max = words[0];\n    for (let i = 1; i < words.length; i++) {\n        if (words[i].length > max.length) {\n            max = words[i];\n        }\n    }\n    return max;\n};\n\n/*\n  Write a function that takes a list of words and returns the\n  shortest word in the list. (If there are several shortest words,\n  return the one that comes first in the list)\n\n  For example:\n  >>> shortestWord([])\n  []\n  >>> shortestWord(['hello', 'hi'])\n  'hello'\n  >>> shortestWord(['hi', 'hello'])\n  'hi'\n  */\nconst shortestWord = (words) => {\n    let min = words[0];\n    for (let i = 1; i < words.length; i++) {\n        if (words[i].length < min.length) {\n            min = words[i];\n        }\n    }\n    return min;\n};\n\n/*\n  Write a function that takes a list of words and returns the\n  shortest word in the list. (If there are several shortest words,\n  return the one that comes first in the list)\n\n  For example:\n  >>> shortestWord([])\n  []\n  >>> shortestWord(['hello', 'hi'])\n  'hello'\n  >>> shortestWord(['hi', 'hello'])\n  'hi'\n  */\nconst shortestWord = (words) => {\n    let min = words[0];\n    for (let i = 1; i < words.length; i++) {\n        if (words[i].length < min.length) {\n            min = words[i];\n        }\n    }\n    return min;\n};\n<|endoftext|>"}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary htat are greater than 10 and both \n  frist nad last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary htat are greater than 10 and both \n  frist nad last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n    const filter = [];\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 10 && nums[i] % 2 === 1) {\n            filter.push(nums[i]);\n        }\n    }\n    return filter.length;\n};\n\nexport {specialFilter};\n<|endoftext|>"}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the numebr of tripels (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] si a multpile fo 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the numebr of tripels (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] si a multpile fo 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n    let a = [1, 3, 7, 13, 21]\n    let count = 0\n\n    for (let i = 0; i < n - 1; i++) {\n        for (let j = i + 1; j < n; j++) {\n            for (let k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] === n * n - n + 1) {\n                    count++\n                }\n            }\n        }\n    }\n\n    return count\n}\n\nconst getMaxTriplesV2 = (n) => {\n    let a = [1, 3, 7, 13, 21]\n    let count = 0\n    let len = n\n    let t = 0\n    let i = 0\n    let j = 0\n    let k = 0\n    let sum = 0\n\n    while (len) {\n        sum = a[i] + a[j] + a[k]\n        if (sum === len * len - len + 1) {\n            count++\n            t = sum\n        }\n        len--\n        i++\n        if (i === len) {\n            i = 0\n            j++\n        }\n        if (j === len) {\n            j = 0\n            k++\n        }\n    }\n\n    return count\n}\n\nconst getMaxTriplesV3 = (n) => {\n    let a = [1, 3, 7, 13, 21]\n    let count = 0\n    let len = n\n    let t = 0\n    let i = 0\n    let j = 0\n    let k = 0\n    let sum = 0\n\n    while (len) {\n        sum = a[i] + a[j] + a[k]\n        if (sum === len * len - len + 1) {\n            count++\n            t = sum\n        }\n        len--\n        i++\n        if (i === len) {\n            i = 0\n            j++\n        }\n        if (j === len) {\n            j = 0\n            k++\n        }\n        if (k === len) {\n            k = 0\n        }\n    }\n\n    return count\n}\n\nconst getMaxTriplesV4 = (n) => {\n    let a = [1, 3, 7, 13, 21]\n    let count = 0\n    let len = n\n    let t = 0\n    let i = 0\n    let j = 0\n    let k = 0\n    let sum = 0\n\n    while (len) {\n        sum = a[i] + a[j] + a[k]\n        if (sum === len * len - len + 1) {\n            count++\n            t = sum\n        }\n        len--\n        i++\n        if (i === len) {\n            i = 0\n            j++\n        }\n        if (j === len) {\n            j = 0\n            k++\n        }\n        if (k === len) {\n            k = 0\n        }\n    }\n\n    return count\n}\n\nconst getMaxTriplesV5 = (n) => {\n    let a = [1, 3, 7, 13, 21]\n    let count = 0\n    let len = n\n    let t = 0\n    let i = 0\n    let j = 0\n    let k = 0\n    let sum = 0\n\n    while (len) {\n        sum = a[i] + a[j] + a[k]\n        if (sum === len * len - len + 1) {\n            count++\n            t = sum\n        }\n        len--\n        i++\n        if (i === len) {\n            i = 0\n            j++\n        }\n        if (j === len) {\n            j = 0\n            k++\n        }\n        if (k === len) {\n            k = 0\n        }\n    }\n\n    return count\n}\n\nconst getMaxTriplesV6 = (n) => {\n    let a = [1, 3, 7, 13, 21]\n    let count = 0\n    let len = n\n    let t = 0\n    let i = 0\n    let j = 0\n    let k = 0\n    let sum = 0\n\n    while (len) {\n        sum = a[i] + a[j] + a[k]\n        if (sum === len * len - len + 1) {\n            count++\n            t = sum\n        }\n        len--\n        i++\n        if (i === len) {\n            i = 0\n            j++\n        }\n        if (j === len) {\n            j = 0\n            k++\n        }\n        if (k === len) {\n            k = 0\n        }\n    }\n\n    return count\n}\n\nconst getMaxTriplesV7 = (n) => {\n    let a = [1, 3, 7, 13, 21]\n    let count = 0\n    let len = n\n    let t = 0\n    let i = 0\n    let j = 0\n    let k = 0\n    let sum = 0\n\n    while (len) {\n        sum = a[i] + a[j] + a[k]\n        if (sum === len * len - len + 1) {\n            count++\n            t = sum\n        }\n        len--\n        i++\n        if (i === len) {\n            i = 0\n            j++\n        }\n        if (j === len) {\n            j = 0\n            k++\n        }\n        if (k === len) {\n            k = 0\n        }\n    }\n\n    return count\n}\n\nconst getMaxTriplesV8 = (n) => {\n    let a = [1, 3, 7, 13, 21]\n    let count = 0\n    let len = n\n    "}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar ysstem: the clsoerst to the Sun\n  is Mercury, the next one is Venus, then Earht, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function shuold return a tuple conatining all planets whose orbist are\n  loctaed ebtween the orbit of planet1 adn the orbit of planet2, sorted by\n  the proximity to the sun.\n  The funtcion should return an empty tuple if planet1 or planet2\n  are not crorect planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "/* There are eight planets in our solar ysstem: the clsoerst to the Sun\n  is Mercury, the next one is Venus, then Earht, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function shuold return a tuple conatining all planets whose orbist are\n  loctaed ebtween the orbit of planet1 adn the orbit of planet2, sorted by\n  the proximity to the sun.\n  The funtcion should return an empty tuple if planet1 or planet2\n  are not crorect planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  //check if the planet names are valid\n  if (validator.isString(planet1) && validator.isString(planet2)) {\n    let p1 = planet1.toUpperCase();\n    let p2 = planet2.toUpperCase();\n    let p1_idx = planets.indexOf(p1);\n    let p2_idx = planets.indexOf(p2);\n    if (p1_idx === -1 || p2_idx === -1) {\n      return []\n    }\n    return planets.filter( (planet, idx) => {\n      return (idx <= p1_idx) || (idx <= p2_idx)\n    });\n  }\n  return []\n}\n\n/*\n  If we have the list of all the planets:\n  1) Sort the list by the distance from the Sun\n  2) Return the list of the nearest seven planets\n  */\nconst sortList = planets => {\n  let sun = 0\n  let dist = 0\n  let sorted = []\n  for (let i = 0; i < planets.length; i++) {\n    let p = planets[i];\n    sun = sun + planets[i].toUpperCase().length\n    dist = dist + Math.pow(Math.abs(planet_distance(p.toUpperCase(),'sun')), 2)\n  }\n  sorted = sorted.sort((a, b) => {\n    return dist - Math.pow(Math.abs(planet_distance(a.toUpperCase(),'sun')), 2) - Math.pow(Math.abs(planet_distance(b.toUpperCase(),'sun')), 2)\n  })\n  return sorted.slice(0, 7)\n}\n\n/*\n  1) Sort the list of all the planets by the distance from the Sun\n  2) Return the list of the nearest seven planets\n  */\nconst sortAll = planets => {\n  let sorted = []\n  for (let i = 0; i < planets.length; i++) {\n    sorted.push(planets[i].toUpperCase())\n  }\n  sorted = sorted.sort((a, b) => {\n    return planet_distance(a.toUpperCase(),'sun') - planet_distance(b.toUpperCase(),'sun')\n  })\n  return sorted.slice(0, 7)\n}\n\n/*\n  Calculate the euclid distance between two planets\n  */\nconst planet_distance = (planet1, planet2) => {\n  let sun = 0\n  let dist = 0\n  let p1 = planet1.toUpperCase();\n  let p2 = planet2.toUpperCase();\n  if (p1 === 'SUN') {\n    p1 = 'URANUS';\n  }\n  if (p2 === 'SUN') {\n    p2 = 'URANUS';\n  }\n  sun = sun + p1.length\n  sun = sun + p2.length\n  dist = Math.pow(Math.abs(planet_distance(p1,'sun')), 2) + Math.pow(Math.abs(planet_distance(p2,'sun')), 2)\n  return Math.sqrt(dist)\n}\n<|endoftext|>"}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings taht have odd lengths form it,\n  and returns the resultde list wtih a sorted order,\n  The list is always a list of tsrings adn never an array of numbers,\n  and it may ocntani duplicates.\n  The order of the list should eb ascending by length of each word, and you\n  sholud return the list sorted by htta rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words iwll haev the saem length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings taht have odd lengths form it,\n  and returns the resultde list wtih a sorted order,\n  The list is always a list of tsrings adn never an array of numbers,\n  and it may ocntani duplicates.\n  The order of the list should eb ascending by length of each word, and you\n  sholud return the list sorted by htta rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words iwll haev the saem length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const list = lst.sort((a, b) => a.length - b.length);\n  const sum = list.reduce((a, b) => a + b.length, 0);\n  return list.filter(a => a.length % 2 === 0).sort((a, b) => a.length - b.length);\n};\n\nconsole.log(sortedListSum([ 'a', 'aa', 'aaa' ]) === [ 'a', 'aa' ])\nconsole.log(sortedListSum([ 'a', 'b', 'aa', 'aaa' ]) === [ 'a', 'b', 'aa' ])\nconsole.log(sortedListSum([ 'a', 'b', 'aa', 'aaa', 'c' ]) === [ 'a', 'b', 'aa', 'aaa' ])\n<|endoftext|>"}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst xOrYPrime = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nconst main = () => {\n  const isPrime = prime => {\n    const i = prime;\n    while (i < 1e7) {\n      if (i % 2 === 0) {\n        return false;\n      }\n      i = i + prime;\n    }\n    return true;\n  };\n  const xOrYPrime = prime => {\n    const x = prime;\n    const y = prime + prime;\n    return xOrYPrime(x, y);\n  }\n  const xOrY = prime => {\n    const x = prime;\n    const y = prime + prime;\n    return xOrY(x, y);\n  }\n  const checkPrime = isPrime;\n  const isPrime = checkPrime;\n  const prime = isPrime(2);\n  const primePrime = isPrime(3);\n  const primePrimePrime = isPrime(5);\n  const primePrimePrimePrime = isPrime(7);\n  const primePrimePrimePrimePrime = isPrime(11);\n  const primePrimePrimePrimePrimePrime = isPrime(13);\n  const primePrimePrimePrimePrimePrimePrime = isPrime(17);\n  const primePrimePrimePrimePrimePrimePrimePrime = isPrime(19);\n  const primePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(23);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(29);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(31);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(37);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(41);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(43);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(47);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(53);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(59);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(61);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(67);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(71);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(73);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(79);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(83);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime = isPrime(89);\n  const primePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrimePrime"}
{"task_id": "JavaScript/151", "prompt": "/* iGven a list of numbres, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negaitve or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "/* iGven a list of numbres, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negaitve or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const list = listOf(lst)\n  let sum = 0\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] % 2 === 1) {\n      sum += Math.pow(list[i], 2)\n    }\n  }\n  return sum\n}\n\nexport default doubleTheDifference\n<|endoftext|>"}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeilng when the reslut of some long-awaited\n  eevnt is finally knwno. The feelings and thuoghts you have at that ommnet are\n  definitely worth noting dwon and cmoparing.\n  Your task is to determine if a person correctly guessed hte results of a number of matches.\n  You are given two arrays of socres and guesses of equal length, where each index shows a match. \n  Return an array of the same elgnth denoting how far off each guess was. If they have guessed correctyl,\n  the avlue is 0, and if not, the value si the absoulte difference ebtween the guess and the csore.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "/*I think we all remember that feeilng when the reslut of some long-awaited\n  eevnt is finally knwno. The feelings and thuoghts you have at that ommnet are\n  definitely worth noting dwon and cmoparing.\n  Your task is to determine if a person correctly guessed hte results of a number of matches.\n  You are given two arrays of socres and guesses of equal length, where each index shows a match. \n  Return an array of the same elgnth denoting how far off each guess was. If they have guessed correctyl,\n  the avlue is 0, and if not, the value si the absoulte difference ebtween the guess and the csore.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let guess = _.cloneDeep(guess);\n  let game = _.cloneDeep(game);\n  let count = 0;\n  let diff = 0;\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let index = 0;\n    for (let j = 0; j < game.length; j++) {\n      if (game[i] === guess[j]) {\n        index = j;\n      }\n    }\n    if (index === game.length - 1) {\n      count++;\n      diff = 0;\n    } else {\n      diff = Math.abs(index - game.length - 1);\n    }\n    result.push(diff);\n  }\n  return result;\n};\n\nexport default compare;\n<|endoftext|>"}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used ot load additoianl classes to the lcass. The\n  stregnth of the extenison is as follwos: Let CAP be the nmuber of the uppercsae\n  lettres in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strentgh is given by the fraction CPA - SM.\n  You shuold find the srtonegst extensino and return a string in thsi\n  fomrat: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used ot load additoianl classes to the lcass. The\n  stregnth of the extenison is as follwos: Let CAP be the nmuber of the uppercsae\n  lettres in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strentgh is given by the fraction CPA - SM.\n  You shuold find the srtonegst extensino and return a string in thsi\n  fomrat: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const class_name_split = class_name.split('.')\n  const class_name_upper = class_name_split[0].toUpperCase() + class_name_split.slice(1)\n  const cap_count = class_name_split.map(c => c.toUpperCase()).reduce((a, b) => {\n    return a + b\n  })\n  const lower_count = class_name_split.map(c => c.toLowerCase()).reduce((a, b) => {\n    return a + b\n  })\n  const extensions_length = extensions.length\n  const strongest_extension = extensions.find(extension =>\n    (cap_count - lower_count) / extensions_length >= -1\n  )\n  return class_name_upper + '.' + strongest_extension\n}\n\nmodule.exports = strongestExtension\n<|endoftext|>"}
{"task_id": "JavaScript/154", "prompt": "/*You are givne 2 words. You need to return true if the escond word or any of its rotations is a substring in the fisrt word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => ture\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => rtue\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "/*You are givne 2 words. You need to return true if the escond word or any of its rotations is a substring in the fisrt word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => ture\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => rtue\n  */\nconst cycpatternCheck = (a, b) => {\n  let aa = a.split(\"\");\n  let bb = b.split(\"\");\n  let ai = 0;\n  let bi = 0;\n  let count = 0;\n  while(ai < aa.length && bi < bb.length){\n    if(aa[ai] === bb[bi]){\n      count++;\n      ai++;\n      bi++;\n    }\n    else{\n      if(count === 2){\n        return true;\n      }\n      count = 0;\n      ai++;\n      bi++;\n    }\n  }\n  if(ai === aa.length){\n    if(count === 2){\n      return true;\n    }\n    else{\n      return false;\n    }\n  }\n  else{\n    return false;\n  }\n}\n\nmodule.exports = cycpatternCheck;\n<|endoftext|>"}
{"task_id": "JavaScript/155", "prompt": "/*Given na integre. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "/*Given na integre. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  let isOdd = true;\n  while (num) {\n    count++;\n    isOdd =!isOdd;\n    num = num % 10;\n  }\n  return (isOdd? count : count + 1);\n};\n\nconst test = () => {\n  const num = (isOdd) => {\n    return isOdd? evenOddCount(num) : evenOddCount(10 * num);\n  };\n\n  const num2 = (isOdd) => {\n    return isOdd? evenOddCount(num2) : evenOddCount(10 * num2);\n  };\n\n  const num3 = (isOdd) => {\n    return isOdd? evenOddCount(num3) : evenOddCount(10 * num3);\n  };\n\n  const num4 = (isOdd) => {\n    return isOdd? evenOddCount(num4) : evenOddCount(10 * num4);\n  };\n\n  const num5 = (isOdd) => {\n    return isOdd? evenOddCount(num5) : evenOddCount(10 * num5);\n  };\n\n  const num6 = (isOdd) => {\n    return isOdd? evenOddCount(num6) : evenOddCount(10 * num6);\n  };\n\n  const num7 = (isOdd) => {\n    return isOdd? evenOddCount(num7) : evenOddCount(10 * num7);\n  };\n\n  const num8 = (isOdd) => {\n    return isOdd? evenOddCount(num8) : evenOddCount(10 * num8);\n  };\n\n  const num9 = (isOdd) => {\n    return isOdd? evenOddCount(num9) : evenOddCount(10 * num9);\n  };\n\n  const num10 = (isOdd) => {\n    return isOdd? evenOddCount(num10) : evenOddCount(10 * num10);\n  };\n\n  const num11 = (isOdd) => {\n    return isOdd? evenOddCount(num11) : evenOddCount(10 * num11);\n  };\n\n  const num12 = (isOdd) => {\n    return isOdd? evenOddCount(num12) : evenOddCount(10 * num12);\n  };\n\n  const num13 = (isOdd) => {\n    return isOdd? evenOddCount(num13) : evenOddCount(10 * num13);\n  };\n\n  const num14 = (isOdd) => {\n    return isOdd? evenOddCount(num14) : evenOddCount(10 * num14);\n  };\n\n  const num15 = (isOdd) => {\n    return isOdd? evenOddCount(num15) : evenOddCount(10 * num15);\n  };\n\n  const num16 = (isOdd) => {\n    return isOdd? evenOddCount(num16) : evenOddCount(10 * num16);\n  };\n\n  const num17 = (isOdd) => {\n    return isOdd? evenOddCount(num17) : evenOddCount(10 * num17);\n  };\n\n  const num18 = (isOdd) => {\n    return isOdd? evenOddCount(num18) : evenOddCount(10 * num18);\n  };\n\n  const num19 = (isOdd) => {\n    return isOdd? evenOddCount(num19) : evenOddCount(10 * num19);\n  };\n\n  const num20 = (isOdd) => {\n    return isOdd? evenOddCount(num20) : evenOddCount(10 * num20);\n  };\n\n  const num21 = (isOdd) => {\n    return isOdd? evenOddCount(num21) : evenOddCount(10 * num21);\n  };\n\n  const num22 = (isOdd) => {\n    return isOdd? evenOddCount(num22) : evenOddCount(10 * num22);\n  };\n\n  const num23 = (isOdd) => {\n    return isOdd? evenOddCount(num23) : evenOddCount(10 * num23);\n  };\n\n  const num24 = (isOdd) => {\n    return isOdd? evenOddCount(num24) : evenOddCount(10 * num24);\n  };\n\n  const num25 = (isOdd) => {\n    return isOdd? evenOddCount(num25) : evenOddCount(10 * num25);\n  };\n\n  const num26 = (isOdd) => {\n    return isOdd? evenOddCount(num26) : evenOddCount(10 * num26);\n  };\n\n  const num27 = (isOdd) => {\n    return isOdd? evenOddCount(num27) : evenOddCount(10 * num27);\n  };\n\n  const num28 = (isOdd) => {\n    return isOdd? evenOddCount(num28) : evenOddCount(10 * num28);\n  };\n\n  const num29 = (isOdd) => {\n    return isOdd? evenOddCount(num29) : evenOddCount(10 * num29);\n  };\n\n  const num30 = (isOdd) => {\n    return isOdd? evenOddCount(num30) : evenOddCount(10 * num30);\n  };\n\n  const num31 = (isOdd) => {\n    return isOdd? evenOddCount(num31) : evenOddCount(10 * num31);\n  };\n\n  const num32 = (isOdd) => {\n    return isOdd? evenOddCount(num32) : evenOddCount(10 * num32);\n  };\n\n  const num33 = (isOdd) => {\n    return isOdd? evenOddCount(num33) : evenOddCount(10 * num33);\n  };\n\n  const num34 = (isO"}
{"task_id": "JavaScript/156", "prompt": "/*\n  Gievn a positive integer, obtain its roman numearl equivaletn as a string,\n  and return it in lowercase.\n  Retsritcions: 1 <= num <= 1000\n\n  Exmaples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "/*\n  Gievn a positive integer, obtain its roman numearl equivaletn as a string,\n  and return it in lowercase.\n  Retsritcions: 1 <= num <= 1000\n\n  Exmaples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  number = number.toString();\n  number = number.replace(/(\\d{3})(\\d{1})/g, (x, y) => x + y.toUpperCase());\n  return number.replace(/(\\d{1})(\\d{3})/g, (x, y) => x + y.toUpperCase());\n}\n\n/*\n  Gievn a positive integer, obtain its roman numearl equivelent as a string,\n  and return it in upper case.\n  Retsritcions: 1 <= num <= 1000\n\n  Exmaples:\n  >>> intToMiniRoman(19) == 'XIX'\n  >>> intToMiniRoman(152) == 'CLII'\n  >>> intToMiniRoman(426) == 'CDXXVI'\n  */\nconst intToMiniRomanU = (number) => {\n  number = number.toString();\n  number = number.replace(/(\\d{3})(\\d{1})/g, (x, y) => x.toUpperCase() + y);\n  return number.replace(/(\\d{1})(\\d{3})/g, (x, y) => x.toUpperCase() + y);\n}\n\n// __________________________________________\n// Test Code:  Do not alter code below this line.\n\nfunction assert(test, message, test_number) {\n  if (!test) {\n    console.log(`Error: ${message} Number: ${test_number}`);\n  }\n}\n\nassert(\n  (intToRoman(1) === \"I\"),\n  \"intToRoman should return 'I' for number 1\",\n  1\n);\n\nassert(\n  (intToRoman(4) === \"IV\"),\n  \"intToRoman should return 'IV' for number 4\",\n  4\n);\n\nassert(\n  (intToRoman(39) === \"XCIX\"),\n  \"intToRoman should return 'XCIX' for number 39\",\n  39\n);\n\nassert(\n  (intToRoman(3999) === \"MMMCMXCIX\"),\n  \"intToRoman should return 'MMMCMXCIX' for number 3999\",\n  3999\n);\n\nassert(\n  (intToRomanU(1) === \"I\"),\n  \"intToRomanU should return 'I' for number 1\",\n  1\n);\n\nassert(\n  (intToRomanU(4) === \"IV\"),\n  \"intToRomanU should return 'IV' for number 4\",\n  4\n);\n\nassert(\n  (intToRomanU(39) === \"XCIX\"),\n  \"intToRomanU should return 'XCIX' for number 39\",\n  39\n);\n\nassert(\n  (intToRomanU(3999) === \"MMMCMXCIX\"),\n  \"intToRomanU should return 'MMMCMXCIX' for number 3999\",\n  3999\n);\n<|endoftext|>"}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b === c && b + c === a && a + c === b;\n};\n\nexport default rightAngleTriangle;\n<|endoftext|>"}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with amximum numbre\n  fo unique hcaratecrs. If multipel strings have maximum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with amximum numbre\n  fo unique hcaratecrs. If multipel strings have maximum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  if (words.length === 0) {\n    return ''\n  }\n  const max = words[0]\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i]\n    }\n  }\n  return max\n}\n\nmodule.exports = findMax\n<|endoftext|>"}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eatne a certain number fo acrrots,\n  but now you need to eat mroe crarots to complete the day's maels.\n  you should return an array of [ total number of eaten carrots aftre your meals,\n                                  the number of carrots elft after your meals ]\n  if there are not enough remaining carrots, oyu will eat all remaining carrots, ubt will still eb uhngry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "/*\n  You're a hungry rabbit, and you already have eatne a certain number fo acrrots,\n  but now you need to eat mroe crarots to complete the day's maels.\n  you should return an array of [ total number of eaten carrots aftre your meals,\n                                  the number of carrots elft after your meals ]\n  if there are not enough remaining carrots, oyu will eat all remaining carrots, ubt will still eb uhngry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n    if (number <= need) {\n        return [number, remaining];\n    }\n\n    return [number - (need - remaining), remaining];\n}\n\nconst {eat} = require('./eat');\n\nconst {expect} = require('chai');\n\ndescribe('eat', () => {\n    it('should be a function', () => {\n        expect(eat).to.be.a('function');\n    });\n\n    it('should throw error if number is not integer', () => {\n        expect(() => eat(1.5, 2, 3)).to.throw(Error, 'number must be an integer');\n    });\n\n    it('should throw error if need is not integer', () => {\n        expect(() => eat(1, 2.5, 3)).to.throw(Error, 'need must be an integer');\n    });\n\n    it('should throw error if remaining is not integer', () => {\n        expect(() => eat(1, 2, 3.5)).to.throw(Error,'remaining must be an integer');\n    });\n});<|endoftext|>"}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has baisc algebra operations, and \n  hte escond list is a list of integers. Use the two gievn lists to build the algerbic \n  expression nad return the evaluation of this expression.\n\n  The basic aglebra operations:\n  Addition ( + ) \n  Subrtaction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "/*\n  Given two lists operator, and operand. The first list has baisc algebra operations, and \n  hte escond list is a list of integers. Use the two gievn lists to build the algerbic \n  expression nad return the evaluation of this expression.\n\n  The basic aglebra operations:\n  Addition ( + ) \n  Subrtaction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const opLength = operator.length\n  const operandLength = operand.length\n  if(opLength < 1) throw new Error('Operator list must have at least one element')\n  if(operandLength < 2) throw new Error('Operand list must have at least two elements')\n\n  // Get first and second elements of operand\n  const firstOperand = operand[0]\n  const secondOperand = operand[1]\n\n  // Get first and second elements of operator\n  const firstOperator = operator[0]\n  const secondOperator = operator[1]\n\n  // Create a new array\n  const result = []\n  \n  // Process operand\n  for (let i = 0; i < operandLength; i++) {\n    // Process each element of the array\n    let currentOperand = operand[i]\n    if (typeof currentOperand!== 'number') {\n      throw new Error('Operand element must be a number')\n    }\n    result.push(currentOperand)\n  }\n\n  // Process operator\n  for (let i = 0; i < opLength; i++) {\n    // Process each element of the array\n    let currentOperator = operator[i]\n    if (typeof currentOperator!== 'number') {\n      throw new Error('Operator element must be a number')\n    }\n    let currentOperand = result[i]\n\n    // Get new value\n    let newValue = 0\n    if (firstOperator === '+') {\n      newValue = firstOperand + currentOperand\n    } else if (firstOperator === '-') {\n      newValue = firstOperand - currentOperand\n    } else if (firstOperator === '*') {\n      newValue = firstOperand * currentOperand\n    } else if (firstOperator === '/') {\n      newValue = firstOperand / currentOperand\n    } else if (firstOperator === '**') {\n      newValue = Math.pow(firstOperand, currentOperand)\n    }\n\n    // Add new value to result\n    result.push(newValue)\n  }\n\n  return result[0]\n}\n\nconsole.log(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]))\n<|endoftext|>"}
{"task_id": "JavaScript/161", "prompt": "/*You rae given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "/*You rae given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = [];\n  for (let i = 0; i < s.length; i++) {\n    let letter = s[i];\n    let char = letter.toLowerCase();\n    let tmp = '';\n    if (char.length === 1) {\n      if (char === 'a' || char === 'A') {\n        char = 'A';\n      } else {\n        char = 'a';\n      }\n    }\n    result.push(char);\n  }\n  return result.join('');\n}\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\n<|endoftext|>"}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "/*\n  Given a string 'text', return its md5 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  let md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n}\n\n/**\n  Given a string 'text', return its md5 hash equivaletn string.\n  If 'text' is an empty string, return null.\n  \n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst md5ToString = (text) => {\n  let md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n}\n\n/**\n  Given a string 'text', return its sha1 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == '3f5a6dcc9d7a3b2e6a0d2c9e0c6ddbdbb2f8d7'\n  */\nconst stringToSha1 = (text) => {\n  let sha1 = crypto.createHash('sha1');\n  sha1.update(text);\n  return sha1.digest('hex');\n}\n\n/**\n  Given a string 'text', return its sha1 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == '3f5a6dcc9d7a3b2e6a0d2c9e0c6ddbdbb2f8d7'\n  */\nconst sha1ToString = (text) => {\n  let sha1 = crypto.createHash('sha1');\n  sha1.update(text);\n  return sha1.digest('hex');\n}\n\n/**\n  Given a string 'text', return its sha1 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == '3f5a6dcc9d7a3b2e6a0d2c9e0c6ddbdbb2f8d7'\n  */\nconst sha1ToBuffer = (text) => {\n  let sha1 = crypto.createHash('sha1');\n  sha1.update(text);\n  return sha1.digest();\n}\n\nmodule.exports = {\n  stringToMd5,\n  md5ToString,\n  stringToSha1,\n  sha1ToString,\n  sha1ToBuffer\n}<|endoftext|>"}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive nitegers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "/*\n  Given two positive nitegers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let i, j, result = [];\n  for (i = a, j = b; i < j; i += 2) {\n    result.push(i);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer, return the sum of all the even digits of its\n  power, starting from 2.\n\n  For example:\n  sumDigits(5) => 15\n  sumDigits(10) => 30\n  sumDigits(100) => 1206\n  sumDigits(123) => 1477\n  sumDigits(1729) => 1501\n  sumDigits(1812) => 1812\n  sumDigits(9069) => 10285\n  */\nconst sumDigits = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i += 2) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  Given two positive integers, return the larger of the two.\n\n  For example:\n  compare(2, 5) => 5\n  compare(2, 3) => 3\n  compare(5, 2) => 5\n  compare(3, 2) => 3\n  compare(4, 2) => 4\n  compare(4, 3) => 4\n  compare(9, 5) => 9\n  compare(10, 5) => 10\n  compare(11, 5) => 11\n  */\nconst compare = (a, b) => {\n  if (a > b) {\n    return a;\n  } else if (a < b) {\n    return b;\n  } else {\n    return a;\n  }\n};\n\n/*\n  Given a positive integer, return the number of 1's in the binary\n  representation of that number.\n\n  For example:\n  bitCount(5) => 2\n  bitCount(8) => 3\n  bitCount(10) => 2\n  bitCount(18) => 3\n  bitCount(1234) => 7\n  */\nconst bitCount = (n) => {\n  let count = 0;\n  while (n > 0) {\n    count += n % 2;\n    n = n / 2;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer, return the index of the first bit set to 1.\n\n  For example:\n  firstBit(11) => 4\n  firstBit(8) => 3\n  firstBit(4) => 0\n  firstBit(1) => 0\n  firstBit(0) => -1\n  */\nconst firstBit = (n) => {\n  for (let i = 0; i < 32; i++) {\n    if (n > 0) {\n      if (n % 2 === 1) {\n        return i;\n      }\n      n = n / 2;\n    }\n  }\n  return -1;\n};\n\n/*\n  Given a positive integer, return the index of the last bit set to 1.\n\n  For example:\n  lastBit(11) => 4\n  lastBit(8) => 3\n  lastBit(4) => 0\n  lastBit(1) => 31\n  lastBit(0) => -1\n  */\nconst lastBit = (n) => {\n  for (let i = 31; i >= 0; i--) {\n    if (n > 0) {\n      if (n % 2 === 1) {\n        return i;\n      }\n      n = n / 2;\n    }\n  }\n  return -1;\n};\n\n/*\n  Given two positive integers, return the larger of the two.\n\n  For example:\n  min(5, 8) => 5\n  min(3, 4) => 3\n  min(7, 9) => 9\n  min(4, 3) => 3\n  min(1, 9) => 9\n  */\nconst min = (a, b) => {\n  if (a < b) {\n    return a;\n  } else {\n    return b;\n  }\n};\n\n/*\n  Given two positive integers, return the larger of the two.\n\n  For example:\n  max(5, 8) => 8\n  max(3, 4) => 4\n  max(7, 9) => 9\n  max(4, 3) => 4\n  max(1, 9) => 9\n  */\nconst max = (a, b) => {\n  if (a > b) {\n    return a;\n  } else {\n    return b;\n  }\n};\n\n/*\n  Given a positive integer, return the number of 1's in the binary\n  representation of that number, without extra leading 1's.\n\n  For example:\n  binaryDigits(10) => 2\n  binaryDigits(15) => 3\n  binaryDigits(8) => 3\n  binaryDigits(4) => 0\n  binaryDigits(1) => 0\n  binaryDigits(0) => -1\n  */\nconst binaryDigits = (n) => {\n  let count = 0;\n  while (n > 0) {\n    count += n % 2;\n    n = n / 2;\n  }\n  return count;\n};\n\nexport default {\n  generateIntegers,\n  sumDigits,\n  bitCount,\n  firstBit,\n  lastBit,\n  min,\n  max,\n  binaryDigits\n};\n<|endoftext|>"}
