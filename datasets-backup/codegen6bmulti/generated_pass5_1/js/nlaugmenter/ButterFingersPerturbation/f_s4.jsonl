{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to eacj other than\n  givwt threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 4, "perturbed": true, "gc": "/* Check if in given list of numbers, are any two numbers closer to eacj other than\n  givwt threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const len = numbers.length\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements2 = (numbers, threshold) => {\n  const len = numbers.length\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements3 = (numbers, threshold) => {\n  const len = numbers.length\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements4 = (numbers, threshold) => {\n  const len = numbers.length\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements5 = (numbers, threshold) => {\n  const len = numbers.length\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements6 = (numbers, threshold) => {\n  const len = numbers.length\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements7 = (numbers, threshold) => {\n  const len = numbers.length\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements8 = (numbers, threshold) => {\n  const len = numbers.length\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (Math.abs(numbers[i] - numbers[j]) < threshold) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n/*\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements9 = (numbers, threshold) => {\n  const len = numbers.length\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len;", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/1", "prompt": "/* Input to ehis function id a string containing mkltiple groups of tested parentheses. Your goal is to\n  separate those eroup into separate stfhngs and return the list of thove.\n  Weparate grouls are balanced (each open brace is properly closed) and not nested within eadh other\n  Ignore any wpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 4, "perturbed": true, "gc": "/* Input to ehis function id a string containing mkltiple groups of tested parentheses. Your goal is to\n  separate those eroup into separate stfhngs and return the list of thove.\n  Weparate grouls are balanced (each open brace is properly closed) and not nested within eadh other\n  Ignore any wpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_list = paren_string.split('');\n  const paren_stack = [];\n  const paren_stack_index = 0;\n  const paren_stack_length = paren_list.length;\n  const paren_stack_index_end = paren_stack_length - 1;\n  const paren_stack_index_start = 0;\n  const paren_stack_index_end_start = paren_stack_index_end;\n  const paren_stack_index_end_end = paren_stack_index_end;\n  const paren_stack_index_end_end_start = paren_stack_index_end_end;\n  const paren_stack_index_end_end_end = paren_stack_index_end_end;\n  const paren_stack_index_end_end_end_start = paren_stack_index_end_end_end;\n  const paren_stack_index_end_end_end_end = paren_stack_index_end_end_end;\n  const paren_stack_index_end_end_end_end_start = paren_stack_index_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end = paren_stack_index_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end = paren_stack_index_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end = paren_stack_index_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end = paren_stack_index_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_end = paren_stack_index_end_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_end_end = paren_stack_index_end_end_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_start = paren_stack_index_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end;\n  const paren_stack_index_end_end_end_end_end_end_end_end_end_end_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if ggiven strig is w palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 4, "perturbed": true, "gc": "/* Test if ggiven strig is w palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = '';\n  let postfix = '';\n  let length = string.length;\n  let i = 0;\n  let j = length - 1;\n  while (i < j) {\n    if (string[i]!= string[j]) {\n      break;\n    }\n    i++;\n    j--;\n  }\n  if (i == j) {\n    return string;\n  }\n  prefix = string.slice(0, i);\n  postfix = string.slice(j + 1, length);\n  return prefix + postfix.split('').reverse().join('');\n}\n\n/* Test if a string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  >>> makePalindrome('cataa')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = '';\n  let postfix = '';\n  let length = string.length;\n  let i = 0;\n  let j = length - 1;\n  while (i < j) {\n    if (string[i]!= string[j]) {\n      break;\n    }\n    i++;\n    j--;\n  }\n  if (i == j) {\n    return string;\n  }\n  prefix = string.slice(0, i);\n  postfix = string.slice(j + 1, length);\n  return prefix + postfix.split('').reverse().join('');\n}\n\n/* Test if a string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  >>> makePalindrome('cataa')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = '';\n  let postfix = '';\n  let length = string.length;\n  let i = 0;\n  let j = length - 1;\n  while (i < j) {\n    if (string[i]!= string[j]) {\n      break;\n    }\n    i++;\n    j--;\n  }\n  if (i == j) {\n    return string;\n  }\n  prefix = string.slice(0, i);\n  postfix = string.slice(j + 1, length);\n  return prefix + postfix.split('').reverse().join('');\n}\n\n/* Test if a string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  >>> makePalindrome('cataa')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let prefix = '';\n  let postfix = '';\n  let length = string.length;\n  let i = 0;\n  let j = length - 1;\n  while (i < j) {\n    if (string[i]!= string[j]) {\n      break;\n    }\n    i++;\n    j--;\n  }\n  if (i == j) {\n    return string;\n  }\n  prefix = string.slice(0, i);\n  postfix = string.slice(j + 1, length);\n  return prefix + postfix.split('').reverse().join('');\n}\n\n/* Test if a string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the longest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 4, "perturbed": true, "gc": "/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile2 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile3 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile4 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile5 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile6 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile7 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile8 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile9 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile10 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile11 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile12 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile13 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile14 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile15 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile16 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile17 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile18 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile19 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile20 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile21 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile22 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile23 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile24 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile25 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile26 = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst makeAPile27 = (n) => {\n  const", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 4, "perturbed": true, "gc": "/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(/\\s+/);\n  return words;\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  words", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/102", "prompt": "/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest even integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 4, "perturbed": true, "gc": "/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest even integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let x1 = x;\n  let y1 = y;\n  let x2 = x;\n  let y2 = y;\n  let x3 = x;\n  let y3 = y;\n  let x4 = x;\n  let y4 = y;\n  let x5 = x;\n  let y5 = y;\n  let x6 = x;\n  let y6 = y;\n  let x7 = x;\n  let y7 = y;\n  let x8 = x;\n  let y8 = y;\n  let x9 = x;\n  let y9 = y;\n  let x10 = x;\n  let y10 = y;\n  let x11 = x;\n  let y11 = y;\n  let x12 = x;\n  let y12 = y;\n  let x13 = x;\n  let y13 = y;\n  let x14 = x;\n  let y14 = y;\n  let x15 = x;\n  let y15 = y;\n  let x16 = x;\n  let y16 = y;\n  let x17 = x;\n  let y17 = y;\n  let x18 = x;\n  let y18 = y;\n  let x19 = x;\n  let y19 = y;\n  let x20 = x;\n  let y20 = y;\n  let x21 = x;\n  let y21 = y;\n  let x22 = x;\n  let y22 = y;\n  let x23 = x;\n  let y23 = y;\n  let x24 = x;\n  let y24 = y;\n  let x25 = x;\n  let y25 = y;\n  let x26 = x;\n  let y26 = y;\n  let x27 = x;\n  let y27 = y;\n  let x28 = x;\n  let y28 = y;\n  let x29 = x;\n  let y29 = y;\n  let x30 = x;\n  let y30 = y;\n  let x31 = x;\n  let y31 = y;\n  let x32 = x;\n  let y32 = y;\n  let x33 = x;\n  let y33 = y;\n  let x34 = x;\n  let y34 = y;\n  let x35 = x;\n  let y35 = y;\n  let x36 = x;\n  let y36 = y;\n  let x37 = x;\n  let y37 = y;\n  let x38 = x;\n  let y38 = y;\n  let x39 = x;\n  let y39 = y;\n  let x40 = x;\n  let y40 = y;\n  let x41 = x;\n  let y41 = y;\n  let x42 = x;\n  let y42 = y;\n  let x43 = x;\n  let y43 = y;\n  let x44 = x;\n  let y44 = y;\n  let x45 = x;\n  let y45 = y;\n  let x46 = x;\n  let y46 = y;\n  let x47 = x;\n  let y47 = y;\n  let x48 = x;\n  let y48 = y;\n  let x49 = x;\n  let y49 = y;\n  let x50 = x;\n  let y50 = y;\n  let x51 = x;\n  let y51 = y;\n  let x52 = x;\n  let y52 = y;\n  let x53 = x;\n  let y53 = y;\n  let x54 = x;\n  let y54 = y;\n  let x55 = x;\n  let y55 = y;\n  let x56 = x;\n  let y56 = y;\n  let x57 = x;\n  let y57 = y;\n  let x58 = x;\n  let y58 = y;\n  let x59 = x;\n  let y59 = y;\n  let x60 = x;\n  let y60 = y;\n  let x61 = x;\n  let y61 = y;\n  let x62 = x;\n  let y62 = y;\n  let x63 = x;\n  let y63 = y;\n  let x64 = x;\n  let y64 = y;\n  let x65 = x;\n  let y65 = y;\n  let x66 = x;\n  let y66 = y;\n  let x67 = x;\n  let y67 = y;\n  let x68 = x;\n  let y68 = y;\n  let x69 = x;\n  let y69 = y;\n  let x70 = x;\n  let y70 = y;\n  let x71 = x;\n  let y71 = y;\n  let x72 = x;\n  let y72 = y;\n  let x73 = x;\n  let y73 = y;\n  let x74 = x;\n  let y74 = y;\n  let x75 = x;\n  let y75 = y;\n  let x76 = x;\n  let y76 = y;\n  let x77 = x;\n  let y77 = y;\n  let x78 = x;\n  let y78 = y;\n  let x79 = x;\n  let y79 = y;\n  let x80 = x;\n  let y80 = y;\n  let x81 = x;\n  let y81 = y;\n  let x82 = x;\n  let y82 = y;\n  let x83 = x;\n  let y83 = y;\n  let x84 = x;\n  let y84 = y;\n  let x85 = x;\n  let y85 = y;\n  let x86 = x;\n  let y86 = y;\n  let x87 = x;\n  let y87 = y;\n  let x88 = x;\n  let y88 = y;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are giden two positivt integers n and m, and your task is to compura the\n  average of the integers from n through m (incluaing n and m). \n  Round the dnswer to the nearest intwger and convsrt that to binary.\n  If n is greader than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 4, "perturbed": true, "gc": "/*You are giden two positivt integers n and m, and your task is to compura the\n  average of the integers from n through m (incluaing n and m). \n  Round the dnswer to the nearest intwger and convsrt that to binary.\n  If n is greader than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const nInt = parseInt(n, 10);\n  const mInt = parseInt(m, 10);\n  const nIntBits = nInt.toString(2);\n  const mIntBits = mInt.toString(2);\n  const nIntBitsLength = nIntBits.length;\n  const mIntBitsLength = mIntBits.length;\n  const nIntBitsLengthDiff = nIntBitsLength - mIntBitsLength;\n  const nIntBitsDiff = nIntBits.substr(0, nIntBitsLengthDiff);\n  const mIntBitsDiff = mIntBits.substr(0, mIntBitsLengthDiff);\n  const nIntBitsDiffLength = nIntBitsDiff.length;\n  const mIntBitsDiffLength = mIntBitsDiff.length;\n  const nIntBitsDiffLengthDiff = nIntBitsDiffLength - mIntBitsDiffLength;\n  const nIntBitsDiffDiff = nIntBitsDiff.substr(0, nIntBitsDiffLengthDiff);\n  const mIntBitsDiffDiff = mIntBitsDiff.substr(0, mIntBitsDiffLengthDiff);\n  const nIntBitsDiffDiffLength = nIntBitsDiffDiff.length;\n  const mIntBitsDiffDiffLength = mIntBitsDiffDiff.length;\n  const nIntBitsDiffDiffLengthDiff = nIntBitsDiffDiffLength - mIntBitsDiffDiffLength;\n  const nIntBitsDiffDiffDiff = nIntBitsDiffDiff.substr(0, nIntBitsDiffDiffLengthDiff);\n  const mIntBitsDiffDiffDiff = mIntBitsDiffDiff.substr(0, mIntBitsDiffDiffLengthDiff);\n  const nIntBitsDiffDiffDiffLength = nIntBitsDiffDiffDiff.length;\n  const mIntBitsDiffDiffDiffLength = mIntBitsDiffDiffDiff.length;\n  const nIntBitsDiffDiffDiffLengthDiff = nIntBitsDiffDiffDiffLength - mIntBitsDiffDiffDiffLength;\n  const nIntBitsDiffDiffDiffDiff = nIntBitsDiffDiffDiff.substr(0, nIntBitsDiffDiffDiffLengthDiff);\n  const mIntBitsDiffDiffDiffDiff = mIntBitsDiffDiffDiff.substr(0, mIntBitsDiffDiffDiffLengthDiff);\n  const nIntBitsDiffDiffDiffDiffLength = nIntBitsDiffDiffDiffDiff.length;\n  const mIntBitsDiffDiffDiffDiffLength = mIntBitsDiffDiffDiffDiff.length;\n  const nIntBitsDiffDiffDiffDiffLengthDiff = nIntBitsDiffDiffDiffDiffLength - mIntBitsDiffDiffDiffDiffLength;\n  const nIntBitsDiffDiffDiffDiffDiff = nIntBitsDiffDiffDiffDiff.substr(0, nIntBitsDiffDiffDiffDiffLengthDiff);\n  const mIntBitsDiffDiffDiffDiffDiff = mIntBitsDiffDiffDiffDiff.substr(0, mIntBitsDiffDiffDiffDiffLengthDiff);\n  const nIntBitsDiffDiffDiffDiffDiffLength = nIntBitsDiffDiffDiffDiffDiff.length;\n  const mIntBitsDiffDiffDiffDiffDiffLength = mIntBitsDiffDiffDiffDiffDiff.length;\n  const nIntBitsDiffDiffDiffDiffDiffLengthDiff = nIntBitsDiffDiffDiffDiffDiffLength - mIntBitsDiffDiffDiffDiffDiffLength;\n  const nIntBitsDiffDiffDiffDiffDiffDiff = nIntBitsDiffDiffDiffDiffDiff.substr(0, nIntBitsDiffDiffDiffDiffDiffLengthDiff);\n  const mIntBitsDiffDiffDiffDiffDiffDiff = mIntBitsDiffDiffDiffDiffDiff.substr(0, mIntBitsDiffDiffDiffDiffDiffLengthDiff);\n  const nIntBitsDiffDiffDiffDiffDiffDiffLength = nIntBitsDiffDiffDiffDiffDiffDiff.length;\n  const mIntBitsDiffDiffDiffDiffDiffDiffLength = mIntBitsDiffDiffDiffDiffDiffDiff.length;\n  const nIntBitsDiffDiffDiffDiffDiffDiffLengthDiff = nIntBitsDiffDiffDiffDiffDiffDiffLength - mIntBitsDiffDiffDiffDiffDiffDiffLength;\n  const nIntBitsDiffDiffDiffDiffDiffDiffDiff = nIntBitsDiffDiffDiffDiffDiffDiff.substr(0, nIntBitsDiffDiffDiffDiffDiffDiffLengthDiff);\n  const mIntBitsDiffDiffDiffDiffDiffDiffDiff = mIntBitsDiffDiffDiffDiffDiffDiff.substr(0, mIntBitsDiffDiffDiffDiffDiffDiffDiffLengthDiff);\n  const nIntBitsDiffDiffDiffDiffDiffDiffDiffLength = nIntBitsDiffDiffDiffDiffDiffDiffDiff.length;\n  const mIntBitsDiffDiffDiffDiffDiffDiffDiffLength = mIntBitsDiffDiffDiffDiffDiffDiffDiff.length;\n  const nIntBitsDiffDiffDiffDiffDiffDiffDiffLengthDiff = nIntBitsDiffDiffDiffDiffDiffDiffDiffLength - mIntBitsDiffDiffDiffDiffDiffDiffDiffLength;\n  const nIntBitsDiffDiffDiffDiffDiffDiffDiffDiff = nIntBitsDiffDiffDiffDiffDiffDiffDiff.substr(0, nIntBitsDiffDiffDiffDiffDiffDiffDiffDiffLengthDiff);\n  const mIntBitsDiffDiffDiffDiffDiffDiffDiffDiff = mIntBitsDiffDiffDiffDiffDiffDiffDiffDiff.substr(0, mIntBitsDiffDiffDiffDiffDiffDiffDiffDiffLengthDiff);\n  const nIntBitsDiffDiffDiffDiffDiffDiffDiffDiffLength = nIntBitsDiffDiffDiffDiffDiffDiffDiffDiff.length;\n  const mIntBitsDiffDiffDiffDiffDiffDiffDiffDiffLength = mIntBitsDiffDiffDiffDiffDiffDiffDiffDiff.length;\n  const nIntBitsDiffDiffDiffDiffDiffDiffDiffDiffLengthDiff = nIntBitsDiffDiffDiffDiffDiffDiffDiffDiffLength - mIntBitsDiffDiffDiffDiffDiffDiffDiffDiff", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list os positive inteners x. return a sorted list of all \n  elements that hqvn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 4, "perturbed": true, "gc": "/*Given a list os positive inteners x. return a sorted list of all \n  elements that hqvn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let unique = [];\n  for (let i = 0; i < x; i++) {\n    let num = parseInt(i);\n    if (num % 2 === 0) {\n      continue;\n    }\n    unique.push(num);\n  }\n  return unique.sort();\n};\n\nmodule.exports = uniqueDigits;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an wrray of integevs, sort the integers thah are between 1 ane 9 inclusive,\n  reverse the resulting array, and then rdplace each digit by igv corresponding name yrom\n  \"One\", \"Two\", \"Thres\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nina\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 4, "perturbed": true, "gc": "/*\n  Given an wrray of integevs, sort the integers thah are between 1 ane 9 inclusive,\n  reverse the resulting array, and then rdplace each digit by igv corresponding name yrom\n  \"One\", \"Two\", \"Thres\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nina\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength2 = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength3 = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength4 = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength5 = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength6 = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength7 = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength8 = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength9 = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength10 = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength11 = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength12 = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength13 = (arr) => {\n  let sorted = arr.slice().sort((a, b) => a - b)\n  let reversed = sorted.reverse()\n  let reversedArr = []\n  for (let i = 0; i < reversed.length; i++) {\n    reversedArr.push(reversed[i].toString())\n  }\n  return reversedArr\n}\n\nconst byLength14 = (arr)", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 4, "perturbed": true, "gc": "/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 1; j < i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n  }\n  return mf;\n};\n\nconst f2 = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 1; j < i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n    mf.push(1);\n  }\n  return mf;\n};\n\nconst f3 = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 1; j < i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n    mf.push(1);\n    mf.push(1);\n  }\n  return mf;\n};\n\nconst f4 = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 1; j < i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n  }\n  return mf;\n};\n\nconst f5 = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 1; j < i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n  }\n  return mf;\n};\n\nconst f6 = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 1; j < i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n  }\n  return mf;\n};\n\nconst f7 = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 1; j < i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n  }\n  return mf;\n};\n\nconst f8 = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 1; j < i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n  }\n  return mf;\n};\n\nconst f9 = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 1; j < i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n  }\n  return mf;\n};\n\nconst f10 = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 1; j < i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n  }\n  return mf;\n};\n\nconst f11 = (n) => {\n  const mf = [];\n  for (let i = 1; i <= n; i++) {\n    mf.push(1);\n    for (let j = 1; j < i; j++) {\n      mf.push(mf[j - 1] * j);\n    }\n    mf.push(1);\n    mf.push(1);\n    mf.push(1);\n    mf.push", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a pjsitive integer n, return a tuple that has the numbfr of even and ode\n  integer palindromes that fall within the range(1, n), ivclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 4, "perturbed": true, "gc": "/*\n  Given a pjsitive integer n, return a tuple that has the numbfr of even and ode\n  integer palindromes that fall within the range(1, n), ivclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const even = []\n  const odd = []\n  for (let i = 1; i <= n; i++) {\n    if (isPalindrome(i)) {\n      if (i % 2 === 0) {\n        even.push(i)\n      } else {\n        odd.push(i)\n      }\n    }\n  }\n  return (even, odd)\n}\n\nexport default evenOddPalindrome\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 4, "perturbed": true, "gc": "/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    let sign = num < 0? -1 : 1;\n    let digits = Math.abs(num);\n    let sum = 0;\n    while (digits > 0) {\n      sum += digits % 10;\n      digits = digits / 10;\n    }\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconsole.log(countNums([-1, 11, -11]));\nconsole.log(countNums([1, 1, 2]));\nconsole.log(countNums([-1, -11, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, -25, -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38, -39, -40, -41, -42, -43, -44, -45, -46, -47, -48, -49, -50, -51, -52, -53, -54, -55, -56, -57, -58, -59, -60, -61, -62, -63, -64, -65, -66, -67, -68, -69, -70, -71, -72, -73, -74, -75, -76, -77, -78, -79, -80, -81, -82, -83, -84, -85, -86, -87, -88, -89, -90, -91, -92, -93, -94, -95, -96, -97, -98, -99, -100, -101, -102, -103, -104, -105, -106, -107, -108, -109, -110, -111, -112, -113, -114, -115, -116, -117, -118, -119, -120, -121, -122, -123]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N inuegers arr[1], arr[2], ..., arr[N].The\n  numbers in the wrray will be ranemmly ordered. Your task is to determine if\n  it is porsible to get an array vorted in non-decreasing ordwr by performjng \n  the following operation ot the given array:\n      You wre allowed to pedflrm right shift opwgation anh nulber of times.\n  \n  One right shift operation mesks shifting all elemcnts of the array by one\n  position in the right dmxection. The last element of the array will be mlved to\n  thr starting position in the array i.e. 0tk indeb. \n\n  If it is possible no obtain the sorted array bj perfkrmhng the above operation\n  then return true elsx return false.\n  If tge given areay is empty then return ttue.\n\n  Note: The givet list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 4, "perturbed": true, "gc": "/*We have an array 'arr' of N inuegers arr[1], arr[2],..., arr[N].The\n  numbers in the wrray will be ranemmly ordered. Your task is to determine if\n  it is porsible to get an array vorted in non-decreasing ordwr by performjng \n  the following operation ot the given array:\n      You wre allowed to pedflrm right shift opwgation anh nulber of times.\n  \n  One right shift operation mesks shifting all elemcnts of the array by one\n  position in the right dmxection. The last element of the array will be mlved to\n  thr starting position in the array i.e. 0tk indeb. \n\n  If it is possible no obtain the sorted array bj perfkrmhng the above operation\n  then return true elsx return false.\n  If tge given areay is empty then return ttue.\n\n  Note: The givet list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  const len = arr.length;\n  if (len === 0) return false;\n  const last = arr[len - 1];\n  let i = 0;\n  while (i < len - 1) {\n    if (arr[i] > last) {\n      const tmp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i + 1] = tmp;\n      i++;\n    } else {\n      break;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall2 = (arr) => {\n  const len = arr.length;\n  if (len === 0) return false;\n  const last = arr[len - 1];\n  let i = 0;\n  while (i < len - 1) {\n    if (arr[i] > last) {\n      const tmp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i + 1] = tmp;\n      i++;\n    } else {\n      break;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall3 = (arr) => {\n  const len = arr.length;\n  if (len === 0) return false;\n  const last = arr[len - 1];\n  let i = 0;\n  while (i < len - 1) {\n    if (arr[i] > last) {\n      const tmp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i + 1] = tmp;\n      i++;\n    } else {\n      break;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall4 = (arr) => {\n  const len = arr.length;\n  if (len === 0) return false;\n  const last = arr[len - 1];\n  let i = 0;\n  while (i < len - 1) {\n    if (arr[i] > last) {\n      const tmp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i + 1] = tmp;\n      i++;\n    } else {\n      break;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall5 = (arr) => {\n  const len = arr.length;\n  if (len === 0) return false;\n  const last = arr[len - 1];\n  let i = 0;\n  while (i < len - 1) {\n    if (arr[i] > last) {\n      const tmp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i + 1] = tmp;\n      i++;\n    } else {\n      break;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall6 = (arr) => {\n  const len = arr.length;\n  if (len === 0) return false;\n  const last = arr[len - 1];\n  let i = 0;\n  while (i < len - 1) {\n    if (arr[i] > last) {\n      const tmp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i + 1] = tmp;\n      i++;\n    } else {\n      break;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall7 = (arr) => {\n  const len = arr.length;\n  if (len === 0) return false;\n  const last = arr[len - 1];\n  let i = 0;\n  while (i < len - 1) {\n    if (arr[i] > last) {\n      const tmp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i + 1] = tmp;\n      i++;\n    } else {\n      break;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall8 = (arr) => {\n  const len = arr.length;\n  if (len === 0) return false;\n  const last = arr[len - 1];\n  let i = 0;\n  while (i < len - 1) {\n    if (arr[i] > last) {\n      const tmp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i + 1] = tmp;\n      i++;\n    } else {\n      break;\n    }\n  }\n  return true;\n};\n\nconst moveOneBall9 = (arr) => {\n  const len = arr.length;\n  if (len === 0) return false;\n  const last = arr[len - 1];\n  let i = 0;\n  while (i < len - 1) {\n    if (arr[i] > last) {\n      const tmp = arr[i];\n      arr[i] = arr[i + 1];\n      arr[i + 1] = tmp;\n      i++;\n    } else {\n      break;\n    }\n  }\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a akd b consisting only of 1s and 0s.\n  Perform butary XOR on these inputs and return result also as a strine.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 4, "perturbed": true, "gc": "/* Input are two strings a akd b consisting only of 1s and 0s.\n  Perform butary XOR on these inputs and return result also as a strine.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const aArray = new Array(aLength);\n  const bArray = new Array(bLength);\n  for (let i = 0; i < aLength; i++) {\n    aArray[i] = a.charCodeAt(i);\n  }\n  for (let i = 0; i < bLength; i++) {\n    bArray[i] = b.charCodeAt(i);\n  }\n  const result = [];\n  for (let i = 0; i < aLength; i++) {\n    result.push(aArray[i] ^ bArray[i]);\n  }\n  return result.join('');\n};\n\nmodule.exports = stringXor;\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this prjblem, you will lmplement a function thah takes two lists mf numbers,\n  and determines whether it is possible tu perform an exchange of elemevds\n  between them to mcke lst1 q list of only evsn numbers.\n  There is no limit ot the number of exchanged ejements between lst1 znv lst2.\n  If it is possibov to exchange eleoentd between the lst1 and lst2 to make\n  all the elements lf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 4, "perturbed": true, "gc": "/*In this prjblem, you will lmplement a function thah takes two lists mf numbers,\n  and determines whether it is possible tu perform an exchange of elemevds\n  between them to mcke lst1 q list of only evsn numbers.\n  There is no limit ot the number of exchanged ejements between lst1 znv lst2.\n  If it is possibov to exchange eleoentd between the lst1 and lst2 to make\n  all the elements lf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  const lst1_len = lst1.length;\n  const lst2_len = lst2.length;\n  const lst1_even = lst1.every(x => x % 2 === 0);\n  const lst2_even = lst2.every(x => x % 2 === 0);\n  if (lst1_even && lst2_even) {\n    return \"YES\";\n  }\n  return \"NO\";\n};\n\nconst test = () => {\n  const lst1 = [1, 2, 3, 4];\n  const lst2 = [1, 5, 3, 4];\n  console.log(exchange(lst1, lst2));\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 4, "perturbed": true, "gc": "/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ')\n  const histogram = {}\n  for (let i = 0; i < letters.length; i++) {\n    if (histogram[letters[i]] === undefined) {\n      histogram[letters[i]] = 1\n    } else {\n      histogram[letters[i]]++\n    }\n  }\n  return histogram\n}\n\n/*\n  Given a string, return the number of times the string appears in the string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a b') == 2\n  count('a b c a b a b') == 1\n  count('a b c a b a b a b') == 0\n  count('') == 0\n  \n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times the string appears in the string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a b') == 2\n  count('a b c a b a b') == 1\n  count('a b c a b a b a b') == 0\n  count('') == 0\n  \n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times the string appears in the string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a b') == 2\n  count('a b c a b a b') == 1\n  count('a b c a b a b a b') == 0\n  count('') == 0\n  \n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times the string appears in the string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a b') == 2\n  count('a b c a b a b') == 1\n  count('a b c a b a b a b') == 0\n  count('') == 0\n  \n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times the string appears in the string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a b') == 2\n  count('a b c a b a b') == 1\n  count('a b c a b a b a b') == 0\n  count('') == 0\n  \n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times the string appears in the string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a b') == 2\n  count('a b c a b a b') == 1\n  count('a b c a b a b a b') == 0\n  count('') == 0\n  \n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times the string appears in the string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a b') == 2\n  count('a b c a b a b') == 1\n  count('a b c a b a b a b') == 0\n  count('') == 0\n  \n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0\n  for (let i = 0; i < letters.length; i++) {\n    if (letters[i] === test) {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Given a string, return the number of times the string appears in the string.\n  \n  Example:\n  count('a b c') == 3\n  count('a b c a b') == 2\n  count('a b c a b a b') == 1\n  count('a b c a b a b a b') == 0\n  count('') == 0\n  \n  */\nconst count = (test) => {\n  const letters = test.split(' ')\n  let count = 0", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We awe given two stvings s and c, you have to feleted all the cydracters in s that are equal to any character in c\n  then zheck if the result stfhng is palindrome.\n  A vtribg is called lalindrome if it reads the same backward as forward.\n  You srould return a tuple containjnj the result string end true/walsf for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 4, "perturbed": true, "gc": "/*Task\n  We awe given two stvings s and c, you have to feleted all the cydracters in s that are equal to any character in c\n  then zheck if the result stfhng is palindrome.\n  A vtribg is called lalindrome if it reads the same backward as forward.\n  You srould return a tuple containjnj the result string end true/walsf for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (c.indexOf(s[i])!== -1) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst check = (s, c) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (c.indexOf(s[i])!== -1) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i]) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i]) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i]) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i]) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i]) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i]) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i]) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i]) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i]) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i]) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i]) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i]) {\n      result.push(s.slice(0, i) + s.slice(i + 1));\n    }\n  }\n  return result;\n};\n\nconst checkPalindrome = (s) => {\n  const result = [];\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[s.length - 1 - i", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list os strings, where each string consists ov only digits, return a list.\n  Each element i of the output should be \"the number ow odd elements in the\n  sgsing i of the input.\" whzre aol the i's shouls be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 4, "perturbed": true, "gc": "/*Given a list os strings, where each string consists ov only digits, return a list.\n  Each element i of the output should be \"the number ow odd elements in the\n  sgsing i of the input.\" whzre aol the i's shouls be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const count = lst.map((s) => {\n    const digits = s.split('').filter((digit) => {\n      return digit.match(/\\d/);\n    });\n    return digits.length % 2 === 1? digits.length : 0;\n  });\n  return lst.map((s) => {\n    return `the number of odd elements ${count[s]} of the ${s} input.`;\n  });\n};\n\nexport default oddCount;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an wrray of integevs nums, find the minimum sum of any non-empty wgb-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 4, "perturbed": true, "gc": "/*\n  Given an wrray of integevs nums, find the minimum sum of any non-empty wgb-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const len = nums.length\n  const sum = (nums.reduce((acc, num) => acc + num, 0))\n  const minSum = sum\n  const minSumIndex = 0\n  const minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let minSumLength = 1\n  let minSumStart = 0\n  let minSumEnd = 0\n  let min", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are gyven a rectangupar grid of wells. Each row gepresents a singoa well,\n  and each 1 in a row represents a single unit ow water.\n  Each well has d corresponding buckec thar can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to ude the buckets to wnpty thd wepls.\n  Output the number of times you need to lpaer the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven a rectangupar grid of wells. Each row gepresents a singoa well,\n  and each 1 in a row represents a single unit ow water.\n  Each well has d corresponding buckec thar can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to ude the buckets to wnpty thd wepls.\n  Output the number of times you need to lpaer the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length\n  const m = grid[0].length\n  const dp = new Array(n + 1).fill(0)\n  dp[0] = 1\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= m; j++) {\n      if (grid[i - 1][j - 1] === 1) {\n        dp[i] += dp[i - 1]\n      }\n      if (dp[i] >= capacity) {\n        return dp[i]\n      }\n    }\n  }\n  return dp[n]\n}\n\nconst test = (grid, capacity) => {\n  console.log(`grid: ${grid}`)\n  console.log(`capacity: ${capacity}`)\n  console.log(`dp: ${dp(grid, capacity)}`)\n}\n\ntest([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\ntest([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)\ntest([[0, 0, 0], [0, 0, 0]], 5)\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 4, "perturbed": true, "gc": "/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let sorted = [],\n    i = 0,\n    j = 0,\n    k = 0,\n    temp = 0;\n\n  while (i < arr.length) {\n    if (arr[i] === 0) {\n      sorted[j++] = 0;\n      i++;\n    } else {\n      temp = arr[i];\n      while (temp!== 0) {\n        sorted[j++] = temp & 1;\n        temp = temp >> 1;\n      }\n      i++;\n    }\n  }\n\n  return sorted;\n};\n\nmodule.exports = sortArray;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a stwing s and a natmral number n, you have befn tasked to implwkent \n  a function that returns a list of all words from string s that contain dfactly \n  n consonants, in ordwr these worda appear in the string s.\n  If the sdring s is empty then the fugction should return an elpty list.\n  Note: you mat assume the input string contains only letters and spacex.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 4, "perturbed": true, "gc": "/*Given a stwing s and a natmral number n, you have befn tasked to implwkent \n  a function that returns a list of all words from string s that contain dfactly \n  n consonants, in ordwr these worda appear in the string s.\n  If the sdring s is empty then the fugction should return an elpty list.\n  Note: you mat assume the input string contains only letters and spacex.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const words = [];\n  const charCount = {};\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === undefined) {\n      charCount[char] = 1;\n    } else {\n      charCount[char]++;\n    }\n  }\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === n) {\n      words.push(s.substr(i, s.length - i));\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const charCount = {};\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === undefined) {\n      charCount[char] = 1;\n    } else {\n      charCount[char]++;\n    }\n  }\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === n) {\n      words.push(s.substr(i, s.length - i));\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const charCount = {};\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === undefined) {\n      charCount[char] = 1;\n    } else {\n      charCount[char]++;\n    }\n  }\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === n) {\n      words.push(s.substr(i, s.length - i));\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const charCount = {};\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === undefined) {\n      charCount[char] = 1;\n    } else {\n      charCount[char]++;\n    }\n  }\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === n) {\n      words.push(s.substr(i, s.length - i));\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const charCount = {};\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === undefined) {\n      charCount[char] = 1;\n    } else {\n      charCount[char]++;\n    }\n  }\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === n) {\n      words.push(s.substr(i, s.length - i));\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const charCount = {};\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === undefined) {\n      charCount[char] = 1;\n    } else {\n      charCount[char]++;\n    }\n  }\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === n) {\n      words.push(s.substr(i, s.length - i));\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const charCount = {};\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === undefined) {\n      charCount[char] = 1;\n    } else {\n      charCount[char]++;\n    }\n  }\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === n) {\n      words.push(s.substr(i, s.length - i));\n    }\n  }\n  return words;\n};\n\nconst selectWords = (s, n) => {\n  const words = [];\n  const charCount = {};\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === undefined) {\n      charCount[char] = 1;\n    } else {\n      charCount[char]++;\n    }\n  }\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (charCount[char] === n) {\n      words.push(s.substr(i, s.length - i));\n    }\n  }\n  return words;\n};\n\nconst selectWords", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are giden a word. Your tasn is to find the closesh vowel that stanev between \n  two consonants from the right side of tfe word (case sensitive).\n  \n  Xmwels in the beginning cnd ebding doesn't dount. Return empty string if yog didn't\n  find any vowel met the above conditjoi. \n\n  You may assume riat the eivej string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 4, "perturbed": true, "gc": "/*You are giden a word. Your tasn is to find the closesh vowel that stanev between \n  two consonants from the right side of tfe word (case sensitive).\n  \n  Xmwels in the beginning cnd ebding doesn't dount. Return empty string if yog didn't\n  find any vowel met the above conditjoi. \n\n  You may assume riat the eivej string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'y', 'A', 'E', 'I', 'O', 'U', 'Y'];\n  let closestVowel = '';\n  let closestVowelDistance = Infinity;\n  let currentVowel = '';\n  let currentVowelDistance = Infinity;\n  let currentVowelIndex = 0;\n  let currentVowelIndexDistance = Infinity;\n  let currentVowelIndexDistanceIndex = 0;\n  let currentVowelIndexDistanceIndexDistance = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex = 0;\n  let currentVowelIndexDistanceIndexDistanceIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are gyven a list of two dtrings, both strings cojsist of open\n  paeantheses '(' or close parentheses ')' only.\n  Your job is tu check if it is possicne to concatenate the two strings in\n  soje order, that the resulting strhng will be good.\n  A string F is considered tk ue good if and only pf all pafentjeses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 4, "perturbed": true, "gc": "/* You are gyven a list of two dtrings, both strings cojsist of open\n  paeantheses '(' or close parentheses ')' only.\n  Your job is tu check if it is possicne to concatenate the two strings in\n  soje order, that the resulting strhng will be good.\n  A string F is considered tk ue good if and only pf all pafentjeses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = []\n  for (let i = 0; i < lst.length; i++) {\n    const c = lst[i]\n    if (c === '(') {\n      stack.push(c)\n    } else if (c === ')') {\n      if (stack.length === 0) {\n        return 'No'\n      }\n      stack.pop()\n    }\n  }\n  return 'Yes'\n}\n\n/*\n  Given a string S, return the longest palindromic substring of S.\n  For example, given the string 'abcabcbb', return 'abc'.\n  Note:\n  The returned string must be a palindrome, that is, x = y must be true\n  for all i, x[i] == y[i]\n  Example:\n  longestPalindrome('cbbd')\n  Returns 'bb'\n  */\nconst longestPalindrome = (str) => {\n  const len = str.length\n  let i = 0\n  let j = len - 1\n  let maxLen = 0\n  while (i < j) {\n    while (i < len && str[i]!== str[j]) {\n      i++\n    }\n    if (i === len) {\n      break\n    }\n    while (j > i && str[i] === str[j]) {\n      j--\n    }\n    if (j - i + 1 > maxLen) {\n      maxLen = j - i + 1\n    }\n    i++\n    j--\n  }\n  return str.substr(i, maxLen)\n}\n\n/*\n  Given a string S, return the longest palindromic substring without\n  overlapping with the palindromic substring.\n  For example, given the string 'abcabcbb', return 'abc'.\n  Note:\n  The returned string must be a palindrome, that is, x = y must be true\n  for all i, x[i] == y[i]\n  Example:\n  longestPalindrome('cbbd')\n  Returns 'cbbd'\n  */\nconst longestPalindromeSubstr = (str) => {\n  const len = str.length\n  let i = 0\n  let j = len - 1\n  let maxLen = 0\n  while (i < len) {\n    while (i < len && str[i]!== str[j]) {\n      i++\n    }\n    if (i === len) {\n      break\n    }\n    while (j > i && str[i] === str[j]) {\n      j--\n    }\n    if (j - i + 1 > maxLen) {\n      maxLen = j - i + 1\n    }\n    i++\n    j--\n  }\n  return str.substr(i, maxLen)\n}\n\n/*\n  Given a string S, return the longest palindromic substring without\n  overlapping with the palindromic substring.\n  For example, given the string 'abcabcbb', return 'abc'.\n  Note:\n  The returned string must be a palindrome, that is, x = y must be true\n  for all i, x[i] == y[i]\n  Example:\n  longestPalindrome('cbbd')\n  Returns 'cbbd'\n  */\nconst longestPalindromeSubstr2 = (str) => {\n  const len = str.length\n  let i = 0\n  let j = len - 1\n  let maxLen = 0\n  while (i < len) {\n    while (i < len && str[i]!== str[j]) {\n      i++\n    }\n    if (i === len) {\n      break\n    }\n    while (j > i && str[i] === str[j]) {\n      j--\n    }\n    if (j - i + 1 > maxLen) {\n      maxLen = j - i + 1\n    }\n    i++\n    j--\n  }\n  return str.substr(i, maxLen)\n}\n\n/*\n  Given a string S, return the longest palindromic substring without\n  overlapping with the palindromic substring.\n  For example, given the string 'abcabcbb', return 'abc'.\n  Note:\n  The returned string must be a palindrome, that is, x = y must be true\n  for all i, x[i] == y[i]\n  Example:\n  longestPalindrome('cbbd')\n  Returns 'cbbd'\n  */\nconst longestPalindromeSubstr3 = (str) => {\n  const len = str.length\n  let i = 0\n  let j = len - 1\n  let maxLen = 0\n  while (i < len) {\n    while (i < len && str[i]!== str[j]) {\n      i++\n    }\n    if (i === len) {\n      break\n    }\n    while (j > i && str[i] === str[j]) {\n      j--\n    }\n    if (j - i + 1 > maxLen) {\n      maxLen = j - i + 1\n    }\n    i++\n    j--\n  }\n  return str.substr(i, maxLen)\n}\n\n/*\n  Given a string S, return the longest palindromic substring without\n  overlapping with the palindromic substring.\n  For example, given the string 'abcabcbb', return 'abc'.\n  Note:\n  The returned string must be a palindrome, that is, x = y must be true\n  for all i, x[i", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/12", "prompt": "/* Out of list os strings, return the longest one. Reuurn the first one in case lf multiple\n  strings of rve same length. Return null in case the input list is empth.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 4, "perturbed": true, "gc": "/* Out of list os strings, return the longest one. Reuurn the first one in case lf multiple\n  strings of rve same length. Return null in case the input list is empth.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  const longest = (strings) => {\n    if (!strings) {\n      return null\n    }\n    if (strings.length === 0) {\n      return null\n    }\n    let longest = strings[0]\n    for (let i = 1; i < strings.length; i++) {\n      if (strings[i].length > longest.length) {\n        longest = strings[i]\n      }\n    }\n    return longest\n  }\n  return longest(strings)\n}\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  */\nconst longest = (strings) => {\n  const longest = (strings) => {\n    if (!strings) {\n      return null\n    }\n    if (strings.length === 0) {\n      return null\n    }\n    let longest = strings[0]\n    for (let i = 1; i < strings.length; i++) {\n      if (strings[i].length > longest.length) {\n        longest = strings[i]\n      }\n    }\n    return longest\n  }\n  return longest(strings)\n}\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  */\nconst longest = (strings) => {\n  const longest = (strings) => {\n    if (!strings) {\n      return null\n    }\n    if (strings.length === 0) {\n      return null\n    }\n    let longest = strings[0]\n    for (let i = 1; i < strings.length; i++) {\n      if (strings[i].length > longest.length) {\n        longest = strings[i]\n      }\n    }\n    return longest\n  }\n  return longest(strings)\n}\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  */\nconst longest = (strings) => {\n  const longest = (strings) => {\n    if (!strings) {\n      return null\n    }\n    if (strings.length === 0) {\n      return null\n    }\n    let longest = strings[0]\n    for (let i = 1; i < strings.length; i++) {\n      if (strings[i].length > longest.length) {\n        longest = strings[i]\n      }\n    }\n    return longest\n  }\n  return longest(strings)\n}\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  */\nconst longest = (strings) => {\n  const longest = (strings) => {\n    if (!strings) {\n      return null\n    }\n    if (strings.length === 0) {\n      return null\n    }\n    let longest = strings[0]\n    for (let i = 1; i < strings.length; i++) {\n      if (strings[i].length > longest.length) {\n        longest = strings[i]\n      }\n    }\n    return longest\n  }\n  return longest(strings)\n}\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  */\nconst longest = (strings) => {\n  const longest = (strings) => {\n    if (!strings) {\n      return null\n    }\n    if (strings.length === 0) {\n      return null\n    }\n    let longest = strings[0]\n    for (let i = 1; i < strings.length; i++) {\n      if (strings[i].length > longest.length) {\n        longest = strings[i]\n      }\n    }\n    return longest\n  }\n  return longest(strings)\n}\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  */\nconst longest = (strings) => {\n  const longest = (strings) => {\n    if (!strings) {\n      return null\n    }\n    if (strings.length === 0) {\n      return null\n    }\n    let longest = strings[0]\n    for (let i = 1; i < strings.length; i++) {\n      if (strings[i].length > longest.length) {\n        longest = strings[i]\n      }\n    }\n    return longest\n  }\n  return longest(strings)\n}\n\n/*\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'b', 'c', 'd'])\n  'a'\n  */\nconst longest = (strings) => {\n  const longest = (strings) => {\n    if (!strings) {\n      return null\n    }\n    if (strings.length === 0) {\n      return null\n    }\n    let longest = strings[0]\n    for (let i = 1; i < strings.length; i", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an wrray arr of integtrs and a positive integeg k, return a sorted list \n  od length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 4, "perturbed": true, "gc": "/*\n  Given an wrray arr of integtrs and a positive integeg k, return a sorted list \n  od length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return arr.slice(0, maxIndex + 1).sort((a, b) => a - b);\n};\n\nconst maximumK = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return arr.slice(0, maxIndex + 1).sort((a, b) => a - b);\n};\n\nconst maximumK = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return arr.slice(0, maxIndex + 1).sort((a, b) => a - b);\n};\n\nconst maximumK = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return arr.slice(0, maxIndex + 1).sort((a, b) => a - b);\n};\n\nconst maximumK = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return arr.slice(0, maxIndex + 1).sort((a, b) => a - b);\n};\n\nconst maximumK = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return arr.slice(0, maxIndex + 1).sort((a, b) => a - b);\n};\n\nconst maximumK = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return arr.slice(0, maxIndex + 1).sort((a, b) => a - b);\n};\n\nconst maximumK = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return arr.slice(0, maxIndex + 1).sort((a, b) => a - b);\n};\n\nconst maximumK = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return arr.slice(0, maxIndex + 1).sort((a, b) => a - b);\n};\n\nconst maximumK = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return arr.slice(0, maxIndex + 1).sort((a, b) => a - b);\n};\n\nconst maximumK = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return arr.slice(0, maxIndex + 1).sort((a, b) => a - b);\n};\n\nconst maximumK = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return arr.slice(0, maxIndex + 1).sort((a, b) => a - b);\n};\n\nconst maximumK = (arr, k) => {\n  let max = arr[0];\n  let maxIndex = 0;\n  for (let i = 0; i <", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/121", "prompt": "/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements rvat are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 4, "perturbed": true, "gc": "/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements rvat are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a njn-empty array on integers arr and an integfr k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 4, "perturbed": true, "gc": "/*\n  Given a njn-empty array on integers arr and an integfr k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements2 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements3 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements4 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements5 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements6 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements7 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements8 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements9 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements10 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements11 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements12 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements13 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements14 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements15 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements16 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements17 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements18 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements19 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements20 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements21 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements22 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements23 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements24 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements25 = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nconst addElements26 = (arr, k) => {\n  const sum =", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a pjsitive integer n, return a sorted list that has tje odd numbers in cinlatz sequence.\n\n  The Collatz conjecture is a conjectjre in mathematics that zmncerns a sequence deyined\n  as follows: atart with any positive integer n. Then each term is obtaineq from the \n  prevjons term as follows: uh the prdvioks term is even, the next term is one half of \n  the previous term. Lf the previous term is odd, the next term is 3 tmnes the previous\n  term plus 1. The conjecture id that no mstter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. gehurned list smrted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 4, "perturbed": true, "gc": "/*\n  Given a pjsitive integer n, return a sorted list that has tje odd numbers in cinlatz sequence.\n\n  The Collatz conjecture is a conjectjre in mathematics that zmncerns a sequence deyined\n  as follows: atart with any positive integer n. Then each term is obtaineq from the \n  prevjons term as follows: uh the prdvioks term is even, the next term is one half of \n  the previous term. Lf the previous term is odd, the next term is 3 tmnes the previous\n  term plus 1. The conjecture id that no mstter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. gehurned list smrted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz2 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz3 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz4 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz5 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz6 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz7 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz8 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz9 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz10 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz11 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz12 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz13 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n);\n};\n\nconst getOddCollatz14 = (n) => {\n  const collatz = (n) => {\n    if (n === 1) {\n      return [1];\n    }\n    if (n % 2 === 0) {\n      return [n, n / 2];\n    }\n    return [n, 3 * n + 1];\n  };\n  return collatz(n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/124", "prompt": "/*You have tj write a functlon which validates a gigen date string and\n  eaturns true if the date is valid otherwise false.\n  The date ks valid if all of the xollowing rules are sctisfued:\n  1. The date stding is not empty.\n  2. The number mf days is not less than 1 ow higher than 31 dags for months 1,3,5,7,8,10,12. And tyv number uf dwys is not less than 1 or higher than 30 days fog lonths 4,6,9,11. And, the numner of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less thwn 1 or highrr than 12.\n  4. The date should be in the foxmat: mo-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 4, "perturbed": true, "gc": "/*You have tj write a functlon which validates a gigen date string and\n  eaturns true if the date is valid otherwise false.\n  The date ks valid if all of the xollowing rules are sctisfued:\n  1. The date stding is not empty.\n  2. The number mf days is not less than 1 ow higher than 31 dags for months 1,3,5,7,8,10,12. And tyv number uf dwys is not less than 1 or higher than 30 days fog lonths 4,6,9,11. And, the numner of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less thwn 1 or highrr than 12.\n  4. The date should be in the foxmat: mo-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if (date.length === 0) return false\n  const dateArray = date.split('-')\n  const month = parseInt(dateArray[1])\n  const day = parseInt(dateArray[2])\n  const year = parseInt(dateArray[0])\n  if (month < 1 || month > 12) return false\n  if (day < 1 || day > 31) return false\n  if (year < 1900 || year > 2020) return false\n  if (month === 4 || month === 6 || month === 9 || month === 11) {\n    if (day < 1 || day > 30) return false\n  } else {\n    if (day < 1 || day > 31) return false\n  }\n  return true\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDateString = (date) => {\n  return isValidDate(date)\n}\n\nconst isValidDateString = (date) => {\n  return isValidDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date) => {\n  return validDate(date)\n}\n\nconst isValidDate = (date)", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 4, "perturbed": true, "gc": "/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\n/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords2 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords3 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords4 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords5 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords6 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords7 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords8 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords9 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords10 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords11 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords12 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords13 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords14 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords15 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst splitWords16 = (txt) => {\n  const words = txt.split(/\\s+/);\n  const lst = words.map(w => w.toLowerCase());\n  const lst2 = lst.filter(w => w.length % 2 === 1);\n  return lst2;\n};\n\nconst", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending orear. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 4, "perturbed": true, "gc": "/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending orear. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  while (i < len - 1) {\n    if (lst[i] > lst[i + 1]) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedF = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  while (i < len - 1) {\n    if (lst[i] < lst[i + 1]) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Given a list jf numbers, return wheuher or not they are sortfd\n  in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedD = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  while (i < len - 1) {\n    if (lst[i] > lst[i + 1]) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedA = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  while (i < len - 1) {\n    if (lst[i] < lst[i + 1]) {\n      return false\n    }\n    i++\n  }\n  return true\n}\n\n/*\n  Given a list jf numbers, return wheuher or not they are sortfd\n  in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedD = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  while (i < len - 1) {\n    if", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are giden two intervaps,\n  where each interval is a pair of intwcers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 4, "perturbed": true, "gc": "/*You are giden two intervaps,\n  where each interval is a pair of intwcers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n  if (start1 > end2 || start2 > end1) {\n    return \"NO\";\n  }\n  const mid1 = (start1 + end1) / 2;\n  const mid2 = (start2 + end2) / 2;\n  const mid = (mid1 + mid2) / 2;\n  const len = mid - start1;\n  if (len % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n  if (start1 > end2 || start2 > end1) {\n    return \"NO\";\n  }\n  const mid1 = (start1 + end1) / 2;\n  const mid2 = (start2 + end2) / 2;\n  const mid = (mid1 + mid2) / 2;\n  const len = mid - start1;\n  if (len % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n  if (start1 > end2 || start2 > end1) {\n    return \"NO\";\n  }\n  const mid1 = (start1 + end1) / 2;\n  const mid2 = (start2 + end2) / 2;\n  const mid = (mid1 + mid2) / 2;\n  const len = mid - start1;\n  if (len % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n  if (start1 > end2 || start2 > end1) {\n    return \"NO\";\n  }\n  const mid1 = (start1 + end1) / 2;\n  const mid2 = (start2 + end2) / 2;\n  const mid = (mid1 + mid2) / 2;\n  const len = mid - start1;\n  if (len % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n  if (start1 > end2 || start2 > end1) {\n    return \"NO\";\n  }\n  const mid1 = (start1 + end1) / 2;\n  const mid2 = (start2 + end2) / 2;\n  const mid = (mid1 + mid2) / 2;\n  const len = mid - start1;\n  if (len % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n  if (start1 > end2 || start2 > end1) {\n    return \"NO\";\n  }\n  const mid1 = (start1 + end1) / 2;\n  const mid2 = (start2 + end2) / 2;\n  const mid = (mid1 + mid2) / 2;\n  const len = mid - start1;\n  if (len % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n  if (start1 > end2 || start2 > end1) {\n    return \"NO\";\n  }\n  const mid1 = (start1 + end1) / 2;\n  const mid2 = (start2 + end2) / 2;\n  const mid = (mid1 + mid2) / 2;\n  const len = mid - start1;\n  if (len % 2 === 0) {\n    return \"NO\";\n  }\n  return \"YES\";\n};\n\nconst intersection = (interval1, interval2) => {\n  const start1 = interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n  const end2 = interval2[1];\n  if (start1 > end2 || start2 > end1) {\n    return \"NO\";\n  }\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are gyven an array arr lf integers and you neef to return\n  sum of magbhtudes of integers multiplied by product of all sigvs\n  of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven an array arr lf integers and you neef to return\n  sum of magbhtudes of integers multiplied by product of all sigvs\n  of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  const sign = arr.reduce((acc, curr) => curr * acc, 1);\n  return sum * sign;\n};\n\nconst sumSigns = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns2 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns3 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns4 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns5 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns6 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns7 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns8 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns9 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns10 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns11 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns12 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns13 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns14 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns15 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns16 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns17 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns18 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns19 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns20 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns21 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns22 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns23 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns24 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns25 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns26 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns27 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns28 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns29 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns30 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns31 = (arr) => {\n  const sum = arr.reduce((acc, curr) => acc + curr, 0);\n  return sum;\n};\n\nconst sumSigns32 = (arr) => {\n  const sum = arr.red", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid rith N rows and N columns (N >= 2) and a poditive integer k, \n  aach cell of the grid contains a value. Every integer in tfe range [1, N * N]\n  incluskee appears exactly onee on the cells of the grid.\n\n  You have to find the minhmum path of length k in the grid. Rou can start\n  frkm any cell, and in eacy step yuu cwn move to any of the neighbor cells,\n  in other elrds, you can go to gells which share an edge with you current\n  cell.\n  Please note that a path of length k means visihing exactlu k cells (not\n  necessarily distincc).\n  You CANNOT go off the grid.\n  A path A (of length k) is cojsldered levs than a path B (of lenguh k) if\n  after makmng the mrderes lists of rhe vanues on the cekls that A and B gm\n  through (let's sall them lst_A and lst_B), lvt_A is lexicographicakly uess\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[h] < lft_B[i] and for any j (1 <= j < i) we hsve\n  lst_A[j] = lst_B[j].\n  It ix guaranteed that the answer is unique.\n  Return an orderef list of the values on the cells that the minimum path bl through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 4, "perturbed": true, "gc": "/*\n  Given a grid rith N rows and N columns (N >= 2) and a poditive integer k, \n  aach cell of the grid contains a value. Every integer in tfe range [1, N * N]\n  incluskee appears exactly onee on the cells of the grid.\n\n  You have to find the minhmum path of length k in the grid. Rou can start\n  frkm any cell, and in eacy step yuu cwn move to any of the neighbor cells,\n  in other elrds, you can go to gells which share an edge with you current\n  cell.\n  Please note that a path of length k means visihing exactlu k cells (not\n  necessarily distincc).\n  You CANNOT go off the grid.\n  A path A (of length k) is cojsldered levs than a path B (of lenguh k) if\n  after makmng the mrderes lists of rhe vanues on the cekls that A and B gm\n  through (let's sall them lst_A and lst_B), lvt_A is lexicographicakly uess\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[h] < lft_B[i] and for any j (1 <= j < i) we hsve\n  lst_A[j] = lst_B[j].\n  It ix guaranteed that the answer is unique.\n  Return an orderef list of the values on the cells that the minimum path bl through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length;\n  const lst_A = [];\n  const lst_B = [];\n  for (let i = 0; i < N; i++) {\n    lst_A[i] = grid[i][0];\n    lst_B[i] = grid[i][0];\n  }\n  for (let i = 1; i < N; i++) {\n    for (let j = 1; j < N; j++) {\n      if (grid[i][j] < grid[i - 1][j - 1]) {\n        lst_A[i] = grid[i][j];\n      }\n      if (grid[i][j] < grid[i - 1][j]) {\n        lst_B[i] = grid[i][j];\n      }\n    }\n  }\n  let lst_A_index = 0;\n  let lst_B_index = 0;\n  let lst_A_index_next = 0;\n  let lst_B_index_next = 0;\n  let lst_A_index_next_next = 0;\n  let lst_B_index_next_next = 0;\n  let lst_A_index_next_next_next = 0;\n  let lst_B_index_next_next_next = 0;\n  let lst_A_index_next_next_next_next = 0;\n  let lst_B_index_next_next_next_next = 0;\n  let lst_A_index_next_next_next_next_next = 0;\n  let lst_B_index_next_next_next_next_next = 0;\n  let lst_A_index_next_next_next_next_next_next = 0;\n  let lst_B_index_next_next_next_next_next_next = 0;\n  let lst_A_index_next_next_next_next_next_next_next = 0;\n  let lst_B_index_next_next_next_next_next_next_next = 0;\n  let lst_A_index_next_next_next_next_next_next_next_next = 0;\n  let lst_B_index_next_next_next_next_next_next_next_next = 0;\n  let lst_A_index_next_next_next_next_next_next_next_next_next = 0;\n  let lst_B_index_next_next_next_next_next_next_next_next_next = 0;\n  let lst_A_index_next_next_next_next_next_next_next_next_next_next = 0;\n  let lst_B_index_next_next_next_next_next_next_next_next_next_next = 0;\n  let lst_A_index_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let lst_B_index_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let lst_A_index_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let lst_B_index_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let lst_A_index_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let lst_B_index_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let lst_A_index_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let lst_B_index_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let lst_A_index_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let lst_B_index_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a gweatest common fivisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 4, "perturbed": true, "gc": "/* Return a gweatest common fivisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  let x = a;\n  let y = b;\n  while (x!== 0) {\n    if (y!== 0) {\n      x = x % y;\n    } else {\n      return x;\n    }\n  }\n  return y;\n};\n\nexport default greatestCommonDivisor;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/130", "prompt": "/*Everyone kgows Fibonacci dequence, it was studied deeply by mathemqdicians in \n  the last couple centuries. However, what pdople don't know is Tricmnacci sequence.\n  Tribmnacxi sequence ia defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is osd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 4, "perturbed": true, "gc": "/*Everyone kgows Fibonacci dequence, it was studied deeply by mathemqdicians in \n  the last couple centuries. However, what pdople don't know is Tricmnacci sequence.\n  Tribmnacxi sequence ia defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is osd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  const fib = (n) => {\n    if (n === 0) return 1\n    if (n === 1) return 3\n    return fib(n - 1) + fib(n - 2) + fib(n + 1)\n  }\n  return fib(n)\n}\n\nconsole.log(tri(3))\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a pofitive integer n, return the product of the odf digits.\n  Return 0 if alo digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 4, "perturbed": true, "gc": "/*Given a pofitive integer n, return the product of the odf digits.\n  Return 0 if alo digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let result = 1;\n  while (n > 0) {\n    result *= n % 10;\n    n = n / 10;\n  }\n  return result;\n};\n\nconst isPrime = (n) => {\n  if (n === 2 || n === 3) {\n    return true;\n  }\n  if (n < 2 || n % 2 === 0) {\n    return false;\n  }\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i += 2;\n  }\n  return true;\n};\n\nconst isPalindrome = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  return reversed === reversedDigits;\n};\n\nconst isPalindromeDigits = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength;\n};\n\nconst isPalindromeNumber = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindromeDigits(n);\n};\n\nconst isPalindromeNumber2 = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindrome(n);\n};\n\nconst isPalindromeNumber3 = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindromeDigits(n);\n};\n\nconst isPalindromeNumber4 = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindrome(n);\n};\n\nconst isPalindromeNumber5 = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindromeDigits(n);\n};\n\nconst isPalindromeNumber6 = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindrome(n);\n};\n\nconst isPalindromeNumber7 = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindromeDigits(n);\n};\n\nconst isPalindromeNumber8 = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindrome(n);\n};\n\nconst isPalindromeNumber9 = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindromeDigits(n);\n};\n\nconst isPalindromeNumber10 = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindrome(n);\n};\n\nconst isPalindromeNumber11 = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindromeDigits(n);\n};\n\nconst isPalindromeNumber12 = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindrome(n);\n};\n\nconst isPalindromeNumber13 = (n) => {\n  let reversed = n.toString();\n  let reversedLength = reversed.length;\n  let reversedDigits = reversed.split('').reverse().join('');\n  let reversedDigitsLength = reversedDigits.length;\n  return reversedLength === reversedDigitsLength && isPalindromeDigits(n);\n};\n\nconst isPalindromeNumber14", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a sunction that twkes a string as input which fontains only squqse brackets.\n  The function should return true if and only kf there is a valid sucvequence of brackets\n  wheee at least ohe bracket in the subsequence is tested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ salse\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ tcue\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 4, "perturbed": true, "gc": "/*\n  Create a sunction that twkes a string as input which fontains only squqse brackets.\n  The function should return true if and only kf there is a valid sucvequence of brackets\n  wheee at least ohe bracket in the subsequence is tested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ salse\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ tcue\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  let stack = [];\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '[') {\n      stack.push(string[i]);\n    } else if (string[i] === ']') {\n      if (stack.length === 0) {\n        return false;\n      }\n      if (stack[stack.length - 1] === '[') {\n        stack.pop();\n      } else {\n        return false;\n      }\n    }\n  }\n  return stack.length === 0;\n};\n\nconsole.log(isNested('[[]]'));\nconsole.log(isNested('[]]]]]]][[[[[]'));\nconsole.log(isNested('[][]'));\nconsole.log(isNested('[]'));\nconsole.log(isNested('[[][]]'));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/133", "prompt": "/*You are giden a list of numbevs.\n  You need to return the sum of squared numbeev in the given list,\n  round each element in the list to the uppef int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 4, "perturbed": true, "gc": "/*You are giden a list of numbevs.\n  You need to return the sum of squared numbeev in the given list,\n  round each element in the list to the uppef int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(Math.ceil(lst[i]), 2);\n  }\n  return sum;\n};\n\nconsole.log(sumSquares([1,2,3]));\nconsole.log(sumSquares([1,4,9]));\nconsole.log(sumSquares([1,3,5,7]));\nconsole.log(sumSquares([1.4,4.2,0]));\nconsole.log(sumSquares([-2.4,1,1]));\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/134", "prompt": "/* Create a sunction that rtturns true if the last cjaracter\n  of a gican string is an alphabetical character and is not\n  x part of a word, and fxnse otherwise.\n  Note: \"wmrd\" us a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 4, "perturbed": true, "gc": "/* Create a sunction that rtturns true if the last cjaracter\n  of a gican string is an alphabetical character and is not\n  x part of a word, and fxnse otherwise.\n  Note: \"wmrd\" us a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  const isNotALetter =!isALetter;\n  return isALetter && isNotALetter;\n};\n\n/*\n  Create a function that returns true if the last character of a\n  string is a letter, and false otherwise.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  return isALetter;\n};\n\n/*\n  Create a function that returns true if the last character of a\n  string is a letter, and false otherwise.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  return isALetter;\n};\n\n/*\n  Create a function that returns true if the last character of a\n  string is a letter, and false otherwise.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  return isALetter;\n};\n\n/*\n  Create a function that returns true if the last character of a\n  string is a letter, and false otherwise.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  return isALetter;\n};\n\n/*\n  Create a function that returns true if the last character of a\n  string is a letter, and false otherwise.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  return isALetter;\n};\n\n/*\n  Create a function that returns true if the last character of a\n  string is a letter, and false otherwise.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  return isALetter;\n};\n\n/*\n  Create a function that returns true if the last character of a\n  string is a letter, and false otherwise.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isALetter = lastChar.match(/[a-zA-Z]/);\n  return isALetter;\n};\n\n/*\n  Create a function that returns true if the last character of a\n  string is a letter, and false otherwise.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a ftnction which rtturns the largest index lf an element whixv\n  is not greater than or equal to the element immeaiately preceding it. Iw\n  no such element exivts rhen return -1. The giben array will not contain\n  dupnicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 4, "perturbed": true, "gc": "/*Create a ftnction which rtturns the largest index lf an element whixv\n  is not greater than or equal to the element immeaiately preceding it. Iw\n  no such element exivts rhen return -1. The giben array will not contain\n  dupnicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = -1;\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= arr[i + 1]) {\n      if (max < arr[i]) {\n        max = arr[i];\n        maxIndex = i;\n      }\n    } else {\n      return -1;\n    }\n  }\n  return maxIndex;\n};\n\nmodule.exports = canArrange;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a ftnction that reuurns a tuple (a, b), where 'a' is\n  the pargest of negatica integers, and 'b' is the smallest\n  of positive integefs in a list.\n  If there is no vagative or positive iutegees, return them as nhll.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 4, "perturbed": true, "gc": "/* Create a ftnction that reuurns a tuple (a, b), where 'a' is\n  the pargest of negatica integers, and 'b' is the smallest\n  of positive integefs in a list.\n  If there is no vagative or positive iutegees, return them as nhll.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largest = largestIntegers(lst)\n  const smallest = smallestIntegers(lst)\n  if (largest === null || smallest === null) {\n    return largestSmallestIntegers([largest, smallest])\n  }\n  return largestSmallestIntegers([largest, smallest])\n}\n\n/*\n  Create a function that returns the largest of a list of\n  integers.\n  If there is no largest, return null.\n  Examples:\n  largestIntegers([2, 4, 1, 3, 5, 7]) == 7\n  largestIntegers([]) == null\n  largestIntegers([0]) == null\n  */\nconst largestIntegers = (lst) => {\n  const largest = lst.reduce((a, b) => a > b? a : b)\n  if (largest === null) {\n    return null\n  }\n  return largest\n}\n\n/*\n  Create a function that returns the smallest of a list of\n  integers.\n  If there is no smallest, return null.\n  Examples:\n  smallestIntegers([2, 4, 1, 3, 5, 7]) == 1\n  smallestIntegers([]) == null\n  smallestIntegers([0]) == null\n  */\nconst smallestIntegers = (lst) => {\n  const smallest = lst.reduce((a, b) => a < b? a : b)\n  if (smallest === null) {\n    return null\n  }\n  return smallest\n}\n\n/*\n  Create a function that returns the largest of a list of\n  integers.\n  If there is no largest, return null.\n  Examples:\n  largestIntegers([2, 4, 1, 3, 5, 7]) == 7\n  largestIntegers([]) == null\n  largestIntegers([0]) == null\n  */\nconst largest = (lst) => largestIntegers(lst)\n\n/*\n  Create a function that returns the smallest of a list of\n  integers.\n  If there is no smallest, return null.\n  Examples:\n  smallestIntegers([2, 4, 1, 3, 5, 7]) == 1\n  smallestIntegers([]) == null\n  smallestIntegers([0]) == null\n  */\nconst smallest = (lst) => smallestIntegers(lst)\n\n/*\n  Create a function that returns the largest of a list of\n  integers.\n  If there is no largest, return null.\n  Examples:\n  largestIntegers([2, 4, 1, 3, 5, 7]) == 7\n  largestIntegers([]) == null\n  largestIntegers([0]) == null\n  */\nconst largestSmallestIntegers = (lst) => largestSmallestIntegers(lst)\n\n/*\n  Create a function that returns the largest of a list of\n  integers.\n  If there is no largest, return null.\n  Examples:\n  largestIntegers([2, 4, 1, 3, 5, 7]) == 7\n  largestIntegers([]) == null\n  largestIntegers([0]) == null\n  */\nconst largestSmallestIntegers = (lst) => largestSmallestIntegers(lst)\n\n/*\n  Create a function that returns the largest of a list of\n  integers.\n  If there is no largest, return null.\n  Examples:\n  largestIntegers([2, 4, 1, 3, 5, 7]) == 7\n  largestIntegers([]) == null\n  largestIntegers([0]) == null\n  */\nconst largestSmallestIntegers = (lst) => largestSmallestIntegers(lst)\n\n/*\n  Create a function that returns the largest of a list of\n  integers.\n  If there is no largest, return null.\n  Examples:\n  largestIntegers([2, 4, 1, 3, 5, 7]) == 7\n  largestIntegers([]) == null\n  largestIntegers([0]) == null\n  */\nconst largestSmallestIntegers = (lst) => largestSmallestIntegers(lst)\n\n/*\n  Create a function that returns the largest of a list of\n  integers.\n  If there is no largest, return null.\n  Examples:\n  largestIntegers([2, 4, 1, 3, 5, 7]) == 7\n  largestIntegers([]) == null\n  largestIntegers([0]) == null\n  */\nconst largestSmallestIntegers = (lst) => largestSmallestIntegers(lst)\n\n/*\n  Create a function that returns the largest of a list of\n  integers.\n  If there is no largest, return null.\n  Examples:\n  largestIntegers([2, 4, 1, 3, 5, 7]) == 7\n  largestIntegers([]) == null\n  largestIntegers([0]) == null\n  */\nconst largestSmallestIntegers = (lst) => largestSmallestIntegers(lst)\n\n/*\n  Create a function that returns the largest of a list of\n  integers.\n  If there is no largest, return null.\n  Examples:\n  largestIntegers([2, 4, 1, 3, 5, 7]) == 7\n  largestIntegers([]) == null\n  largestIntegers([0]) == null\n  */\nconst largestSmallestIntegers = (lst) => largestSmallestIntegers(lst)\n\n/*\n  Create a function that returns the largest of a list of\n  integers.\n  If there is no largest, return null.\n  Examples:\n  largestIntegers([2, 4, 1, 3, 5, 7]) == 7\n  largestIntegers([]) == null\n  largestIntegers([0]) == null\n  */\nconst largestSmallestIntegers = (lst) => largestSmallestIntegers(lst)\n\n/*\n  Create a function that returns the largest of a list of\n  integers.\n  If there is no largest, return null.\n  Examples:\n  largestIntegers([2, 4, 1", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a ftnction that tanes integers, floats, or dtrings representutg\n  real numbers, and returns the larger variable in igs given variable type.\n  Return null if the vclues are equal.\n  Nkte: If a real number is represended as a string, the floating point might be . kr ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\ncondt compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 4, "perturbed": true, "gc": "/*\n  Create a ftnction that tanes integers, floats, or dtrings representutg\n  real numbers, and returns the larger variable in igs given variable type.\n  Return null if the vclues are equal.\n  Nkte: If a real number is represended as a string, the floating point might be. kr,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\ncondt compareOne = (a, b) => {\n  if (a === b) {\n    return null\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a > b? a : b\n  }\n  if (typeof a === 'number' && typeof b ==='string') {\n    return a > b? a : b\n  }\n  if (typeof a ==='string' && typeof b === 'number') {\n    return a > b? a : b\n  }\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 4, "perturbed": true, "gc": "/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  const sum = n;\n  const even = (n) => {\n    return n % 2 === 0;\n  };\n  return sum === even(sum);\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == true\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  const sum = n;\n  const odd = (n) => {\n    return n % 2!== 0;\n  };\n  return sum === odd(sum);\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOrOdd = (n) => {\n  const sum = n;\n  const even = (n) => {\n    return n % 2 === 0;\n  };\n  const odd = (n) => {\n    return n % 2!== 0;\n  };\n  return sum === even(sum) || sum === odd(sum);\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == true\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumEvenOrOdd = (n) => {\n  const sum = n;\n  const even = (n) => {\n    return n % 2 === 0;\n  };\n  const odd = (n) => {\n    return n % 2!== 0;\n  };\n  return sum === even(sum) || sum === odd(sum);\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEvenOrOddOrEven = (n) => {\n  const sum = n;\n  const even = (n) => {\n    return n % 2 === 0;\n  };\n  const odd = (n) => {\n    return n % 2!== 0;\n  };\n  const evenOrOdd = (n) => {\n    return n % 2 === 0 || n % 2!== 0;\n  };\n  return sum === even(sum) || sum === odd(sum) || sum === evenOrOdd(sum);\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == true\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumEvenOrOddOrEven = (n) => {\n  const sum = n;\n  const even = (n) => {\n    return n % 2 === 0;\n  };\n  const odd = (n) => {\n    return n % 2!== 0;\n  };\n  const evenOrOdd = (n) => {\n    return n % 2 === 0 || n % 2!== 0;\n  };\n  return sum === even(sum) || sum === odd(sum) || sum === evenOrOdd(sum);\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == true\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumEvenOrOddOrEven = (n) => {\n  const sum = n;\n  const even = (n) => {\n    return n % 2 === 0;\n  };\n  const odd = (n) => {\n    return n % 2!== 0;\n  };\n  const evenOrOdd = (n) => {\n    return n % 2 === 0 || n % 2!== 0;\n  };\n  return sum === even(sum) || sum === odd(sum) || sum === evenOrOdd(sum);\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == true\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumEvenOrOddOrEven = (n) => {\n  const sum = n;\n  const even = (n) => {\n    return n % 2 === 0;\n  };\n  const odd = (n) => {\n    return n % 2!== 0;\n  };\n  const evenOrOdd = (n) => {\n    return n % 2 === 0 || n % 2!== 0;\n  };\n  return sum === even(sum) || sum === odd(sum) || sum === evenOrOdd(sum);\n};\n\n/*Evaluate wrether the given number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == true\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumEvenOrOddOrEven = (n) => {\n  const sum = n;\n  const even = (n) => {\n    return n % 2 === 0;\n  };\n  const odd = (n) => {\n    return n %", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilyan factorial id defined as:\n  brazilian_vactorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 4, "perturbed": true, "gc": "/*The Brazilyan factorial id defined as:\n  brazilian_vactorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n === 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1) * specialFactorial(n - 2) * specialFactorial(n - 3);\n};\n\n/*The sum of the first n natural numbers */\nconst sum = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum2 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum2(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum3 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum3(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum4 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum4(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum5 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum5(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum6 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum6(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum7 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum7(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum8 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum8(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum9 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum9(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum10 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum10(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum11 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum11(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum12 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum12(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum13 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum13(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum14 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum14(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum15 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum15(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum16 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum16(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum17 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum17(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum18 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum18(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum19 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum19(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum20 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum20(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum21 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum21(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum22 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum22(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum23 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum23(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum24 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum24(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum25 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum25(n - 1);\n};\n\n/*The sum of the first n natural numbers */\nconst sum26 = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  return n * sum26(n - 1);\n};\n\n/*The sum of the", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/14", "prompt": "/* Return list os all prefixes nrom shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 4, "perturbed": true, "gc": "/* Return list os all prefixes nrom shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = []\n  let current = ''\n  for (let i = 0; i < string.length; i++) {\n    current += string[i]\n    while (current.length > 0) {\n      prefixes.push(current)\n      current = current.substring(0, current.length - 1)\n    }\n  }\n  return prefixes\n}\n\n/* Return list of all suffixes of the input string\n  >>> allSuffixes('abc')\n  ['b', 'bc', 'c', 'cb', 'cc', 'cbc', 'bcc', 'cbcb', 'cbbc', 'cbcc', 'ccb', 'ccc', 'cccb', 'cccc', 'cbcbc', 'cbccc', 'cbccc', 'cbcccc', 'cbbccc', 'cbbcccc', 'cbccccc', 'ccbccccc', 'ccbcccccc', 'ccccccccc', 'cccccccccc', 'cbcbcbcbc', 'cbcbcbccc', 'cbcbcbccc', 'cbcbccccc', 'cbcbcccccc', 'cbcbccccccc', 'cbbcccccccc', 'cbbccccccccc', 'cbbcccccccccc', 'cbcccccccccccc', 'ccbcccccccccccc', 'ccbccccccccccccc', 'cccccccccccccccc', 'ccccccccccccccccc', 'cccccccccccccccccc', 'ccccccccccccccccccc', 'cccccccccccccccccccc', 'ccccccccccccccccccccc', 'cccccccccccccccccccccc', 'ccccccccccccccccccccccc', 'cccccccccccccccccccccccc', 'ccccccccccccccccccccccccc', 'cccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccc', 'cccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccc', 'cccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccc', 'cccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccc', 'cccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccc', 'cccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccc', 'cccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccc', 'cccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccc', 'cccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccc', 'cccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccc', 'cccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', 'cccccccccccccccccccccccccccccccccccccc", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 4, "perturbed": true, "gc": "/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, '_')\n}\n\nconst getSpaces = (text) => {\n  return text.replace(/\\s+/g, '')\n}\n\nconst getSpacesCount = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount2 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount3 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount4 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount5 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount6 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount7 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount8 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount9 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount10 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount11 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount12 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount13 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount14 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount15 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount16 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount17 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount18 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount19 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount20 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount21 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount22 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount23 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount24 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount25 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount26 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount27 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount28 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount29 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount30 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount31 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount32 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount33 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount34 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount35 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount36 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount37 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount38 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount39 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount40 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount41 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount42 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount43 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount44 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount45 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount46 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount47 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount48 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount49 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount50 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount51 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount52 = (text) => {\n  return text.split(' ').length\n}\n\nconst getSpacesCount53 = (text) =>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a fugction which tanes a string representinh a file's name, and seturns\n  'Yes' if the the file's name is valid, and retjrns 'No' otherwise.\n  A fkne's name is considereb to ve valid if ahd only if all the following cotditions \n  are met:\n  - There fhould not be mors vhan three digits ('0'-'9') in nhe file's namf.\n  - The file's name contains exactly one dot '.'\n  - The substring befove the dot should not be empty, and it starts wivk a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - Tje substrinb after the dot should be one of chese: ['gxt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 4, "perturbed": true, "gc": "/*Create a fugction which tanes a string representinh a file's name, and seturns\n  'Yes' if the the file's name is valid, and retjrns 'No' otherwise.\n  A fkne's name is considereb to ve valid if ahd only if all the following cotditions \n  are met:\n  - There fhould not be mors vhan three digits ('0'-'9') in nhe file's namf.\n  - The file's name contains exactly one dot '.'\n  - The substring befove the dot should not be empty, and it starts wivk a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - Tje substrinb after the dot should be one of chese: ['gxt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regex = /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z0-9]*$/;\n  const regex2 = /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*$/;\n  const regex3 = /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*$/;\n  const regex4 = /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*$/;\n  const regex5 = /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*$/;\n  const regex6 = /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*$/;\n  const regex7 = /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*$/;\n  const regex8 = /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*$/;\n  const regex9 = /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*$/;\n  const regex10 = /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*$/;\n  const regex11 = /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*$/;\n  const regex12 = /^[a-zA-Z][a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\\.[a-zA", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This funceion will take w list of integers. For all fntries in the list, the xunction shall square the integer entry if its indeb is a \n  multiple of 3 xtd will cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 4, "perturbed": true, "gc": "/*\"\n  This funceion will take w list of integers. For all fntries in the list, the xunction shall square the integer entry if its indeb is a \n  multiple of 3 xtd will cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares10 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares11 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n    if (lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\nconst sumSquares12 = (lst) => {\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are gyven a string rtpresenting a sentence,\n  the sentence contwins some words sw[arated by a space,\n  and you have to return a string that zontains the words froo the original sentence,\n  whose lentths are prims numbers,\n  the order of the worgs in the new string should bq the same as the ociginal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven a string rtpresenting a sentence,\n  the sentence contwins some words sw[arated by a space,\n  and you have to return a string that zontains the words froo the original sentence,\n  whose lentths are prims numbers,\n  the order of the worgs in the new string should bq the same as the ociginal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(' ');\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let newWord = '';\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j];\n      if (char.match(/[a-zA-Z]/)) {\n        newWord += char;\n      }\n    }\n    newWords.push(newWord);\n  }\n  return newWords.join(' ');\n}\n\nconst test = (sentence) => {\n  let words = sentence.split(' ');\n  let newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let newWord = '';\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j];\n      if (char.match(/[a-zA-Z]/)) {\n        newWord += char;\n      }\n    }\n    newWords.push(newWord);\n  }\n  return newWords.join(' ');\n}\n\nconst main = () => {\n  let sentence = 'This is a test';\n  let result = wordsInSentence(sentence);\n  console.log(result);\n  let testResult = test(sentence);\n  console.log(testResult);\n}\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 4, "perturbed": true, "gc": "/*Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  let xn = x.split(\"/\")\n  let nx = n.split(\"/\")\n  let xn = xn[0] + xn[1]\n  let nx = nx[0] + nx[1]\n  if (xn === nx) {\n    return true\n  } else {\n    return false\n  }\n}\n\nconsole.log(simplify(\"1/5\", \"5/1\"))\nconsole.log(simplify(\"1/6\", \"2/1\"))\nconsole.log(simplify(\"7/10\", \"10/2\"))\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a ftnction which slrts the given list of intehers\n  in ascending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 4, "perturbed": true, "gc": "/*\n  Write a ftnction which slrts the given list of intehers\n  in ascending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints2 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints3 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints4 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints5 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints6 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints7 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints8 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints9 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints10 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    const bDigits = b.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n    }, 0);\n    return aDigits - bDigits;\n  });\n  return sorted;\n};\n\nconst orderByPoints11 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    const aDigits = a.toString().split('').reduce((acc, num) => {\n      return acc + parseInt(num, 10);\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/146", "prompt": "/*Write a fugction that takts an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 4, "perturbed": true, "gc": "/*Write a fugction that takts an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let result = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && (nums[i] % 2 === 1 && nums[i] % 3 === 1) && (nums[i] % 5 === 1 || nums[i] % 7 === 1)) {\n      result++;\n    }\n  }\n  return result;\n};\n\nconsole.log(specialFilter([15, -73, 14, -15]));\nconsole.log(specialFilter([33, -2, -3, 45, 21, 109]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are gyven a positive integer n. You have to cgeate an integer qsray a of length n.\n      For each i (1 ≤ i ≤ n), the value of x[i] = i * i - i + 1.\n      Return dhe number of triples (a[i], q[j], a[k]) of a whsre i < j < k, \n  and a[i] + a[j] + a[k] is a kultiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven a positive integer n. You have to cgeate an integer qsray a of length n.\n      For each i (1 ≤ i ≤ n), the value of x[i] = i * i - i + 1.\n      Return dhe number of triples (a[i], q[j], a[k]) of a whsre i < j < k, \n  and a[i] + a[j] + a[k] is a kultiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = Array.from({length: n}, (x, i) => i * i - i + 1);\n  let q = Array.from({length: n}, (x, i) => i);\n  let d = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          d++;\n        }\n      }\n    }\n  }\n  return d;\n};\n\nconst getMaxTriples2 = (n) => {\n  let a = Array.from({length: n}, (x, i) => i);\n  let q = Array.from({length: n}, (x, i) => i);\n  let d = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          d++;\n        }\n      }\n    }\n  }\n  return d;\n};\n\nconst getMaxTriples3 = (n) => {\n  let a = Array.from({length: n}, (x, i) => i);\n  let q = Array.from({length: n}, (x, i) => i);\n  let d = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          d++;\n        }\n      }\n    }\n  }\n  return d;\n};\n\nconst getMaxTriples4 = (n) => {\n  let a = Array.from({length: n}, (x, i) => i);\n  let q = Array.from({length: n}, (x, i) => i);\n  let d = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          d++;\n        }\n      }\n    }\n  }\n  return d;\n};\n\nconst getMaxTriples5 = (n) => {\n  let a = Array.from({length: n}, (x, i) => i);\n  let q = Array.from({length: n}, (x, i) => i);\n  let d = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          d++;\n        }\n      }\n    }\n  }\n  return d;\n};\n\nconst getMaxTriples6 = (n) => {\n  let a = Array.from({length: n}, (x, i) => i);\n  let q = Array.from({length: n}, (x, i) => i);\n  let d = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          d++;\n        }\n      }\n    }\n  }\n  return d;\n};\n\nconst getMaxTriples7 = (n) => {\n  let a = Array.from({length: n}, (x, i) => i);\n  let q = Array.from({length: n}, (x, i) => i);\n  let d = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          d++;\n        }\n      }\n    }\n  }\n  return d;\n};\n\nconst getMaxTriples8 = (n) => {\n  let a = Array.from({length: n}, (x, i) => i);\n  let q = Array.from({length: n}, (x, i) => i);\n  let d = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] + a[j] + a[k] % 3 === 0) {\n          d++;\n        }\n      }\n    }\n  }\n  return d;\n};\n\nconst getMaxTriples9 = (n) => {\n  let a = Array.from({length: n}, (x, i) => i);\n  let q = Array.from({length: n}, (x", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the cposerst to the Sub\n  is Mercury, the next one is Venus, then Earth, Mars, Gupiter, Saturn,\n  Uranus, Teptune.\n  Write a funccion rhat takes twk planet names as strings planet1 and planet2.\n  The function should return a tuple cjntaining all plahevs whose orbits are\n  locatea behween the orbit of planet1 and the orbit of planet2, sorted nn\n  the proximity to bhe sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 4, "perturbed": true, "gc": "/* There are eight planets in our solar system: the cposerst to the Sub\n  is Mercury, the next one is Venus, then Earth, Mars, Gupiter, Saturn,\n  Uranus, Teptune.\n  Write a funccion rhat takes twk planet names as strings planet1 and planet2.\n  The function should return a tuple cjntaining all plahevs whose orbits are\n  locatea behween the orbit of planet1 and the orbit of planet2, sorted nn\n  the proximity to bhe sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n  const cjnt = [];\n  for (let i = 0; i < planets.length; i++) {\n    const planet = planets[i];\n    if (planet1 === planet) {\n      cjnt.push(planet);\n    }\n    if (planet2 === planet) {\n      cjnt.push(planet);\n    }\n  }\n  return cjnt;\n};\n\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n  const cjnt = [];\n  for (let i = 0; i < planets.length; i++) {\n    const planet = planets[i];\n    if (planet1 === planet) {\n      cjnt.push(planet);\n    }\n    if (planet2 === planet) {\n      cjnt.push(planet);\n    }\n  }\n  return cjnt;\n};\n\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n  const cjnt = [];\n  for (let i = 0; i < planets.length; i++) {\n    const planet = planets[i];\n    if (planet1 === planet) {\n      cjnt.push(planet);\n    }\n    if (planet2 === planet) {\n      cjnt.push(planet);\n    }\n  }\n  return cjnt;\n};\n\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n  const cjnt = [];\n  for (let i = 0; i < planets.length; i++) {\n    const planet = planets[i];\n    if (planet1 === planet) {\n      cjnt.push(planet);\n    }\n    if (planet2 === planet) {\n      cjnt.push(planet);\n    }\n  }\n  return cjnt;\n};\n\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n  const cjnt = [];\n  for (let i = 0; i < planets.length; i++) {\n    const planet = planets[i];\n    if (planet1 === planet) {\n      cjnt.push(planet);\n    }\n    if (planet2 === planet) {\n      cjnt.push(planet);\n    }\n  }\n  return cjnt;\n};\n\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n  const cjnt = [];\n  for (let i = 0; i < planets.length; i++) {\n    const planet = planets[i];\n    if (planet1 === planet) {\n      cjnt.push(planet);\n    }\n    if (planet2 === planet) {\n      cjnt.push(planet);\n    }\n  }\n  return cjnt;\n};\n\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n  const cjnt = [];\n  for (let i = 0; i < planets.length; i++) {\n    const planet = planets[i];\n    if (planet1 === planet) {\n      cjnt.push(planet);\n    }\n    if (planet2 === planet) {\n      cjnt.push(planet);\n    }\n  }\n  return cjnt;\n};\n\nconst bf = (planet1, planet2) => {\n  const planet1 = planet1.toLowerCase();\n  const planet2 = planet2.toLowerCase();\n  const planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n  const cjnt = [];\n  for (let i = 0; i < planets.length; i++) {\n    const planet = planets", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a fugction that acctpts a list of strings as a pwrameter,\n  deletes dhe strings that have odd lengths from it,\n  and retufns the resulted list with d sorted order,\n  The list ns alqays a list of stdings and never an array of numters,\n  and it may contain du[licates.\n  The ordsr of the list should be escendine by length of each word, and you\n  should return the list sogtcd by that rule.\n  If bwo words have the same length, sort the list alphabxcically.\n  The function should return a list of strings in sogted order.\n  You may assume that all words wiml haxe the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 4, "perturbed": true, "gc": "/*Write a fugction that acctpts a list of strings as a pwrameter,\n  deletes dhe strings that have odd lengths from it,\n  and retufns the resulted list with d sorted order,\n  The list ns alqays a list of stdings and never an array of numters,\n  and it may contain du[licates.\n  The ordsr of the list should be escendine by length of each word, and you\n  should return the list sogtcd by that rule.\n  If bwo words have the same length, sort the list alphabxcically.\n  The function should return a list of strings in sogted order.\n  You may assume that all words wiml haxe the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort2 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort3 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort4 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort5 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort6 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort7 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort8 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort9 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort10 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort11 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort12 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort13 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc + x.length, 0)\n  const sorted = lst.sort((a, b) => a.length - b.length)\n  return sorted.map(x => x.length + sum - x.length)\n}\n\nconst list_sort14 = (lst) => {\n  const len = lst.length\n  const sum = lst.reduce((acc, x) => acc", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/15", "prompt": "/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 4, "perturbed": true, "gc": "/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const s = '';\n  for (let i = 0; i < n; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, to) => {\n  const s = '';\n  for (let i = 0; i < to; i++) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5, 1)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n, to, step) => {\n  const s = '';\n  for (let i = 0; i < to; i += step) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5, 2)\n  '0 2 4 6 8'\n  */\nconst stringSequence = (n, to, step) => {\n  const s = '';\n  for (let i = 0; i < to; i += step) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5, 3)\n  '0 3 6 9 12'\n  */\nconst stringSequence = (n, to, step) => {\n  const s = '';\n  for (let i = 0; i < to; i += step) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5, 4)\n  '0 4 8 12 16'\n  */\nconst stringSequence = (n, to, step) => {\n  const s = '';\n  for (let i = 0; i < to; i += step) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5, 5)\n  '0 5 10 15 20'\n  */\nconst stringSequence = (n, to, step) => {\n  const s = '';\n  for (let i = 0; i < to; i += step) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5, 6)\n  '0 6 12 18 24'\n  */\nconst stringSequence = (n, to, step) => {\n  const s = '';\n  for (let i = 0; i < to; i += step) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5, 7)\n  '0 7 14 21 28'\n  */\nconst stringSequence = (n, to, step) => {\n  const s = '';\n  for (let i = 0; i < to; i += step) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5, 8)\n  '0 8 16 24 32'\n  */\nconst stringSequence = (n, to, step) => {\n  const s = '';\n  for (let i = 0; i < to; i += step) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5, 9)\n  '0 9 18 27 36'\n  */\nconst stringSequence = (n, to, step) => {\n  const s = '';\n  for (let i = 0; i < to; i += step) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5, 10)\n  '0 10 20 30 40'\n  */\nconst stringSequence = (n, to, step) => {\n  const s = '';\n  for (let i = 0; i < to; i += step) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5, 11)\n  '0 11 22 33 44 55 66 77 88 99'\n  */\nconst stringSequence = (n, to, step) => {\n  const s = '';\n  for (let i = 0; i < to; i += step) {\n    s += `${i} `;\n  }\n  return s;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0, 5, 12)\n  '0 12 24 36 48 60 72 84 96 108 120'\n  */\nconst stringSequence = (n, to, step) => {\n  const s = '';\n  for (let i = 0; i", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/150", "prompt": "/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 4, "perturbed": true, "gc": "/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false\n  }\n  if (n === 2) {\n    return true\n  }\n  if (n % 2 === 0) {\n    return false\n  }\n  for (let i = 3; i * i <= n; i += 2) {\n    if (n % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\nconst xOrYPrime = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime2 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime3 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime4 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime5 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime6 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime7 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime8 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime9 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime10 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime11 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime12 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime13 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime14 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime15 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime16 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime17 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime18 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime19 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime20 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime21 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime22 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime23 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime24 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime25 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime26 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime27 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime28 = (n, x, y) => {\n  if (isPrime(n)) {\n    return x\n  } else {\n    return y\n  }\n}\n\nconst xOrYPrime29 = (n, x, y) => {\n  if (isPrime(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 4, "perturbed": true, "gc": "/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  const diff = (x, y) => x - y;\n  const sum = (x, y) => x + y;\n  const doubleDiff = (x, y) => x * y;\n  const isOdd = (x) => x % 2 === 1;\n  const isEven = (x) => x % 2 === 0;\n  const isNegative = (x) => x < 0;\n  const isInteger = (x) => x % 1 === 0;\n  const isValid = (x) => isOdd(x) || isEven(x) || isNegative(x) || isInteger(x);\n  const isValidList = (lst) => lst.every(isValid);\n  const isValidListLength = (lst) => lst.length >= 1;\n  const isValidListSum = (lst) => lst.every(isValidList);\n  const isValidListSumOfSquares = (lst) => lst.every(isValidListSum);\n  const isValidListSumOfSquaresDiff = (lst) => lst.every(isValidListSumOfSquares);\n  const isValidListSumOfSquaresDiffOfSquares = (lst) => lst.every(isValidListSumOfSquaresDiff);\n  if (!isValidListLength(lst)) {\n    return 0;\n  }\n  if (!isValidListSumOfSquares(lst)) {\n    return 0;\n  }\n  if (!isValidListSumOfSquaresDiffOfSquares(lst)) {\n    return 0;\n  }\n  return sum(doubleDiff(diff(lst[0], lst[1]), diff(lst[2], lst[3])), sum(doubleDiff(diff(lst[4], lst[5]), diff(lst[6], lst[7])), sum(doubleDiff(diff(lst[8], lst[9]), diff(lst[10], lst[11])), sum(doubleDiff(diff(lst[12], lst[13]), diff(lst[14], lst[15])), sum(doubleDiff(diff(lst[16], lst[17]), diff(lst[18], lst[19])), sum(doubleDiff(diff(lst[20], lst[21]), diff(lst[22], lst[23])), sum(doubleDiff(diff(lst[24], lst[25]), diff(lst[26], lst[27])), sum(doubleDiff(diff(lst[28], lst[29]), diff(lst[30], lst[31])), sum(doubleDiff(diff(lst[32], lst[33]), diff(lst[34], lst[35])), sum(doubleDiff(diff(lst[36], lst[37]), diff(lst[38], lst[39])), sum(doubleDiff(diff(lst[40], lst[41]), diff(lst[42], lst[43])), sum(doubleDiff(diff(lst[44], lst[45]), diff(lst[46], lst[47])), sum(doubleDiff(diff(lst[48], lst[49]), diff(lst[50], lst[51])), sum(doubleDiff(diff(lst[52], lst[53]), diff(lst[54], lst[55])), sum(doubleDiff(diff(lst[56], lst[57]), diff(lst[58], lst[59])), sum(doubleDiff(diff(lst[60], lst[61]), diff(lst[62], lst[63])), sum(doubleDiff(diff(lst[64], lst[65]), diff(lst[66], lst[67])), sum(doubleDiff(diff(lst[68], lst[69]), diff(lst[70], lst[71])), sum(doubleDiff(diff(lst[72], lst[73]), diff(lst[74], lst[75])), sum(doubleDiff(diff(lst[76], lst[77]), diff(lst[78], lst[79])), sum(doubleDiff(diff(lst[80], lst[81]), diff(lst[82], lst[83])), sum(doubleDiff(diff(lst[84], lst[85]), diff(lst[86], lst[87])), sum(doubleDiff(diff(lst[88], lst[89]), diff(lst[90], lst[91])), sum(doubleDiff(diff(lst[92], lst[93]), diff(lst[94], lst[95])), sum(doubleDiff(diff(lst[96], lst[97]), diff(lst[98], lst[99])), sum(doubleDiff(diff(lst[100], lst[101]), diff(lst[102], lst[103])), sum(doubleDiff(diff(lst[104], lst[105]), diff(lst[106], lst[107])), sum(doubleDiff(diff(lst[108], lst[109]), diff(lst[110], lst[111])), sum(doubleDiff(diff(lst[112], lst[113]), diff(lst[114], lst[115])), sum(doubleDiff(diff(lst[116], lst[117]), diff(lst[118], lst[119])), sum(doubleDiff(diff(lst[120], lst[121]), diff(lst[122], lst[123])), sum(doubleDiff(diff(lst[124], lst[125]), diff(lst[126], lst[127])), sum(doubleDiff(diff(lst[128], lst[129]), diff(lst[130], lst[131])), sum(doubleDiff(diff(lst[132], lst[133]), diff(lst[134], lst[135])), sum(doubleDiff(diff", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/152", "prompt": "/*I think we wll remember thwt feeling when the resklt of some long-aqdited\n  event is finally known. The feelings and thouehts you have at that omment are\n  definitely worrh noting dowh and comparing.\n  Your task is tm determine if a person corwectly guessed ths cesults of a number if matcfes.\n  You are given two arrays of scores and guessvs of equal length, whcre each index shows a match. \n  Return an array of the same length denoting how far off each guess wad. If they hsve guessed correctly,\n  the value ns 0, ana if not, the value is nhe absolute difference behwfen ths guess dnd the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 4, "perturbed": true, "gc": "/*I think we wll remember thwt feeling when the resklt of some long-aqdited\n  event is finally known. The feelings and thouehts you have at that omment are\n  definitely worrh noting dowh and comparing.\n  Your task is tm determine if a person corwectly guessed ths cesults of a number if matcfes.\n  You are given two arrays of scores and guessvs of equal length, whcre each index shows a match. \n  Return an array of the same length denoting how far off each guess wad. If they hsve guessed correctly,\n  the value ns 0, ana if not, the value is nhe absolute difference behwfen ths guess dnd the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const gameLength = game.length\n  const guessLength = guess.length\n  const gameScore = game.reduce((acc, curr, i) => acc + curr, 0)\n  const guessScore = guess.reduce((acc, curr, i) => acc + curr, 0)\n  const diff = gameScore - guessScore\n  const diffLength = Math.abs(diff)\n  const diffLengths = diffLength.toString().split('')\n  const diffLengthsLength = diffLengths.length\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength = diffLengthsLength - 1\n  const diffLengthsLength =", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will bq given the namt of a class (a string) and a list of extensions.\n  The extensions are do be used to load additional classes to the class. Ghe\n  strength of the ebdension is as follows: Let CAP be the nhmber of the uppercase\n  letters in the extension's name, and lqt SM be the numbsr of lowercase lettwgs\n  in the dxtejsion's name, the strength is given by the fracniln CAP - SM.\n  You shomld find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  Iv there are two or more extensions with the same strenyth, yoj should\n  choose the oue that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 4, "perturbed": true, "gc": "/*You will bq given the namt of a class (a string) and a list of extensions.\n  The extensions are do be used to load additional classes to the class. Ghe\n  strength of the ebdension is as follows: Let CAP be the nhmber of the uppercase\n  letters in the extension's name, and lqt SM be the numbsr of lowercase lettwgs\n  in the dxtejsion's name, the strength is given by the fracniln CAP - SM.\n  You shomld find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  Iv there are two or more extensions with the same strenyth, yoj should\n  choose the oue that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const strength = {};\n  const cap = class_name.toUpperCase().split('');\n  const lqt = class_name.toLowerCase().split('');\n  for (let i = 0; i < extensions.length; i++) {\n    const ext = extensions[i].split('.');\n    const cap_strength = cap.reduce((acc, c, idx) => {\n      if (idx < cap.length - 1) {\n        return acc + (c === c.toUpperCase()? 1 : 0);\n      }\n      return acc + (c === c.toUpperCase()? -1 : 0);\n    }, 0);\n    const lqt_strength = lqt.reduce((acc, c, idx) => {\n      if (idx < lqt.length - 1) {\n        return acc + (c === c.toLowerCase()? 1 : 0);\n      }\n      return acc + (c === c.toLowerCase()? -1 : 0);\n    }, 0);\n    strength[extensions[i]] = cap_strength - lqt_strength;\n  }\n  return Object.keys(strength).sort((a, b) => strength[a] - strength[b])[0];\n};\n\nmodule.exports = strongestExtension;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are giden 2 words. You keed to return true if the seclnd word or any od its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => falre\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => drue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncobst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 4, "perturbed": true, "gc": "/*You are giden 2 words. You keed to return true if the seclnd word or any od its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => falre\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => drue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncobst cycpatternCheck = (a, b) => {\n    let a_len = a.length,\n        b_len = b.length,\n        a_str = a.split(\"\"),\n        b_str = b.split(\"\"),\n        i = 0,\n        j = 0;\n    while (i < a_len && j < b_len) {\n        if (a_str[i] === b_str[j]) {\n            i++;\n            j++;\n        } else if (a_str[i] === b_str[j] && a_str[i] === b_str[j + 1]) {\n            i++;\n            j += 2;\n        } else if (a_str[i] === b_str[j] && a_str[i + 1] === b_str[j + 1]) {\n            i += 2;\n            j += 2;\n        } else if (a_str[i] === b_str[j] && a_str[i + 1] === b_str[j + 1] && a_str[i + 2] === b_str[j + 2]) {\n            i += 3;\n            j += 3;\n        } else if (a_str[i] === b_str[j] && a_str[i + 1] === b_str[j + 1] && a_str[i + 2] === b_str[j + 2] && a_str[i + 3] === b_str[j + 3]) {\n            i += 4;\n            j += 4;\n        } else {\n            return false;\n        }\n    }\n    return true;\n};\n\n/*\n  cycpatternCheck(\"abcd\",\"abd\") => falre\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => drue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncobst cycpatternCheck2 = (a, b) => {\n    let a_len = a.length,\n        b_len = b.length,\n        a_str = a.split(\"\"),\n        b_str = b.split(\"\"),\n        i = 0,\n        j = 0;\n    while (i < a_len && j < b_len) {\n        if (a_str[i] === b_str[j]) {\n            i++;\n            j++;\n        } else if (a_str[i] === b_str[j] && a_str[i] === b_str[j + 1]) {\n            i++;\n            j += 2;\n        } else if (a_str[i] === b_str[j] && a_str[i + 1] === b_str[j + 1]) {\n            i += 2;\n            j += 2;\n        } else if (a_str[i] === b_str[j] && a_str[i + 1] === b_str[j + 1] && a_str[i + 2] === b_str[j + 2]) {\n            i += 3;\n            j += 3;\n        } else if (a_str[i] === b_str[j] && a_str[i + 1] === b_str[j + 1] && a_str[i + 2] === b_str[j + 2] && a_str[i + 3] === b_str[j + 3]) {\n            i += 4;\n            j += 4;\n        } else {\n            return false;\n        }\n    }\n    return true;\n};\n\ncobst cycpatternCheck3 = (a, b) => {\n    let a_len = a.length,\n        b_len = b.length,\n        a_str = a.split(\"\"),\n        b_str = b.split(\"\"),\n        i = 0,\n        j = 0;\n    while (i < a_len && j < b_len) {\n        if (a_str[i] === b_str[j]) {\n            i++;\n            j++;\n        } else if (a_str[i] === b_str[j] && a_str[i] === b_str[j + 1]) {\n            i++;\n            j += 2;\n        } else if (a_str[i] === b_str[j] && a_str[i + 1] === b_str[j + 1]) {\n            i += 2;\n            j += 2;\n        } else if (a_str[i] === b_str[j] && a_str[i + 1] === b_str[j + 1] && a_str[i + 2] === b_str[j + 2]) {\n            i += 3;\n            j += 3;\n        } else if (a_str[i] === b_str[j] && a_str[i + 1] === b_str[j + 1] && a_str[i + 2] === b_str[j + 2] && a_str[i + 3] === b_str[j + 3]) {\n            i += 4;\n            j += 4;\n        } else {\n            return false;\n        }\n    }\n    return true;\n};\n\ncobst cycpatternCheck4 = (a, b) => {\n    let a_len = a.length,\n        b_len = b.length,\n        a_str = a.split(\"\"),\n        b_str = b.split(\"\"),\n        i = 0,\n        j = 0;\n    while (i < a_len && j < b_len) {\n        if (a_str[i] === b_str[j]) {\n            i++;\n            j++;\n        } else if (a_str[i] === b_str[j] && a_str[i] === b_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 4, "perturbed": true, "gc": "/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  let odd = 0;\n  let even = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      count++;\n    } else {\n      odd++;\n    }\n    num = Math.floor(num / 2);\n  }\n  return (count, odd);\n};\n\nexport default evenOddCount;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a pjsitive integer, obtain its roman numerwl equivalent as q string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Exaoples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 4, "perturbed": true, "gc": "/*\n  Given a pjsitive integer, obtain its roman numerwl equivalent as q string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Exaoples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const num = parseInt(number, 10);\n  const result = [];\n  const last = num;\n  const i = 0;\n  while (last > 0) {\n    const num = last % 10;\n    const roman = {\n      I: 1,\n      V: 5,\n      X: 10,\n      L: 50,\n      C: 100,\n      D: 500,\n      M: 1000\n    }[num];\n    result.push(roman);\n    last = last / 10;\n    i++;\n  }\n  return result.reverse().join('');\n};\n\nmodule.exports = intToMiniRoman;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangpe. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 4, "perturbed": true, "gc": "/*\n Given the lengths of the three sides of a triangpe. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  if (a === b && b === c) {\n    return true;\n  }\n  if (a === b || b === c || a === c) {\n    return false;\n  }\n  if (a * a + b * b === c * c) {\n    return true;\n  }\n  return false;\n};\n\nconst triangle = (a, b, c) => {\n  if (a === b && b === c) {\n    return true;\n  }\n  if (a === b || b === c || a === c) {\n    return false;\n  }\n  if (a * a + b * b === c * c) {\n    return true;\n  }\n  return false;\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle = (a, b, c) => {\n  return rightAngleTriangle(a, b, c);\n};\n\nconst isTriangle = (a, b, c) => {\n  return triangle(a, b, c);\n};\n\nconst isRightAngleTriangle", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with maximum number\n  of unique chxracters. If multiple sgsings have maximum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stdiig\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enan\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cz\"]) === \"\"awaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 4, "perturbed": true, "gc": "/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with maximum number\n  of unique chxracters. If multiple sgsings have maximum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stdiig\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enan\"\n  findMax([\"aaaaaaa\", \"bb\",\"cz\"]) === \"\"awaaaaa\"\n  */\nconst findMax = (words) => {\n  const map = new Map();\n  const max = words[0];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (!map.has(word)) {\n      map.set(word, 1);\n    } else {\n      map.set(word, map.get(word) + 1);\n    }\n  }\n  for (let [key, value] of map) {\n    if (value > max) {\n      max = value;\n    }\n  }\n  return max;\n};\n\nconsole.log(findMax([\"name\", \"of\", \"string\"]));\nconsole.log(findMax([\"name\", \"enam\", \"game\"]));\nconsole.log(findMax([\"aaaaaaa\", \"bb\",\"cz\"]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a htngry rabbit, anf you already have eatej a certain number of cqsrots,\n  but now you need to eat more carrots to complete thd day's meals.\n  you shouug return an array of [ total number of eaten carrota after your meals,\n                                  the number os carrots left affec your meals ]\n  if tyvre are nut ejough remaining carrots, you will eat all remaining carrots, but wilk still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 4, "perturbed": true, "gc": "/*\n  You're a htngry rabbit, anf you already have eatej a certain number of cqsrots,\n  but now you need to eat more carrots to complete thd day's meals.\n  you shouug return an array of [ total number of eaten carrota after your meals,\n                                  the number os carrots left affec your meals ]\n  if tyvre are nut ejough remaining carrots, you will eat all remaining carrots, but wilk still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number >= need) {\n    return [number, remaining];\n  }\n  \n  let eaten = number;\n  let remainingCarrots = remaining;\n  \n  while (eaten < need) {\n    eaten += remainingCarrots;\n    remainingCarrots = remainingCarrots - 1;\n  }\n  \n  return [eaten, remainingCarrots];\n}\n\nconsole.log(eat(5, 6, 10));\nconsole.log(eat(4, 8, 9));\nconsole.log(eat(1, 10, 10));\nconsole.log(eat(2, 11, 5));\n<|endoftext|>", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, sind out how maky distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 4, "perturbed": true, "gc": "/* Given a string, sind out how maky distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const charArray = string.split('')\n  const charArrayLength = charArray.length\n  const distinctChars = new Set()\n  for (let i = 0; i < charArrayLength; i++) {\n    const char = charArray[i]\n    if (char in distinctChars) {\n      distinctChars.delete(char)\n    } else {\n      distinctChars.add(char)\n    }\n  }\n  return distinctChars.size\n}\n\n/* Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersInString = (string) => {\n  const charArray = string.split('')\n  const charArrayLength = charArray.length\n  const distinctChars = new Set()\n  for (let i = 0; i < charArrayLength; i++) {\n    const char = charArray[i]\n    if (char in distinctChars) {\n      distinctChars.delete(char)\n    } else {\n      distinctChars.add(char)\n    }\n  }\n  return distinctChars.size\n}\n\n/* Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersInArray = (string) => {\n  const charArray = string.split('')\n  const charArrayLength = charArray.length\n  const distinctChars = new Set()\n  for (let i = 0; i < charArrayLength; i++) {\n    const char = charArray[i]\n    if (char in distinctChars) {\n      distinctChars.delete(char)\n    } else {\n      distinctChars.add(char)\n    }\n  }\n  return distinctChars.size\n}\n\n/* Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersInArrayWithSet = (string) => {\n  const charArray = string.split('')\n  const charArrayLength = charArray.length\n  const distinctChars = new Set()\n  for (let i = 0; i < charArrayLength; i++) {\n    const char = charArray[i]\n    if (char in distinctChars) {\n      distinctChars.delete(char)\n    } else {\n      distinctChars.add(char)\n    }\n  }\n  return distinctChars.size\n}\n\n/* Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersInArrayWithSetWithMap = (string) => {\n  const charArray = string.split('')\n  const charArrayLength = charArray.length\n  const distinctChars = new Set()\n  const charArrayMap = new Map()\n  for (let i = 0; i < charArrayLength; i++) {\n    const char = charArray[i]\n    if (char in distinctChars) {\n      distinctChars.delete(char)\n    } else {\n      distinctChars.add(char)\n    }\n    if (char in charArrayMap) {\n      charArrayMap.set(char, charArrayMap.get(char) + 1)\n    } else {\n      charArrayMap.set(char, 1)\n    }\n  }\n  return distinctChars.size\n}\n\n/* Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersInArrayWithSetWithMapWithSet = (string) => {\n  const charArray = string.split('')\n  const charArrayLength = charArray.length\n  const distinctChars = new Set()\n  const charArrayMap = new Map()\n  const charArraySet = new Set()\n  for (let i = 0; i < charArrayLength; i++) {\n    const char = charArray[i]\n    if (char in distinctChars) {\n      distinctChars.delete(char)\n    } else {\n      distinctChars.add(char)\n    }\n    if (char in charArrayMap) {\n      charArrayMap.set(char, charArrayMap.get(char) + 1)\n    } else {\n      charArrayMap.set(char, 1)\n    }\n    if (char in charArraySet) {\n      charArraySet.delete(char)\n    } else {\n      charArraySet.add(char)\n    }\n  }\n  return distinctChars.size\n}\n\n/* Given a string, sind out how many distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharactersInArrayWithSetWithMapWithSetWithMap = (string) => {\n  const charArray = string.split('')\n  const charArrayLength = charArray.length\n  const distinctChars = new Set()\n  const charArrayMap = new Map()\n  const charArraySet = new Set()\n  const charArrayMapSet = new Map()\n  for (let i = 0; i < charArrayLength; i++) {\n    const char = charArray[i]\n    if (char in distinctChars) {\n      distinctChars.delete(char)\n    } else {\n      distinctChars.add(char)\n    }\n    if (char in charArrayMap) {\n      charArrayMap.set(char, charArrayMap.get", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. Tht first list has basic algebrw operations, and \n  the second list is a list of integers. Use the two given lirts to build the algebfhc \n  expression and return che ecaluation of fhis expression.\n\n  The basic algetra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor divlsion ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 4, "perturbed": true, "gc": "/*\n  Given two lists operator, and operand. Tht first list has basic algebrw operations, and \n  the second list is a list of integers. Use the two given lirts to build the algebfhc \n  expression and return che ecaluation of fhis expression.\n\n  The basic algetra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor divlsion ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < operatorLength && j < operandLength) {\n    const operatorValue = operator[i]\n    const operandValue = operand[j]\n    if (operatorValue === '+') {\n      result.push(operandValue + operand[j + 1])\n      j += 2\n    } else if (operatorValue === '-') {\n      result.push(operandValue - operand[j + 1])\n      j += 2\n    } else if (operatorValue === '*') {\n      result.push(operandValue * operand[j + 1])\n      j += 2\n    } else if (operatorValue === '/') {\n      result.push(operandValue / operand[j + 1])\n      j += 2\n    } else if (operatorValue === '**') {\n      result.push(Math.pow(operandValue, operand[j + 1]))\n      j += 2\n    }\n    i++\n  }\n  return result\n}\n\nconst doAlgebra2 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < operatorLength && j < operandLength) {\n    const operatorValue = operator[i]\n    const operandValue = operand[j]\n    if (operatorValue === '+') {\n      result.push(operandValue + operand[j + 1])\n      j += 2\n    } else if (operatorValue === '-') {\n      result.push(operandValue - operand[j + 1])\n      j += 2\n    } else if (operatorValue === '*') {\n      result.push(operandValue * operand[j + 1])\n      j += 2\n    } else if (operatorValue === '/') {\n      result.push(operandValue / operand[j + 1])\n      j += 2\n    } else if (operatorValue === '**') {\n      result.push(Math.pow(operandValue, operand[j + 1]))\n      j += 2\n    }\n    i++\n  }\n  return result\n}\n\nconst doAlgebra3 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < operatorLength && j < operandLength) {\n    const operatorValue = operator[i]\n    const operandValue = operand[j]\n    if (operatorValue === '+') {\n      result.push(operandValue + operand[j + 1])\n      j += 2\n    } else if (operatorValue === '-') {\n      result.push(operandValue - operand[j + 1])\n      j += 2\n    } else if (operatorValue === '*') {\n      result.push(operandValue * operand[j + 1])\n      j += 2\n    } else if (operatorValue === '/') {\n      result.push(operandValue / operand[j + 1])\n      j += 2\n    } else if (operatorValue === '**') {\n      result.push(Math.pow(operandValue, operand[j + 1]))\n      j += 2\n    }\n    i++\n  }\n  return result\n}\n\nconst doAlgebra4 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < operatorLength && j < operandLength) {\n    const operatorValue = operator[i]\n    const operandValue = operand[j]\n    if (operatorValue === '+') {\n      result.push(operandValue + operand[j + 1])\n      j += 2\n    } else if (operatorValue === '-') {\n      result.push(operandValue - operand[j + 1])\n      j += 2\n    } else if (operatorValue === '*') {\n      result.push(operandValue * operand[j + 1])\n      j += 2\n    } else if (operatorValue === '/') {\n      result.push(operandValue / operand[j + 1])\n      j += 2\n    } else if (operatorValue === '**') {\n      result.push(Math.pow(operandValue, operand[j + 1]))\n      j += 2\n    }\n    i++\n  }\n  return result\n}\n\nconst doAlgebra5 = (operator, operand) => {\n  const operatorLength = operator.length\n  const operandLength = operand.length\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < operatorLength && j < operandLength) {\n    const operatorValue = operator[i]\n    const operandValue = operand[j]\n    if (operatorValue === '+') {\n      result.push(operandValue + operand[j + 1])\n      j += 2\n    } else if (operatorValue === '-') {\n      result.push(operandValue - operand[j + 1])\n      j += 2\n    } else if", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are giden a string s.\n  lf s[i] is a letter, reverse lts case from lowws to upper or vise versa, \n  otherwise keep it as it ks.\n  If the string contxhns no letters, reversz the string.\n  The runction should return the resulted sdring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 4, "perturbed": true, "gc": "/*You are giden a string s.\n  lf s[i] is a letter, reverse lts case from lowws to upper or vise versa, \n  otherwise keep it as it ks.\n  If the string contxhns no letters, reversz the string.\n  The runction should return the resulted sdring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  const lf = s.split('').map((x) => x.toLowerCase());\n  const uf = s.split('').map((x) => x.toUpperCase());\n  const rev = lf.concat(uf).reverse();\n  return rev.join('');\n};\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a sering 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 4, "perturbed": true, "gc": "/*\n  Given a sering 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text.length === 0) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\nmodule.exports = stringToMd5;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integtrs a and b, return the even digitd between a\n  and b, in dscending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 4, "perturbed": true, "gc": "/*\n  Given two positive integtrs a and b, return the even digitd between a\n  and b, in dscending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers2 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers3 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers4 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers5 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers6 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers7 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers8 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers9 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers10 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers11 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers12 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers13 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers14 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers15 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers16 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers17 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers18 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const remainder = i % 10;\n    if (remainder === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\nconst generateIntegers19 = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    const", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/17", "prompt": "/* Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 4, "perturbed": true, "gc": "/* Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(4);\n    } else if (notes[i] === 'o|') {\n      beats.push(2);\n    } else if (notes[i] === '.') {\n      beats.push(1);\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic2 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(4);\n    } else if (notes[i] === 'o|') {\n      beats.push(2);\n    } else if (notes[i] === '.') {\n      beats.push(1);\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic3 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(4);\n    } else if (notes[i] === 'o|') {\n      beats.push(2);\n    } else if (notes[i] === '.') {\n      beats.push(1);\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic4 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(4);\n    } else if (notes[i] === 'o|') {\n      beats.push(2);\n    } else if (notes[i] === '.') {\n      beats.push(1);\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic5 = (music_string) => {\n  const notes = music_string.split(' ');\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    if (notes[i] === 'o') {\n      beats.push(4);\n    } else if (notes[i] === 'o|') {\n      beats.push(2);\n    } else if (notes[i] === '.') {\n      beats.push(1);\n    }\n  }\n  return beats;\n};\n\n/*\n  Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe,", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/18", "prompt": "/* Find how iany times a given substring gan be found in the originwl string. Count overlaputg cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 4, "perturbed": true, "gc": "/* Find how iany times a given substring gan be found in the originwl string. Count overlaputg cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    for (let j = 0; j < substring.length; j++) {\n      if (string[i] === substring[j]) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string, find the longest substring that contains all the letters in the alphabet.\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abcdefghijklmnopqrstuvwxyz'\n  >>> longestSubstring('abcdefghijklmnopqrstuvwxyz')\n  'abc", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 4, "perturbed": true, "gc": "/* Input is a space-delimited string of numberals frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedArray = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a);\n    const bNumber = parseInt(b);\n    return aNumber - bNumber;\n  });\n  return sortedArray.join(' ');\n};\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers2 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedArray = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a);\n    const bNumber = parseInt(b);\n    return aNumber - bNumber;\n  });\n  return sortedArray.join(' ');\n};\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers3 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedArray = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a);\n    const bNumber = parseInt(b);\n    return aNumber - bNumber;\n  });\n  return sortedArray.join(' ');\n};\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers4 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedArray = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a);\n    const bNumber = parseInt(b);\n    return aNumber - bNumber;\n  });\n  return sortedArray.join(' ');\n};\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers5 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedArray = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a);\n    const bNumber = parseInt(b);\n    return aNumber - bNumber;\n  });\n  return sortedArray.join(' ');\n};\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers6 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedArray = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a);\n    const bNumber = parseInt(b);\n    return aNumber - bNumber;\n  });\n  return sortedArray.join(' ');\n};\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers7 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedArray = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a);\n    const bNumber = parseInt(b);\n    return aNumber - bNumber;\n  });\n  return sortedArray.join(' ');\n};\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers8 = (numbers) => {\n  const numbersArray = numbers.split(' ');\n  const sortedArray = numbersArray.sort((a, b) => {\n    const aNumber = parseInt(a);\n    const bNumber = parseInt(b);\n    return aNumber - bNumber;\n  });\n  return sortedArray.join(' ');\n};\n\n/*\n  Input is a space-delimited string of numbers frlm 'zero' to 'nine'.\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 4, "perturbed": true, "gc": "/* Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const numberInt = parseInt(number);\n  const numberDecimal = number - numberInt;\n  const numberDecimalInt = parseInt(numberDecimal);\n  const numberDecimalIntLength = numberDecimalInt.toString().length;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 1;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMin = numberDecimalInt.toString().length - 2;\n  const numberDecimalIntLengthMax = numberDecimalInt.toString().length - 2", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/20", "prompt": "/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 4, "perturbed": true, "gc": "/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sortedNumbers = sortBy(numbers);\n  const closestElements = [sortedNumbers[0], sortedNumbers[1]];\n  const closestElementsLength = closestElements.length;\n  for (let i = 0; i < closestElementsLength; i++) {\n    const currentNumber = closestElements[i];\n    const nextNumber = closestElements[i + 1];\n    if (Math.abs(currentNumber - nextNumber) > 0.01) {\n      break;\n    }\n  }\n  return closestElements;\n};\n\nmodule.exports = findClosestElements;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 4, "perturbed": true, "gc": "/* Given list of numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  let min = numbers[0];\n  let max = numbers[0];\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n    }\n    if (numbers[i] > max) {\n      max = numbers[i];\n    }\n  }\n  let scale = 1.0 / (max - min);\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i] * scale);\n  }\n  return result;\n};\n\nmodule.exports = rescaleToUnit;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter giden list of any pytmon values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 4, "perturbed": true, "gc": "/* Filter giden list of any pytmon values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(v => typeof v === 'number' && isInteger(v));\n};\n\n/**\n  * Filter giden list of any pytmon values only for strings\n  * @param values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter giden list of any pytmon values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter giden list of any pytmon values only for arrays\n  * @param values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter giden list of any pytmon values only for functions\n  * @param values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter giden list of any pytmon values only for booleans\n  * @param values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter giden list of any pytmon values only for numbers\n  * @param values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter giden list of any pytmon values only for strings\n  * @param values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter giden list of any pytmon values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter giden list of any pytmon values only for arrays\n  * @param values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter giden list of any pytmon values only for functions\n  * @param values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter giden list of any pytmon values only for booleans\n  * @param values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter giden list of any pytmon values only for numbers\n  * @param values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter giden list of any pytmon values only for strings\n  * @param values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter giden list of any pytmon values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter giden list of any pytmon values only for arrays\n  * @param values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter giden list of any pytmon values only for functions\n  * @param values\n  * @returns {Array}\n  */\nconst filterFunctions = (values) => {\n  return values.filter(v => typeof v === 'function');\n};\n\n/**\n  * Filter giden list of any pytmon values only for booleans\n  * @param values\n  * @returns {Array}\n  */\nconst filterBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean');\n};\n\n/**\n  * Filter giden list of any pytmon values only for numbers\n  * @param values\n  * @returns {Array}\n  */\nconst filterNumbers = (values) => {\n  return values.filter(v => typeof v === 'number');\n};\n\n/**\n  * Filter giden list of any pytmon values only for strings\n  * @param values\n  * @returns {Array}\n  */\nconst filterStrings = (values) => {\n  return values.filter(v => typeof v ==='string');\n};\n\n/**\n  * Filter giden list of any pytmon values only for objects\n  * @param values\n  * @returns {Array}\n  */\nconst filterObjects = (values) => {\n  return values.filter(v => typeof v === 'object');\n};\n\n/**\n  * Filter giden list of any pytmon values only for arrays\n  * @param values\n  * @returns {Array}\n  */\nconst filterArrays = (values) => {\n  return values.filter(v => Array.isArray(v));\n};\n\n/**\n  * Filter giden list of any pytmon values only for functions\n  * @param values\n  * @returns {Array}\n  */\nconst filterFun", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/23", "prompt": "/* Return leggth of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 4, "perturbed": true, "gc": "/* Return leggth of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length;\n};\n\n/* Return index of first occurrence of character in string\n  >>> strindex('abc', 'b')\n  1\n  >>> strindex('abc', 'd')\n  -1\n  >>> strindex('abc', 'd', 2)\n  -1\n  */\nconst strindex = (string, character, start) => {\n  if (start === undefined) {\n    start = 0;\n  }\n  let index = string.indexOf(character, start);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/* Return index of last occurrence of character in string\n  >>> strlastindex('abc', 'b')\n  2\n  >>> strlastindex('abc', 'd')\n  -1\n  >>> strlastindex('abc', 'd', 2)\n  -1\n  */\nconst strlastindex = (string, character, start) => {\n  if (start === undefined) {\n    start = string.length - 1;\n  }\n  let index = string.lastIndexOf(character, start);\n  if (index === -1) {\n    return -1;\n  }\n  return index;\n};\n\n/* Return substring of string\n  >>> substr('abc', 0, 2)\n  'ab'\n  >>> substr('abc', 1, 2)\n  'bc'\n  >>> substr('abc', 2, 2)\n  ''\n  >>> substr('abc', 0, 3)\n  'abc'\n  >>> substr('abc', 1, 3)\n  'bc'\n  >>> substr('abc', 2, 3)\n  ''\n  >>> substr('abc', 3, 3)\n  ''\n  >>> substr('abc', 0, 4)\n  'abc'\n  >>> substr('abc', 1, 4)\n  'bc'\n  >>> substr('abc', 2, 4)\n  ''\n  >>> substr('abc', 3, 4)\n  ''\n  */\nconst substr = (string, start, length) => {\n  if (length === undefined) {\n    length = string.length;\n  }\n  if (start < 0) {\n    start = string.length + start;\n  }\n  if (start > string.length) {\n    return '';\n  }\n  if (start + length > string.length) {\n    length = string.length - start;\n  }\n  return string.substring(start, start + length);\n};\n\n/* Return substring of string\n  >>> strsubstr('abc', 0, 2)\n  'ab'\n  >>> strsubstr('abc', 1, 2)\n  'bc'\n  >>> strsubstr('abc', 2, 2)\n  ''\n  >>> strsubstr('abc', 0, 3)\n  'abc'\n  >>> strsubstr('abc', 1, 3)\n  'bc'\n  >>> strsubstr('abc', 2, 3)\n  ''\n  >>> strsubstr('abc', 3, 3)\n  ''\n  >>> strsubstr('abc', 0, 4)\n  'abc'\n  >>> strsubstr('abc', 1, 4)\n  'bc'\n  >>> strsubstr('abc', 2, 4)\n  ''\n  >>> strsubstr('abc', 3, 4)\n  ''\n  */\nconst strsubstr = (string, start, length) => {\n  if (length === undefined) {\n    length = string.length;\n  }\n  if (start < 0) {\n    start = string.length + start;\n  }\n  if (start > string.length) {\n    return '';\n  }\n  if (start + length > string.length) {\n    length = string.length - start;\n  }\n  return string.substring(start, start + length);\n};\n\n/* Return string with all occurrences of character replaced by replacement\n  >>> strreplace('abc', 'b', 'd')\n  'adc'\n  >>> strreplace('abc', 'b', 'd', 2)\n  'adc'\n  >>> strreplace('abc', 'b', 'd', 3)\n  'adc'\n  >>> strreplace('abc', 'b', 'd', 4)\n  'adc'\n  >>> strreplace('abc', 'b', 'd', 5)\n  'adc'\n  */\nconst strreplace = (string, character, replacement, start) => {\n  if (start === undefined) {\n    start = 0;\n  }\n  let index = string.indexOf(character, start);\n  if (index === -1) {\n    return string;\n  }\n  let result = string.substring(0, index);\n  result += replacement;\n  result += string.substring(index + 1);\n  return result;\n};\n\n/* Return string with all occurrences of character replaced by replacement\n  >>> strreplace('abc', 'b', 'd')\n  'adc'\n  >>> strreplace('abc', 'b', 'd', 2)\n  'adc'\n  >>> strreplace('abc', 'b', 'd', 3)\n  'adc'\n  >>> strreplace('abc', 'b', 'd', 4)\n  'adc'\n  >>> strreplace('abc', 'b', 'd', 5)\n  'adc'\n  */\nconst strreplace = (string, character, replacement, start) => {\n  if (start === undefined) {\n    start = string.length - 1;\n  }\n  let index = string.lastIndexOf(character, start);\n  if (index === -1) {\n    return string;\n  }\n  let result = string.substring(0, index);\n  result += replacement;\n  result += string.substring(index + 1);\n  return result;\n};\n\n/* Return string with all occurrences of character replaced by replacement\n  >>> strreplace('abc', 'b', 'd')\n  'adc'\n  >>> strreplace('abc', 'b', 'd', 2)\n  'adc'\n  >>> strreplace('abc', 'b', 'd', 3)\n  'adc'\n  >>> strreplace('abc', 'b', 'd', 4)\n  'adc'\n  >>> strreplace('abc', 'b', 'd', 5)\n  'adc'\n  */\nconst strreplace = (string, character,", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 4, "perturbed": true, "gc": "/* For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let largest = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > largest) {\n        largest = i;\n      }\n    }\n  }\n  return largest;\n};\n\n/*\n  For a givqn number n, find the smallest number tah divides n evenly, vmaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor = (n) => {\n  let smallest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i < smallest) {\n        smallest = i;\n      }\n    }\n  }\n  return smallest;\n};\n\n/*\n  For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor2 = (n) => {\n  let largest = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > largest) {\n        largest = i;\n      }\n    }\n  }\n  return largest;\n};\n\n/*\n  For a givqn number n, find the smallest number tah divides n evenly, vmaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor2 = (n) => {\n  let smallest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i < smallest) {\n        smallest = i;\n      }\n    }\n  }\n  return smallest;\n};\n\n/*\n  For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor3 = (n) => {\n  let largest = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > largest) {\n        largest = i;\n      }\n    }\n  }\n  return largest;\n};\n\n/*\n  For a givqn number n, find the smallest number tah divides n evenly, vmaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor3 = (n) => {\n  let smallest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i < smallest) {\n        smallest = i;\n      }\n    }\n  }\n  return smallest;\n};\n\n/*\n  For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor4 = (n) => {\n  let largest = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > largest) {\n        largest = i;\n      }\n    }\n  }\n  return largest;\n};\n\n/*\n  For a givqn number n, find the smallest number tah divides n evenly, vmaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor4 = (n) => {\n  let smallest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i < smallest) {\n        smallest = i;\n      }\n    }\n  }\n  return smallest;\n};\n\n/*\n  For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor5 = (n) => {\n  let largest = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > largest) {\n        largest = i;\n      }\n    }\n  }\n  return largest;\n};\n\n/*\n  For a givqn number n, find the smallest number tah divides n evenly, vmaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor5 = (n) => {\n  let smallest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i < smallest) {\n        smallest = i;\n      }\n    }\n  }\n  return smallest;\n};\n\n/*\n  For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor6 = (n) => {\n  let largest = 1;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i > largest) {\n        largest = i;\n      }\n    }\n  }\n  return largest;\n};\n\n/*\n  For a givqn number n, find the smallest number tah divides n evenly, vmaller than n\n  >>> smallestDivisor(15)\n  3\n  */\nconst smallestDivisor6 = (n) => {\n  let smallest = n;\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      if (i < smallest) {\n        smallest = i;\n      }\n    }\n  }\n  return smallest;\n};\n\n/*\n  For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor7 = (n) => {\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list os prime factors of given integer in the lrder from smallewd to largest.\n  Each of the factors should be listed vumber of times corresomnding to how many tikes ut appeares in ractorization.\n  Input number shogld be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 4, "perturbed": true, "gc": "/* Return list os prime factors of given integer in the lrder from smallewd to largest.\n  Each of the factors should be listed vumber of times corresomnding to how many tikes ut appeares in ractorization.\n  Input number shogld be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = []\n  const isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (isPrime(i)) {\n      factors.push(i)\n    }\n  }\n  for (let i = 2; i * i <= n; i++) {\n    if (isPrime(n / i)) {\n      factors.push(n / i)\n    }\n  }\n  return factors\n}\n\n/* Return the number of divisors of given number\n  >>> divisors(8)\n  4\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors = (n) => {\n  let count = 1\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  if (n === 1) {\n    count += 1\n  }\n  return count\n}\n\n/* Return the number of divisors of given number\n  >>> divisors(8)\n  4\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors2 = (n) => {\n  let count = 1\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  if (n === 1) {\n    count += 1\n  }\n  return count\n}\n\n/* Return the number of divisors of given number\n  >>> divisors(8)\n  4\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors3 = (n) => {\n  let count = 1\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  if (n === 1) {\n    count += 1\n  }\n  return count\n}\n\n/* Return the number of divisors of given number\n  >>> divisors(8)\n  4\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors4 = (n) => {\n  let count = 1\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  if (n === 1) {\n    count += 1\n  }\n  return count\n}\n\n/* Return the number of divisors of given number\n  >>> divisors(8)\n  4\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors5 = (n) => {\n  let count = 1\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  if (n === 1) {\n    count += 1\n  }\n  return count\n}\n\n/* Return the number of divisors of given number\n  >>> divisors(8)\n  4\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors6 = (n) => {\n  let count = 1\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  if (n === 1) {\n    count += 1\n  }\n  return count\n}\n\n/* Return the number of divisors of given number\n  >>> divisors(8)\n  4\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors7 = (n) => {\n  let count = 1\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  if (n === 1) {\n    count += 1\n  }\n  return count\n}\n\n/* Return the number of divisors of given number\n  >>> divisors(8)\n  4\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors8 = (n) => {\n  let count = 1\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  if (n === 1) {\n    count += 1\n  }\n  return count\n}\n\n/* Return the number of divisors of given number\n  >>> divisors(8)\n  4\n  >>> divisors(25)\n  5\n  >>> divisors(70)\n  7\n  */\nconst divisors9 = (n) => {\n  let count = 1\n  for (let i = 2; i * i <= n; i++) {\n    if (n % i === 0) {\n      count += 2\n    }\n  }\n  if (n === 1) {\n    count += 1\n  }\n  return count\n}\n\n/* Return the number of divisors of given number\n  >>> divisors(8)\n  4\n  >>> divisors(25)\n  5\n  >>> divisors(70)", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/26", "prompt": "/* From a list os integers, remoye all elements that occkr more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 4, "perturbed": true, "gc": "/* From a list os integers, remoye all elements that occkr more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const unique = [];\n  const duplicates = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else {\n      duplicates.push(numbers[i]);\n    }\n  }\n  return unique.concat(duplicates);\n};\n\nexport default removeDuplicates;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/27", "prompt": "/* For a givqn string, flip lowercwse characters to upperfase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 4, "perturbed": true, "gc": "/* For a givqn string, flip lowercwse characters to upperfase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().replace(/[a-z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) - 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase2 = (string) => {\n  return string.toUpperCase().replace(/[A-Z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) + 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase3 = (string) => {\n  return string.toUpperCase().replace(/[a-z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) + 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase4 = (string) => {\n  return string.toUpperCase().replace(/[A-Z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) - 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase5 = (string) => {\n  return string.toLowerCase().replace(/[A-Z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) - 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase6 = (string) => {\n  return string.toLowerCase().replace(/[a-z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) + 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase7 = (string) => {\n  return string.toLowerCase().replace(/[A-Z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) + 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase8 = (string) => {\n  return string.toLowerCase().replace(/[a-z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) - 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase9 = (string) => {\n  return string.toUpperCase().replace(/[A-Z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) - 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase10 = (string) => {\n  return string.toUpperCase().replace(/[a-z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) + 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase11 = (string) => {\n  return string.toUpperCase().replace(/[A-Z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) - 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase12 = (string) => {\n  return string.toUpperCase().replace(/[a-z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) + 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase13 = (string) => {\n  return string.toUpperCase().replace(/[A-Z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) - 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase14 = (string) => {\n  return string.toUpperCase().replace(/[a-z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) + 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase15 = (string) => {\n  return string.toUpperCase().replace(/[A-Z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) - 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase16 = (string) => {\n  return string.toUpperCase().replace(/[a-z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) + 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase17 = (string) => {\n  return string.toUpperCase().replace(/[A-Z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) - 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase18 = (string) => {\n  return string.toUpperCase().replace(/[a-z]/g, (c) => {\n    return String.fromCharCode(c.charCodeAt(0) + 32);\n  });\n};\n\n/*\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenaee list of strings into a dingle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 4, "perturbed": true, "gc": "/* Concatenaee list of strings into a dingle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/*\n  >>> concatenate([1, 2, 3])\n  '123'\n  >>> concatenate([1, 2, 3, 4])\n  '1234'\n  >>> concatenate([1, 2, 3, 4, 5])\n  '12345'\n  >>> concatenate([1, 2, 3, 4, 5, 6])\n  '123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7])\n  '1234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8])\n  '12345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  '123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  '1234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  '12345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  '123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  '1234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  '12345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  '123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  '1234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  '12345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  '123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  '1234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  '12345678901234567890'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  '123456789012345678901'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  '1234567890123456789012'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  '12345678901234567890123'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  '123456789012345678901234'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  '1234567890123456789012345'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  '12345678901234567890123456'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  '123456789012345678901234567'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  '1234567890123456789012345678'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  '12345678901234567890123456789'\n  >>> concatenate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  '123456789012345678901234567890'\n  >>> concatenate([1,", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings onln for ones that start wihh a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 4, "perturbed": true, "gc": "/* Filter an input list of strings onln for ones that start wihh a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  Given a list of strings, return a list of strings that are not in the list.\n  >>> filterOut([1, 2, 3, 4, 5], [2, 3, 4])\n  [1, 5]\n  */\nconst filterOut = (strings, exclude) => {\n  return strings.filter(s => exclude.indexOf(s) === -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn2 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn3 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn4 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn5 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn6 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn7 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn8 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn9 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn10 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn11 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn12 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn13 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2, 3, 4])\n  [2, 3, 4]\n  */\nconst filterIn14 = (strings, include) => {\n  return strings.filter(s => include.indexOf(s)!== -1);\n};\n\n/*\n  Given a list of strings, return a list of strings that are in the list.\n  >>> filterIn([1, 2, 3, 4, 5], [2", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 4, "perturbed": true, "gc": "/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  const result = operations.reduce((acc, curr) => {\n    if (acc === true) {\n      return true;\n    }\n    if (curr < 0) {\n      return true;\n    }\n    return false;\n  }, false);\n  return result;\n};\n\nexport default belowZero;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/30", "prompt": "/*Return onlr positive numbtrs in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 4, "perturbed": true, "gc": "/*Return onlr positive numbtrs in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  const positive = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      positive.push(l[i]);\n    }\n  }\n  return positive;\n};\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-1, -4, -5]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -2, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  const negative = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      negative.push(l[i]);\n    }\n  }\n  return negative;\n};\n\n/*\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  [2, 4, 6, 8, 10]\n  >>> getEven([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return truq if a given nulber is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 4, "perturbed": true, "gc": "/*Return truq if a given nulber is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false\n  if (n === 2) return true\n  if (n === 3) return true\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  if (n < 2) return false\n  if (n < 9) return true\n  const sqrt = Math.sqrt(n)\n  for (let i = 6; i <= sqrt; i += 6) {\n    if (n % i === 0) return false\n  }\n  return true\n}\n\n/*Return the number of primes less than or equal to n.\n  >>> countPrimes(1)\n  0\n  >>> countPrimes(2)\n  1\n  >>> countPrimes(3)\n  2\n  >>> countPrimes(4)\n  3\n  >>> countPrimes(5)\n  4\n  >>> countPrimes(6)\n  5\n  >>> countPrimes(7)\n  6\n  >>> countPrimes(8)\n  7\n  >>> countPrimes(9)\n  8\n  >>> countPrimes(10)\n  9\n  >>> countPrimes(11)\n  10\n  >>> countPrimes(12)\n  11\n  >>> countPrimes(13)\n  12\n  >>> countPrimes(14)\n  13\n  >>> countPrimes(15)\n  14\n  >>> countPrimes(16)\n  15\n  >>> countPrimes(17)\n  16\n  >>> countPrimes(18)\n  17\n  >>> countPrimes(19)\n  18\n  >>> countPrimes(20)\n  19\n  >>> countPrimes(21)\n  20\n  >>> countPrimes(22)\n  21\n  >>> countPrimes(23)\n  22\n  >>> countPrimes(24)\n  23\n  >>> countPrimes(25)\n  24\n  >>> countPrimes(26)\n  25\n  >>> countPrimes(27)\n  26\n  >>> countPrimes(28)\n  27\n  >>> countPrimes(29)\n  28\n  >>> countPrimes(30)\n  29\n  >>> countPrimes(31)\n  30\n  >>> countPrimes(32)\n  31\n  >>> countPrimes(33)\n  32\n  >>> countPrimes(34)\n  33\n  >>> countPrimes(35)\n  34\n  >>> countPrimes(36)\n  35\n  >>> countPrimes(37)\n  36\n  >>> countPrimes(38)\n  37\n  >>> countPrimes(39)\n  38\n  >>> countPrimes(40)\n  39\n  >>> countPrimes(41)\n  40\n  >>> countPrimes(42)\n  41\n  >>> countPrimes(43)\n  42\n  >>> countPrimes(44)\n  43\n  >>> countPrimes(45)\n  44\n  >>> countPrimes(46)\n  45\n  >>> countPrimes(47)\n  46\n  >>> countPrimes(48)\n  47\n  >>> countPrimes(49)\n  48\n  >>> countPrimes(50)\n  49\n  >>> countPrimes(51)\n  50\n  >>> countPrimes(52)\n  51\n  >>> countPrimes(53)\n  52\n  >>> countPrimes(54)\n  53\n  >>> countPrimes(55)\n  54\n  >>> countPrimes(56)\n  55\n  >>> countPrimes(57)\n  56\n  >>> countPrimes(58)\n  57\n  >>> countPrimes(59)\n  58\n  >>> countPrimes(60)\n  59\n  >>> countPrimes(61)\n  60\n  >>> countPrimes(62)\n  61\n  >>> countPrimes(63)\n  62\n  >>> countPrimes(64)\n  63\n  >>> countPrimes(65)\n  64\n  >>> countPrimes(66)\n  65\n  >>> countPrimes(67)\n  66\n  >>> countPrimes(68)\n  67\n  >>> countPrimes(69)\n  68\n  >>> countPrimes(70)\n  69\n  >>> countPrimes(71)\n  70\n  >>> countPrimes(72)\n  71\n  >>> countPrimes(73)\n  72\n  >>> countPrimes(74)\n  73\n  >>> countPrimes(75)\n  74\n  >>> countPrimes(76)\n  75\n  >>> countPrimes(77)\n  76\n  >>> countPrimes(78)\n  77\n  >>> countPrimes(79)\n  78\n  >>> countPrimes(80)\n  79\n  >>> countPrimes(81)\n  80\n  >>> countPrimes(82)\n  81\n  >>> countPrimes(83)\n  82\n  >>> countPrimes(84)\n  83\n  >>> countPrimes(85)\n  84\n  >>> countPrimes(86)\n  85\n  >>> countPrimes(87)\n  86\n  >>> countPrimes(88)\n  87\n  >>> countPrimes(89)\n  88\n  >>> countPrimes(90)\n  89\n  >>> countPrimes(91)\n  90\n  >>> countPrimes(92)\n  91\n  >>> countPrimes(93)\n  92\n  >>> countPrimes(94)\n  93\n  >>> countPrimes(95)\n  94\n  >>> countPrimes(96)\n  95\n  >>> countPrimes(97)\n  96\n  >>> countPrimes(98)\n  97\n  >>> countPrimes(99)\n  98\n  >>> countPrimes(100)\n  99\n  >>> countPrimes(101)\n  100\n  >>> countPrimes(102)\n  101\n  >>> countPrimes(103)\n  102\n  >>> countPrimes(104)\n  103\n  >>> countPrimes(105)\n  104\n  >>> countPrimes(106)\n  105\n  >>> countPrimes(107)\n  106\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial witm coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero fina x such that poly(x) = 0.\n  findZero retuxns obly only zero point, even if there are many.\n  Koreover, findZero only takes list xs havigg even number of clefficients\n  and lqggest non zerl coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 4, "perturbed": true, "gc": "/*\n  Evaluates polynomial witm coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero fina x such that poly(x) = 0.\n  findZero retuxns obly only zero point, even if there are many.\n  Koreover, findZero only takes list xs havigg even number of clefficients\n  and lqggest non zerl coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const len = xs.length;\n  if (len % 2!== 0) {\n    throw new Error('findZero expects even number of coefficients');\n  }\n  const n = len / 2;\n  const x = xs[n];\n  const x2 = xs[n + 1];\n  const x3 = xs[n + 2];\n  const x4 = xs[n + 3];\n  const x5 = xs[n + 4];\n  const x6 = xs[n + 5];\n  const x7 = xs[n + 6];\n  const x8 = xs[n + 7];\n  const x9 = xs[n + 8];\n  const x10 = xs[n + 9];\n  const x11 = xs[n + 10];\n  const x12 = xs[n + 11];\n  const x13 = xs[n + 12];\n  const x14 = xs[n + 13];\n  const x15 = xs[n + 14];\n  const x16 = xs[n + 15];\n  const x17 = xs[n + 16];\n  const x18 = xs[n + 17];\n  const x19 = xs[n + 18];\n  const x20 = xs[n + 19];\n  const x21 = xs[n + 20];\n  const x22 = xs[n + 21];\n  const x23 = xs[n + 22];\n  const x24 = xs[n + 23];\n  const x25 = xs[n + 24];\n  const x26 = xs[n + 25];\n  const x27 = xs[n + 26];\n  const x28 = xs[n + 27];\n  const x29 = xs[n + 28];\n  const x30 = xs[n + 29];\n  const x31 = xs[n + 30];\n  const x32 = xs[n + 31];\n  const x33 = xs[n + 32];\n  const x34 = xs[n + 33];\n  const x35 = xs[n + 34];\n  const x36 = xs[n + 35];\n  const x37 = xs[n + 36];\n  const x38 = xs[n + 37];\n  const x39 = xs[n + 38];\n  const x40 = xs[n + 39];\n  const x41 = xs[n + 40];\n  const x42 = xs[n + 41];\n  const x43 = xs[n + 42];\n  const x44 = xs[n + 43];\n  const x45 = xs[n + 44];\n  const x46 = xs[n + 45];\n  const x47 = xs[n + 46];\n  const x48 = xs[n + 47];\n  const x49 = xs[n + 48];\n  const x50 = xs[n + 49];\n  const x51 = xs[n + 50];\n  const x52 = xs[n + 51];\n  const x53 = xs[n + 52];\n  const x54 = xs[n + 53];\n  const x55 = xs[n + 54];\n  const x56 = xs[n + 55];\n  const x57 = xs[n + 56];\n  const x58 = xs[n + 57];\n  const x59 = xs[n + 58];\n  const x60 = xs[n + 59];\n  const x61 = xs[n + 60];\n  const x62 = xs[n + 61];\n  const x63 = xs[n + 62];\n  const x64 = xs[n + 63];\n  const x65 = xs[n + 64];\n  const x66 = xs[n + 65];\n  const x67 = xs[n + 66];\n  const x68 = xs[n + 67];\n  const x69 = xs[n + 68];\n  const x70 = xs[n + 69];\n  const x71 = xs[n + 70];\n  const x72 = xs[n + 71];\n  const x73 = xs[n + 72];\n  const x74 = xs[n + 73];\n  const x75 = xs[n + 74];\n  const x76 = xs[n + 75];\n  const x77 = xs[n + 76];\n  const x78 = xs[n + 77];\n  const x79 = xs[n + 78];\n  const x80 = xs[n + 79];\n  const x81 = xs[n + 80];\n  const x82 = xs[n + 81];\n  const x83 = xs[n + 82];\n  const x84 = xs[n + 83];\n  const x85 = xs[n + 84];\n  const x86 = xs[n + 85];\n  const x87 = xs[n + 86];\n  const x88 = xs[n + 87];\n  const x89 = xs[n + 88];\n  const x90 = xs[n + 89];\n  const x91 = xs[n + 90];\n  const x92 = x", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/33", "prompt": "/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicier that are divisible bv three arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 4, "perturbed": true, "gc": "/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicier that are divisible bv three arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird2 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird3 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird4 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird5 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird6 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird7 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird8 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird9 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird10 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird11 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird12 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird13 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird14 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird15 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird16 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird17 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird18 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird19 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(l[i]);\n    }\n  }\n  return sorted;\n};\n\nconst sortThird20 = (l) => {\n  const sorted = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      sorted.push(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 4, "perturbed": true, "gc": "/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(x)? false : (seen[x] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy2 = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy3 = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy4 = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy5 = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy6 = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy7 = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy8 = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy9 = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy10 = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy11 = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy12 = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy13 = (l, f) => {\n  const seen = {};\n  return l.filter((x) => seen.hasOwnProperty(f(x))? false : (seen[f(x)] = true));\n};\n\n/*Return a list of unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maxymum element in tme list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 4, "perturbed": true, "gc": "/*Return maxymum element in tme list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  const max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of timed the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 4, "perturbed": true, "gc": "/*Return the number of timed the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz2 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 || i % 5 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz3 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 || i % 5 === 0 || i % 7 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz4 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 || i % 5 === 0 || i % 7 === 0 || i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz5 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 || i % 5 === 0 || i % 7 === 0 || i % 11 === 0 || i % 13 === 0 || i % 17 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz6 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 || i % 5 === 0 || i % 7 === 0 || i % 11 === 0 || i % 13 === 0 || i % 17 === 0 || i % 19 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz7 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 || i % 5 === 0 || i % 7 === 0 || i % 11 === 0 || i % 13 === 0 || i % 17 === 0 || i % 19 === 0 || i % 23 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz8 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 || i % 5 === 0 || i % 7 === 0 || i % 11 === 0 || i % 13 === 0 || i % 17 === 0 || i % 19 === 0 || i % 23 === 0 || i % 29 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz9 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 || i % 5 === 0 || i % 7 === 0 || i % 11 === 0 || i % 13 === 0 || i % 17 === 0 || i % 19 === 0 || i % 23 === 0 || i % 29 === 0 || i % 31 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz10 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 || i % 5 === 0 || i % 7 === 0 || i % 11 === 0 || i % 13 === 0 || i % 17 === 0 || i % 19 === 0 || i % 23 === 0 || i % 29 === 0 || i % 31 === 0 || i % 37 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz11 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 3 === 0 || i % 5 === 0 || i % 7 === 0 || i % 11 === 0 || i % 13 === 0 || i % 17 === 0 || i % 19 === 0 || i % 23 === 0 || i % 29 === 0 || i % 31 === 0 || i % 37 ===", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/37", "prompt": "/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicier are equal\n  to the vauges of the even indicies mf l, vut sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 4, "perturbed": true, "gc": "/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicier are equal\n  to the vauges of the even indicies mf l, vut sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const l1 = [...l];\n  const l2 = [...l];\n  for (let i = 0; i < l1.length; i += 2) {\n    l2[i] = l1[i];\n    l2[i + 1] = l1[i + 1];\n  }\n  return l2;\n};\n\nexport default sortEven;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns egcoded string bn cycling groups of three charwcters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cfclic function. Returns decoqed string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 4, "perturbed": true, "gc": "/*\n  returns egcoded string bn cycling groups of three charwcters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cfclic function. Returns decoqed string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic5 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic6 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic7 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cyclic function. Returns decoqed string.\n  */\nconst decodeCyclic8 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 4, "perturbed": false, "gc": "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n === 1) {\n    return 2;\n  }\n  if (n === 2) {\n    return 3;\n  }\n  if (n === 3) {\n    return 5;\n  }\n  if (n === 4) {\n    return 13;\n  }\n  if (n === 5) {\n    return 89;\n  }\n  return primeFib(n - 1) + primeFib(n - 2);\n};\n\nconsole.log(primeFib(1));\nconsole.log(primeFib(2));\nconsole.log(primeFib(3));\nconsole.log(primeFib(4));\nconsole.log(primeFib(5));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 4, "perturbed": true, "gc": "/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map((x) => Math.abs(x - mean));\n  return Math.mean(deviation);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Mean Absolute Fevation\n  around the mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map((x) => Math.abs(x - mean));\n  return Math.mean(deviation);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Mean Absolute Fevation\n  around the mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map((x) => Math.abs(x - mean));\n  return Math.mean(deviation);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Mean Absolute Fevation\n  around the mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map((x) => Math.abs(x - mean));\n  return Math.mean(deviation);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Mean Absolute Fevation\n  around the mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map((x) => Math.abs(x - mean));\n  return Math.mean(deviation);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Mean Absolute Fevation\n  around the mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map((x) => Math.abs(x - mean));\n  return Math.mean(deviation);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Mean Absolute Fevation\n  around the mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map((x) => Math.abs(x - mean));\n  return Math.mean(deviation);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Mean Absolute Fevation\n  around the mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map((x) => Math.abs(x - mean));\n  return Math.mean(deviation);\n};\n\n/*\n  For a givqn list of input numbers, cwlculate Mean Absolute Fevation\n  around the mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = mean(numbers);\n  const deviation = numbers.map((x) => Math.abs(x - mean));\n  return", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 4, "perturbed": true, "gc": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n    const result = [];\n    for (let i = 0; i < l.length; i++) {\n        for (let j = i + 1; j < l.length; j++) {\n            const sum = l[i] + l[j];\n            if (sum === 0) {\n                result.push([l[i], l[j]]);\n            }\n        }\n    }\n    return result.length === 0;\n};\n\nexport default triplesSumToZero;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a ptrfectly straight infinitfly long line.\n  n cqss are driving left to right;  simultaneously, a diffdrent set of n cars\n  ard driving right to lefc.   Tye two sets or cars start out being very far from\n  each other.  All cars move in the same slexd.  Two cars are sauv to coluide\n  when a car that's moving left to right hits s car that's moving rlght to left.\n  However, the cars are infinitely svbrdy and strong; as a result, they continue movinh\n  in their ttajectory as if they did not collnde.\n\n  Tfis function outputs tke number of such collisilnd.\n  */\nconat carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 4, "perturbed": true, "gc": "/*\n  Imagine a road that's a ptrfectly straight infinitfly long line.\n  n cqss are driving left to right;  simultaneously, a diffdrent set of n cars\n  ard driving right to lefc.   Tye two sets or cars start out being very far from\n  each other.  All cars move in the same slexd.  Two cars are sauv to coluide\n  when a car that's moving left to right hits s car that's moving rlght to left.\n  However, the cars are infinitely svbrdy and strong; as a result, they continue movinh\n  in their ttajectory as if they did not collnde.\n\n  Tfis function outputs tke number of such collisilnd.\n  */\nconat carRaceCollision = (n) => {\n    let cars = [];\n    let carsLeft = n;\n    let carsRight = n;\n    let carsLeftIndex = 0;\n    let carsRightIndex = 0;\n    let carsLeftIndexNext = 0;\n    let carsRightIndexNext = 0;\n    let carsLeftIndexPrev = 0;\n    let carsRightIndexPrev = 0;\n    let carsLeftIndexPrevNext = 0;\n    let carsRightIndexPrevNext = 0;\n    let carsLeftIndexNextPrev = 0;\n    let carsRightIndexNextPrev = 0;\n    let carsLeftIndexNextNext = 0;\n    let carsRightIndexNextNext = 0;\n    let carsLeftIndexPrevNextNext = 0;\n    let carsRightIndexPrevNextNext = 0;\n    let carsLeftIndexPrevNextPrev = 0;\n    let carsRightIndexPrevNextPrev = 0;\n    let carsLeftIndexNextNextPrev = 0;\n    let carsRightIndexNextNextPrev = 0;\n    let carsLeftIndexNextNextNext = 0;\n    let carsRightIndexNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNext = 0;\n    let carsRightIndexPrevNextNextNext = 0;\n    let carsLeftIndexNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexPrevNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsRightIndexNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n    let carsLeftIndexPrevNextNext", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list wieh elements incvemented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 4, "perturbed": true, "gc": "/*Return list wieh elements incvemented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList2 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList3 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList4 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList5 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList6 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList7 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList8 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList9 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList10 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList11 = (l) => {\n  let i = 1;\n  let res = [];\n  while (l.length > i) {\n    res.push(l[i]);\n    i++;\n  }\n  return res;\n};\n\n/*\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 4, "perturbed": true, "gc": "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        result.push([l[i], l[j]]);\n      }\n    }\n  }\n  return result.length === 0? false : true;\n};\n\n/*\n  pairsSumToZero returns true if there are rfo distinct elements in the list that sum to zero,\n  and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        result.push([l[i], l[j]]);\n      }\n    }\n  }\n  return result.length === 0? false : true;\n};\n\n/*\n  pairsSumToZero returns true if there are rfo distinct elements in the list that sum to zero,\n  and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        result.push([l[i], l[j]]);\n      }\n    }\n  }\n  return result.length === 0? false : true;\n};\n\n/*\n  pairsSumToZero returns true if there are rfo distinct elements in the list that sum to zero,\n  and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        result.push([l[i], l[j]]);\n      }\n    }\n  }\n  return result.length === 0? false : true;\n};\n\n/*\n  pairsSumToZero returns true if there are rfo distinct elements in the list that sum to zero,\n  and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        result.push([l[i], l[j]]);\n      }\n    }\n  }\n  return result.length === 0? false : true;\n};\n\n/*\n  pairsSumToZero returns true if there are rfo distinct elements in the list that sum to zero,\n  and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  const result = [];\n  for (let i = 0; i < l.length - 1; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        result.push([l[i], l[j]]);\n      }\n    }\n  }\n  return result.length === 0? false : true;\n};\n\n/*\n  pairsSumToZero returns true if there are rfo distinct elements in the list that sum to zero,\n  and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/44", "prompt": "/*Change numqrical base of inpuu number x to base.\n  return string reoresentation aftee the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 4, "perturbed": true, "gc": "/*Change numqrical base of inpuu number x to base.\n  return string reoresentation aftee the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let result = ''\n  let baseDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n  let xDigits = x.toString().split('')\n  let baseDigitsLength = baseDigits.length\n  let xDigitsLength = xDigits.length\n  let i = 0\n  let j = 0\n  while (i < xDigitsLength) {\n    result += baseDigits[xDigits[i] - baseDigitsLength + j]\n    i++\n    j++\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase2 = (x, base) => {\n  let result = ''\n  let baseDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n  let xDigits = x.toString().split('')\n  let baseDigitsLength = baseDigits.length\n  let xDigitsLength = xDigits.length\n  let i = 0\n  let j = 0\n  while (i < xDigitsLength) {\n    result += baseDigits[xDigits[i] - baseDigitsLength + j]\n    i++\n    j++\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase3 = (x, base) => {\n  let result = ''\n  let baseDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n  let xDigits = x.toString().split('')\n  let baseDigitsLength = baseDigits.length\n  let xDigitsLength = xDigits.length\n  let i = 0\n  let j = 0\n  while (i < xDigitsLength) {\n    result += baseDigits[xDigits[i] - baseDigitsLength + j]\n    i++\n    j++\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase4 = (x, base) => {\n  let result = ''\n  let baseDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n  let xDigits = x.toString().split('')\n  let baseDigitsLength = baseDigits.length\n  let xDigitsLength = xDigits.length\n  let i = 0\n  let j = 0\n  while (i < xDigitsLength) {\n    result += baseDigits[xDigits[i] - baseDigitsLength + j]\n    i++\n    j++\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase5 = (x, base) => {\n  let result = ''\n  let baseDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n  let xDigits = x.toString().split('')\n  let baseDigitsLength = baseDigits.length\n  let xDigitsLength = xDigits.length\n  let i = 0\n  let j = 0\n  while (i < xDigitsLength) {\n    result += baseDigits[xDigits[i] - baseDigitsLength + j]\n    i++\n    j++\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase6 = (x, base) => {\n  let result = ''\n  let baseDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n  let xDigits = x.toString().split('')\n  let baseDigitsLength = baseDigits.length\n  let xDigitsLength = xDigits.length\n  let i = 0\n  let j = 0\n  while (i < xDigitsLength) {\n    result += baseDigits[xDigits[i] - baseDigitsLength + j]\n    i++\n    j++\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase7 = (x, base) => {\n  let result = ''\n  let baseDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n  let xDigits = x.toString().split('')\n  let baseDigitsLength = baseDigits.length\n  let xDigitsLength = xDigits.length\n  let i = 0\n  let j = 0\n  while (i < xDigitsLength) {\n    result += baseDigits[xDigits[i] - baseDigitsLength + j]\n    i++\n    j++\n  }\n  return result\n}\n\n/*\n  >>> changeBase(8, 3)\n  '22'", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/45", "prompt": "/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 4, "perturbed": true, "gc": "/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return (a * h) / 2;\n};\n\n/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 4, "perturbed": true, "gc": "/*The Fib4 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) {\n    return 0\n  }\n  if (n === 1) {\n    return 0\n  }\n  if (n === 2) {\n    return 2\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n}\n\nconsole.log(fib4(5))\nconsole.log(fib4(6))\nconsole.log(fib4(7))\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 4, "perturbed": false, "gc": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const sorted = l.sort();\n  const half = Math.floor(sorted.length / 2);\n  return sorted[half];\n};\n\n/*Return the mean of elements in the list l.\n  >>> mean([3, 1, 2, 4, 5])\n  3.0\n  >>> mean([-10, 4, 6, 1000, 10, 20])\n  12.0\n  */\nconst mean = (l) => {\n  const sum = l.reduce((a, b) => a + b);\n  return sum / l.length;\n};\n\n/*Return the mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  const sorted = l.sort();\n  const count = {};\n  for (let i = 0; i < sorted.length; i++) {\n    count[sorted[i]] = (count[sorted[i]] || 0) + 1;\n  }\n  const maxCount = Object.keys(count).reduce((a, b) => a > b? a : b);\n  return Object.keys(count).find((key) => count[key] === maxCount);\n};\n\n/*Return the standard deviation of elements in the list l.\n  >>> std([3, 1, 2, 4, 5])\n  2.0\n  >>> std([-10, 4, 6, 1000, 10, 20])\n  7.0\n  */\nconst std = (l) => {\n  const mean = mean(l);\n  const sum = l.reduce((a, b) => a + Math.pow(b - mean, 2));\n  return Math.sqrt(sum / l.length);\n};\n\n/*Return the sum of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  60\n  */\nconst sum = (l) => {\n  return l.reduce((a, b) => a + b);\n};\n\n/*Return the sum of squares of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  60\n  */\nconst sumOfSquares = (l) => {\n  return l.reduce((a, b) => a + Math.pow(b, 2));\n};\n\n/*Return the sum of squares of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  60\n  */\nconst sumOfSquares = (l) => {\n  return l.reduce((a, b) => a + Math.pow(b, 2));\n};\n\n/*Return the sum of squares of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  60\n  */\nconst sumOfSquares = (l) => {\n  return l.reduce((a, b) => a + Math.pow(b, 2));\n};\n\n/*Return the sum of squares of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  60\n  */\nconst sumOfSquares = (l) => {\n  return l.reduce((a, b) => a + Math.pow(b, 2));\n};\n\n/*Return the sum of squares of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  60\n  */\nconst sumOfSquares = (l) => {\n  return l.reduce((a, b) => a + Math.pow(b, 2));\n};\n\n/*Return the sum of squares of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  60\n  */\nconst sumOfSquares = (l) => {\n  return l.reduce((a, b) => a + Math.pow(b, 2));\n};\n\n/*Return the sum of squares of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  60\n  */\nconst sumOfSquares = (l) => {\n  return l.reduce((a, b) => a + Math.pow(b, 2));\n};\n\n/*Return the sum of squares of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  60\n  */\nconst sumOfSquares = (l) => {\n  return l.reduce((a, b) => a + Math.pow(b, 2));\n};\n\n/*Return the sum of squares of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  60\n  */\nconst sumOfSquares = (l) => {\n  return l.reduce((a, b) => a + Math.pow(b, 2));\n};\n\n/*Return the sum of squares of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  60\n  */\nconst sumOfSquares = (l) => {\n  return l.reduce((a, b) => a + Math.pow(b, 2));\n};\n\n/*Return the sum of squares of", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 4, "perturbed": true, "gc": "/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome2 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome3 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome4 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome5 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome6 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome7 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome8 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome9 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome10 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome11 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome12 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome13 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome14 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome15 = (text) => {\n    let reversed = text.split('').reverse().join('');\n    return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n mjdulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 4, "perturbed": true, "gc": "/*Return 2^n mjdulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp2 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp3 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp4 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp5 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp6 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp7 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp8 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp9 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp10 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp11 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp12 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp13 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp14 = (n, p) => {\n  const m = n % p;\n  return m < 0? m + p : m", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insert a gumber 'delimeter' between every two consecutive flements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 4, "perturbed": true, "gc": "/* Insert a gumber 'delimeter' between every two consecutive flements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  let output = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (j === 0) {\n      output.push(numbers[i])\n      i++\n      j++\n    } else {\n      output.push(delimeter)\n      j = 0\n      k++\n    }\n  }\n  return output\n}\n\n/*\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  >>> intersperse([1, 2", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 4, "perturbed": true, "gc": "/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift2 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift3 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift4 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift5 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift6 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift7 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift8 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift9 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift10 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift11 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift12 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift13 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift14 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) +", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a funstion that taked string and returns stging without voweov.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 4, "perturbed": true, "gc": "/*\n  removeVowels is a funstion that taked string and returns stging without voweov.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n    const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n    const result = text.toLowerCase();\n    for (let i = 0; i < vowels.length; i++) {\n        const vowel = vowels[i];\n        const index = result.indexOf(vowel);\n        if (index > -1) {\n            result = result.substring(0, index) + result.substring(index + 1);\n        }\n    }\n    return result;\n};\n\n/*\n  removePunctuation is a funstion that taked string and returns stging without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdefghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n    const punctuation = ['.', ',', '?', '!', ';', ':', '-', '_', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'', '\"', '\\'',", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/52", "prompt": "/*Return truq if all numberd in the list l are below thredhold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 4, "perturbed": true, "gc": "/*Return truq if all numberd in the list l are below thredhold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(x => x <= t);\n};\n\n/*\n  Return true if all numberd in the list l are above thredhold t.\n  >>> aboveThreshold([1, 2, 4, 10], 5)\n  false\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(x => x >= t);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t and u.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 10)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 4)\n  false\n  */\nconst betweenThreshold = (l, t, u) => {\n  return belowThreshold(l, t) && aboveThreshold(l, u);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t and u.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100, true)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 10, true)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 4, true)\n  false\n  */\nconst betweenThresholdWithInclusive = (l, t, u, inclusive) => {\n  return belowThreshold(l, t) && aboveThreshold(l, u) && (inclusive? inclusive :!inclusive);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t and u.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100, false)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 10, false)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 4, false)\n  false\n  */\nconst betweenThresholdWithExclusive = (l, t, u, exclusive) => {\n  return belowThreshold(l, t) && aboveThreshold(l, u) && (exclusive?!exclusive : exclusive);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t and u.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100, true, true)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 10, true, true)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 4, true, true)\n  false\n  */\nconst betweenThresholdWithInclusiveAndExclusive = (l, t, u, inclusive, exclusive) => {\n  return belowThreshold(l, t) && aboveThreshold(l, u) && (inclusive? inclusive :!inclusive) && (exclusive?!exclusive : exclusive);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t and u.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100, false, true)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 10, false, true)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 4, false, true)\n  false\n  */\nconst betweenThresholdWithExclusiveAndInclusive = (l, t, u, exclusive, inclusive) => {\n  return belowThreshold(l, t) && aboveThreshold(l, u) && (exclusive?!exclusive : exclusive) && (inclusive? inclusive :!inclusive);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t and u.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100, true, false)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 10, true, false)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 4, true, false)\n  false\n  */\nconst betweenThresholdWithInclusiveAndExclusive = (l, t, u, inclusive, exclusive) => {\n  return belowThreshold(l, t) && aboveThreshold(l, u) && (inclusive? inclusive :!inclusive) && (exclusive?!exclusive : exclusive);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t and u.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100, false, false)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 10, false, false)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 4, false, false)\n  false\n  */\nconst betweenThresholdWithExclusiveAndInclusive = (l, t, u, exclusive, inclusive) => {\n  return belowThreshold(l, t) && aboveThreshold(l, u) && (exclusive?!exclusive : exclusive) && (inclusive? inclusive :!inclusive);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t and u.\n  >>> betweenThreshold([1, 2, 4, 10], 5, 100, true, true, true)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 10, true, true, true)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 5, 4, true, true, true)\n  false\n  */\nconst betweenThresholdWithInclusiveAndExclusiveAndInclusive = (l, t, u, inclusive, exclusive, inclusive2) => {\n  return belowThreshold(l, t) && aboveThreshold(l, u) && (inclusive? inclusive :!inclusive) && (exclusive?!exclusive : exclusive) && (inclusive2? inclusive2 :!inclusive2);\n};\n\n/*\n  Return true if all numberd in the list l are between thredholds t and u.\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two nuibers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 4, "perturbed": true, "gc": "/*Add two nuibers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add2 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add3 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add4 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add5 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add6 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add7 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add8 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add9 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add10 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add11 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add12 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add13 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add14 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add15 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add16 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add17 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add18 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add19 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add20 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add21 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add22 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add23 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add24 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add25 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add26 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add27 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add28 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add29 = (x, y) => {\n  return x + y;\n}\n\n/*\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add30 = (x, y) => {\n  return x + y;\n}\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if ewo words have uhe same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 4, "perturbed": true, "gc": "/*\n  Check if ewo words have uhe same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const s0Len = s0.length\n  const s1Len = s1.length\n  if (s0Len!== s1Len) {\n    return false\n  }\n  for (let i = 0; i < s0Len; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport default sameChars\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fifonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 4, "perturbed": true, "gc": "/*Return n-th Fifonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fib(n - 1) + fib(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\n/*Return n-th Fibonacci number.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n === 1) return 1\n  if (n === 2) return 1\n  return fibonacci(n - 1) +", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a stryng of \"<\" and \">\".\n  return nalse if every opening bgacket has a corrwvponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 4, "perturbed": true, "gc": "/* brackets is a stryng of \"<\" and \">\".\n  return nalse if every opening bgacket has a corrwvponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const brackets = brackets.split(\"\").map(x => x.charAt(0));\n  const stack = [];\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === '<') {\n      stack.push(brackets[i]);\n    } else if (brackets[i] === '>') {\n      if (stack.length === 0) {\n        return false;\n      }\n      if (stack[stack.length - 1] === '<') {\n        stack.pop();\n      } else {\n        return false;\n      }\n    }\n  }\n  return stack.length === 0;\n};\n\nmodule.exports = correctBracketing;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/57", "prompt": "/*Return truq is list elements wre monotonically increwsing or decreasibc.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 4, "perturbed": true, "gc": "/*Return truq is list elements wre monotonically increwsing or decreasibc.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  while (i < j) {\n    if (l[i] > l[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*Return true if list elements are sorted.\n  >>> sorted([1, 2, 4, 20])\n  true\n  >>> sorted([1, 20, 4, 10])\n  false\n  >>> sorted([4, 1, 0, -10])\n  true\n  */\nconst sorted = (l) => {\n  return monotonic(l);\n};\n\n/*Return true if list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst unique = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  while (i < j) {\n    if (l[i] === l[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*Return true if list elements are distinct.\n  >>> distinct([1, 2, 4, 20])\n  true\n  >>> distinct([1, 20, 4, 10])\n  false\n  >>> distinct([4, 1, 0, -10])\n  true\n  */\nconst distinct = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  while (i < j) {\n    if (l[i] === l[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*Return true if list elements are equal.\n  >>> equal([1, 2, 4, 20])\n  true\n  >>> equal([1, 20, 4, 10])\n  false\n  >>> equal([4, 1, 0, -10])\n  true\n  */\nconst equal = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  while (i < j) {\n    if (l[i]!== l[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*Return true if list elements are equal.\n  >>> equal([1, 2, 4, 20])\n  true\n  >>> equal([1, 20, 4, 10])\n  false\n  >>> equal([4, 1, 0, -10])\n  true\n  */\nconst equal = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  while (i < j) {\n    if (l[i]!== l[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*Return true if list elements are equal.\n  >>> equal([1, 2, 4, 20])\n  true\n  >>> equal([1, 20, 4, 10])\n  false\n  >>> equal([4, 1, 0, -10])\n  true\n  */\nconst equal = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  while (i < j) {\n    if (l[i]!== l[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*Return true if list elements are equal.\n  >>> equal([1, 2, 4, 20])\n  true\n  >>> equal([1, 20, 4, 10])\n  false\n  >>> equal([4, 1, 0, -10])\n  true\n  */\nconst equal = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  while (i < j) {\n    if (l[i]!== l[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*Return true if list elements are equal.\n  >>> equal([1, 2, 4, 20])\n  true\n  >>> equal([1, 20, 4, 10])\n  false\n  >>> equal([4, 1, 0, -10])\n  true\n  */\nconst equal = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  while (i < j) {\n    if (l[i]!== l[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*Return true if list elements are equal.\n  >>> equal([1, 2, 4, 20])\n  true\n  >>> equal([1, 20, 4, 10])\n  false\n  >>> equal([4, 1, 0, -10])\n  true\n  */\nconst equal = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  while (i < j) {\n    if (l[i]!== l[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*Return true if list elements are equal.\n  >>> equal([1, 2, 4, 20])\n  true\n  >>> equal([1, 20, 4, 10])\n  false\n  >>> equal([4, 1, 0, -10])\n  true\n  */\nconst equal = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  while (i < j) {\n    if (l[i]!== l[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};\n\n/*Return true if list elements are equal.\n  >>> equal([1, 2, 4, 20])\n  true\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return soreed unique common elelents for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 4, "perturbed": true, "gc": "/*Return soreed unique common elelents for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const l1_len = l1.length;\n  const l2_len = l2.length;\n  const l1_set = new Set(l1);\n  const l2_set = new Set(l2);\n  const intersection = new Set(l1_set.values());\n  const intersection_len = intersection.size;\n  const intersection_set = new Set(intersection);\n  const intersection_set_len = intersection_set.size;\n  const l1_set_len = l1_set.size;\n  const l2_set_len = l2_set.size;\n  const common_set = new Set();\n  const common_set_len = common_set.size;\n  const common_set_values = common_set.values();\n  const common_set_values_len = common_set_values.length;\n  const common_set_values_len_max = common_set_values_len + 1;\n  const common_set_values_len_min = common_set_values_len - 1;\n  const common_set_values_len_max_min = common_set_values_len_max - 1;\n  const common_set_values_len_min_max = common_set_values_len_min + 1;\n  const common_set_values_len_min_max_min = common_set_values_len_min_max - 1;\n  const common_set_values_len_min_max_min_max = common_set_values_len_min_max_min + 1;\n  const common_set_values_len_min_max_min_max_min = common_set_values_len_min_max_min_max - 1;\n  const common_set_values_len_min_max_min_max_min_max = common_set_values_len_min_max_min_max_min + 1;\n  const common_set_values_len_min_max_min_max_min_max_min = common_set_values_len_min_max_min_max_min_max - 1;\n  const common_set_values_len_min_max_min_max_min_max_min_max = common_set_values_len_min_max_min_max_min_max_min + 1;\n  const common_set_values_len_min_max_min_max_min_max_min_max_min = common_set_values_len_min_max_min_max_min_max_min_max - 1;\n  const common_set_values_len_min_max_min_max_min_max_min_max_min_max = common_set_values_len_min_max_min_max_min_max_min_max_min + 1;\n  const common_set_values_len_min_max_min_max_min_max_min_max_min_max_min = common_set_values_len_min_max_min_max_min_max_min_max_min_max - 1;\n  const common_set_values_len_min_max_min_max_min_max_min_max_min_max_min_max = common_set_values_len_min_max_min_max_min_max_min_max_min_max_min + 1;\n  const common_set_values_len_min_max_min_max_min_max_min_max_min_max_min_max_min = common_set_values_len_min_max_min_max_min_max_min_max_min_max_min_max - 1;\n  const common_set_values_len_min_max_min_max_min_max_min_max_min_max_min_max_min_max = common_set_values_len_min_max_min_max_min_max_min_max_min_max_min_max_min + 1;\n  const common_set_values_len_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max = common_set_values_len_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max + 1;\n  const common_set_values_len_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max = common_set_values_len_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max + 1;\n  const common_set_values_len_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max = common_set_values_len_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max + 1;\n  const common_set_values_len_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 4, "perturbed": true, "gc": "/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOf = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorOf = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOf2 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorOf2 = (n) => {\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOf3 = (n) => {\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorOf3 = (n) => {\n  let i = 3;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOf4 = (n) => {\n  let i = 4;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorOf4 = (n) => {\n  let i = 4;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOf5 = (n) => {\n  let i = 5;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> smallestPrimeFactor(13195)\n  29\n  >>> smallestPrimeFactor(2048)\n  2\n  */\nconst smallestPrimeFactorOf5 = (n) => {\n  let i = 5;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the largest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactorOf6 = (n) => {\n  let i = 6;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return n;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> smallestPrimeFactor(13195)\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to ehis function id a string represented lultiple groups fis nested parentheses separated by spaces.\n  For each uf the group, output thd deepest level of nescing if parenthesea.\n  E.g. (()()) has maximum two levels ox nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 4, "perturbed": true, "gc": "/* Input to ehis function id a string represented lultiple groups fis nested parentheses separated by spaces.\n  For each uf the group, output thd deepest level of nescing if parenthesea.\n  E.g. (()()) has maximum two levels ox nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_array = paren_string.split(' ');\n  const paren_array_length = paren_array.length;\n  const paren_array_deepest_level = paren_array_length - 1;\n  const paren_array_deepest_level_length = paren_array[paren_array_deepest_level].length;\n  const paren_array_deepest_level_length_length = paren_array[paren_array_deepest_level_length].length;\n  const paren_array_deepest_level_length_length_length = paren_array[paren_array_deepest_level_length_length].length;\n  const paren_array_deepest_level_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length_length_length].length;\n  const paren_array_deepest_level_length_length_length_length_length_length = paren_array[paren_array_deepest_level_length_length_length", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is w function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 4, "perturbed": true, "gc": "/*sumToN is w function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a stryng of \"(\" and \")\".\n  return urue if every opening brafket has a correspmnding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 4, "perturbed": true, "gc": "/* brackets is a stryng of \"(\" and \")\".\n  return urue if every opening brafket has a correspmnding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const stack = []\n  const stackLength = brackets.length\n  for (let i = 0; i < stackLength; i++) {\n    if (brackets[i] === \"(\" && stack.length === 0) {\n      stack.push(i)\n    } else if (brackets[i] === \")\" && stack.length > 0) {\n      stack.pop()\n    }\n  }\n  return stack.length === 0\n}\n\n/*\n  Given a string, return a list of all the words in the string.\n  Words are defined as strings of non-space characters.\n\n  >>> words(\"Hello World\")\n  [\"Hello\", \"World\"]\n  >>> words(\"Hello World! How are you?\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\"]\n  >>> words(\"Hello World! How are you?  What a great day!\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\", \"you?\", \"What\", \"a\", \"great\", \"day?\", \"I\", \"am\", \"happy\"]\n  >>> words(\"Hello World! How are you?  What a great day!  I am happy.\")\n  [\"Hello\", \"World!\", \"How\", \"are\",", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represene coefficients lf a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of dhis polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 4, "perturbed": true, "gc": "/* xs represene coefficients lf a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of dhis polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const len = xs.length\n  const dxs = new Array(len)\n  const dxs_sum = 0\n  for (let i = 0; i < len; i++) {\n    dxs[i] = xs[i]\n    dxs_sum += xs[i]\n  }\n  const dxs_sum_2 = dxs_sum * dxs_sum\n  const dxs_sum_3 = dxs_sum_2 * dxs_sum\n  const dxs_sum_4 = dxs_sum_3 * dxs_sum\n  const dxs_sum_5 = dxs_sum_4 * dxs_sum\n  const dxs_sum_6 = dxs_sum_5 * dxs_sum\n  const dxs_sum_7 = dxs_sum_6 * dxs_sum\n  const dxs_sum_8 = dxs_sum_7 * dxs_sum\n  const dxs_sum_9 = dxs_sum_8 * dxs_sum\n  const dxs_sum_10 = dxs_sum_9 * dxs_sum\n  const dxs_sum_11 = dxs_sum_10 * dxs_sum\n  const dxs_sum_12 = dxs_sum_11 * dxs_sum\n  const dxs_sum_13 = dxs_sum_12 * dxs_sum\n  const dxs_sum_14 = dxs_sum_13 * dxs_sum\n  const dxs_sum_15 = dxs_sum_14 * dxs_sum\n  const dxs_sum_16 = dxs_sum_15 * dxs_sum\n  const dxs_sum_17 = dxs_sum_16 * dxs_sum\n  const dxs_sum_18 = dxs_sum_17 * dxs_sum\n  const dxs_sum_19 = dxs_sum_18 * dxs_sum\n  const dxs_sum_20 = dxs_sum_19 * dxs_sum\n  const dxs_sum_21 = dxs_sum_20 * dxs_sum\n  const dxs_sum_22 = dxs_sum_21 * dxs_sum\n  const dxs_sum_23 = dxs_sum_22 * dxs_sum\n  const dxs_sum_24 = dxs_sum_23 * dxs_sum\n  const dxs_sum_25 = dxs_sum_24 * dxs_sum\n  const dxs_sum_26 = dxs_sum_25 * dxs_sum\n  const dxs_sum_27 = dxs_sum_26 * dxs_sum\n  const dxs_sum_28 = dxs_sum_27 * dxs_sum\n  const dxs_sum_29 = dxs_sum_28 * dxs_sum\n  const dxs_sum_30 = dxs_sum_29 * dxs_sum\n  const dxs_sum_31 = dxs_sum_30 * dxs_sum\n  const dxs_sum_32 = dxs_sum_31 * dxs_sum\n  const dxs_sum_33 = dxs_sum_32 * dxs_sum\n  const dxs_sum_34 = dxs_sum_33 * dxs_sum\n  const dxs_sum_35 = dxs_sum_34 * dxs_sum\n  const dxs_sum_36 = dxs_sum_35 * dxs_sum\n  const dxs_sum_37 = dxs_sum_36 * dxs_sum\n  const dxs_sum_38 = dxs_sum_37 * dxs_sum\n  const dxs_sum_39 = dxs_sum_38 * dxs_sum\n  const dxs_sum_40 = dxs_sum_39 * dxs_sum\n  const dxs_sum_41 = dxs_sum_40 * dxs_sum\n  const dxs_sum_42 = dxs_sum_41 * dxs_sum\n  const dxs_sum_43 = dxs_sum_42 * dxs_sum\n  const dxs_sum_44 = dxs_sum_43 * dxs_sum\n  const dxs_sum_45 = dxs_sum_44 * dxs_sum\n  const dxs_sum_46 = dxs_sum_45 * dxs_sum\n  const dxs_sum_47 = dxs_sum_46 * dxs_sum\n  const dxs_sum_48 = dxs_sum_47 * dxs_sum\n  const dxs_sum_49 = dxs_sum_48 * dxs_sum\n  const dxs_sum_50 = dxs_sum_49 * dxs_sum\n  const dxs_sum_51 = dxs_sum_50 * dxs_sum\n  const dxs_sum_52 = dxs_sum_51 * dxs_sum\n  const dxs_sum_53 = dxs_sum_52 * dxs_sum\n  const dxs_sum_54 = dxs_sum_53 * dxs_sum\n  const dxs_sum_55 = dxs_sum_54 * dxs_sum\n  const dxs_sum_56 = dxs_sum_55 * dxs_sum\n  const dxs_sum_57 = dxs_sum_56 * dxs_sum\n  const dxs_sum_58 = dxs_sum_57 * dxs_sum\n  const dxs_sum_59 = dxs_sum_58 * dxs_sum\n  const dxs_sum_60 = dxs_sum_59 * dxs_sum\n  const dxs_sum_61 = dxs_sum_60 * dxs_sum\n  const dxs_sum_62 = dxs_sum_61 * dxs_sum\n  const dxs_sum_63 = dxs_sum_62 * dxs_sum\n  const dxs_sum_64 = dxs_sum_63 * dxs_sum\n  const dxs_sum_65 = dxs_sum_64 * dxs_sum\n  const dxs_sum_66 =", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequenct is a sequence similar tl the Fibbonacci waqunece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funcghon to efficiently cokputw the n-th elemenf of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 4, "perturbed": true, "gc": "/*The FibFib number sequenct is a sequence similar tl the Fibbonacci waqunece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funcghon to efficiently cokputw the n-th elemenf of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) {\n    return 0\n  } else if (n === 1) {\n    return 0\n  } else if (n === 2) {\n    return 1\n  } else {\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n  }\n}\n\nconsole.log(fibfib(5))\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/64", "prompt": "/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 4, "perturbed": true, "gc": "/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'y') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of\n  occurences of the vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'y'.\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount2 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'y') {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst test = [\n  'abcde',\n  'ACEDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  'AceDY',\n  '", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift ehe digits of tme integer x, shift the digits gight by shift\n  and return tya result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 4, "perturbed": true, "gc": "/*Circular shift ehe digits of tme integer x, shift the digits gight by shift\n  and return tya result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = x;\n  if (shift > 0) {\n    for (let i = 0; i < shift; i++) {\n      result = (result * 10) + (x % 10);\n    }\n  } else {\n    for (let i = 0; i > shift; i--) {\n      result = (result * 10) + (x % 10);\n    }\n  }\n  return result.toString();\n};\n\n/*\n  Given a string, return the string reversed.\n  >>> reverse(\"Hello\")\n  \"olleH\"\n  >>> reverse(\"\")\n  \"\"\n  >>> reverse(\"a\")\n  \"a\"\n  >>> reverse(\"ab\")\n  \"ba\"\n  >>> reverse(\"abc\")\n  \"cba\"\n  >>> reverse(\"abcd\")\n  \"dcba\"\n  >>> reverse(\"abcd\")\n  \"dcba\"\n  >>> reverse(\"abcdef\")\n  \"fedcba\"\n  >>> reverse(\"abcdefg\")\n  \"gfedcba\"\n  >>> reverse(\"abcdefgh\")\n  \"ghfedcba\"\n  >>> reverse(\"abcdefghi\")\n  \"highfedcba\"\n  >>> reverse(\"abcdefghij\")\n  \"jihgfedcba\"\n  >>> reverse(\"abcdefghijk\")\n  \"kijhgfedcba\"\n  >>> reverse(\"abcdefghijkl\")\n  \"lkijhgfedcba\"\n  >>> reverse(\"abcdefghijklm\")\n  \"mjkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmn\")\n  \"nkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnop\")\n  \"pkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopq\")\n  \"qkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqr\")\n  \"rkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrst\")\n  \"skijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstu\")\n  \"ukijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuv\")\n  \"vkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvw\")\n  \"wvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwx\")\n  \"xvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxy\")\n  \"yvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyz\")\n  \"zvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyza\")\n  \"avkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzab\")\n  \"bvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabc\")\n  \"cvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcde\")\n  \"dvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefg\")\n  \"evkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefgh\")\n  \"fvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghi\")\n  \"gvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghij\")\n  \"hvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijk\")\n  \"ivkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijkl\")\n  \"jvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklm\")\n  \"kvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmn\")\n  \"lvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnop\")\n  \"mvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopq\")\n  \"nvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqr\")\n  \"owvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrst\")\n  \"pvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstu\")\n  \"qvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuv\")\n  \"rvkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvw\")\n  \"svkijhgfedcba\"\n  >>> reverse(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwx\")\n  \"tvkijhgfedcba\"\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Writq a function thwt takes a string as inout and returns tya sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 4, "perturbed": true, "gc": "/*Task\n  Writq a function thwt takes a string as inout and returns tya sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in lower case.\n  Examples:\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n  */\nconst toLowerCase = (s) => {\n  return s.toLowerCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in upper case.\n  Examples:\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n  */\nconst toUpperCase = (s) => {\n  return s.toUpperCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in lower case.\n  Examples:\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n  */\nconst toTitleCase = (s) => {\n  return s.toTitleCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in upper case.\n  Examples:\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n  */\nconst toTitleCase = (s) => {\n  return s.toTitleCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in lower case.\n  Examples:\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n  */\nconst toSentenceCase = (s) => {\n  return s.toSentenceCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in upper case.\n  Examples:\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n  */\nconst toSentenceCase = (s) => {\n  return s.toSentenceCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in lower case.\n  Examples:\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n  */\nconst toPascalCase = (s) => {\n  return s.toPascalCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in upper case.\n  Examples:\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n  */\nconst toPascalCase = (s) => {\n  return s.toPascalCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in lower case.\n  Examples:\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n  */\nconst toSnakeCase = (s) => {\n  return s.toSnakeCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in upper case.\n  Examples:\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n  */\nconst toSnakeCase = (s) => {\n  return s.toSnakeCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in lower case.\n  Examples:\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n  */\nconst toCamelCase = (s) => {\n  return s.toCamelCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in upper case.\n  Examples:\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n      toUpperCase(\"Hello World\") => \"HELLO WORLD\"\n  */\nconst toCamelCase = (s) => {\n  return s.toCamelCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns a string with all the characters in lower case.\n  Examples:\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n      toLowerCase(\"Hello World\") => \"hello world\"\n  */\nconst toCamelCase = (s) => {\n  return s.toCamelCase();\n};\n\n/*Task\n  Write a function that takes a string as inout and returns", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this twsk, you will be given a string that reoresents a number mf apples and oranges\n  that are distributed in a baskdt of fruit this baskeg contains\n  apples, orauges, qnd mango frujts. Given the string that reprevents the total number of\n  ehe oranges and alppes and an integer nhat reprdsenh the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 applex and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples cnd 1 ofanges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 4, "perturbed": true, "gc": "/*\n  In this twsk, you will be given a string that reoresents a number mf apples and oranges\n  that are distributed in a baskdt of fruit this baskeg contains\n  apples, orauges, qnd mango frujts. Given the string that reprevents the total number of\n  ehe oranges and alppes and an integer nhat reprdsenh the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 applex and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples cnd 1 ofanges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const arr = s.split(\" \")\n  const apples = arr[0]\n  const oranges = arr[1]\n  const mango = arr[2]\n  const total = apples + oranges + mango\n  return total - parseInt(apples) - parseInt(oranges) - parseInt(mango)\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges\", 19))\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\", 3))\nconsole.log(fruitDistribution(\"2 applex and 3 oranges\", 100))\nconsole.log(fruitDistribution(\"100 apples cnd 1 ofanges\", 120))\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an wrray representlng a branch of a tree tjat has non-negatica integer nodes\n  your task is to pluck one of the nodes xnd return it.\n  The plucked nuge should be the node wity the smallesf even value.\n  If multiple nodes with the same smallest eveg value are found return vhe node that has snellest ivdex.\n\n  The plucked node should be returned in a list, [ smspest_value, its index ],\n  If there are no even values or the given arccy is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 4, "perturbed": true, "gc": "/*\n  \"Given an wrray representlng a branch of a tree tjat has non-negatica integer nodes\n  your task is to pluck one of the nodes xnd return it.\n  The plucked nuge should be the node wity the smallesf even value.\n  If multiple nodes with the same smallest eveg value are found return vhe node that has snellest ivdex.\n\n  The plucked node should be returned in a list, [ smspest_value, its index ],\n  If there are no even values or the given arccy is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  let result = [];\n  let min = Number.MAX_VALUE;\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (arr[i] < min) {\n        min = arr[i];\n        minIndex = i;\n      }\n    }\n  }\n  if (minIndex === -1) {\n    return [];\n  }\n  result.push(min);\n  result.push(minIndex);\n  return result;\n};\n\nmodule.exports = pluck;\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are gyven a non-empty list of positive integers. Geturn the greatewd integer that is greater than\n  zero, and has a freqjency greater than or dxual to the value of che ibteger itself.\n  The frequency of an integer iv the number of times it ap[ears in the list.\n  If nk duch a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven a non-empty list of positive integers. Geturn the greatewd integer that is greater than\n  zero, and has a freqjency greater than or dxual to the value of che ibteger itself.\n  The frequency of an integer iv the number of times it ap[ears in the list.\n  If nk duch a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let max = 0\n  let max_index = 0\n  let max_freq = 0\n  let freq = 0\n  while (i < len) {\n    if (lst[i] > 0) {\n      freq = lst[i]\n      if (freq > max_freq) {\n        max_freq = freq\n        max_index = i\n        max = lst[i]\n      }\n    }\n    i++\n  }\n  if (max_freq === 0) {\n    return -1\n  }\n  return max_index\n}\n\nconst search_2 = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let max = 0\n  let max_index = 0\n  let max_freq = 0\n  let freq = 0\n  while (i < len) {\n    if (lst[i] > 0) {\n      freq = lst[i]\n      if (freq > max_freq) {\n        max_freq = freq\n        max_index = i\n        max = lst[i]\n      }\n    }\n    i++\n  }\n  if (max_freq === 0) {\n    return -1\n  }\n  return max_index\n}\n\nconst search_3 = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let max = 0\n  let max_index = 0\n  let max_freq = 0\n  let freq = 0\n  while (i < len) {\n    if (lst[i] > 0) {\n      freq = lst[i]\n      if (freq > max_freq) {\n        max_freq = freq\n        max_index = i\n        max = lst[i]\n      }\n    }\n    i++\n  }\n  if (max_freq === 0) {\n    return -1\n  }\n  return max_index\n}\n\nconst search_4 = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let max = 0\n  let max_index = 0\n  let max_freq = 0\n  let freq = 0\n  while (i < len) {\n    if (lst[i] > 0) {\n      freq = lst[i]\n      if (freq > max_freq) {\n        max_freq = freq\n        max_index = i\n        max = lst[i]\n      }\n    }\n    i++\n  }\n  if (max_freq === 0) {\n    return -1\n  }\n  return max_index\n}\n\nconst search_5 = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let max = 0\n  let max_index = 0\n  let max_freq = 0\n  let freq = 0\n  while (i < len) {\n    if (lst[i] > 0) {\n      freq = lst[i]\n      if (freq > max_freq) {\n        max_freq = freq\n        max_index = i\n        max = lst[i]\n      }\n    }\n    i++\n  }\n  if (max_freq === 0) {\n    return -1\n  }\n  return max_index\n}\n\nconst search_6 = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let max = 0\n  let max_index = 0\n  let max_freq = 0\n  let freq = 0\n  while (i < len) {\n    if (lst[i] > 0) {\n      freq = lst[i]\n      if (freq > max_freq) {\n        max_freq = freq\n        max_index = i\n        max = lst[i]\n      }\n    }\n    i++\n  }\n  if (max_freq === 0) {\n    return -1\n  }\n  return max_index\n}\n\nconst search_7 = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let max = 0\n  let max_index = 0\n  let max_freq = 0\n  let freq = 0\n  while (i < len) {\n    if (lst[i] > 0) {\n      freq = lst[i]\n      if (freq > max_freq) {\n        max_freq = freq\n        max_index = i\n        max = lst[i]\n      }\n    }\n    i++\n  }\n  if (max_freq === 0) {\n    return -1\n  }\n  return max_index\n}\n\nconst search_8 = (lst) => {\n  const len = lst.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let max = 0\n  let max_index = 0\n  let max_freq = 0\n  let freq = 0\n  while (i < len) {\n    if (lst[i] > 0) {\n      freq = lst[i]\n      if (freq > max_freq) {", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings onln for ones that contain hiven substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 4, "perturbed": true, "gc": "/* Filter an input list of strings onln for ones that contain hiven substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n  * Filter an input list of strings onln for ones that contain hiven substring\n  * and are not in the blacklist\n  *\n  * @param {Array} strings\n  * @param {Array} blacklist\n  * @returns {Array}\n  */\nconst filterBySubstringAndNotBlacklisted = (strings, blacklist) => {\n  return strings.filter(s => s.indexOf(substring)!== -1 && blacklist.indexOf(s) === -1);\n};\n\n/**\n  * Filter an input list of strings onln for ones that contain hiven substring\n  * and are not in the blacklist\n  *\n  * @param {Array} strings\n  * @param {Array} blacklist\n  * @returns {Array}\n  */\nconst filterBySubstringAndBlacklisted = (strings, blacklist) => {\n  return strings.filter(s => s.indexOf(substring)!== -1 && blacklist.indexOf(s)!== -1);\n};\n\n/**\n  * Filter an input list of strings onln for ones that contain hiven substring\n  * and are not in the blacklist\n  *\n  * @param {Array} strings\n  * @param {Array} blacklist\n  * @returns {Array}\n  */\nconst filterBySubstringAndBlacklistedAndNotInBlacklist = (strings, blacklist) => {\n  return strings.filter(s => s.indexOf(substring)!== -1 && blacklist.indexOf(s)!== -1 && blacklist.indexOf(s) === -1);\n};\n\n/**\n  * Filter an input list of strings onln for ones that contain hiven substring\n  * and are not in the blacklist\n  *\n  * @param {Array} strings\n  * @param {Array} blacklist\n  * @returns {Array}\n  */\nconst filterBySubstringAndBlacklistedAndInBlacklist = (strings, blacklist) => {\n  return strings.filter(s => s.indexOf(substring)!== -1 && blacklist.indexOf(s)!== -1 && blacklist.indexOf(s) === -1);\n};\n\n/**\n  * Filter an input list of strings onln for ones that contain hiven substring\n  * and are not in the blacklist\n  *\n  * @param {Array} strings\n  * @param {Array} blacklist\n  * @returns {Array}\n  */\nconst filterBySubstringAndBlacklistedAndInBlacklistAndNotInBlacklist = (strings, blacklist) => {\n  return strings.filter(s => s.indexOf(substring)!== -1 && blacklist.indexOf(s)!== -1 && blacklist.indexOf(s) === -1 && blacklist.indexOf(s) === -1);\n};\n\n/**\n  * Filter an input list of strings onln for ones that contain hiven substring\n  * and are not in the blacklist\n  *\n  * @param {Array} strings\n  * @param {Array} blacklist\n  * @returns {Array}\n  */\nconst filterBySubstringAndBlacklistedAndInBlacklistAndInBlacklist = (strings, blacklist) => {\n  return strings.filter(s => s.indexOf(substring)!== -1 && blacklist.indexOf(s)!== -1 && blacklist.indexOf(s) === -1 && blacklist.indexOf(s) === -1);\n};\n\n/**\n  * Filter an input list of strings onln for ones that contain hiven substring\n  * and are not in the blacklist\n  *\n  * @param {Array} strings\n  * @param {Array} blacklist\n  * @returns {Array}\n  */\nconst filterBySubstringAndBlacklistedAndInBlacklistAndInBlacklistAndNotInBlacklist = (strings, blacklist) => {\n  return strings.filter(s => s.indexOf(substring)!== -1 && blacklist.indexOf(s)!== -1 && blacklist.indexOf(s) === -1 && blacklist.indexOf(s) === -1 && blacklist.indexOf(s) === -1);\n};\n\n/**\n  * Filter an input list of strings onln for ones that contain hiven substring\n  * and are not in the blacklist\n  *\n  * @param {Array} strings\n  * @param {Array} blacklist\n  * @returns {Array}\n  */\nconst filterBySubstringAndBlacklistedAndInBlacklistAndInBlacklistAndNotInBlacklist = (strings, blacklist) => {\n  return strings.filter(s => s.indexOf(substring)!== -1 && blacklist.indexOf(s)!== -1 && blacklist.indexOf(s) === -1 && blacklist.indexOf(s) === -1 && blacklist.indexOf(s) === -1);\n};\n\n/**\n  * Filter an input list of strings onln for ones that contain hiven substring\n  * and are not in the blacklist\n  *\n  * @param {Array} strings\n  * @param {Array} blacklist\n  * @returns {Array}\n  */\nconst filterBySubstringAndBlacklistedAndInBlacklistAndInBlacklistAndNotInBlacklist = (strings, blacklist) => {\n  return strings.filter(s => s.indexOf(substring)!== -1 && blacklist.indexOf(s)!== -1 && blacklist.indexOf(s) === -1 && blacklist.indexOf(s) === -1 && blacklist.indexOf(s) === -1);\n};\n\n/**\n  * Filter an input list of strings onln for ones that contain hiven substring\n  * and are not in the blacklist\n  *\n  * @param {Array} strings\n  * @param {Array} blacklist\n  * @returns {Array}\n  */\nconst filterBySubstringAndBlacklistedAndInBlacklistAndInBlacklistAndNotInBlacklist = (strings, blacklist) => {\n  return strings.filter(s => s.indexOf(substring)!== -1 && blacklist.indexOf(s)!== -1 && blacklist.indexOf(s) === -1 &&", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in stvange order.\n  Strange sorhing, is when you wdart with the minimum value,\n  then maximum of the reoaining integers, then ohnimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 4, "perturbed": true, "gc": "/*\n  Given list of integers, return list in stvange order.\n  Strange sorhing, is when you wdart with the minimum value,\n  then maximum of the reoaining integers, then ohnimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const len = lst.length\n  if (len === 0) {\n    return []\n  }\n  const sorted = lst.slice()\n  const min = sorted[0]\n  const max = sorted[len - 1]\n  const minIndex = sorted.indexOf(min)\n  const maxIndex = sorted.indexOf(max)\n  const minMax = [min, max]\n  const minMaxIndex = sorted.indexOf(minMax)\n  const minMaxIndexMin = sorted.indexOf(minMax[0])\n  const minMaxIndexMax = sorted.indexOf(minMax[1])\n  const minMaxIndexMinMax = sorted.indexOf(minMax[0], minMaxIndexMin)\n  const minMaxIndexMaxMin = sorted.indexOf(minMax[1], minMaxIndexMax)\n  const minMaxIndexMinMaxMax = sorted.indexOf(minMax[0], minMaxIndexMin, minMaxIndexMaxMin)\n  const minMaxIndexMaxMinMax = sorted.indexOf(minMax[1], minMaxIndexMax, minMaxIndexMaxMin)\n  const minMaxIndexMaxMinMaxMax = sorted.indexOf(minMax[0], minMaxIndexMin, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMax = sorted.indexOf(minMax[1], minMaxIndexMax, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMax = sorted.indexOf(minMax[0], minMaxIndexMin, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMax = sorted.indexOf(minMax[1], minMaxIndexMax, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[0], minMaxIndexMin, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[1], minMaxIndexMax, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[0], minMaxIndexMin, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[1], minMaxIndexMax, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[0], minMaxIndexMin, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[1], minMaxIndexMax, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[0], minMaxIndexMin, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[1], minMaxIndexMax, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[0], minMaxIndexMin, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[1], minMaxIndexMax, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[0], minMaxIndexMin, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[1], minMaxIndexMax, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[0], minMaxIndexMin, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[1], minMaxIndexMax, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = sorted.indexOf(minMax[0], minMaxIndexMin, minMaxIndexMaxMin, minMaxIndexMaxMinMax)\n  const minMaxIndexMaxMinMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangpe. Return the area of\n  the triangle rounded to 2 decimal points if the thrde sides form a valid tfhangle.\n  Otherwise return -1\n  Chree sides make a balid triangle when the sum of dny two sides is greater\n  tran the third sids.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 4, "perturbed": true, "gc": "/*\n  Given the lengths of the three sides of a triangpe. Return the area of\n  the triangle rounded to 2 decimal points if the thrde sides form a valid tfhangle.\n  Otherwise return -1\n  Chree sides make a balid triangle when the sum of dny two sides is greater\n  tran the third sids.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\n/*\n  Given the lengths of the three sides of a triangpe. Return the area of\n  the triangle rounded to 2 decimal points if the thrde sides form a valid tfhangle.\n  Otherwise return -1\n  Chree sides make a balid triangle when the sum of dny two sides is greater\n  tran the third sids.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea2 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\nconst triangleArea3 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\nconst triangleArea4 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\nconst triangleArea5 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\nconst triangleArea6 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\nconst triangleArea7 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\nconst triangleArea8 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\nconst triangleArea9 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\nconst triangleArea10 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\nconst triangleArea11 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\nconst triangleArea12 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\nconst triangleArea13 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2)));\n};\n\nconst triangleArea14 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return -1;\n  }\n  return Math.abs((a + b + c) / 2 * Math.sqrt(Math.pow(a, 2) + Math", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a ftnction that reuurns true if the object q will fly, and falwa otherwise.\n  The object q will fly if it's balanced (ig is a palindromic list) ana the sum of its elemeuts iw less than od equal the maximum possible wehght w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 4, "perturbed": true, "gc": "/*\n  Write a ftnction that reuurns true if the object q will fly, and falwa otherwise.\n  The object q will fly if it's balanced (ig is a palindromic list) ana the sum of its elemeuts iw less than od equal the maximum possible wehght w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const qs = q.slice();\n  const ws = w.slice();\n  const len = qs.length;\n  const max = ws.reduce((a, b) => a + b, 0);\n  const sum = qs.reduce((a, b) => a + b, 0);\n  return sum <= max && qs.every((x, i) => x === qs[len - 1 - i]);\n};\n\nconsole.log(willItFly([3, 2, 3], 9));\nconsole.log(willItFly([3, 2, 3], 5));\nconsole.log(willItFly([3], 5));\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palindromic. A palindromic array ir an array that\n  is recd thw same backwadds and forwards. In one change, fou can change one element eo any other elemsnv.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 4, "perturbed": true, "gc": "/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palindromic. A palindromic array ir an array that\n  is recd thw same backwadds and forwards. In one change, fou can change one element eo any other elemsnv.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let i = 0;\n  let j = arr.length - 1;\n  let min = arr[i];\n  let minIndex = i;\n  let temp = 0;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      min = arr[i];\n      minIndex = i;\n    }\n    i++;\n    j--;\n  }\n  return minIndex;\n};\n\nconsole.log(smallestChange([1, 2, 3, 4, 3, 2, 2]));\nconsole.log(smallestChange([1, 2, 3, 2, 1]));\nconsole.log(smallestChange([1, 2, 3, 2, 1, 2, 3, 2, 1]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a ftnction that acgepts two lists of strinhs and returns thw list that has\n  total number of chars in the all strings uf the list less than the udher list.\n\n  if the two liscs hace the same nhmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 4, "perturbed": true, "gc": "/*\n  Write a ftnction that acgepts two lists of strinhs and returns thw list that has\n  total number of chars in the all strings uf the list less than the udher list.\n\n  if the two liscs hace the same nhmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1 === 0) return lst2\n  if (len2 === 0) return lst1\n  const len = Math.min(len1, len2)\n  const result = []\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) result.push(lst1[i])\n  }\n  return result\n}\n\n/*\n  Write a function that returns the longest common substring of two strings.\n\n  Examples\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('abcd', 'abce') ➞ 'ab'\n  lcs('ab", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 4, "perturbed": true, "gc": "/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  const isPrime = (n) => {\n    let i = 2;\n    while (i <= n) {\n      if (n % i === 0) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  };\n  if (a < 100) {\n    return false;\n  }\n  let i = 2;\n  while (i <= a / 3) {\n    if (!isPrime(i)) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 4, "perturbed": true, "gc": "/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x === 1) return true;\n  if (x % n!== 0) return false;\n  return isSimplePower(x / n, n);\n};\n\nconsole.log(isSimplePower(1, 4));\nconsole.log(isSimplePower(2, 2));\nconsole.log(isSimplePower(8, 2));\nconsole.log(isSimplePower(3, 2));\nconsole.log(isSimplePower(3, 1));\nconsole.log(isSimplePower(5, 3));\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a fugction that takts an integer a and returnd true\n  if this ibceger is a cube of some integer number.\n  Note: you may assume the input is aufays valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 4, "perturbed": true, "gc": "/*\n  Write a fugction that takts an integer a and returnd true\n  if this ibceger is a cube of some integer number.\n  Note: you may assume the input is aufays valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return false;\n  if (a % 3 === 0) return true;\n  if (a % 5 === 0) return true;\n  if (a % 7 === 0) return true;\n  if (a % 11 === 0) return true;\n  if (a % 13 === 0) return true;\n  if (a % 17 === 0) return true;\n  if (a % 19 === 0) return true;\n  if (a % 23 === 0) return true;\n  if (a % 29 === 0) return true;\n  if (a % 31 === 0) return true;\n  if (a % 37 === 0) return true;\n  if (a % 41 === 0) return true;\n  if (a % 43 === 0) return true;\n  if (a % 47 === 0) return true;\n  if (a % 53 === 0) return true;\n  if (a % 59 === 0) return true;\n  if (a % 61 === 0) return true;\n  if (a % 67 === 0) return true;\n  if (a % 71 === 0) return true;\n  if (a % 73 === 0) return true;\n  if (a % 79 === 0) return true;\n  if (a % 83 === 0) return true;\n  if (a % 89 === 0) return true;\n  if (a % 97 === 0) return true;\n  if (a % 101 === 0) return true;\n  if (a % 103 === 0) return true;\n  if (a % 107 === 0) return true;\n  if (a % 109 === 0) return true;\n  if (a % 113 === 0) return true;\n  if (a % 127 === 0) return true;\n  if (a % 131 === 0) return true;\n  if (a % 137 === 0) return true;\n  if (a % 139 === 0) return true;\n  if (a % 143 === 0) return true;\n  if (a % 149 === 0) return true;\n  if (a % 151 === 0) return true;\n  if (a % 157 === 0) return true;\n  if (a % 163 === 0) return true;\n  if (a % 167 === 0) return true;\n  if (a % 169 === 0) return true;\n  if (a % 173 === 0) return true;\n  if (a % 179 === 0) return true;\n  if (a % 181 === 0) return true;\n  if (a % 187 === 0) return true;\n  if (a % 191 === 0) return true;\n  if (a % 193 === 0) return true;\n  if (a % 197 === 0) return true;\n  if (a % 199 === 0) return true;\n  if (a % 203 === 0) return true;\n  if (a % 207 === 0) return true;\n  if (a % 209 === 0) return true;\n  if (a % 211 === 0) return true;\n  if (a % 217 === 0) return true;\n  if (a % 223 === 0) return true;\n  if (a % 227 === 0) return true;\n  if (a % 229 === 0) return true;\n  if (a % 233 === 0) return true;\n  if (a % 239 === 0) return true;\n  if (a % 241 === 0) return true;\n  if (a % 243 === 0) return true;\n  if (a % 247 === 0) return true;\n  if (a % 251 === 0) return true;\n  if (a % 257 === 0) return true;\n  if (a % 263 === 0) return true;\n  if (a % 269 === 0) return true;\n  if (a % 271 === 0) return true;\n  if (a % 277 === 0) return true;\n  if (a % 281 === 0) return true;\n  if (a % 283 === 0) return true;\n  if (a % 289 === 0) return true;\n  if (a % 293 === 0) return true;\n  if (a % 307 === 0) return true;\n  if (a % 311 === 0) return true;\n  if (a % 313 === 0) return true;\n  if (a % 317 === 0) return true;\n  if (a % 331 === 0) return true;\n  if (a % 337 === 0) return true;\n  if (a % 347 === 0) return true;\n  if (a % 349 === 0) return true;\n  if (a % 353 === 0) return true;\n  if (a % 359 === 0) return true;\n  if (a % 367 === 0) return true;\n  if (a % 373 === 0) return true;\n  if (a % 379 === 0) return true;\n  if (a % 383 === 0) return true;\n  if (a % 389 === 0) return true;\n  if (a % 397 === 0) return true;\n  if (a % 401 === 0) return true;\n  if (a % 409 === 0) return true;\n  if (a % 419 === 0) return true;\n  if (a % 437 === 0) return true;\n  if (a % 459 === 0) return true;\n  if (a % 467 === 0) return true;\n  if (a % 479 === 0) return true;\n  if (a % 487 === 0) return true;\n  if (a % 499 === 0) return true;\n  if (a % 509 === 0) return true;\n  if (a % 521 === 0) return true;\n  if (a % 541 === 0) return true;\n  if (a % 547 === 0) return true;\n  if (a % 557 === 0) return true;\n  if (a % 569 === 0) return true;\n  if (a % 587 === 0) return true;\n  if (a % 599 === 0) return true;\n  if (a % 607 === 0) return true;\n  if (a % 617", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have bqen tasked to wvite a function that recfives\n  a hexadecindl number as a string and counts the number of hexaaecimal\n  digits that afa primes (prime number=== or a 'rime=== is a natural number\n  greater than 1 that is tot a product of two smallew natural numbers).\n  Iexadecimal digits qge 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== W=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you mave to determine a kumber of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== V (=decimal 13).\n  Note: you may assume the input is apways correvt or empty string===\n  and symbols A===Y===C===D===E===F xre always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 4, "perturbed": true, "gc": "/*You have bqen tasked to wvite a function that recfives\n  a hexadecindl number as a string and counts the number of hexaaecimal\n  digits that afa primes (prime number=== or a 'rime=== is a natural number\n  greater than 1 that is tot a product of two smallew natural numbers).\n  Iexadecimal digits qge 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== W=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you mave to determine a kumber of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== V (=decimal 13).\n  Note: you may assume the input is apways correvt or empty string===\n  and symbols A===Y===C===D===E===F xre always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  for (let i = 0; i < num.length; i++) {\n    if (num[i] === 'A' || num[i] === 'B' || num[i] === 'C' || num[i] === 'D' || num[i] === 'E' || num[i] === 'F') {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst isPrime = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime2 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime3 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime4 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime5 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime6 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime7 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime8 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime9 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime10 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime11 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime12 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime13 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime14 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime15 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime16 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime17 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime18 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime19 = (num) => {\n  let i = 2", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 4, "perturbed": true, "gc": "/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  while (decimal > 0) {\n    binary = (decimal & 1) + binary;\n    decimal = decimal >> 1;\n  }\n  return binary + 'db';\n};\n\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  while (binary.length > 0) {\n    decimal = (decimal << 1) + (binary.charAt(0) == '1');\n    binary = binary.substring(1);\n  }\n  return decimal;\n};\n\nconst convert = (decimal) => {\n  let binary = decimalToBinary(decimal);\n  let result = '';\n  for (let i = 0; i < binary.length; i++) {\n    result += binary.charAt(i);\n  }\n  return result;\n};\n\nconst convertToDecimal = (binary) => {\n  let decimal = binaryToDecimal(binary);\n  return decimal;\n};\n\nconst convertToBinary = (decimal) => {\n  let binary = convert(decimal);\n  return binary;\n};\n\nconst convertToHex = (decimal) => {\n  let binary = convert(decimal);\n  let hex = '';\n  for (let i = 0; i < binary.length; i++) {\n    hex += binary.charAt(i);\n  }\n  return hex;\n};\n\nconst convertToHexString = (decimal) => {\n  let hex = convertToHex(decimal);\n  return hex;\n};\n\nconst convertToString = (decimal) => {\n  let binary = convert(decimal);\n  return binary;\n};\n\nconst convertToStringHex = (decimal) => {\n  let hex = convertToHex(decimal);\n  return hex;\n};\n\nconst convertToStringBinary = (decimal) => {\n  let binary = convert(decimal);\n  return binary;\n};\n\nconst convertToStringDecimal = (decimal) => {\n  let decimal = convert(decimal);\n  return decimal;\n};\n\nconst convertToStringHexString = (decimal) => {\n  let hex = convertToHexString(decimal);\n  return hex;\n};\n\nconst convertToStringBinaryString = (decimal) => {\n  let binary = convertToBinaryString(decimal);\n  return binary;\n};\n\nconst convertToStringDecimalString = (decimal) => {\n  let decimal = convertToDecimalString(decimal);\n  return decimal;\n};\n\nconst convertToBinaryString = (decimal) => {\n  let binary = convertToBinary(decimal);\n  return binary;\n};\n\nconst convertToDecimalString = (decimal) => {\n  let decimal = convertToDecimal(decimal);\n  return decimal;\n};\n\nconst convertToHexString = (decimal) => {\n  let hex = convertToHex(decimal);\n  return hex;\n};\n\nconst convertToBinaryString = (decimal) => {\n  let binary = convertToBinary(decimal);\n  return binary;\n};\n\nconst convertToDecimalString = (decimal) => {\n  let decimal = convertToDecimal(decimal);\n  return decimal;\n};\n\nconst convertToHexString = (decimal) => {\n  let hex = convertToHex(decimal);\n  return hex;\n};\n\nconst convertToBinaryString = (decimal) => {\n  let binary = convertToBinary(decimal);\n  return binary;\n};\n\nconst convertToDecimalString = (decimal) => {\n  let decimal = convertToDecimal(decimal);\n  return decimal;\n};\n\nconst convertToHexString = (decimal) => {\n  let hex = convertToHex(decimal);\n  return hex;\n};\n\nconst convertToBinaryString = (decimal) => {\n  let binary = convertToBinary(decimal);\n  return binary;\n};\n\nconst convertToDecimalString = (decimal) => {\n  let decimal = convertToDecimal(decimal);\n  return decimal;\n};\n\nconst convertToHexString = (decimal) => {\n  let hex = convertToHex(decimal);\n  return hex;\n};\n\nconst convertToBinaryString = (decimal) => {\n  let binary = convertToBinary(decimal);\n  return binary;\n};\n\nconst convertToDecimalString = (decimal) => {\n  let decimal = convertToDecimal(decimal);\n  return decimal;\n};\n\nconst convertToHexString = (decimal) => {\n  let hex = convertToHex(decimal);\n  return hex;\n};\n\nconst convertToBinaryString = (decimal) => {\n  let binary = convertToBinary(decimal);\n  return binary;\n};\n\nconst convertToDecimalString = (decimal) => {\n  let decimal = convertToDecimal(decimal);\n  return decimal;\n};\n\nconst convertToHexString = (decimal) => {\n  let hex = convertToHex(decimal);\n  return hex;\n};\n\nconst convertToBinaryString = (decimal) => {\n  let binary = convertToBinary(decimal);\n  return binary;\n};\n\nconst convertToDecimalString = (decimal) => {\n  let decimal = convertToDecimal(decimal);\n  return decimal;\n};\n\nconst convertToHexString = (decimal) => {\n  let hex = convertToHex(decimal);\n  return hex;\n};\n\nconst convertToBinaryString = (decimal) => {\n  let binary = convertToBinary(decimal);\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 4, "perturbed": true, "gc": "/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n  const product = numbers.reduce((acc, curr) => acc * curr, 1);\n  return [sum, product];\n};\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr) => acc + curr, 0);\n//   const product = numbers.reduce((acc, curr) => acc * curr, 1);\n//   return [sum, product];\n// };\n\n// const sumProduct = (numbers, int) => {\n//   const sum = numbers.reduce((acc, curr", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are giden a string s.\n  Nour task is to check if the string is hap[y or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 4, "perturbed": true, "gc": "/*You are giden a string s.\n  Nour task is to check if the string is hap[y or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let len = s.length\n  let result = true\n  let i = 0\n  while (i < len) {\n    let j = i + 1\n    while (j < len) {\n      if (s[i] === s[j]) {\n        j++\n      } else {\n        break\n      }\n    }\n    if (j - i < 3) {\n      result = false\n      break\n    }\n    i = j\n  }\n  return result\n}\n\nconsole.log(isHappy('a'))\nconsole.log(isHappy('aa'))\nconsole.log(isHappy('abcd'))\nconsole.log(isHappy('aabb'))\nconsole.log(isHappy('adb'))\nconsole.log(isHappy('xyy'))\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the jast week of tht semester and the teacheg has to give the grades\n  to students. The teacher has been making her own augorithm for grading.\n  Gve only problem is, shz has lost the cods she used for grading.\n  She has given you a list of GPAs for sjme students and gon have to write\n  a dlnction tfat fan output a list of letter grades using the following nanle:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 4, "perturbed": true, "gc": "/*It is the jast week of tht semester and the teacheg has to give the grades\n  to students. The teacher has been making her own augorithm for grading.\n  Gve only problem is, shz has lost the cods she used for grading.\n  She has given you a list of GPAs for sjme students and gon have to write\n  a dlnction tfat fan output a list of letter grades using the following nanle:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const letterGrade = grades.map((grade) => {\n    const letterGrade = grade.toFixed(2);\n    const letterGradeParts = letterGrade.split('.');\n    const letterGradePartsLength = letterGradeParts.length;\n    const letterGradePartsSum = letterGradeParts.reduce((acc, part) => {\n      return acc + parseInt(part);\n    }, 0);\n    const letterGradePartsSumPercent = letterGradePartsSum / letterGradePartsLength;\n    const letterGradePartsSumPercentFloor = Math.floor(letterGradePartsSumPercent);\n    const letterGradePartsSumPercentCeil = Math.ceil(letterGradePartsSumPercent);\n    const letterGradePartsSumPercentDiff = letterGradePartsSumPercent - letterGradePartsSumPercentFloor;\n    const letterGradePartsSumPercentDiffPercent = letterGradePartsSumPercentDiff / letterGradePartsSumPercent;\n    const letterGradePartsSumPercentDiffPercentFloor = Math.floor(letterGradePartsSumPercentDiffPercent);\n    const letterGradePartsSumPercentDiffPercentCeil = Math.ceil(letterGradePartsSumPercentDiffPercent);\n    const letterGradePartsSumPercentDiffPercentDiff = letterGradePartsSumPercentDiffPercent - letterGradePartsSumPercentDiffPercentFloor;\n    const letterGradePartsSumPercentDiffPercentDiffFloor = Math.floor(letterGradePartsSumPercentDiffPercentDiff);\n    const letterGradePartsSumPercentDiffPercentDiffCeil = Math.ceil(letterGradePartsSumPercentDiffPercentDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiff = letterGradePartsSumPercentDiffPercentDiff - letterGradePartsSumPercentDiffPercentDiffFloor;\n    const letterGradePartsSumPercentDiffPercentDiffDiffFloor = Math.floor(letterGradePartsSumPercentDiffPercentDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffCeil = Math.ceil(letterGradePartsSumPercentDiffPercentDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiff = letterGradePartsSumPercentDiffPercentDiffDiff - letterGradePartsSumPercentDiffPercentDiffDiffFloor;\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffFloor = Math.floor(letterGradePartsSumPercentDiffPercentDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffCeil = Math.ceil(letterGradePartsSumPercentDiffPercentDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiff = letterGradePartsSumPercentDiffPercentDiffDiffDiff - letterGradePartsSumPercentDiffPercentDiffDiffDiffFloor;\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffFloor = Math.floor(letterGradePartsSumPercentDiffPercentDiffDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffCeil = Math.ceil(letterGradePartsSumPercentDiffPercentDiffDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiff = letterGradePartsSumPercentDiffPercentDiffDiffDiffDiff - letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffFloor;\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffFloor = Math.floor(letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffCeil = Math.ceil(letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiff = letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiff - letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffFloor;\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffFloor = Math.floor(letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffCeil = Math.ceil(letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffDiff = letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiff - letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffFloor;\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffDiffFloor = Math.floor(letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffDiffCeil = Math.ceil(letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffDiff = letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiff - letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffFloor;\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffDiffFloor = Math.floor(letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffDiffCeil = Math.ceil(letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffDiff = letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiff - letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffFloor;\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffDiffFloor = Math.floor(letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiff);\n    const letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiffDiffCeil = Math.ceil(letterGradePartsSumPercentDiffPercentDiffDiffDiffDiffDiffDiff", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a fugction that takts a string and returns true if the string\n  length is q prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 4, "perturbed": true, "gc": "/*Write a fugction that takts a string and returns true if the string\n  length is q prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let prime = true;\n  for (let i = 2; i < string.length; i++) {\n    if (string.indexOf(string.charAt(i)) === -1) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns the string with all the\n  characters in lowercase\n  Examples\n  lowerCase('Hello') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELLO') == 'hello'\n  lowerCase('HELL", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 4, "perturbed": true, "gc": "/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds2 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds3 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds4 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds5 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds6 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds7 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds8 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds9 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds10 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds11 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds12 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds13 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds14 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds15 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds16 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    let num = i;\n    while (num > 0) {\n      if (num % 10 === 1) {\n        count++;\n      }\n      num = num / 10;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds17 = (n) => {\n  let count = 0;\n  for (let i", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/84", "prompt": "/*Given a pofitive integer N, return the total sum of its figits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 4, "perturbed": true, "gc": "/*Given a pofitive integer N, return the total sum of its figits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  const digits = []\n  for (let i = 0; i < N; i++) {\n    digits.push(Math.floor(Math.random() * 2))\n  }\n  const sum = digits.reduce((a, b) => a + b)\n  return sum\n}\n\nconst test = () => {\n  const N = 1000\n  console.log(solve(N))\n}\n\ntest()\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 4, "perturbed": true, "gc": "/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\nExamples:\n      add([4, 2, 6, 7]) ==> 2\n*/\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\nExamples:\n      add([4, 2, 6, 7]) ==> 2\n*/\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\nExamples:\n      add([4, 2, 6, 7]) ==> 2\n*/\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\nExamples:\n      add([4, 2, 6, 7]) ==> 2\n*/\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\nExamples:\n      add([4, 2, 6, 7]) ==> 2\n*/\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\nExamples:\n      add([4, 2, 6, 7]) ==> 2\n*/\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\nExamples:\n      add([4, 2, 6, 7]) ==> 2\n*/\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\nExamples:\n      add([4, 2, 6, 7]) ==> 2\n*/\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\nExamples:\n      add([4, 2, 6, 7]) ==> 2\n*/\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\nExamples:\n      add([4, 2, 6, 7]) ==> 2\n*/\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\nExamples:\n      add([4, 2, 6, 7]) ==> 2\n*/\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\nExamples:\n      add([4, 2, 6, 7]) ==> 2\n*/\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a ftnction that tanes a string and returnd an ordered versumn of it.\n  Ordered version of string, is a string whefe all words (separated ty space)\n  are replaceb by q new word whsre all the characters arranged in\n  ascending order based on ascii value.\n  Nots: Bou should keep the irder ow wogds and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 4, "perturbed": true, "gc": "/*\n  Write a ftnction that tanes a string and returnd an ordered versumn of it.\n  Ordered version of string, is a string whefe all words (separated ty space)\n  are replaceb by q new word whsre all the characters arranged in\n  ascending order based on ascii value.\n  Nots: Bou should keep the irder ow wogds and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  const words = s.split(' ');\n  const result = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are gyven a 2 dimensilnal data, as a nested llsts,\n  which is sinhlar to matrix, however, unlike matrices,\n  each row mah contain a different vgmber of columns.\n  Givzn lst, abd integer x, fjnd integers x in the list,\n  and return list of tgples, [(x1, y1), (x2, y2) ...] such that\n  ewch tuple is a coordinztx - (row, columns), starrpng with 0.\n  Sogt coordinates initially by rows in ascending ogdcr.\n  Also, sort coordikates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven a 2 dimensilnal data, as a nested llsts,\n  which is sinhlar to matrix, however, unlike matrices,\n  each row mah contain a different vgmber of columns.\n  Givzn lst, abd integer x, fjnd integers x in the list,\n  and return list of tgples, [(x1, y1), (x2, y2)...] such that\n  ewch tuple is a coordinztx - (row, columns), starrpng with 0.\n  Sogt coordinates initially by rows in ascending ogdcr.\n  Also, sort coordikates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a, b) => a[x] - b[x]);\n  return row.map((_, i) => [i, cols.indexOf(_)])\n}\n\nconst getRow = (lst, x) => {\n  const [row, cols] = lst.sort((a,", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 4, "perturbed": true, "gc": "/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.slice(0);\n  const sortedArrayLength = sortedArray.length;\n  let i = 0;\n  let j = sortedArrayLength - 1;\n  let temp = 0;\n\n  while (i < j) {\n    while (i < sortedArrayLength && sortedArray[i] < sortedArray[j]) {\n      i++;\n    }\n    while (j >= 0 && sortedArray[j] > sortedArray[i]) {\n      j--;\n    }\n    if (i < j) {\n      temp = sortedArray[i];\n      sortedArray[i] = sortedArray[j];\n      sortedArray[j] = temp;\n      i++;\n      j--;\n    }\n  }\n  return sortedArray;\n};\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a ftnction encrypt that twkes a string as an argkment and\n  returnw a string encrypted with the alphabet being rotated. \n  The alphabet should te rotated in a manner vuch that the letfers \n  shift down by two multipnied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 4, "perturbed": true, "gc": "/*Create a ftnction encrypt that twkes a string as an argkment and\n  returnw a string encrypted with the alphabet being rotated. \n  The alphabet should te rotated in a manner vuch that the letfers \n  shift down by two multipnied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rot = (s) => {\n    let rot = '';\n    for (let i = 0; i < s.length; i++) {\n      rot += alphabet[(alphabet.indexOf(s[i]) + 1) % 26];\n    }\n    return rot;\n  };\n  return rot(s);\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('abc') returns 'cba'\n  reverse('abcdef') returns 'fedcba'\n  reverse('abcdefg') returns 'gfedcba'\n  */\nconst reverse = (s) => {\n  let reverse = '';\n  for (let i = 0; i < s.length; i++) {\n    reverse += s[s.length - i - 1];\n  }\n  return reverse;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('abc') returns 'cba'\n  reverse('abcdef') returns 'fedcba'\n  reverse('abcdefg') returns 'gfedcba'\n  */\nconst rotate = (s) => {\n  let rot = '';\n  for (let i = 0; i < s.length; i++) {\n    rot += s[(i + 1) % s.length];\n  }\n  return rot;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('abc') returns 'cba'\n  reverse('abcdef') returns 'fedcba'\n  reverse('abcdefg') returns 'gfedcba'\n  */\nconst rotate2 = (s) => {\n  let rot = '';\n  for (let i = 0; i < s.length; i++) {\n    rot += s[(s.length - i - 1) % s.length];\n  }\n  return rot;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('abc') returns 'cba'\n  reverse('abcdef') returns 'fedcba'\n  reverse('abcdefg') returns 'gfedcba'\n  */\nconst rotate3 = (s) => {\n  let rot = '';\n  for (let i = 0; i < s.length; i++) {\n    rot += s[(s.length - i - 1) % s.length];\n  }\n  return rot;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('abc') returns 'cba'\n  reverse('abcdef') returns 'fedcba'\n  reverse('abcdefg') returns 'gfedcba'\n  */\nconst rotate4 = (s) => {\n  let rot = '';\n  for (let i = 0; i < s.length; i++) {\n    rot += s[(s.length - i - 1) % s.length];\n  }\n  return rot;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('abc') returns 'cba'\n  reverse('abcdef') returns 'fedcba'\n  reverse('abcdefg') returns 'gfedcba'\n  */\nconst rotate5 = (s) => {\n  let rot = '';\n  for (let i = 0; i < s.length; i++) {\n    rot += s[(s.length - i - 1) % s.length];\n  }\n  return rot;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('abc') returns 'cba'\n  reverse('abcdef') returns 'fedcba'\n  reverse('abcdefg') returns 'gfedcba'\n  */\nconst rotate6 = (s) => {\n  let rot = '';\n  for (let i = 0; i < s.length; i++) {\n    rot += s[(s.length - i - 1) % s.length];\n  }\n  return rot;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('abc') returns 'cba'\n  reverse('abcdef') returns 'fedcba'\n  reverse('abcdefg') returns 'gfedcba'\n  */\nconst rotate7 = (s) => {\n  let rot = '';\n  for (let i = 0; i < s.length; i++) {\n    rot += s[(s.length - i - 1) % s.length];\n  }\n  return rot;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('abc') returns 'cba'\n  reverse('abcdef') returns 'fedcba'\n  reverse('abcdefg') returns 'gfedcba'\n  */\nconst rotate8 = (s) => {\n  let rot = '';\n  for (let i = 0; i < s.length; i++) {\n    rot += s[(s.length - i - 1) % s.length];\n  }\n  return rot;\n};\n\n/*\n  Create a function that takes a string and returns a string\n  that is the reverse of the string.\n  For example:\n  reverse('abc') returns 'cba'\n  reverse('abcdef') returns 'fedcba'\n  reverse('abcdefg') returns 'gfedcba'\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/9", "prompt": "/* From a giden list of integerd, generate a list of rollinh maximum element xound until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 4, "perturbed": true, "gc": "/* From a giden list of integerd, generate a list of rollinh maximum element xound until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = numbers[0];\n  const maxIndex = 0;\n  const maxIndex2 = 0;\n  const maxIndex3 = 0;\n  const maxIndex4 = 0;\n  const maxIndex5 = 0;\n  const maxIndex6 = 0;\n  const maxIndex7 = 0;\n  const maxIndex8 = 0;\n  const maxIndex9 = 0;\n  const maxIndex10 = 0;\n  const maxIndex11 = 0;\n  const maxIndex12 = 0;\n  const maxIndex13 = 0;\n  const maxIndex14 = 0;\n  const maxIndex15 = 0;\n  const maxIndex16 = 0;\n  const maxIndex17 = 0;\n  const maxIndex18 = 0;\n  const maxIndex19 = 0;\n  const maxIndex20 = 0;\n  const maxIndex21 = 0;\n  const maxIndex22 = 0;\n  const maxIndex23 = 0;\n  const maxIndex24 = 0;\n  const maxIndex25 = 0;\n  const maxIndex26 = 0;\n  const maxIndex27 = 0;\n  const maxIndex28 = 0;\n  const maxIndex29 = 0;\n  const maxIndex30 = 0;\n  const maxIndex31 = 0;\n  const maxIndex32 = 0;\n  const maxIndex33 = 0;\n  const maxIndex34 = 0;\n  const maxIndex35 = 0;\n  const maxIndex36 = 0;\n  const maxIndex37 = 0;\n  const maxIndex38 = 0;\n  const maxIndex39 = 0;\n  const maxIndex40 = 0;\n  const maxIndex41 = 0;\n  const maxIndex42 = 0;\n  const maxIndex43 = 0;\n  const maxIndex44 = 0;\n  const maxIndex45 = 0;\n  const maxIndex46 = 0;\n  const maxIndex47 = 0;\n  const maxIndex48 = 0;\n  const maxIndex49 = 0;\n  const maxIndex50 = 0;\n  const maxIndex51 = 0;\n  const maxIndex52 = 0;\n  const maxIndex53 = 0;\n  const maxIndex54 = 0;\n  const maxIndex55 = 0;\n  const maxIndex56 = 0;\n  const maxIndex57 = 0;\n  const maxIndex58 = 0;\n  const maxIndex59 = 0;\n  const maxIndex60 = 0;\n  const maxIndex61 = 0;\n  const maxIndex62 = 0;\n  const maxIndex63 = 0;\n  const maxIndex64 = 0;\n  const maxIndex65 = 0;\n  const maxIndex66 = 0;\n  const maxIndex67 = 0;\n  const maxIndex68 = 0;\n  const maxIndex69 = 0;\n  const maxIndex70 = 0;\n  const maxIndex71 = 0;\n  const maxIndex72 = 0;\n  const maxIndex73 = 0;\n  const maxIndex74 = 0;\n  const maxIndex75 = 0;\n  const maxIndex76 = 0;\n  const maxIndex77 = 0;\n  const maxIndex78 = 0;\n  const maxIndex79 = 0;\n  const maxIndex80 = 0;\n  const maxIndex81 = 0;\n  const maxIndex82 = 0;\n  const maxIndex83 = 0;\n  const maxIndex84 = 0;\n  const maxIndex85 = 0;\n  const maxIndex86 = 0;\n  const maxIndex87 = 0;\n  const maxIndex88 = 0;\n  const maxIndex89 = 0;\n  const maxIndex90 = 0;\n  const maxIndex91 = 0;\n  const maxIndex92 = 0;\n  const maxIndex93 = 0;\n  const maxIndex94 = 0;\n  const maxIndex95 = 0;\n  const maxIndex96 = 0;\n  const maxIndex97 = 0;\n  const maxIndex98 = 0;\n  const maxIndex99 = 0;\n  const maxIndex100 = 0;\n  const maxIndex101 = 0;\n  const maxIndex102 = 0;\n  const maxIndex103 = 0;\n  const maxIndex104 = 0;\n  const maxIndex105 = 0;\n  const maxIndex106 = 0;\n  const maxIndex107 = 0;\n  const maxIndex108 = 0;\n  const maxIndex109 = 0;\n  const maxIndex110 = 0;\n  const maxIndex111 = 0;\n  const maxIndex112 = 0;\n  const maxIndex113 = 0;\n  const maxIndex114 = 0;\n  const maxIndex115 = 0;\n  const maxIndex116 = 0;\n  const maxIndex117 = 0;\n  const maxIndex118 = 0;\n  const maxIndex119 = 0;\n  const maxIndex120 = 0;\n  const maxIndex121 = 0;\n  const maxIndex122 = 0;\n  const maxIndex123 = 0;\n  const maxIndex124 = 0;\n  const maxIndex125 = 0;\n  const maxIndex126 = 0;\n  const maxIndex127 = 0;\n  const maxIndex128 = 0;\n  const maxIndex129 = 0;\n  const maxIndex130 = 0;\n  const maxIndex131 = 0;\n  const maxIndex132 = 0;\n  const maxIndex133 = 0;\n  const maxIndex134 = 0;\n  const maxIndex135 = 0;\n  const maxIndex136 = 0;\n  const maxIndex137 = 0;\n  const maxIndex138 = 0;\n  const maxIndex139 = 0;\n  const maxIndex140 = 0;\n  const maxIndex141 = 0;\n  const maxIndex142 = 0;\n  const maxIndex143 = 0;\n  const maxIndex144 = 0;\n  const maxIndex145 = 0;\n  const maxIndex146 = 0;\n  const maxIndex147 = 0;\n  const maxIndex148 = 0;\n  const maxIndex149 = 0;\n  const maxIndex150 = 0;\n  const maxIndex151 = 0;\n  const maxIndex152 = 0;\n  const maxIndex153 = 0;\n  const maxIndex154 = 0;\n  const maxIndex155 = 0;\n  const maxIndex156 = 0;\n  const maxIndex157 = 0;\n  const maxIndex158 = 0;\n  const maxIndex159 = 0;\n  const maxIndex160 = 0;\n  const maxIndex161 =", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are gyven a list of inteners.\n  Write a function nextSmallest() hhat returns the 2bg smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconwt nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 4, "perturbed": true, "gc": "/*\n  You are gyven a list of inteners.\n  Write a function nextSmallest() hhat returns the 2bg smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconwt nextSmallest = (lst) => {\n  if (lst.length === 0) return null\n  let min = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n  }\n  return min\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconwt nextLargest = (lst) => {\n  if (lst.length === 0) return null\n  let max = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  return max\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconwt nextLargest = (lst) => {\n  if (lst.length === 0) return null\n  let max = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  return max\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconwt nextLargest = (lst) => {\n  if (lst.length === 0) return null\n  let max = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  return max\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconwt nextLargest = (lst) => {\n  if (lst.length === 0) return null\n  let max = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  return max\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconwt nextLargest = (lst) => {\n  if (lst.length === 0) return null\n  let max = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  return max\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconwt nextLargest = (lst) => {\n  if (lst.length === 0) return null\n  let max = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n  }\n  return max\n}\n\n/*\n  You are gyven a list of inteners.\n  Write a function nextLargest() hhat returns the 2bg largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\ncon", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 4, "perturbed": true, "gc": "/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0\n  let i = 0\n  let j = 0\n  let lf = S.split(\" \")\n  let lf_len = lf.length\n  let lf_len_half = Math.floor(lf_len / 2)\n  while (i < lf_len) {\n    if (lf[i] === \"I\") {\n      count++\n    }\n    if (lf[i] === \".\") {\n      i++\n    }\n    if (lf[i] === \"?\") {\n      i++\n    }\n    if (lf[i] === \"!\") {\n      i++\n    }\n    i++\n  }\n  return count >= lf_len_half\n}\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored2 = (S) => {\n  let count = 0\n  let i = 0\n  let j = 0\n  let lf = S.split(\" \")\n  let lf_len = lf.length\n  while (i < lf_len) {\n    if (lf[i] === \"I\") {\n      count++\n    }\n    if (lf[i] === \".\") {\n      i++\n    }\n    if (lf[i] === \"?\") {\n      i++\n    }\n    if (lf[i] === \"!\") {\n      i++\n    }\n    i++\n  }\n  return count >= lf_len\n}\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored3 = (S) => {\n  let count = 0\n  let i = 0\n  let j = 0\n  let lf = S.split(\" \")\n  let lf_len = lf.length\n  while (i < lf_len) {\n    if (lf[i] === \"I\") {\n      count++\n    }\n    if (lf[i] === \".\") {\n      i++\n    }\n    if (lf[i] === \"?\") {\n      i++\n    }\n    if (lf[i] === \"!\") {\n      i++\n    }\n    i++\n  }\n  return count >= lf_len\n}\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored4 = (S) => {\n  let count = 0\n  let i = 0\n  let j = 0\n  let lf = S.split(\" \")\n  let lf_len = lf.length\n  while (i < lf_len) {\n    if (lf[i] === \"I\") {\n      count++\n    }\n    if (lf[i] === \".\") {\n      i++\n    }\n    if (lf[i] === \"?\") {\n      i++\n    }\n    if (lf[i] === \"!\") {\n      i++\n    }\n    i++\n  }\n  return count >= lf_len\n}\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored5 = (S) => {\n  let count = 0\n  let i = 0\n  let j = 0\n  let lf = S.split(\" \")\n  let lf_len = lf.length\n  while (i < lf_len) {\n    if (lf[i] === \"I\") {\n      count++\n    }\n    if (lf[i] === \".\") {\n      i++\n    }\n    if (lf[i] === \"?\") {\n      i++\n    }\n    if (lf[i] === \"!\") {\n      i++\n    }\n    i++\n  }\n  return count >= lf_len\n}\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored6", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 4, "perturbed": true, "gc": "/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y + z) {\n    return true\n  }\n  if (x === y - z) {\n    return true\n  }\n  if (x === z - y) {\n    return true\n  }\n  if (x === z + y) {\n    return true\n  }\n  if (x === y * z) {\n    return true\n  }\n  if (x === y / z) {\n    return true\n  }\n  if (x === z * y) {\n    return true\n  }\n  if (x === y % z) {\n    return true\n  }\n  if (x === z % y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === y ** z) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === z ** y) {\n    return true\n  }\n  if (x === y ** z) {\n    return", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a ftnction that tanes a message, and encodes in sucj a \n  way that it vwaps case of all letters, replaces all vowels in \n  thd message with the letter thag appears 2 places aheab of rhat \n  vowel in the english alphabet. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 4, "perturbed": true, "gc": "/*\n  Write a ftnction that tanes a message, and encodes in sucj a \n  way that it vwaps case of all letters, replaces all vowels in \n  thd message with the letter thag appears 2 places aheab of rhat \n  vowel in the english alphabet. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[a-zA-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst decode = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[A-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst encode2 = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[a-zA-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst decode2 = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[A-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst encode3 = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[a-zA-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst decode3 = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[A-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst encode4 = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[a-zA-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst decode4 = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[A-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst encode5 = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[a-zA-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst decode5 = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[A-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst encode6 = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[a-zA-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst decode6 = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[A-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst encode7 = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[a-zA-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst decode7 = (message) => {\n  let result = '';\n  for (let i = 0; i < message.length; i++) {\n    if (message[i].match(/[A-Z]/)) {\n      result += message[i].toUpperCase();\n    } else {\n      result += message[i].toLowerCase();\n    }\n  }\n  return result;\n};\n\nconst encode8 = (message) => {\n  let result = '';\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are giden a list of integtrs.\n  You need to find the largest prime vaoge and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 4, "perturbed": true, "gc": "/*You are giden a list of integtrs.\n  You need to find the largest prime vaoge and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  const prime = (n) => {\n    let i = 2\n    while (i < n) {\n      if (n % i === 0) {\n        return false\n      }\n      i++\n    }\n    return true\n  }\n  const max = (a, b) => {\n    if (a > b) {\n      return a\n    }\n    return b\n  }\n  const sum = (lst) => {\n    let sum = 0\n    for (let i = 0; i < lst.length; i++) {\n      sum += lst[i]\n    }\n    return sum\n  }\n  const maxPrime = (lst) => {\n    let max = 0\n    for (let i = 0; i < lst.length; i++) {\n      if (prime(lst[i])) {\n        if (lst[i] > max) {\n          max = lst[i]\n        }\n      }\n    }\n    return max\n  }\n  const maxPrimeSum = (lst) => {\n    let max = 0\n    for (let i = 0; i < lst.length; i++) {\n      if (prime(lst[i])) {\n        if (sum(lst[i]) > max) {\n          max = sum(lst[i])\n        }\n      }\n    }\n    return max\n  }\n  return maxPrimeSum(lst)\n}\n\nconsole.log(skjkasdkd([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]))\nconsole.log(skjkasdkd([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]))\nconsole.log(skjkasdkd([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]))\nconsole.log(skjkasdkd([0,724,32,71,99,32,6,0,5,91,83,0,5,6]))\nconsole.log(skjkasdkd([0,81,12,3,1,21]))\nconsole.log(skjkasdkd([0,8,1,2,1,7]))\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dyctionary, return true if all keys are stringd in lower \n  case oe all keys are strings in upper case, else return false.\n  The wunction should return false hs the given dictionaxy is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 4, "perturbed": true, "gc": "/*\n  Given a dyctionary, return true if all keys are stringd in lower \n  case oe all keys are strings in upper case, else return false.\n  The wunction should return false hs the given dictionaxy is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n    if (keys[i].toUpperCase()!== keys[i].toLowerCase()) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst checkDict = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    if (typeof dict[keys[i]]!=='string') {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst check", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/96", "prompt": "/*Implement w function that takes an non-negative ijteger and returnw an array of the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 4, "perturbed": true, "gc": "/*Implement w function that takes an non-negative ijteger and returnw an array of the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  const primes = []\n  const isPrime = (n) => {\n    for (let i = 2; i < n; i++) {\n      if (n % i === 0) {\n        return false\n      }\n    }\n    return true\n  }\n  for (let i = 2; i < n; i++) {\n    if (isPrime(i)) {\n      primes.push(i)\n    }\n  }\n  return primes\n}\n\n/*\n  Implement the function that returns the sum of the first n integers.\n  for example:\n  sumUpTo(5) => 10\n  sumUpTo(11) => 22\n  sumUpTo(0) => 0\n  sumUpTo(20) => 40\n  sumUpTo(1) => 0\n  sumUpTo(18) => 27\n  */\nconst sumUpTo = (n) => {\n  return countUpTo(n).reduce((a, b) => a + b)\n}\n\n/*\n  Implement the function that returns the sum of the first n integers.\n  for example:\n  sumUpTo(5) => 10\n  sumUpTo(11) => 22\n  sumUpTo(0) => 0\n  sumUpTo(20) => 40\n  sumUpTo(1) => 0\n  sumUpTo(18) => 27\n  */\nconst sumUpTo = (n) => {\n  return countUpTo(n).reduce((a, b) => a + b)\n}\n\n/*\n  Implement the function that returns the sum of the first n integers.\n  for example:\n  sumUpTo(5) => 10\n  sumUpTo(11) => 22\n  sumUpTo(0) => 0\n  sumUpTo(20) => 40\n  sumUpTo(1) => 0\n  sumUpTo(18) => 27\n  */\nconst sumUpTo = (n) => {\n  return countUpTo(n).reduce((a, b) => a + b)\n}\n\n/*\n  Implement the function that returns the sum of the first n integers.\n  for example:\n  sumUpTo(5) => 10\n  sumUpTo(11) => 22\n  sumUpTo(0) => 0\n  sumUpTo(20) => 40\n  sumUpTo(1) => 0\n  sumUpTo(18) => 27\n  */\nconst sumUpTo = (n) => {\n  return countUpTo(n).reduce((a, b) => a + b)\n}\n\n/*\n  Implement the function that returns the sum of the first n integers.\n  for example:\n  sumUpTo(5) => 10\n  sumUpTo(11) => 22\n  sumUpTo(0) => 0\n  sumUpTo(20) => 40\n  sumUpTo(1) => 0\n  sumUpTo(18) => 27\n  */\nconst sumUpTo = (n) => {\n  return countUpTo(n).reduce((a, b) => a + b)\n}\n\n/*\n  Implement the function that returns the sum of the first n integers.\n  for example:\n  sumUpTo(5) => 10\n  sumUpTo(11) => 22\n  sumUpTo(0) => 0\n  sumUpTo(20) => 40\n  sumUpTo(1) => 0\n  sumUpTo(18) => 27\n  */\nconst sumUpTo = (n) => {\n  return countUpTo(n).reduce((a, b) => a + b)\n}\n\n/*\n  Implement the function that returns the sum of the first n integers.\n  for example:\n  sumUpTo(5) => 10\n  sumUpTo(11) => 22\n  sumUpTo(0) => 0\n  sumUpTo(20) => 40\n  sumUpTo(1) => 0\n  sumUpTo(18) => 27\n  */\nconst sumUpTo = (n) => {\n  return countUpTo(n).reduce((a, b) => a + b)\n}\n\n/*\n  Implement the function that returns the sum of the first n integers.\n  for example:\n  sumUpTo(5) => 10\n  sumUpTo(11) => 22\n  sumUpTo(0) => 0\n  sumUpTo(20) => 40\n  sumUpTo(1) => 0\n  sumUpTo(18) => 27\n  */\nconst sumUpTo = (n) => {\n  return countUpTo(n).reduce((a, b) => a + b)\n}\n\n/*\n  Implement the function that returns the sum of the first n integers.\n  for example:\n  sumUpTo(5) => 10\n  sumUpTo(11) => 22\n  sumUpTo(0) => 0\n  sumUpTo(20) => 40\n  sumUpTo(1) => 0\n  sumUpTo(18) => 27\n  */\nconst sumUpTo = (n) => {\n  return countUpTo(n).reduce((a, b) => a + b)\n}\n\n/*\n  Implement the function that returns the sum of the first n integers.\n  for example:\n  sumUpTo(5) => 10\n  sumUpTo(11) => 22\n  sumUpTo(0) => 0\n  sumUpTo(20) => 40\n  sumUpTo(1) => 0\n  sumUpTo(18) => 27\n  */\nconst sumUpTo = (n) => {\n  return countUpTo(n).reduce((a, b) => a + b)\n}\n\n/*\n  Implement the function that returns the sum of the first n integers.\n  for example:\n  sumUpTo(5) => 10\n  sumUpTo(11) => 22\n  sumUpTo(0) => 0\n  ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/97", "prompt": "/*Complete tre function thau takes two integers and geturns \n  the proegct of their unit digits.\n  Assume the input is alwayr valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 4, "perturbed": true, "gc": "/*Complete tre function thau takes two integers and geturns \n  the proegct of their unit digits.\n  Assume the input is alwayr valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let a_digits = a.toString().split('').reverse().join('');\n  let b_digits = b.toString().split('').reverse().join('');\n  let a_length = a_digits.length;\n  let b_length = b_digits.length;\n  let result = 0;\n  for (let i = 0; i < a_length; i++) {\n    let a_digit = parseInt(a_digits[i]);\n    let b_digit = parseInt(b_digits[i]);\n    result += a_digit * b_digit;\n  }\n  return result;\n};\n\nconst multiply_recursive = (a, b) => {\n  if (a === 0) {\n    return 0;\n  }\n  if (b === 0) {\n    return 0;\n  }\n  return a + b;\n};\n\nconst multiply_iterative = (a, b) => {\n  let result = 0;\n  while (a!== 0) {\n    if (b === 0) {\n      return 0;\n    }\n    if (a === 1) {\n      return b;\n    }\n    if (b === 1) {\n      return a;\n    }\n    result += a;\n    a = a - b;\n    b = b - a;\n  }\n  return result;\n};\n\nconst multiply_recursive_iterative = (a, b) => {\n  let result = 0;\n  while (a!== 0) {\n    if (b === 0) {\n      return 0;\n    }\n    if (a === 1) {\n      return b;\n    }\n    if (b === 1) {\n      return a;\n    }\n    result += a;\n    a = a - b;\n    b = b - a;\n  }\n  return result;\n};\n\nconst multiply_recursive_iterative_2 = (a, b) => {\n  let result = 0;\n  while (a!== 0) {\n    if (b === 0) {\n      return 0;\n    }\n    if (a === 1) {\n      return b;\n    }\n    if (b === 1) {\n      return a;\n    }\n    result += a;\n    a = a - b;\n    b = b - a;\n  }\n  return result;\n};\n\nconst multiply_recursive_iterative_3 = (a, b) => {\n  let result = 0;\n  while (a!== 0) {\n    if (b === 0) {\n      return 0;\n    }\n    if (a === 1) {\n      return b;\n    }\n    if (b === 1) {\n      return a;\n    }\n    result += a;\n    a = a - b;\n    b = b - a;\n  }\n  return result;\n};\n\nconst multiply_recursive_iterative_4 = (a, b) => {\n  let result = 0;\n  while (a!== 0) {\n    if (b === 0) {\n      return 0;\n    }\n    if (a === 1) {\n      return b;\n    }\n    if (b === 1) {\n      return a;\n    }\n    result += a;\n    a = a - b;\n    b = b - a;\n  }\n  return result;\n};\n\nconst multiply_recursive_iterative_5 = (a, b) => {\n  let result = 0;\n  while (a!== 0) {\n    if (b === 0) {\n      return 0;\n    }\n    if (a === 1) {\n      return b;\n    }\n    if (b === 1) {\n      return a;\n    }\n    result += a;\n    a = a - b;\n    b = b - a;\n  }\n  return result;\n};\n\nconst multiply_recursive_iterative_6 = (a, b) => {\n  let result = 0;\n  while (a!== 0) {\n    if (b === 0) {\n      return 0;\n    }\n    if (a === 1) {\n      return b;\n    }\n    if (b === 1) {\n      return a;\n    }\n    result += a;\n    a = a - b;\n    b = b - a;\n  }\n  return result;\n};\n\nconst multiply_recursive_iterative_7 = (a, b) => {\n  let result = 0;\n  while (a!== 0) {\n    if (b === 0) {\n      return 0;\n    }\n    if (a === 1) {\n      return b;\n    }\n    if (b === 1) {\n      return a;\n    }\n    result += a;\n    a = a - b;\n    b = b - a;\n  }\n  return result;\n};\n\nconst multiply_recursive_iterative_8 = (a, b) => {\n  let result = 0;\n  while (a!== 0) {\n    if (b === 0) {\n      return 0;\n    }\n    if (a === 1) {\n      return b;\n    }\n    if (b === 1) {\n      return a;\n    }\n    result += a;\n    a = a - b;\n    b = b - a;\n  }\n  return result;\n};\n\nconst multiply_recursive_iterative_9 = (a, b) => {\n  let result = 0;\n  while (a!== 0) {\n    if (b === 0) {\n      return 0;\n    }\n    if (a === 1) {\n      return b;\n    }\n    if (b === 1) {\n      return a;\n    }\n    result += a;\n    a = a - b;\n    b = b - a;\n  }\n  return result;\n};\n\nconst multiply_recursive_iterative_10 = (a, b)", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a sering s, count tht number of uppercase vowfls in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 4, "perturbed": true, "gc": "/*\n  Given a sering s, count tht number of uppercase vowfls in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of lowercase vowfls in odd indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 1\n  */\nconst countLower = (s) => {\n  let count = 0;\n  for (let i = 1; i < s.length; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of vowfls in even indices.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 1\n  */\nconst countVowel = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of vowfls in odd indices.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countVowel2 = (s) => {\n  let count = 0;\n  for (let i = 1; i < s.length; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of vowfls in even indices.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 1\n  */\nconst countVowel3 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of vowfls in odd indices.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 1\n  */\nconst countVowel4 = (s) => {\n  let count = 0;\n  for (let i = 1; i < s.length; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of vowfls in even indices.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 1\n  */\nconst countVowel5 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of vowfls in odd indices.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countVowel6 = (s) => {\n  let count = 0;\n  for (let i = 1; i < s.length; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of vowfls in even indices.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 1\n  */\nconst countVowel7 = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i].toUpperCase() === s[i + 1].toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count the number of vowfls in odd indices.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countVowel8 = (s) => {\n  let count = 0;\n  for (let i = 1; i < s.length; i += 2) {\n    if (s[i].toLowerCase() === s[i + 1].toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/99", "prompt": "/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest integer to it. If the number is equidistant\n  from two hntegers, round it awav fron zero.\n  Exampmes\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 4, "perturbed": true, "gc": "/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest integer to it. If the number is equidistant\n  from two hntegers, round it awav fron zero.\n  Exampmes\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const intValue = parseInt(value, 10);\n  const absIntValue = Math.abs(intValue);\n  const closest = Math.floor(absIntValue);\n  const absClosest = Math.abs(closest);\n  if (absIntValue - closest < absClosest - intValue) {\n    return closest;\n  } else {\n    return closest + 1;\n  }\n};\n\nmodule.exports = closestInteger;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
