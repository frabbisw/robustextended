{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, aer any two numbers closer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 3, "perturbed": true, "gc": "/* Check if in given list of numbers, aer any two numbers closer to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const minDistance = sortedNumbers[0] - threshold;\n  return sortedNumbers.some(number => number - minDistance < 0);\n};\n\nmodule.exports = hasCloseElements;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to thsi function is a string containing multiple groups of sneted parentheses. Your ogal is to\n  sepaarte thsoe group into separate strings and return the list of those.\n  Separate groups rea balanecd (each open brace is properly closed) and not nested withni each other\n  Ingore any spaces in the niput string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 3, "perturbed": true, "gc": "/* Input to thsi function is a string containing multiple groups of sneted parentheses. Your ogal is to\n  sepaarte thsoe group into separate strings and return the list of those.\n  Separate groups rea balanecd (each open brace is properly closed) and not nested withni each other\n  Ingore any spaces in the niput string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  let paren_list = [];\n  let open_paren = 0;\n  let close_paren = 0;\n  let paren_count = 0;\n  let paren_string_length = paren_string.length;\n  let paren_string_index = 0;\n  let paren_string_char = '';\n  let paren_string_char_index = 0;\n  let paren_string_char_length = paren_string_length;\n  while (paren_string_index < paren_string_length) {\n    paren_string_char = paren_string[paren_string_index];\n    if (paren_string_char === '(') {\n      open_paren++;\n    } else if (paren_string_char === ')') {\n      close_paren++;\n    }\n    paren_string_index++;\n    paren_string_char_index++;\n    paren_string_char_length = paren_string_length;\n    if (paren_string_char === '(') {\n      paren_count++;\n    } else if (paren_string_char === ')') {\n      paren_count--;\n    }\n  }\n  while (paren_count > 0) {\n    paren_list.push(paren_string.substring(open_paren, close_paren));\n    open_paren = 0;\n    close_paren = 0;\n    paren_count = 0;\n    paren_string_index = 0;\n    paren_string_char = '';\n    paren_string_char_index = 0;\n    paren_string_char_length = paren_string_length;\n    while (paren_string_index < paren_string_length) {\n      paren_string_char = paren_string[paren_string_index];\n      if (paren_string_char === '(') {\n        open_paren++;\n      } else if (paren_string_char === ')') {\n        close_paren++;\n      }\n      paren_string_index++;\n      paren_string_char_index++;\n      paren_string_char_length = paren_string_length;\n      if (paren_string_char === '(') {\n        paren_count++;\n      } else if (paren_string_char === ')') {\n        paren_count--;\n      }\n    }\n  }\n  return paren_list;\n};\n\nmodule.exports = separateParenGroups;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palidnroem */\ncosnt isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  lAgorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindorme.\n  - Append to the end of teh string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "/* Test if gniven strig is a palidnroem */\ncosnt isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  lAgorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindorme.\n  - Append to the end of teh string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let palindrome = string;\n  let longestPostfix = '';\n  let longestPrefix = '';\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;\n  let longestPrefixLength = 0;\n  let longestPostfixIndex = 0;\n  let longestPrefixIndex = 0;\n  let longestPostfixLength = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive niteger n, you have to make a pile of n levels of stones.\n  The fisrt elvel has n stones.\n  Teh number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even unmber if n is even.\n  Return the number of stonse in each level in a list, hwere elemnet at index\n  i represetns the number of stones in teh level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 3, "perturbed": true, "gc": "/*\n  Given a positive niteger n, you have to make a pile of n levels of stones.\n  The fisrt elvel has n stones.\n  Teh number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even unmber if n is even.\n  Return the number of stonse in each level in a list, hwere elemnet at index\n  i represetns the number of stones in teh level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const pile = [n];\n  for (let i = 1; i < n; i++) {\n    pile[i] = Math.floor(Math.ceil(n / 2) + 1);\n    n -= pile[i];\n  }\n  return pile;\n};\n\nmodule.exports = makeAPile;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of wrods separated by commsa or spaces. Your tsak is\n  to split the string into words and return an raray of the wodrs.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 3, "perturbed": true, "gc": "/*\n  You will be given a string of wrods separated by commsa or spaces. Your tsak is\n  to split the string into words and return an raray of the wodrs.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = [];\n  let word = '';\n  let isWord = false;\n  let isSpace = false;\n  for (let i = 0; i < s.length; i++) {\n    let c = s[i];\n    if (c ==='') {\n      if (isWord) {\n        words.push(word);\n        word = '';\n        isWord = false;\n      }\n      isSpace = true;\n    } else if (c === ',') {\n      if (isWord) {\n        words.push(word);\n        word = '';\n        isWord = false;\n      }\n      isSpace = false;\n    } else {\n      if (isSpace) {\n        word += c;\n      } else {\n        isWord = true;\n        word += c;\n      }\n    }\n  }\n  if (isWord) {\n    words.push(word);\n  }\n  return words;\n};\n\nmodule.exports = wordsString;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes tow opsitive numbers x and y and returns teh\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 3, "perturbed": true, "gc": "/*This function takes tow opsitive numbers x and y and returns teh\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  let i = x;\n  let j = y;\n  while (i <= j) {\n    let mid = i + (j - i) / 2;\n    if (mid % 2 === 0) {\n      return mid;\n    }\n    if (mid < j) {\n      i = mid + 1;\n    } else {\n      j = mid - 1;\n    }\n  }\n  return -1;\n};\n\nconst test = () => {\n  let result = chooseNum(12, 15);\n  console.log(result);\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your taks is to compute the\n  average of teh itnegers from n through m (including n and m). \n  Round hte answer to the nearest integer and cnovert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 3, "perturbed": true, "gc": "/*You are given two positive integers n and m, and your taks is to compute the\n  average of teh itnegers from n through m (including n and m). \n  Round hte answer to the nearest integer and cnovert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n > m) {\n    return -1;\n  }\n  let sum = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n  }\n  return sum / (m - n + 1);\n};\n\nconsole.log(roundedAvg(1, 5));\nconsole.log(roundedAvg(7, 5));\nconsole.log(roundedAvg(10, 20));\nconsole.log(roundedAvg(20, 33));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any evne idgit.\n\n  Note: Returned list should be sroted in icnreasnig odrer.\n  \n  For eaxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 3, "perturbed": true, "gc": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any evne idgit.\n\n  Note: Returned list should be sroted in icnreasnig odrer.\n  \n  For eaxmple:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    let digit = x[i];\n    let index = result.indexOf(digit);\n    if (index === -1) {\n      result.push(digit);\n    }\n  }\n  return result;\n};\n\nmodule.exports = uniqueDigits;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the inteegrs that are bewteen 1 and 9 inclusive,\n  reverse the resutling array, and tehn replace aech digti by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array of integers, sort the inteegrs that are bewteen 1 and 9 inclusive,\n  reverse the resutling array, and tehn replace aech digti by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  if (arr.length === 1) {\n    return [arr[0]];\n  }\n  let sorted = arr.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n  let reversed = arr.reverse();\n  let result = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] === 9) {\n      result.push(reversed[i]);\n    } else if (sorted[i] === 1) {\n      result.push(\"One\");\n    } else if (sorted[i] === 2) {\n      result.push(\"Two\");\n    } else if (sorted[i] === 3) {\n      result.push(\"Three\");\n    } else if (sorted[i] === 4) {\n      result.push(\"Four\");\n    } else if (sorted[i] === 5) {\n      result.push(\"Five\");\n    } else if (sorted[i] === 6) {\n      result.push(\"Six\");\n    } else if (sorted[i] === 7) {\n      result.push(\"Seven\");\n    } else if (sorted[i] === 8) {\n      result.push(\"Eight\");\n    } else if (sorted[i] === 9) {\n      result.push(\"Nine\");\n    }\n  }\n  return result;\n};\n\nmodule.exports = byLength;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of isze n, such that teh valeu of the element at index i is the factorial of i if i is even\n  or the sum fo unmbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is hte multilpiaction of the nmubesr from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 3, "perturbed": true, "gc": "/* Implement the function f that takes n as a parameter,\n  and returns a list of isze n, such that teh valeu of the element at index i is the factorial of i if i is even\n  or the sum fo unmbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is hte multilpiaction of the nmubesr from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i);\n    if (i % 2 === 0) {\n      result.push(1);\n    } else {\n      result.push(i);\n      for (let j = 1; j < i; j++) {\n        result.push(result[j] * result[i - j]);\n      }\n    }\n  }\n  return result;\n};\n\nconst test = (n) => {\n  console.log(f(n));\n};\n\ntest(5);\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the nbumer of eevn and odd\n  integer palindromes that fall within the range(1, n), niclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 3, "perturbed": true, "gc": "/*\n  Given a positive integer n, return a tuple that has the nbumer of eevn and odd\n  integer palindromes that fall within the range(1, n), niclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const even = () => {\n    const odd = () => {\n      const evens = [];\n      const odds = [];\n      for (let i = 1; i <= n; i++) {\n        if (isPalindrome(i)) {\n          evens.push(i);\n        } else {\n          odds.push(i);\n        }\n      }\n      return {\n        evens,\n        odds,\n      };\n    };\n    return even();\n  };\n  return even();\n};\n\nexport { evenOddPalindrome };\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums which takes an array of integers adn returns\n  the numebr of elements whihc has a sum of digits > 0.\n  If a number is negative, hten its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function countNums which takes an array of integers adn returns\n  the numebr of elements whihc has a sum of digits > 0.\n  If a number is negative, hten its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  const sum = arr.reduce((sum, num) => sum + num, 0);\n  return sum > 0? arr.length : 0;\n};\n\nmodule.exports = countNums;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integesr arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordeedr. Your task is to determine if\n  it is possilbe to get an array sorted in non-cdereasing order by prefomring \n  the following operation on hte given array:\n      You are allowed to perform rigth shift operatino any number of times.\n  \n  One right shift operation means hsfiting all eleemnts of the arrya by one\n  position in the irght direction. The last eelment of the arary will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the soretd array by performing the above operation\n  then return rtue else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have nuique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 3, "perturbed": true, "gc": "/*We have an array 'arr' of N integesr arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordeedr. Your task is to determine if\n  it is possilbe to get an array sorted in non-cdereasing order by prefomring \n  the following operation on hte given array:\n      You are allowed to perform rigth shift operatino any number of times.\n  \n  One right shift operation means hsfiting all eleemnts of the arrya by one\n  position in the irght direction. The last eelment of the arary will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the soretd array by performing the above operation\n  then return rtue else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have nuique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n\n  let last = arr[arr.length - 1];\n  let i = arr.length - 1;\n  while (i > 0) {\n    if (arr[i - 1] > last) {\n      arr[i] = arr[i - 1];\n      arr[i - 1] = last;\n      last = arr[i - 1];\n      i--;\n    } else {\n      break;\n    }\n  }\n  return arr.length === i + 1;\n};\n\nconst moveOneBall2 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n\n  let last = arr[arr.length - 1];\n  let i = arr.length - 1;\n  while (i > 0) {\n    if (arr[i - 1] > last) {\n      arr[i] = arr[i - 1];\n      arr[i - 1] = last;\n      last = arr[i - 1];\n      i--;\n    } else {\n      break;\n    }\n  }\n  return arr.length === i + 1;\n};\n\nconst moveOneBall3 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n\n  let last = arr[arr.length - 1];\n  let i = arr.length - 1;\n  while (i > 0) {\n    if (arr[i - 1] > last) {\n      arr[i] = arr[i - 1];\n      arr[i - 1] = last;\n      last = arr[i - 1];\n      i--;\n    } else {\n      break;\n    }\n  }\n  return arr.length === i + 1;\n};\n\nconst moveOneBall4 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n\n  let last = arr[arr.length - 1];\n  let i = arr.length - 1;\n  while (i > 0) {\n    if (arr[i - 1] > last) {\n      arr[i] = arr[i - 1];\n      arr[i - 1] = last;\n      last = arr[i - 1];\n      i--;\n    } else {\n      break;\n    }\n  }\n  return arr.length === i + 1;\n};\n\nconst moveOneBall5 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n\n  let last = arr[arr.length - 1];\n  let i = arr.length - 1;\n  while (i > 0) {\n    if (arr[i - 1] > last) {\n      arr[i] = arr[i - 1];\n      arr[i - 1] = last;\n      last = arr[i - 1];\n      i--;\n    } else {\n      break;\n    }\n  }\n  return arr.length === i + 1;\n};\n\nconst moveOneBall6 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n\n  let last = arr[arr.length - 1];\n  let i = arr.length - 1;\n  while (i > 0) {\n    if (arr[i - 1] > last) {\n      arr[i] = arr[i - 1];\n      arr[i - 1] = last;\n      last = arr[i - 1];\n      i--;\n    } else {\n      break;\n    }\n  }\n  return arr.length === i + 1;\n};\n\nconst moveOneBall7 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n\n  let last = arr[arr.length - 1];\n  let i = arr.length - 1;\n  while (i > 0) {\n    if (arr[i - 1] > last) {\n      arr[i] = arr[i - 1];\n      arr[i - 1] = last;\n      last = arr[i - 1];\n      i--;\n    } else {\n      break;\n    }\n  }\n  return arr.length === i + 1;\n};\n\nconst moveOneBall8 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n\n  let last = arr[arr.length - 1];\n  let i = arr.length - 1;\n  while (i > 0) {\n    if (arr[i - 1] > last) {\n      arr[i] = arr[i - 1];\n      arr[i - 1] = last;\n      last = arr[i - 1];\n      i--;\n    } else {\n      break;\n    }\n  }\n  return arr.length === i + 1;\n};\n\nconst moveOneBall9 = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n\n  let last =", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are tow strings a and b consisting only of 1s and 0s.\n  Perform binary XOR no these niputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 3, "perturbed": true, "gc": "/* Input are tow strings a and b consisting only of 1s and 0s.\n  Perform binary XOR no these niputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++) {\n      if (a[i] === '1' && b[j] === '1') {\n        result += '1';\n      } else if (a[i] === '1' && b[j] === '0') {\n        result += '0';\n      } else if (a[i] === '0' && b[j] === '1') {\n        result += '0';\n      } else if (a[i] === '0' && b[j] === '0') {\n        result += '1';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting only of 1s and 0s.\n  Perform XOR no these niputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor2 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++) {\n      if (a[i] === '1' && b[j] === '1') {\n        result += '1';\n      } else if (a[i] === '1' && b[j] === '0') {\n        result += '0';\n      } else if (a[i] === '0' && b[j] === '1') {\n        result += '0';\n      } else if (a[i] === '0' && b[j] === '0') {\n        result += '1';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting only of 1s and 0s.\n  Perform XOR no these niputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor3 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++) {\n      if (a[i] === '1' && b[j] === '1') {\n        result += '1';\n      } else if (a[i] === '1' && b[j] === '0') {\n        result += '0';\n      } else if (a[i] === '0' && b[j] === '1') {\n        result += '0';\n      } else if (a[i] === '0' && b[j] === '0') {\n        result += '1';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting only of 1s and 0s.\n  Perform XOR no these niputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor4 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++) {\n      if (a[i] === '1' && b[j] === '1') {\n        result += '1';\n      } else if (a[i] === '1' && b[j] === '0') {\n        result += '0';\n      } else if (a[i] === '0' && b[j] === '1') {\n        result += '0';\n      } else if (a[i] === '0' && b[j] === '0') {\n        result += '1';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting only of 1s and 0s.\n  Perform XOR no these niputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor5 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++) {\n      if (a[i] === '1' && b[j] === '1') {\n        result += '1';\n      } else if (a[i] === '1' && b[j] === '0') {\n        result += '0';\n      } else if (a[i] === '0' && b[j] === '1') {\n        result += '0';\n      } else if (a[i] === '0' && b[j] === '0') {\n        result += '1';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Input are two strings a and b consisting only of 1s and 0s.\n  Perform XOR no these niputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor6 = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++) {\n      if (a[i] === '1' && b[j] === '1') {\n        result += '1';\n      } else if (a[i] === '1' && b[j] === '0') {\n        result += '0';\n      } else if (a[i] === '0' && b[j] === '1') {\n        result += '0';\n      } else if (a[i] === '0' && b[j] === '0') {\n        result += '1';\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Input are two strings a", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a functoin htat takes two lists of numbres,\n  and determines wehther it is possible to perform an exchange of elements\n  between them to maek lst1 a list of only even numbesr.\n  There is no limit on the number of exchanged leements between lst1 and lst2.\n  fI it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 3, "perturbed": true, "gc": "/*In this problem, you will implement a functoin htat takes two lists of numbres,\n  and determines wehther it is possible to perform an exchange of elements\n  between them to maek lst1 a list of only even numbesr.\n  There is no limit on the number of exchanged leements between lst1 and lst2.\n  fI it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let i = 0;\n  while (i < lst1.length && i < lst2.length) {\n    if (lst1[i] % 2 === 0) {\n      lst1[i] = lst2[i];\n    }\n    if (lst2[i] % 2 === 0) {\n      lst2[i] = lst1[i];\n    }\n    i++;\n  }\n  return lst1.length === lst2.length? \"YES\" : \"NO\";\n};\n\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 5, 3, 4]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]));\nconsole.log(exchange([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/111", "prompt": "/*Given a string rperesenting a space separated lowercase letters, return a dictionary\n  of the letter with the mots repetition and containing the corresponding count.\n  If several letetrs have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 3, "perturbed": true, "gc": "/*Given a string rperesenting a space separated lowercase letters, return a dictionary\n  of the letter with the mots repetition and containing the corresponding count.\n  If several letetrs have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {};\n  let letters = test.split('');\n  let len = letters.length;\n  let i = 0;\n  while (i < len) {\n    let letter = letters[i];\n    let count = histogram[letter] || 0;\n    histogram[letter] = count + 1;\n    i++;\n  }\n  return histogram;\n};\n\nmodule.exports = histogram;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strnigs s and c, you have to deleted all the chaarcters in s that are equal to any character in c\n  then check if hte result stirng is palindrome.\n  A string is called palidnrome if it reads the same backward as forwrad.\n  You sholud return a tuple containing the result string nad true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 3, "perturbed": true, "gc": "/*Task\n  We are given two strnigs s and c, you have to deleted all the chaarcters in s that are equal to any character in c\n  then check if hte result stirng is palindrome.\n  A string is called palidnrome if it reads the same backward as forwrad.\n  You sholud return a tuple containing the result string nad true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = s.split('').reverse().join('');\n  let isPalindrome = result === s;\n  return {result, isPalindrome};\n}\n\nconst isPalindrome = reverseDelete('abcde', 'ae');\nconsole.log(isPalindrome);\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strinsg, where each string consists of only digits, return a list.\n  Each element i of the output shoudl eb \"the number of odd elements in the\n  string i of teh input.\" where all the i's should be replaced by the number\n  of odd digtis in the i'th tsrgin of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 3, "perturbed": true, "gc": "/*Given a list of strinsg, where each string consists of only digits, return a list.\n  Each element i of the output shoudl eb \"the number of odd elements in the\n  string i of teh input.\" where all the i's should be replaced by the number\n  of odd digtis in the i'th tsrgin of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let num = lst[i].split('').filter(e => e.match(/[0-9]/)).length\n    if (num % 2) {\n      res.push(`the number of odd elements ${num}n the str${num}ng ${num} of the ${num}nput.`)\n    }\n  }\n  return res\n}\n\nmodule.exports = oddCount\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given na array of integers nums, nfid the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 3, "perturbed": true, "gc": "/*\n  Given na array of integers nums, nfid the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < 0) {\n      sum = 0;\n    }\n  }\n  return sum;\n};\n\nmodule.exports = minSubArraySum;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Ecah rwo represents a signle well,\n  and each 1 in a row represetns a single unit of water.\n  Each well has a corresponding bucket that acn be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to emtpy the wells.\n  Outptu the number fo times you need ot lwore the bukcets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a rectangular grid of wells. Ecah rwo represents a signle well,\n  and each 1 in a row represetns a single unit of water.\n  Each well has a corresponding bucket that acn be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to emtpy the wells.\n  Outptu the number fo times you need ot lwore the bukcets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  if (grid.length === 0 || grid[0].length === 0) return 0;\n  const grid_length = grid.length;\n  const grid_width = grid[0].length;\n  const bucket_capacity = capacity;\n  const bucket_count = grid_length * grid_width;\n  const bucket_count_max = bucket_capacity * bucket_count;\n  const bucket_count_min = bucket_capacity * (grid_length - 1) * (grid_width - 1);\n  let max_fill = 0;\n  let max_fill_index = 0;\n  let bucket_count_index = 0;\n  for (let i = 0; i < bucket_count_max; i++) {\n    if (grid[0][0] === 1) {\n      max_fill = i;\n      max_fill_index = bucket_count_index;\n      break;\n    }\n    bucket_count_index++;\n  }\n  for (let i = 0; i < grid_length; i++) {\n    for (let j = 0; j < grid_width; j++) {\n      if (grid[i][j] === 1) {\n        let bucket_count_index = 0;\n        for (let k = 0; k < bucket_count_max; k++) {\n          if (grid[i][j] === 1) {\n            max_fill = k;\n            max_fill_index = bucket_count_index;\n            break;\n          }\n          bucket_count_index++;\n        }\n        break;\n      }\n    }\n  }\n  return max_fill;\n};\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary represnetation in ascending order.\n  For similar unmber of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary represnetation in ascending order.\n  For similar unmber of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let sorted = arr.slice(0);\n  sorted.sort((a, b) => {\n    let aBits = a.toString(2);\n    let bBits = b.toString(2);\n    let aBitsLen = aBits.length;\n    let bBitsLen = bBits.length;\n    let aBitsCount = 0;\n    let bBitsCount = 0;\n    let i = 0;\n    let j = 0;\n    while (i < aBitsLen && j < bBitsLen) {\n      if (aBits[i] === bBits[j]) {\n        aBitsCount++;\n        bBitsCount++;\n        i++;\n        j++;\n      } else if (aBits[i] > bBits[j]) {\n        sorted[j] = aBits[i];\n        i++;\n      } else {\n        sorted[j] = bBits[j];\n        j++;\n      }\n    }\n    while (i < aBitsLen) {\n      sorted[j] = aBits[i];\n      i++;\n      j++;\n    }\n    while (j < bBitsLen) {\n      sorted[j] = bBits[j];\n      j++;\n    }\n    return aBitsCount - bBitsCount;\n  });\n  return sorted;\n};\n\nmodule.exports = sortArray;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/117", "prompt": "/*Ginve a srting s and a natural number n, you have been tasked to implement \n  a function htat returns a list of all owdrs from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  fI the string s is empty then the unfction should return na epmty list.\n  Note: yuo may assume the input string cnotains only letters and spaecs.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 3, "perturbed": true, "gc": "/*Ginve a srting s and a natural number n, you have been tasked to implement \n  a function htat returns a list of all owdrs from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  fI the string s is empty then the unfction should return na epmty list.\n  Note: yuo may assume the input string cnotains only letters and spaecs.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  let count = 0;\n  let i = 0;\n  while (i < s.length) {\n    let c = s.charAt(i);\n    if (c.match(/[a-zA-Z]/)) {\n      count++;\n      if (count === n) {\n        words.push(s.substr(i, n));\n        i += n;\n        count = 0;\n      }\n    }\n    i++;\n  }\n  return words;\n};\n\nmodule.exports = selectWords;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/118", "prompt": "/*You rae given a word. Your task is to find the closets vowel that stands between \n  two consonanst from the right side of the word (csae sensitive).\n  \n  Vowlse in the beginning and ending odesn't count. Rteurn empty string if you iddn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contanis English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 3, "perturbed": true, "gc": "/*You rae given a word. Your task is to find the closets vowel that stands between \n  two consonanst from the right side of the word (csae sensitive).\n  \n  Vowlse in the beginning and ending odesn't count. Rteurn empty string if you iddn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contanis English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let result = '';\n  let wordLength = word.length;\n  let wordArray = word.split('');\n  let wordArrayLength = wordArray.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let vowel = '';\n  let vowelArray = [];\n  let vowelArrayLength = 0;\n  let vowelArrayIndex = 0;\n  let vowelArrayIndex2 = 0;\n  let vowelArrayIndex3 = 0;\n  let vowelArrayIndex4 = 0;\n  let vowelArrayIndex5 = 0;\n  let vowelArrayIndex6 = 0;\n  let vowelArrayIndex7 = 0;\n  let vowelArrayIndex8 = 0;\n  let vowelArrayIndex9 = 0;\n  let vowelArrayIndex10 = 0;\n  let vowelArrayIndex11 = 0;\n  let vowelArrayIndex12 = 0;\n  let vowelArrayIndex13 = 0;\n  let vowelArrayIndex14 = 0;\n  let vowelArrayIndex15 = 0;\n  let vowelArrayIndex16 = 0;\n  let vowelArrayIndex17 = 0;\n  let vowelArrayIndex18 = 0;\n  let vowelArrayIndex19 = 0;\n  let vowelArrayIndex20 = 0;\n  let vowelArrayIndex21 = 0;\n  let vowelArrayIndex22 = 0;\n  let vowelArrayIndex23 = 0;\n  let vowelArrayIndex24 = 0;\n  let vowelArrayIndex25 = 0;\n  let vowelArrayIndex26 = 0;\n  let vowelArrayIndex27 = 0;\n  let vowelArrayIndex28 = 0;\n  let vowelArrayIndex29 = 0;\n  let vowelArrayIndex30 = 0;\n  let vowelArrayIndex31 = 0;\n  let vowelArrayIndex32 = 0;\n  let vowelArrayIndex33 = 0;\n  let vowelArrayIndex34 = 0;\n  let vowelArrayIndex35 = 0;\n  let vowelArrayIndex36 = 0;\n  let vowelArrayIndex37 = 0;\n  let vowelArrayIndex38 = 0;\n  let vowelArrayIndex39 = 0;\n  let vowelArrayIndex40 = 0;\n  let vowelArrayIndex41 = 0;\n  let vowelArrayIndex42 = 0;\n  let vowelArrayIndex43 = 0;\n  let vowelArrayIndex44 = 0;\n  let vowelArrayIndex45 = 0;\n  let vowelArrayIndex46 = 0;\n  let vowelArrayIndex47 = 0;\n  let vowelArrayIndex48 = 0;\n  let vowelArrayIndex49 = 0;\n  let vowelArrayIndex50 = 0;\n  let vowelArrayIndex51 = 0;\n  let vowelArrayIndex52 = 0;\n  let vowelArrayIndex53 = 0;\n  let vowelArrayIndex54 = 0;\n  let vowelArrayIndex55 = 0;\n  let vowelArrayIndex56 = 0;\n  let vowelArrayIndex57 = 0;\n  let vowelArrayIndex58 = 0;\n  let vowelArrayIndex59 = 0;\n  let vowelArrayIndex60 = 0;\n  let vowelArrayIndex61 = 0;\n  let vowelArrayIndex62 = 0;\n  let vowelArrayIndex63 = 0;\n  let vowelArrayIndex64 = 0;\n  let vowelArrayIndex65 = 0;\n  let vowelArrayIndex66 = 0;\n  let vowelArrayIndex67 = 0;\n  let vowelArrayIndex68 = 0;\n  let vowelArrayIndex69 = 0;\n  let vowelArrayIndex70 = 0;\n  let vowelArrayIndex71 = 0;\n  let vowelArrayIndex72 = 0;\n  let vowelArrayIndex73 = 0;\n  let vowelArrayIndex74 = 0;\n  let vowelArrayIndex75 = 0;\n  let vowelArrayIndex76 = 0;\n  let vowelArrayIndex77 = 0;\n  let vowelArrayIndex78 = 0;\n  let vowelArrayIndex79 = 0;\n  let vowelArrayIndex80 = 0;\n  let vowelArrayIndex81 = 0;\n  let vowelArrayIndex82 = 0;\n  let vowelArrayIndex83 = 0;\n  let vowelArrayIndex84 = 0;\n  let vowelArrayIndex85 = 0;\n  let vowelArrayIndex86 = 0;\n  let vowelArrayIndex87 = 0;\n  let vowelArrayIndex88 = 0;\n  let vowelArrayIndex89 = 0;\n  let vowelArrayIndex90 = 0;\n  let vowelArrayIndex91 = 0;\n  let vowelArrayIndex92 = 0;\n  let vowelArrayIndex93 = 0;\n  let vowelArrayIndex94 = 0;\n  let vowelArrayIndex95 = 0;\n  let vowelArrayIndex96 = 0;\n  let vowelArrayIndex97 = 0;\n  let vowelArrayIndex98 = 0;\n  let vowelArrayIndex99 = 0;\n  let vowelArrayIndex100 = 0;\n  let vowelArrayIndex101 = 0;\n  let vowelArrayIndex102 = 0;\n  let vowelArrayIndex103 = 0;\n  let vowelArrayIndex104 = 0;\n  let vowelArrayIndex105 = 0;\n  let vowelArrayIndex106 = 0;\n  let vowelArrayIndex107 = 0;\n  let vowelArrayIndex108 = 0;\n  let vowelArrayIndex109 = 0;\n  let vowelArrayIndex110 = 0;\n  let vowelArrayIndex111 = 0;\n  let vowelArrayIndex112 = 0;\n  let vowelArrayIndex113 = 0;\n  let vowelArrayIndex114 = 0;\n  let vowelArrayIndex115 = 0;\n  let vowelArrayIndex116 = 0;\n  let vowelArrayIndex117 = 0;\n  let vowelArrayIndex118 = 0;\n  let vowelArrayIndex119 = 0;\n  let vowelArrayIndex120 = 0;\n  let vowelArrayIndex121 = 0;\n  let vowelArrayIndex122 = 0;\n  let vowelArrayIndex123 = 0;\n  let vowelArrayIndex124 = 0;\n  let vowelArrayIndex125", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of tow strings, both strnigs ocnsist of open\n  paernthesse '(' or close paretnheses ')' only.\n  Your job is to check if it is opssible ot concatenate the two strings in\n  some order, that the resulting string will be godo.\n  A string S is considered to be good if and only if all praentheses in S\n  are balacned. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 3, "perturbed": true, "gc": "/* You are given a list of tow strings, both strnigs ocnsist of open\n  paernthesse '(' or close paretnheses ')' only.\n  Your job is to check if it is opssible ot concatenate the two strings in\n  some order, that the resulting string will be godo.\n  A string S is considered to be good if and only if all praentheses in S\n  are balacned. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const lstLen = lst.length\n  if (lstLen < 2) return 'No'\n  const lst0 = lst[0]\n  const lst1 = lst[1]\n  if (lst0.length!== lst1.length) return 'No'\n  const lst0Len = lst0.length\n  let i = 0\n  while (i < lst0Len) {\n    if (lst0[i]!== lst1[i]) return 'No'\n    i++\n  }\n  return 'Yes'\n}\n\nmodule.exports = matchParens\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest noe. Return the fisrt one in case of multpile\n  strings of the smae lnegth. Return null in case the niput list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 3, "perturbed": true, "gc": "/* Out of list of strings, return the longest noe. Return the fisrt one in case of multpile\n  strings of the smae lnegth. Return null in case the niput list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null;\n  }\n\n  const longest = strings[0];\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i];\n    }\n  }\n  return longest;\n};\n\nmodule.exports = longest;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of itnegers and a positive integer k, return a sorted list \n  of length k with the maximum k unmbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array arr of itnegers and a positive integer k, return a sorted list \n  of length k with the maximum k unmbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const max = arr.reduce((a, b) => a > b? a : b, -Infinity);\n  const result = [];\n  for (let i = 0; i < k; i++) {\n    result.push(arr.findIndex(i => arr[i] === max));\n  }\n  return result;\n};\n\nexport { maximum };\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/121", "prompt": "/*Gievn a non-empty list fo integers, return the usm of all of the odd elements that are in even posiitons.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 3, "perturbed": true, "gc": "/*Gievn a non-empty list fo integers, return the usm of all of the odd elements that are in even posiitons.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  const even = (n) => {\n    return n % 2 === 0;\n  };\n  const odd = (n) => {\n    return n % 2 === 1;\n  };\n  const evens = lst.filter(even);\n  const odds = lst.filter(odd);\n  return evens.reduce((acc, curr) => {\n    return acc + curr;\n  }, 0) + odds.reduce((acc, curr) => {\n    return acc + curr;\n  }, 0);\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Givne a non-empty array of integres arr and an intgeer k, return\n  the sum of the elements with at most two idgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 3, "perturbed": true, "gc": "/*\n  Givne a non-empty array of integres arr and an intgeer k, return\n  the sum of the elements with at most two idgits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nmodule.exports = addElements;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Gievn a positive inetger n, return a sorted list that has the odd numbers in colltaz sequence.\n\n  The oCllatz cojnecture is a cnojecture in mathematics taht concerns a sequence dfeinde\n  as follows: start with any positive integer n. Then each term is obtained form the \n  previuos term sa follows: if the previuos term is even, the next term is one ahlf of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sqeuence will alawys reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. retunred list sorted in niceriasng order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 3, "perturbed": true, "gc": "/*\n  Gievn a positive inetger n, return a sorted list that has the odd numbers in colltaz sequence.\n\n  The oCllatz cojnecture is a cnojecture in mathematics taht concerns a sequence dfeinde\n  as follows: start with any positive integer n. Then each term is obtained form the \n  previuos term sa follows: if the previuos term is even, the next term is one ahlf of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sqeuence will alawys reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. retunred list sorted in niceriasng order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let list = [];\n  let i = 1;\n  while (i <= n) {\n    list.push(i);\n    if (i % 2 === 0) {\n      i = i / 2;\n    } else {\n      i = 3 * i + 1;\n    }\n  }\n  return list.sort((a, b) => a - b);\n};\n\nmodule.exports = getOddCollatz;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validaets a given date string and\n  returns true if the date si valid otherwise fasle.\n  The date is valid fi all of the following rulse are astisfied:\n  1. The date string is not empty.\n  2. hTe number fo days is not elss than 1 or ihgher than 31 days for months 1,3,5,7,8,10,12. And the numbre of days is not less htan 1 or higher than 30 days for months 4,6,9,11. And, the numerb of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date shodul be in the fromat: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 3, "perturbed": true, "gc": "/*You have to write a function which validaets a given date string and\n  returns true if the date si valid otherwise fasle.\n  The date is valid fi all of the following rulse are astisfied:\n  1. The date string is not empty.\n  2. hTe number fo days is not elss than 1 or ihgher than 31 days for months 1,3,5,7,8,10,12. And the numbre of days is not less htan 1 or higher than 30 days for months 4,6,9,11. And, the numerb of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date shodul be in the fromat: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if (date.length === 0) {\n    return false;\n  }\n\n  const dateParts = date.split('-');\n  const day = parseInt(dateParts[0]);\n  const month = parseInt(dateParts[1]);\n  const year = parseInt(dateParts[2]);\n\n  if (day < 1 || day > 31) {\n    return false;\n  }\n\n  if (month < 1 || month > 12) {\n    return false;\n  }\n\n  if (month === 2 && day < 1 || month === 2 && day > 29) {\n    return false;\n  }\n\n  if (month === 4 && day < 1 || month === 4 && day > 30) {\n    return false;\n  }\n\n  if (month === 6 && day < 1 || month === 6 && day > 30) {\n    return false;\n  }\n\n  if (month === 9 && day < 1 || month === 9 && day > 30) {\n    return false;\n  }\n\n  if (month === 11 && day < 1 || month === 11 && day > 30) {\n    return false;\n  }\n\n  if (year < 2000 || year > 2099) {\n    return false;\n  }\n\n  return true;\n};\n\nmodule.exports = validDate;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/125", "prompt": "/* Given a stirng of wrods, return a list fo words split on whitespace, if no whitespaces exists in the text you\n  should pslit on comams ',' if no commas exists you should return the number of lower-caes letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 3, "perturbed": true, "gc": "/* Given a stirng of wrods, return a list fo words split on whitespace, if no whitespaces exists in the text you\n  should pslit on comams ',' if no commas exists you should return the number of lower-caes letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let words = [];\n  let wordsArr = txt.split(/[\\s,]+/);\n  let wordArr = [];\n  let word = \"\";\n  let wordArrLen = 0;\n  let wordArrLen2 = 0;\n  let wordArrLen3 = 0;\n  let wordArrLen4 = 0;\n  let wordArrLen5 = 0;\n  let wordArrLen6 = 0;\n  let wordArrLen7 = 0;\n  let wordArrLen8 = 0;\n  let wordArrLen9 = 0;\n  let wordArrLen10 = 0;\n  let wordArrLen11 = 0;\n  let wordArrLen12 = 0;\n  let wordArrLen13 = 0;\n  let wordArrLen14 = 0;\n  let wordArrLen15 = 0;\n  let wordArrLen16 = 0;\n  let wordArrLen17 = 0;\n  let wordArrLen18 = 0;\n  let wordArrLen19 = 0;\n  let wordArrLen20 = 0;\n  let wordArrLen21 = 0;\n  let wordArrLen22 = 0;\n  let wordArrLen23 = 0;\n  let wordArrLen24 = 0;\n  let wordArrLen25 = 0;\n  let wordArrLen26 = 0;\n  let wordArrLen27 = 0;\n  let wordArrLen28 = 0;\n  let wordArrLen29 = 0;\n  let wordArrLen30 = 0;\n  let wordArrLen31 = 0;\n  let wordArrLen32 = 0;\n  let wordArrLen33 = 0;\n  let wordArrLen34 = 0;\n  let wordArrLen35 = 0;\n  let wordArrLen36 = 0;\n  let wordArrLen37 = 0;\n  let wordArrLen38 = 0;\n  let wordArrLen39 = 0;\n  let wordArrLen40 = 0;\n  let wordArrLen41 = 0;\n  let wordArrLen42 = 0;\n  let wordArrLen43 = 0;\n  let wordArrLen44 = 0;\n  let wordArrLen45 = 0;\n  let wordArrLen46 = 0;\n  let wordArrLen47 = 0;\n  let wordArrLen48 = 0;\n  let wordArrLen49 = 0;\n  let wordArrLen50 = 0;\n  let wordArrLen51 = 0;\n  let wordArrLen52 = 0;\n  let wordArrLen53 = 0;\n  let wordArrLen54 = 0;\n  let wordArrLen55 = 0;\n  let wordArrLen56 = 0;\n  let wordArrLen57 = 0;\n  let wordArrLen58 = 0;\n  let wordArrLen59 = 0;\n  let wordArrLen60 = 0;\n  let wordArrLen61 = 0;\n  let wordArrLen62 = 0;\n  let wordArrLen63 = 0;\n  let wordArrLen64 = 0;\n  let wordArrLen65 = 0;\n  let wordArrLen66 = 0;\n  let wordArrLen67 = 0;\n  let wordArrLen68 = 0;\n  let wordArrLen69 = 0;\n  let wordArrLen70 = 0;\n  let wordArrLen71 = 0;\n  let wordArrLen72 = 0;\n  let wordArrLen73 = 0;\n  let wordArrLen74 = 0;\n  let wordArrLen75 = 0;\n  let wordArrLen76 = 0;\n  let wordArrLen77 = 0;\n  let wordArrLen78 = 0;\n  let wordArrLen79 = 0;\n  let wordArrLen80 = 0;\n  let wordArrLen81 = 0;\n  let wordArrLen82 = 0;\n  let wordArrLen83 = 0;\n  let wordArrLen84 = 0;\n  let wordArrLen85 = 0;\n  let wordArrLen86 = 0;\n  let wordArrLen87 = 0;\n  let wordArrLen88 = 0;\n  let wordArrLen89 = 0;\n  let wordArrLen90 = 0;\n  let wordArrLen91 = 0;\n  let wordArrLen92 = 0;\n  let wordArrLen93 = 0;\n  let wordArrLen94 = 0;\n  let wordArrLen95 = 0;\n  let wordArrLen96 = 0;\n  let wordArrLen97 = 0;\n  let wordArrLen98 = 0;\n  let wordArrLen99 = 0;\n  let wordArrLen100 = 0;\n  let wordArrLen101 = 0;\n  let wordArrLen102 = 0;\n  let wordArrLen103 = 0;\n  let wordArrLen104 = 0;\n  let wordArrLen105 = 0;\n  let wordArrLen106 = 0;\n  let wordArrLen107 = 0;\n  let wordArrLen108 = 0;\n  let wordArrLen109 = 0;\n  let wordArrLen110 = 0;\n  let wordArrLen111 = 0;\n  let wordArrLen112 = 0;\n  let wordArrLen113 = 0;\n  let wordArrLen114 = 0;\n  let wordArrLen115 = 0;\n  let wordArrLen116 = 0;\n  let wordArrLen117 = 0;\n  let wordArrLen118 = 0;\n  let wordArrLen119 = 0;\n  let wordArrLen120 = 0;\n  let wordArrLen121 = 0;\n  let wordArrLen122 = 0;\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbres, return whether or not they are sorted\n  in acseindng order. If list has more than 1 duplicate of the same\n  numbre, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 3, "perturbed": true, "gc": "/* Given a list of numbres, return whether or not they are sorted\n  in acseindng order. If list has more than 1 duplicate of the same\n  numbre, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  if (lst.length < 2) {\n    return true;\n  }\n  let i = 0;\n  let j = lst.length - 1;\n  while (i < j) {\n    if (lst[i] > lst[j]) {\n      return false;\n    }\n    if (lst[i] < lst[j]) {\n      i++;\n    } else {\n      j--;\n    }\n  }\n  return true;\n};\n\nmodule.exports = isSorted;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given two itnervals,\n  wehre each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 3, "perturbed": true, "gc": "/*You are given two itnervals,\n  wehre each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1[0] > interval2[1] || interval2[0] > interval1[1]) {\n    return \"NO\"\n  }\n  if (interval1[0] <= interval2[0] && interval2[1] <= interval1[1]) {\n    return \"YES\"\n  }\n  if (interval1[0] <= interval2[0] && interval2[1] <= interval1[1]) {\n    return \"YES\"\n  }\n  return \"NO\"\n}\n\nmodule.exports = intersection\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given na array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, rerpesented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 3, "perturbed": true, "gc": "/*\n  You are given na array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, rerpesented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null;\n  let res = 0;\n  for (let i = 0; i < arr.length; i++) {\n    res += arr[i] * arr[i];\n  }\n  return res;\n};\n\nmodule.exports = prodSigns;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid wtih N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a valeu. Every integer in teh range [1, N * N]\n  inclusive apperas exactly once no the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any ecll, and in each step you can move to any of the neighbor cells,\n  in other words, yuo can og to cells which share an edge with you curernt\n  ecll.\n  Please note that a path of length k measn visiting exactly k celsl (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (fo length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A adn lst_B), lst_A is lexicographically less\n  than slt_B, in other owdrs, htere exist an integer inedx i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guarnateed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go throuhg.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 3, "perturbed": true, "gc": "/*\n  Given a grid wtih N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a valeu. Every integer in teh range [1, N * N]\n  inclusive apperas exactly once no the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any ecll, and in each step you can move to any of the neighbor cells,\n  in other words, yuo can og to cells which share an edge with you curernt\n  ecll.\n  Please note that a path of length k measn visiting exactly k celsl (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (fo length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A adn lst_B), lst_A is lexicographically less\n  than slt_B, in other owdrs, htere exist an integer inedx i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guarnateed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go throuhg.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const result = []\n  const visited = new Set()\n  const visitedCount = new Map()\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      const current = grid[i][j]\n      if (visitedCount.has(current)) continue\n      visitedCount.set(current, 1)\n      visited.add(current)\n      const next = [...grid,...grid[i].slice(0, j + 1),...grid[i].slice(j + 1)]\n      const minPath = minPath(next, k - 1)\n      visitedCount.set(current, visitedCount.get(current) + 1)\n      visited.delete(current)\n      result.push(...minPath)\n    }\n  }\n\n  return result\n}\n\nmodule.exports = minPath\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a graetest common diivsor of two integesr a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 3, "perturbed": true, "gc": "/* Return a graetest common diivsor of two integesr a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a < b) {\n    return greatestCommonDivisor(b, a)\n  }\n  if (a === 0) {\n    return 1\n  }\n  if (a === 1) {\n    return b\n  }\n  if (b === 1) {\n    return a\n  }\n  if (a === b) {\n    return a\n  }\n  if (a % b === 0) {\n    return greatestCommonDivisor(a / b, b)\n  }\n  return greatestCommonDivisor(b, a % b)\n}\n\nmodule.exports = greatestCommonDivisor\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequecne, it was studied deeply by mathematicians in \n  the last couple cenutires. However, what poelpe don't know is Tribonacci sequenec.\n  Tribnoacci seqeunce is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is veen.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 3, "perturbed": true, "gc": "/*Everyone knows Fibonacci sequecne, it was studied deeply by mathematicians in \n  the last couple cenutires. However, what poelpe don't know is Tribonacci sequenec.\n  Tribnoacci seqeunce is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is veen.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let [a, b] = [1, 3];\n  let [c, d] = [2, 8];\n  let [e, f] = [3, 1];\n  let [g, h] = [4, 3];\n  let [i, j] = [5, 2];\n  let [k, l] = [6, 8];\n  let [m, n] = [7, 3];\n  let [o, p] = [8, 1];\n  let [q, r] = [9, 4];\n  let [s, t] = [10, 3];\n  let [u, v] = [11, 2];\n  let [w, x] = [12, 8];\n  let [y, z] = [13, 3];\n  let [aa, ab] = [14, 1];\n  let [bb, bc] = [15, 4];\n  let [cc, cd] = [16, 3];\n  let [dd, de] = [17, 2];\n  let [ee, ef] = [18, 8];\n  let [ff, gg] = [19, 3];\n  let [hh, hi] = [20, 2];\n  let [ii, jj] = [21, 8];\n  let [kk, ll] = [22, 3];\n  let [mm, nn] = [23, 1];\n  let [oo, pp] = [24, 4];\n  let [qq, rr] = [25, 3];\n  let [ss, tt] = [26, 2];\n  let [uu, vv] = [27, 8];\n  let [ww, xx] = [28, 3];\n  let [yy, zz] = [29, 2];\n  let [aaa, abb] = [30, 1];\n  let [bbb, ccc] = [31, 4];\n  let [ccc, ddd] = [32, 3];\n  let [ddd, eee] = [33, 2];\n  let [eee, fff] = [34, 8];\n  let [fff, ggg] = [35, 3];\n  let [hhhh, iiii] = [36, 2];\n  let [iiii, jjjj] = [37, 8];\n  let [jjjj, kkkk] = [38, 3];\n  let [kkkk, llll] = [39, 2];\n  let [llll, mmmm] = [40, 8];\n  let [mmmm, nnnn] = [41, 3];\n  let [nnnn, oooo] = [42, 2];\n  let [oooo, pppp] = [43, 8];\n  let [pppp, qqqq] = [44, 3];\n  let [qqqq, rrrr] = [45, 2];\n  let [ssss, tttt] = [46, 8];\n  let [tttt, uuuu] = [47, 3];\n  let [uuuu, vvvv] = [48, 2];\n  let [vvvv, wwww] = [49, 8];\n  let [wwww, xxxx] = [50, 3];\n  let [xxxx, yyyy] = [51, 2];\n  let [yyyy, zzzz] = [52, 8];\n  let [zzzz, aaaa] = [53, 3];\n  let [aaaa, bbbb] = [54, 1];\n  let [bbbb, cccc] = [55, 4];\n  let [cccc, dddd] = [56, 3];\n  let [dddd, eeee] = [57, 2];\n  let [eeee, ffff] = [58, 8];\n  let [ffff, gggg] = [59, 3];\n  let [hhhhh, iiii] = [60, 2];\n  let [iiiiii, jjjjj] = [61, 8];\n  let [jjjjjj, kkkkk] = [62, 3];\n  let [kkkkkk, lllll] = [63, 2];\n  let [lllllll, mmmmm] = [64, 8];\n  let [mmmmmm, nnnnn] = [65, 3];\n  let [nnnnnnn, oooooo] = [66, 2];\n  let [ooooooo, pppppp] = [67, 8];\n  let [ppppppp, qqqqqq] = [68, 3];\n  let [qqqqqqq, rrrrrr] = [69, 2];\n  let [sssssss, tttttt] = [70, 8];\n  let [ttttttt, uuuuuu] = [71, 3];\n  let [uuuuuuu, vvvvvv] = [72, 2];\n  let [vvvvvvv, wwwwww] = [73, 8];\n  let [wwwwwww, xxxxxx] = [74, 3];\n  let [xxxxxxx, yyyyyyy] = [75, 2];\n  let [yyyyyyyy, zzzzzzz] = [76, 8];\n  let [zzzzzzzz, aaaaaaa] = [77, 3];\n  let [aaaaaaaa, bbbbbbbb] = [78, 1];\n  let [bbbbbbbb, ccccccc] = [79, 4];\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a postiive niteger n, return the product of the odd digits.\n  Retunr 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 3, "perturbed": true, "gc": "/*Given a postiive niteger n, return the product of the odd digits.\n  Retunr 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits;\n};\n\nconst digits2 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse();\n};\n\nconst digits3 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse();\n};\n\nconst digits4 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse();\n};\n\nconst digits5 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse();\n};\n\nconst digits6 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits7 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits8 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits9 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits10 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits11 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits12 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits13 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits14 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits15 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits16 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits17 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits18 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits19 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\nconst digits20 = (n) => {\n  const digits = [];\n  while (n > 0) {\n    digits.push(n % 10);\n    n = Math.floor(n / 10);\n  }\n  return digits.reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function htat takes a string as inptu which contaisn only square barckets.\n  The function should return utre if nad only if there is a valid subsequecne of brackets\n  where at lesat one bracket in the susbequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 3, "perturbed": true, "gc": "/*\n  Create a function htat takes a string as inptu which contaisn only square barckets.\n  The function should return utre if nad only if there is a valid subsequecne of brackets\n  where at lesat one bracket in the susbequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  let index = 0\n  let isNested = false\n  while (index < string.length) {\n    if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === '[') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === '[') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === '[') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === '[') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === '[') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === '[') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === '[') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === '[') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === '[') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === '[') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === '[') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === '[') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      isNested = true\n      index += 2\n    } else if (string[index] === '[' && string[index + 1] === ']') {\n      ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  Yuo need to return the sum of squared numbers in the given list,\n  round each leemetn in hte list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "/*You are given a list of numbers.\n  Yuo need to return the sum of squared numbers in the given list,\n  round each leemetn in hte list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares2 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares3 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares4 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares5 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares6 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares7 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares8 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares9 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares10 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares11 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares12 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares13 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares14 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares15 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares16 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares17 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares18 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares19 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares20 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares21 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2)\n  }\n  return sum\n}\n\nconst sumSquares22 = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a wodr, and false otheriwse.\n  Note: \"owrd\" is a group of characters esparated by spcae.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 3, "perturbed": true, "gc": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a wodr, and false otheriwse.\n  Note: \"owrd\" is a group of characters esparated by spcae.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z]/);\n};\n\n/*\n  Create a function that returns true if the last character\n  of a given string is a number and is not a part of a wodr,\n  and false otheriwse.\n  Note: \"owrd\" is a group of characters esparated by spcae.\n  Examples:\n  checkIfLastCharIsANumber(\"apple pie\") ➞ false\n  checkIfLastCharIsANumber(\"apple pi e\") ➞ true\n  checkIfLastCharIsANumber(\"apple pi e \") ➞ false\n  checkIfLastCharIsANumber(\"\") ➞ false\n  */\nconst checkIfLastCharIsANumber = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[0-9]/);\n};\n\n/*\n  Create a function that returns true if the last character\n  of a given string is a letter and is not a part of a wodr,\n  and false otheriwse.\n  Note: \"owrd\" is a group of characters esparated by spcae.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrNumber = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z0-9]/);\n};\n\n/*\n  Create a function that returns true if the last character\n  of a given string is a letter and is not a part of a wodr,\n  and false otheriwse.\n  Note: \"owrd\" is a group of characters esparated by spcae.\n  Examples:\n  checkIfLastCharIsALetterOrNumber(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrNumber(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrNumber(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrNumber(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrNumberOrNumber = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z0-9]/);\n};\n\n/*\n  Create a function that returns true if the last character\n  of a given string is a letter and is not a part of a wodr,\n  and false otheriwse.\n  Note: \"owrd\" is a group of characters esparated by spcae.\n  Examples:\n  checkIfLastCharIsALetterOrNumber(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrNumber(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrNumber(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrNumber(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrNumberOrLetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z]/);\n};\n\n/*\n  Create a function that returns true if the last character\n  of a given string is a letter and is not a part of a wodr,\n  and false otheriwse.\n  Note: \"owrd\" is a group of characters esparated by spcae.\n  Examples:\n  checkIfLastCharIsALetterOrNumber(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrNumber(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrNumber(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrNumber(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrNumberOrLetterOrNumber = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z0-9]/);\n};\n\n/*\n  Create a function that returns true if the last character\n  of a given string is a letter and is not a part of a wodr,\n  and false otheriwse.\n  Note: \"owrd\" is a group of characters esparated by spcae.\n  Examples:\n  checkIfLastCharIsALetterOrNumber(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrNumber(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrNumber(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrNumber(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetterOrNumberOrLetterOrNumberOrLetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar.match(/[a-zA-Z]/);\n};\n\n/*\n  Create a function that returns true if the last character\n  of a given string is a letter and is not a part of a wodr,\n  and false otheriwse.\n  Note: \"owrd\" is a group of characters esparated by spcae.\n  Examples:\n  checkIfLastCharIsALetterOrNumberOrLetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetterOrNumberOrLetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetterOrNumberOrLetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetterOrNumberOrLetter(\"\") ➞ false", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a functoin wihch returns the largest index of an element which\n  is not greater than or equal to hte element immediately preceding it. If\n  no such leeemnt exists then return -1. The given array will not contani\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 3, "perturbed": true, "gc": "/*Create a functoin wihch returns the largest index of an element which\n  is not greater than or equal to hte element immediately preceding it. If\n  no such leeemnt exists then return -1. The given array will not contani\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let i = 0;\n  let j = arr.length - 1;\n  let k = arr.length;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let temp = 0;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else if (arr[i] > arr[j]) {\n      temp = arr[j];\n      arr[j] = arr[i];\n      arr[i] = temp;\n      j--;\n    } else {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    }\n  }\n  while (i < k) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else if (arr[i] > arr[j]) {\n      temp = arr[j];\n      arr[j] = arr[i];\n      arr[i] = temp;\n      j--;\n    } else {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    }\n  }\n  while (i < k) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else if (arr[i] > arr[j]) {\n      temp = arr[j];\n      arr[j] = arr[i];\n      arr[i] = temp;\n      j--;\n    } else {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    }\n  }\n  while (i < j) {\n    temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    i++;\n    j--;\n  }\n  while (i < k) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else if (arr[i] > arr[j]) {\n      temp = arr[j];\n      arr[j] = arr[i];\n      arr[i] = temp;\n      j--;\n    } else {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    }\n  }\n  while (i < k) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else if (arr[i] > arr[j]) {\n      temp = arr[j];\n      arr[j] = arr[i];\n      arr[i] = temp;\n      j--;\n    } else {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    }\n  }\n  while (i < j) {\n    temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    i++;\n    j--;\n  }\n  while (i < k) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else if (arr[i] > arr[j]) {\n      temp = arr[j];\n      arr[j] = arr[i];\n      arr[i] = temp;\n      j--;\n    } else {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    }\n  }\n  while (i < k) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else if (arr[i] > arr[j]) {\n      temp = arr[j];\n      arr[j] = arr[i];\n      arr[i] = temp;\n      j--;\n    } else {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    }\n  }\n  while (i < j) {\n    temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    i++;\n    j--;\n  }\n  while (i < k) {\n    if (arr[i] < arr[j]) {\n      temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n      j--;\n    } else if (arr[i] > arr[j]) {\n      temp = arr[j];\n      arr[j] = arr[i];\n      arr[i] = temp;\n      j--;\n    } else {\n      temp = arr[i];\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the lragest of negative integers, and 'b' is the smlalest\n  of positive integers in a list.\n  If there is on negative or positive integers, return them as nlul.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 3, "perturbed": true, "gc": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the lragest of negative integers, and 'b' is the smlalest\n  of positive integers in a list.\n  If there is on negative or positive integers, return them as nlul.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const largest = lst.length > 0? lst[0] : null;\n  const smallest = lst.length > 0? lst[0] : null;\n  lst.forEach((num) => {\n    if (num < 0) {\n      largest = num;\n    } else if (num > 0) {\n      smallest = num;\n    }\n  });\n  return [largest, smallest];\n};\n\nmodule.exports = largestSmallestIntegers;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a fucntion that atkes integesr, floats, or strinsg representing\n  real numbers, and rteurns the larger variable in ist given variable ytpe.\n  Return null if the values are equal.\n  Note: If a real number is represented sa a strign, hte floatnig point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 3, "perturbed": true, "gc": "/*\n  Create a fucntion that atkes integesr, floats, or strinsg representing\n  real numbers, and rteurns the larger variable in ist given variable ytpe.\n  Return null if the values are equal.\n  Note: If a real number is represented sa a strign, hte floatnig point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"number\" && typeof b === \"string\") {\n    return a > b? a : b;\n  } else {\n    return null;\n  }\n};\n\nconst compareTwo = (a, b) => {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"number\" && typeof b === \"string\") {\n    return a > b? a : b;\n  } else {\n    return null;\n  }\n};\n\nconst compareThree = (a, b, c) => {\n  if (typeof a === \"number\" && typeof b === \"number\" && typeof c === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"string\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"number\" && typeof c === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"number\" && typeof b === \"string\" && typeof c === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"string\") {\n    return a > b? a : b;\n  } else if (typeof a === \"number\" && typeof b === \"string\" && typeof c === \"string\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"number\" && typeof c === \"string\") {\n    return a > b? a : b;\n  } else if (typeof a === \"number\" && typeof b === \"string\" && typeof c === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"number\" && typeof c === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"number\" && typeof b === \"number\" && typeof c === \"number\") {\n    return a > b? a : b;\n  } else {\n    return null;\n  }\n};\n\nconst compareFour = (a, b, c, d) => {\n  if (typeof a === \"number\" && typeof b === \"number\" && typeof c === \"number\" && typeof d === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"string\" && typeof d === \"string\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"string\" && typeof d === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"number\" && typeof d === \"string\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"string\" && typeof d === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"number\" && typeof d === \"string\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"number\" && typeof d === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"string\" && typeof d === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"string\" && typeof d === \"string\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"string\" && typeof d === \"number\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"number\" && typeof d === \"string\") {\n    return a > b? a : b;\n  } else if (typeof a === \"string\" && typeof b === \"string\" && typeof c === \"number\" && typeof", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evalaute whether the given number n can be written as the sum of exactly 4 positive veen numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 3, "perturbed": true, "gc": "/*Evalaute whether the given number n can be written as the sum of exactly 4 positive veen numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum % 2 === 0;\n};\n\nmodule.exports = isEqualToSumEven;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 3, "perturbed": true, "gc": "/*The Brazliian factorail is defiend as:\n  brazilain_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n < 0) {\n    throw new Error('The function specialFactorial should receive a positive integer as input.');\n  }\n  if (n === 0) {\n    return 1;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  if (n === 3) {\n    return 6;\n  }\n  if (n === 4) {\n    return 24;\n  }\n  if (n === 5) {\n    return 120;\n  }\n  if (n === 6) {\n    return 720;\n  }\n  if (n === 7) {\n    return 5040;\n  }\n  if (n === 8) {\n    return 40320;\n  }\n  if (n === 9) {\n    return 362880;\n  }\n  if (n === 10) {\n    return 3628800;\n  }\n  if (n === 11) {\n    return 39916800;\n  }\n  if (n === 12) {\n    return 479001600;\n  }\n  if (n === 13) {\n    return 6227020800;\n  }\n  if (n === 14) {\n    return 87178291200;\n  }\n  if (n === 15) {\n    return 1307674368000;\n  }\n  if (n === 16) {\n    return 20922789888000;\n  }\n  if (n === 17) {\n    return 355687428096000;\n  }\n  if (n === 18) {\n    return 6402373705728000;\n  }\n  if (n === 19) {\n    return 121645100408832000;\n  }\n  if (n === 20) {\n    return 2432902008176640000;\n  }\n  if (n === 21) {\n    return 51090942171709440000;\n  }\n  if (n === 22) {\n    return 1124000727777607680000;\n  }\n  if (n === 23) {\n    return 25852016738884976640000;\n  }\n  if (n === 24) {\n    return 620448401733239439360000;\n  }\n  if (n === 25) {\n    return 1220703125162738069600000;\n  }\n  if (n === 26) {\n    return 3027034703822866059400000;\n  }\n  if (n === 27) {\n    return 6046313835653942320000;\n  }\n  if (n === 28) {\n    return 1216451004088322527520000;\n  }\n  if (n === 29) {\n    return 2432902008176643501376;\n  }\n  if (n === 30) {\n    return 510909421717094435184;\n  }\n  if (n === 31) {\n    return 11240007277776076545632;\n  }\n  if (n === 32) {\n    return 25852016738884984265664;\n  }\n  if (n === 33) {\n    return 620448401733239445171264;\n  }\n  if (n === 34) {\n    return 1220703125162738067108864;\n  }\n  if (n === 35) {\n    return 30270347038228660596524864;\n  }\n  if (n === 36) {\n    return 60463138356539437038572864;\n  }\n  if (n === 37) {\n    return 12164510040883225272422464;\n  }\n  if (n === 38) {\n    return 243290200817664350128576;\n  }\n  if (n === 39) {\n    return 5109094217170944352097152;\n  }\n  if (n === 40) {\n    return 1124000727777607654563328;\n  }\n  if (n === 41) {\n    return 2585201673888498426565536;\n  }\n  if (n === 42) {\n    return 62044840173323944517123536;\n  }\n  if (n === 43) {\n    return 122070312516273806710884096;\n  }\n  if (n === 44) {\n    return 3027034703822866059652484096;\n  }\n  if (n === 45) {\n    return 60463138356539437038572484096;\n  }\n  if (n === 46) {\n    return 12164510040883225272422880096;\n  }\n  if (n === 47) {\n    return 2432902008176643501297920096;\n  }\n  if (n === 48) {\n    return 51090942171709443520984096;\n  }\n  if (n === 49) {\n    return 1124000727777607654544984096;\n  }\n  if (n === 50) {\n    return 258520167388849842650784096;\n  }\n  if (n === 51) {\n    return 6204484017332394451801280096;\n  }\n  if (n === 52) {\n    return 12207031251627380671161440096;\n  }\n  if (n === 53) {\n    return 302703470382286605965296096;\n  }\n  if (n === 54) {\n    return 6046313835653943703855296096;\n  }\n  if (n === 55) {\n    return 12164510040883225272422880192;\n  }\n  if (n === 56) {\n    return 2432902008176643501297920096;\n  }\n  if (n === 57) {\n    return", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/14", "prompt": "/* Retrun list of lal prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 3, "perturbed": true, "gc": "/* Retrun list of lal prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  if (string.length === 0) {\n    return [];\n  }\n  let prefixes = [string];\n  let prefix = string;\n  while (prefix.length > 0) {\n    let newPrefix = prefix.substring(0, prefix.length - 1);\n    if (newPrefix.length === 0) {\n      break;\n    }\n    prefixes.push(newPrefix);\n    prefix = newPrefix;\n  }\n  return prefixes;\n};\n\n/**\n  Returns the longest prefix of the input string that is a valid lal prefix.\n  @param {string} string The input string\n  @return {string} The longest prefix of the input string that is a valid lal prefix\n  */\nconst longestPrefix = (string) => {\n  let prefixes = allPrefixes(string);\n  let maxLength = 0;\n  let maxPrefix = '';\n  for (let i = 0; i < prefixes.length; i++) {\n    let prefix = prefixes[i];\n    if (prefix.length > maxLength) {\n      maxLength = prefix.length;\n      maxPrefix = prefix;\n    }\n  }\n  return maxPrefix;\n};\n\nmodule.exports = {\n  allPrefixes,\n  longestPrefix\n};\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consectuive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 3, "perturbed": true, "gc": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consectuive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces2 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces3 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces4 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces5 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces6 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces7 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces8 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces9 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces10 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces11 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces12 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces13 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces14 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces15 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces16 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces17 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces18 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces19 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces20 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces21 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces22 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces23 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces24 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces25 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces26 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces27 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces28 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces29 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces30 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces31 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2,}/g, \"-\");\n};\n\nconst fixSpaces32 = (text) => {\n  return text.replace(/\\s+/g, \"_\").replace(/\\s{2", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string represetning a file's name, nad returns\n  'Yes' if the the file's anme is valid, and returns 'No' otherwise.\n  A file's name is consiedred to be valid if and only fi all the following conditiosn \n  are emt:\n  - There should not be more than three digist ('0'-'9') in the file's name.\n  - The file's name ocntains exactly one dot '.'\n  - The substring before the dot should not be empty, and it strats with a letter from \n  the latin alhpapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of thees: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 3, "perturbed": true, "gc": "/*Create a function which takes a string represetning a file's name, nad returns\n  'Yes' if the the file's anme is valid, and returns 'No' otherwise.\n  A file's name is consiedred to be valid if and only fi all the following conditiosn \n  are emt:\n  - There should not be more than three digist ('0'-'9') in the file's name.\n  - The file's name ocntains exactly one dot '.'\n  - The substring before the dot should not be empty, and it strats with a letter from \n  the latin alhpapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of thees: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  if (file_name.length > 3) {\n    return 'No';\n  }\n  if (file_name.indexOf('.')!== -1) {\n    return 'No';\n  }\n  if (file_name.indexOf('.') === -1) {\n    return 'No';\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    }\n  }\n  if (file_name.indexOf('.')!== -1) {\n    if (file_name.indexOf('.') === 0) {\n      return 'No';\n    }\n    if (file_name.indexOf('.')!== file_name.length - 1) {\n      return 'No';\n    ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall qsuare the integer entyr if its index is a \n  multilpe of 3 and will cube the integer entry if its index is a mulitple of 4 and not a multiple of 3. The funciton will not \n  change the entries in the list whose idnexse are not a mulitple of 3 or 4. The ufnction shall then return the sum of all entreis. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 3, "perturbed": true, "gc": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall qsuare the integer entyr if its index is a \n  multilpe of 3 and will cube the integer entry if its index is a mulitple of 4 and not a multiple of 3. The funciton will not \n  change the entries in the list whose idnexse are not a mulitple of 3 or 4. The ufnction shall then return the sum of all entreis. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i]\n    } else {\n      sum += lst[i] * lst[i]\n    }\n  }\n  return sum\n}\n\nconsole.log(sumSquares([1,2,3]))\nconsole.log(sumSquares([]))\nconsole.log(sumSquares([-1,-5,2,-1,-5]))\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains soem wodrs spearated by a space,\n  and you have to return a string that contians the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string hsuodl be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a string representing a sentence,\n  the sentence contains soem wodrs spearated by a space,\n  and you have to return a string that contians the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string hsuodl be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(/\\s+/);\n  const result = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const prime = Math.max(...words.map((w) => w.length));\n    if (prime % 2 === 0) {\n      result.push(word);\n    }\n  }\n  return result;\n};\n\nmodule.exports = wordsInSentence;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function thta will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and flase\n  otherwise. Both x and n, are string representaiton of a fraction, and have the following formta,\n  <numerator>/<denomintaro> where both numerator and denmoinator rae positive whole numbers.\n\n  You can assmue that x, and n rae valdi fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 3, "perturbed": true, "gc": "/*Your task is to implement a function thta will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and flase\n  otherwise. Both x and n, are string representaiton of a fraction, and have the following formta,\n  <numerator>/<denomintaro> where both numerator and denmoinator rae positive whole numbers.\n\n  You can assmue that x, and n rae valdi fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  let x_n = x.split(\"/\");\n  let n_x = n.split(\"/\");\n  let x_numerator = x_n[0];\n  let x_denominator = x_n[1];\n  let n_x_numerator = n_x[0];\n  let n_x_denominator = n_x[1];\n  let x_numerator_numerator = x_numerator.split(\"\");\n  let x_numerator_denominator = x_numerator.split(\"\");\n  let n_x_numerator_numerator = n_x_numerator.split(\"\");\n  let n_x_numerator_denominator = n_x_numerator.split(\"\");\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_numerator_denominator_length = x_numerator_denominator.length;\n  let x_numerator_numerator_length = x_numerator_numerator.length;\n  let n_x_numerator_denominator_length = n_x_numerator_denominator.length;\n  let x_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  rWite a function which sorts the givne list of integesr\n  in sacedning order acocrding ot the usm of their digits.\n  Note: if there are several items with similar sum of theri digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 3, "perturbed": true, "gc": "/*\n  rWite a function which sorts the givne list of integesr\n  in sacedning order acocrding ot the usm of their digits.\n  Note: if there are several items with similar sum of theri digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints2 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints3 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints4 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints5 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints6 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints7 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints8 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints9 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints10 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints11 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints12 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints13 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints14 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints15 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints16 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints17 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints18 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints19 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints20 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints21 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints22 = (nums) => {\n  const sorted = nums.sort((a, b) => {\n    if (a > b) return 1\n    if (a < b) return -1\n    return 0\n  })\n  return sorted\n}\n\nconst orderByPoints23 = (nums)", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/146", "prompt": "/*Wirte a function that takes an array of numbers as input and returns \n  the unmber of elements in the arrya that aer graeter than 10 and both \n  first and last digist of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 3, "perturbed": true, "gc": "/*Wirte a function that takes an array of numbers as input and returns \n  the unmber of elements in the arrya that aer graeter than 10 and both \n  first and last digist of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = specialFilter;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For ceah i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of trilpes (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multipel of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For ceah i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of trilpes (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multipel of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [];\n  for (let i = 1; i <= n; i++) {\n    a.push(i * i - i + 1);\n  }\n  const result = 0;\n  for (let i = 0; i < a.length; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      for (let k = j + 1; k < a.length; k++) {\n        if (a[i] + a[j] + a[k] === 3 * i) {\n          result++;\n        }\n      }\n    }\n  }\n  return result;\n};\n\nmodule.exports = getMaxTriples;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/148", "prompt": "/* Tehre are eigth planets in our solar ystesm: the closerst to the Sun\n  is Mercury, the nxet one is eVnsu, then Earth, Mras, Jupiter, Saturn,\n  Uransu, Netpune.\n  Write a functoin that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whsoe orbits are\n  located between the orbit fo planet1 and the orbit of planet2, sorted by\n  the proximity to the snu.\n  The function should return an empty tuple if planet1 or planet2\n  are not corerct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 3, "perturbed": true, "gc": "/* Tehre are eigth planets in our solar ystesm: the closerst to the Sun\n  is Mercury, the nxet one is eVnsu, then Earth, Mras, Jupiter, Saturn,\n  Uransu, Netpune.\n  Write a functoin that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whsoe orbits are\n  located between the orbit fo planet1 and the orbit of planet2, sorted by\n  the proximity to the snu.\n  The function should return an empty tuple if planet1 or planet2\n  are not corerct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planets = [\n    \"Mercury\",\n    \"Venus\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n    \"Pluto\",\n  ];\n\n  const distance = (planet1, planet2) => {\n    const distance = [];\n    for (let i = 0; i < planets.length; i++) {\n      distance.push(\n        Math.sqrt(\n          Math.pow(\n            planet1.distance(planet2),\n            2,\n          ) +\n            Math.pow(\n              planet1.distance(planet2),\n              2,\n            )\n        ),\n      );\n    }\n    return distance;\n  };\n\n  const sorted = distance.sort((a, b) => a - b);\n  return sorted.map((d) => planets[d]);\n};\n\nmodule.exports = bf;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strinsg as a parameter,\n  dleetes the strings that hvae odd lengths from it,\n  and rteurns the resultde list with a sorted order,\n  Teh list is always a list of strings nad never an array of unmbers,\n  and it may contain duplicates.\n  The odrer of the list should be ascendnig by length of each word, and you\n  should return the list ostred by that rule.\n  If tow words have the same length, sort hte list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume thta all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 3, "perturbed": true, "gc": "/*Write a function that accepts a list of strinsg as a parameter,\n  dleetes the strings that hvae odd lengths from it,\n  and rteurns the resultde list with a sorted order,\n  Teh list is always a list of strings nad never an array of unmbers,\n  and it may contain duplicates.\n  The odrer of the list should be ascendnig by length of each word, and you\n  should return the list ostred by that rule.\n  If tow words have the same length, sort hte list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume thta all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let res = [];\n  let l = lst.length;\n  let i = 0;\n  while (i < l) {\n    let j = i;\n    while (j < l && lst[j] === lst[j + 1]) {\n      j++;\n    }\n    res.push(lst.slice(i, j));\n    i = j;\n  }\n  return res;\n};\n\nconst list_sort = (lst) => {\n  let res = sortedListSum(lst);\n  return res;\n};\n\nmodule.exports = list_sort;\n<|endoftext|>", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 3, "perturbed": true, "gc": "/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `0${i} `;\n  }\n  return str;\n};\n\n/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence2 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} `;\n  }\n  return str;\n};\n\n/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence3 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} `;\n  }\n  return str;\n};\n\n/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence4 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} `;\n  }\n  return str;\n};\n\n/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence5 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} `;\n  }\n  return str;\n};\n\n/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence6 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} `;\n  }\n  return str;\n};\n\n/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence7 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} `;\n  }\n  return str;\n};\n\n/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence8 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} `;\n  }\n  return str;\n};\n\n/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence9 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} `;\n  }\n  return str;\n};\n\n/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence10 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} `;\n  }\n  return str;\n};\n\n/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence11 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} `;\n  }\n  return str;\n};\n\n/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence12 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} `;\n  }\n  return str;\n};\n\n/* Return a string containing spcae-delimietd numbers starting from 0 upto n incluisve.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence13 = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += `${i} `;\n  }\n  return str;\n};\n\n/* Return", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which shuold return the value of x if n is \n  a prmie number and should return hte value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 3, "perturbed": true, "gc": "/*A simple program which shuold return the value of x if n is \n  a prmie number and should return hte value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n % 2 === 0) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\nconst main = () => {\n  console.log(xOrY(7, 34, 12));\n  console.log(xOrY(15, 8, 5));\n};\n\nmain();\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that aer dod. Ignore numebrs that are negative or not integesr.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 01\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the inupt list is empty, return 0.\n  */\nocnts doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 3, "perturbed": true, "gc": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that aer dod. Ignore numebrs that are negative or not integesr.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 01\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the inupt list is empty, return 0.\n  */\nocnts doubleTheDifference = (lst) => {\n  let sum = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      sum += lst[i] * lst[i]\n    }\n  }\n  return sum\n}\n\nconsole.log(doubleTheDifference([1, 3, 2, 0]))\nconsole.log(doubleTheDifference([-1, -2, 0]))\nconsole.log(doubleTheDifference([9, -2]))\nconsole.log(doubleTheDifference([0]))\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feelnig when the result fo some long-awaited\n  event is finlaly known. The efelings and thoughts you haev at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine fi a person correctly geussed the results of a number of matches.\n  You are given wto arrays of scores and guesses of equal length, where each index shows a match. \n  Rteurn an array of the same length denotngi how far off each guess was. If htey haev guessed correctly,\n  the value is 0, and if not, the value is the absolute differecne between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 3, "perturbed": true, "gc": "/*I think we all remember that feelnig when the result fo some long-awaited\n  event is finlaly known. The efelings and thoughts you haev at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine fi a person correctly geussed the results of a number of matches.\n  You are given wto arrays of scores and guesses of equal length, where each index shows a match. \n  Rteurn an array of the same length denotngi how far off each guess was. If htey haev guessed correctly,\n  the value is 0, and if not, the value is the absolute differecne between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let result = [];\n  for (let i = 0; i < game.length; i++) {\n    let score = game[i];\n    let guessScore = guess[i];\n    let diff = Math.abs(score - guessScore);\n    if (score === guessScore) {\n      result.push(0);\n    } else {\n      result.push(diff);\n    }\n  }\n  return result;\n};\n\nmodule.exports = compare;\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/153", "prompt": "/*You will be igven the name of a class (a stirng) and a list of extensions.\n  The extensions are to be used to load additional classes ot the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the etxension's name, and let SM be the number of lowercaes letters\n  in the extension's name, the strenght is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there aer two or more extensions with the asme strength, oyu hsould\n  chosoe the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 3, "perturbed": true, "gc": "/*You will be igven the name of a class (a stirng) and a list of extensions.\n  The extensions are to be used to load additional classes ot the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the etxension's name, and let SM be the number of lowercaes letters\n  in the extension's name, the strenght is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there aer two or more extensions with the asme strength, oyu hsould\n  chosoe the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let extension_name = '';\n  let extension_strength = 0;\n  let i = 0;\n  while (i < extensions.length) {\n    let extension = extensions[i];\n    let strength = extension.length - extension.replace(/\\s+/g, '').length;\n    if (extension_strength < strength) {\n      extension_name = extension;\n      extension_strength = strength;\n    }\n    i++;\n  }\n  return `${class_name}.${extension_name}`;\n};\n\nmodule.exports = {\n  strongestExtension\n};\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => flase\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 3, "perturbed": true, "gc": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => flase\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let aa = a.split(\"\");\n  let bb = b.split(\"\");\n  let c = 0;\n  while (c < aa.length) {\n    if (aa[c] === bb[0]) {\n      aa.splice(c, 1);\n      bb.splice(0, 1);\n      c++;\n    } else {\n      c++;\n    }\n  }\n  if (aa.length === bb.length) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst test = () => {\n  let a = \"abcd\";\n  let b = \"abd\";\n  console.log(cycpatternCheck(a, b));\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the unmber of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 3, "perturbed": true, "gc": "/*Given an integer. return a tuple that has the unmber of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let even = 0, odd = 0;\n  while (num > 0) {\n    let digit = num % 10;\n    if (digit % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    num = num / 10;\n  }\n  return [even, odd];\n};\n\nmodule.exports = evenOddCount;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive niteger, obtain its roman numeral equivalent as a string,\n  adn return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 3, "perturbed": true, "gc": "/*\n  Given a positive niteger, obtain its roman numeral equivalent as a string,\n  adn return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let result = ''\n  while (number > 0) {\n    let digit = number % 10\n    result = (digit < 4)? (digit + 'i') : (digit - 3 + 'c')\n    number = Math.floor(number / 10)\n  }\n  return result.toLowerCase()\n}\n\n/*\n  Given a positive integer, return its roman numeral equivalent as a string,\n  adn return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'xix'\n  >>> intToRoman(152) == 'clii'\n  >>> intToRoman(426) == 'cdxxvi'\n  */\nconst intToRoman = (number) => {\n  let result = ''\n  while (number > 0) {\n    let digit = number % 10\n    result = (digit < 4)? (digit + 'i') : (digit - 3 + 'c')\n    number = Math.floor(number / 10)\n  }\n  return result.toLowerCase()\n}\n\n/*\n  Given a positive integer, return its roman numeral equivalent as a string,\n  adn return it in upper case.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToUpperRoman = (number) => {\n  let result = ''\n  while (number > 0) {\n    let digit = number % 10\n    result = (digit < 4)? (digit + 'I') : (digit - 3 + 'C')\n    number = Math.floor(number / 10)\n  }\n  return result.toUpperCase()\n}\n\n/*\n  Given a positive integer, return its roman numeral equivalent as a string,\n  adn return it in upper case.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToLowerRoman = (number) => {\n  let result = ''\n  while (number > 0) {\n    let digit = number % 10\n    result = (digit < 4)? (digit + 'i') : (digit - 3 + 'c')\n    number = Math.floor(number / 10)\n  }\n  return result.toLowerCase()\n}\n\n/*\n  Given a positive integer, return its roman numeral equivalent as a string,\n  adn return it in upper case.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRoman(19) == 'XIX'\n  >>> intToRoman(152) == 'CLII'\n  >>> intToRoman(426) == 'CDXXVI'\n  */\nconst intToRomanNumeral = (number) => {\n  let result = ''\n  while (number > 0) {\n    let digit = number % 10\n    result = (digit < 4)? (digit + 'i') : (digit - 3 + 'c')\n    number = Math.floor(number / 10)\n  }\n  return result\n}\n\n/*\n  Given a positive integer, return its roman numeral equivalent as a string,\n  adn return it in upper case.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRomanNumeral(19) == 'XIX'\n  >>> intToRomanNumeral(152) == 'CLII'\n  >>> intToRomanNumeral(426) == 'CDXXVI'\n  */\nconst intToRomanNumeralNumeral = (number) => {\n  let result = ''\n  while (number > 0) {\n    let digit = number % 10\n    result = (digit < 4)? (digit + 'i') : (digit - 3 + 'c')\n    number = Math.floor(number / 10)\n  }\n  return result\n}\n\nmodule.exports = {\n  intToRoman,\n  intToRomanNumeral,\n  intToRomanNumeralNumeral,\n  intToUpperRoman,\n  intToLowerRoman,\n  intToMiniRoman,\n  intToRomanNumeral,\n  intToRomanNumeralNumeral\n}\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lenghts fo the htree sides of a triangle. Retunr true if the three\n  sides form a right-angled tirangle, false otherwise.\n  A right-angled triagnle is a triangle in which one nagle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 3, "perturbed": true, "gc": "/*\n Given the lenghts fo the htree sides of a triangle. Retunr true if the three\n  sides form a right-angled tirangle, false otherwise.\n  A right-angled triagnle is a triangle in which one nagle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n};\n\nconst rightAngleTriangle = (a, b, c) => {\n  return a + b > c && a + c > b && b + c > a;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a funtcion that accepst a list of strigns.\n  The list contains idfferent words. Rteurn the word wiht maximum numebr\n  of uniuqe charatcers. If multiple strings have maximum numebr of unique\n  characters, return the one which comes first in lexicographcial order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"strign\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 3, "perturbed": true, "gc": "/*Write a funtcion that accepst a list of strigns.\n  The list contains idfferent words. Rteurn the word wiht maximum numebr\n  of uniuqe charatcers. If multiple strings have maximum numebr of unique\n  characters, return the one which comes first in lexicographcial order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"strign\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax2 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax3 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax4 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax5 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax6 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax7 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax8 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax9 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax10 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax11 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax12 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax13 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax14 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax15 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i++) {\n    if (words[i].length > max.length) {\n      max = words[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\nconst findMax16 = (words) => {\n  let max = words[0];\n  let maxIndex = 0;\n  for (let i = 1; i < words.length; i", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already ahve eaten a cretain number of carrots,\n  but now you need ot eat mroe acrrots to compleet teh day's meals.\n  you should return an array of [ total number of etaen acrrots after your meals,\n                                  the number of carrots left afetr your emals ]\n  if there are not eonugh remaining carrots, you will eat all remaining carrots, but will stlli be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 3, "perturbed": true, "gc": "/*\n  You're a hungry rabbit, and you already ahve eaten a cretain number of carrots,\n  but now you need ot eat mroe acrrots to compleet teh day's meals.\n  you should return an array of [ total number of etaen acrrots after your meals,\n                                  the number of carrots left afetr your emals ]\n  if there are not eonugh remaining carrots, you will eat all remaining carrots, but will stlli be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  if (number < 0 || number > 1000) return [0, 0];\n  if (need < 0 || need > 1000) return [0, 0];\n  if (remaining < 0 || remaining > 1000) return [0, 0];\n\n  const total = number + need;\n  const left = remaining - need;\n\n  if (total <= left) {\n    return [total, left];\n  } else {\n    return [total, 0];\n  }\n};\n\nexport default eat;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/16", "prompt": "/* Gievn a string, find out how many distinct charatcers (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 3, "perturbed": true, "gc": "/* Gievn a string, find out how many distinct charatcers (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let currentChar = '';\n  for (let i = 0; i < string.length; i++) {\n    currentChar = string[i];\n    if (currentChar!== currentChar.toLowerCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = countDistinctCharacters;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two litss operator, and operand. hTe first list has basic lagebra poeartions, and \n  hte second list is a list of integers. Use teh two given lists to build the algebric \n  expression and return the evaluation of this expressoin.\n\n  The basic aglebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 3, "perturbed": true, "gc": "/*\n  Given two litss operator, and operand. hTe first list has basic lagebra poeartions, and \n  hte second list is a list of integers. Use teh two given lists to build the algebric \n  expression and return the evaluation of this expressoin.\n\n  The basic aglebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j =", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwies ekep it as it is.\n  If the string cnotains no letters, reverse the string.\n  The function should return the resluted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwies ekep it as it is.\n  If the string cnotains no letters, reverse the string.\n  The function should return the resluted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let res = s;\n  if (s.length === 0) {\n    res = s;\n  } else {\n    let l = s.length;\n    for (let i = 0; i < l; i++) {\n      if (s[i].match(/[a-z]/)) {\n        let t = s[i].toLowerCase();\n        if (t!== s[i]) {\n          res = res.replace(s[i], t);\n        }\n      } else {\n        res = res.replace(s[i], s[i].toUpperCase());\n      }\n    }\n  }\n  return res;\n};\n\nconsole.log(solve(\"1234\"));\nconsole.log(solve(\"ab\"));\nconsole.log(solve(\"#a@C\"));\nconsole.log(solve(\"\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(solve(\"a\"));\nconsole.log(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 ahsh equivalent stirng.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 3, "perturbed": true, "gc": "/*\n  Given a string 'text', return its md5 ahsh equivalent stirng.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') {\n    return null;\n  }\n  const md5 = crypto.createHash('md5');\n  md5.update(text);\n  return md5.digest('hex');\n};\n\n/**\n  Given a string 'text', return its sha1 equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == '5b4c5d6c8e4b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4d9b6f2b6f1d6f3d6f5b4", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  iGven two opsitive nitegers a and b, return the even digits bewteen a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 3, "perturbed": true, "gc": "/*\n  iGven two opsitive nitegers a and b, return the even digits bewteen a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  while (a <= b) {\n    result.push(a);\n    a++;\n  }\n  return result;\n};\n\nmodule.exports = generateIntegers;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input ot this function is a stirng representing musical notes in a special ASCII fomrat.\n  Your task is to parse this strign and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legden:\n  'o' - wohle note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one baet\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 3, "perturbed": true, "gc": "/* Input ot this function is a stirng representing musical notes in a special ASCII fomrat.\n  Your task is to parse this strign and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legden:\n  'o' - wohle note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one baet\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  let music_list = [];\n  let music_string_array = music_string.split(' ');\n  for (let i = 0; i < music_string_array.length; i++) {\n    let music_string_array_item = music_string_array[i];\n    let music_string_array_item_array = music_string_array_item.split('|');\n    for (let j = 0; j < music_string_array_item_array.length; j++) {\n      let music_string_array_item_array_item = music_string_array_item_array[j];\n      let music_string_array_item_array_item_array = music_string_array_item_array_item.split(' ');\n      let music_string_array_item_array_item_array_item = music_string_array_item_array_item_array[0];\n      let music_string_array_item_array_item_array_item_array = music_string_array_item_array_item_array_item.split(' ');\n      let music_string_array_item_array_item_array_item_array_item = music_string_array_item_array_item_array_item_array[0];\n      let music_string_array_item_array_item_array_item_array_item_array = music_string_array_item_array_item_array_item_array_item.split(' ');\n      let music_string_array_item_array_item_array_item_array_item_array_item = music_string_array_item_array_item_array_item_array_item_array[0];\n      let music_string_array_item_array_item_array_item_array_item_array_item_array = music_string_array_item_array_item_array_item_array_item_array_item.split(' ');\n      let music_string_array_item_array_item_array_item_array_item_array_item_array_item = music_string_array_item_array_item_array_item_array_item_array_item_array[0];\n      let music_string_array_item_array_item_array_item_array_item_array_item_array_item_array = music_string_array_item_array_item_array_item_array_item_array_item_array_item.split(' ');\n      let music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item = music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array[0];\n      let music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array = music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item.split(' ');\n      let music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array = music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item.split(' ');\n      let music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array = music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item.split(' ');\n      let music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array = music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item.split(' ');\n      let music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array = music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item.split(' ');\n      let music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array = music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item.split(' ');\n      let music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array = music_string_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item_array_item", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can eb found in eth original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 3, "perturbed": true, "gc": "/* Find how many times a given substring can eb found in eth original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  if (string.length === 0) {\n    return 0\n  }\n  if (string.length === substring.length) {\n    return 1\n  }\n  let count = 0\n  for (let i = 0; i < string.length; i++) {\n    if (string.substring(i, i + substring.length) === substring) {\n      count += 1\n    }\n  }\n  return count\n}\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('abcabcabc', 'abc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'ab')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabcabc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabcabcabc')\n  'abc'\n  */\nconst longestSubstring = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  if (string.length === substring.length) {\n    return substring\n  }\n  let maxLength = 0\n  let maxIndex = 0\n  for (let i = 0; i < string.length; i++) {\n    let currentLength = howManyTimes(string, substring, i)\n    if (currentLength > maxLength) {\n      maxLength = currentLength\n      maxIndex = i\n    }\n  }\n  return string.substring(maxIndex, maxIndex + substring.length)\n}\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('abcabcabc', 'abc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'ab')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabcabc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabcabcabc')\n  'abc'\n  */\nconst longestSubstring2 = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  if (string.length === substring.length) {\n    return substring\n  }\n  let maxLength = 0\n  let maxIndex = 0\n  for (let i = 0; i < string.length; i++) {\n    let currentLength = howManyTimes(string, substring, i)\n    if (currentLength > maxLength) {\n      maxLength = currentLength\n      maxIndex = i\n    }\n  }\n  return string.substring(maxIndex, maxIndex + substring.length)\n}\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('abcabcabc', 'abc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'ab')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabcabc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabcabcabc')\n  'abc'\n  */\nconst longestSubstring3 = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  if (string.length === substring.length) {\n    return substring\n  }\n  let maxLength = 0\n  let maxIndex = 0\n  for (let i = 0; i < string.length; i++) {\n    let currentLength = howManyTimes(string, substring, i)\n    if (currentLength > maxLength) {\n      maxLength = currentLength\n      maxIndex = i\n    }\n  }\n  return string.substring(maxIndex, maxIndex + substring.length)\n}\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('abcabcabc', 'abc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'ab')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabcabc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabcabcabc')\n  'abc'\n  */\nconst longestSubstring4 = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  if (string.length === substring.length) {\n    return substring\n  }\n  let maxLength = 0\n  let maxIndex = 0\n  for (let i = 0; i < string.length; i++) {\n    let currentLength = howManyTimes(string, substring, i)\n    if (currentLength > maxLength) {\n      maxLength = currentLength\n      maxIndex = i\n    }\n  }\n  return string.substring(maxIndex, maxIndex + substring.length)\n}\n\n/*\n  Find the longest substring in a given string.\n  >>> longestSubstring('abcabcabc', 'abc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'ab')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabcabc')\n  'abc'\n  >>> longestSubstring('abcabcabc', 'abcabcabcabc')\n  'abc'\n  */\nconst longestSubstring5 = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  if (string.length === substring.length) {\n    return substring\n  }\n  let maxLength = 0\n  let maxIndex = 0\n  for (let i = 0; i < string.length; i++) {\n    let currentLength = howManyTimes(string, substring, i)\n    if (currentLength > maxLength) {\n      maxLength = currentLength\n      maxIndex = i\n    }\n  }\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a psace-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'htree', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the strnig with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 3, "perturbed": true, "gc": "/* Input is a psace-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'htree', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the strnig with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let result = '';\n  let number = '';\n  let i = 0;\n  while (i < numbers.length) {\n    number = numbers[i];\n    if (number === 'zero') {\n      result += '0';\n    } else if (number === 'one') {\n      result += '1';\n    } else if (number === 'two') {\n      result += '2';\n    } else if (number === 'three') {\n      result += '3';\n    } else if (number === 'four') {\n      result += '4';\n    } else if (number === 'five') {\n      result += '5';\n    } else if (number ==='six') {\n      result += '6';\n    } else if (number ==='seven') {\n      result += '7';\n    } else if (number === 'eight') {\n      result += '8';\n    } else if (number === 'nine') {\n      result += '9';\n    } else {\n      throw new Error('Invalid number:'+ number);\n    }\n    i++;\n  }\n  return result;\n};\n\nmodule.exports = sortNumbers;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 3, "perturbed": true, "gc": "/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  if (decimalPart > 0.5) {\n    integerPart++;\n  }\n  return integerPart;\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber2 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  if (decimalPart > 0.5) {\n    integerPart++;\n  }\n  return decimalPart;\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber3 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  if (decimalPart > 0.5) {\n    integerPart++;\n  }\n  return decimalPart;\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber4 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  if (decimalPart > 0.5) {\n    integerPart++;\n  }\n  return decimalPart;\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber5 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  if (decimalPart > 0.5) {\n    integerPart++;\n  }\n  return decimalPart;\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber6 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  if (decimalPart > 0.5) {\n    integerPart++;\n  }\n  return decimalPart;\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber7 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  if (decimalPart > 0.5) {\n    integerPart++;\n  }\n  return decimalPart;\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber8 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  if (decimalPart > 0.5) {\n    integerPart++;\n  }\n  return decimalPart;\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber9 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  if (decimalPart > 0.5) {\n    integerPart++;\n  }\n  return decimalPart;\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber10 = (number) => {\n  let integerPart = Math.floor(number);\n  let decimalPart = number - integerPart;\n  if (decimalPart > 0.5) {\n    integerPart++;\n  }\n  return decimalPart;\n};\n\n/* Given a positive floating ponit number, it can be decomposed into\n  and integer part (largest inteegr smaller thna given number) and dceimals\n  (leftover aprt always smaller than 1).\n\n  Reutrn hte decimal part of the number.\n  >>> truncate", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/20", "prompt": "/* Form a usplpied list of numbers (of length at least two) select adn return two that are the closest to each\n  other and return them in order (smaller number, lrager number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 3, "perturbed": true, "gc": "/* Form a usplpied list of numbers (of length at least two) select adn return two that are the closest to each\n  other and return them in order (smaller number, lrager number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const closest = [...numbers]\n  const sorted = numbers.sort((a, b) => a - b)\n  const lrager = sorted[0]\n  const lsmaller = sorted[sorted.length - 1]\n  const lragerDistance = lrager - lsmaller\n  const lsmallerDistance = lsmaller - lrager\n  const closestDistance = closest[0] - closest[1]\n  const closestIndex = closest.findIndex((n) => n === closestDistance)\n  const closestLragerIndex = closest.findIndex((n) => n === lragerDistance)\n  const closestLsmallerIndex = closest.findIndex((n) => n === lsmallerDistance)\n  return [closest[closestIndex], closest[closestLragerIndex], closest[closestLsmallerIndex]]\n}\n\nconst findClosestElements2 = (numbers) => {\n  const closest = [...numbers]\n  const sorted = numbers.sort((a, b) => a - b)\n  const lrager = sorted[0]\n  const lsmaller = sorted[sorted.length - 1]\n  const lragerDistance = lrager - lsmaller\n  const lsmallerDistance = lsmaller - lrager\n  const closestDistance = closest[0] - closest[1]\n  const closestLragerIndex = closest.findIndex((n) => n === lragerDistance)\n  const closestLsmallerIndex = closest.findIndex((n) => n === lsmallerDistance)\n  return [closest[closestIndex], closest[closestLragerIndex], closest[closestLsmallerIndex]]\n}\n\nconst findClosestElements3 = (numbers) => {\n  const closest = [...numbers]\n  const sorted = numbers.sort((a, b) => a - b)\n  const lrager = sorted[0]\n  const lsmaller = sorted[sorted.length - 1]\n  const lragerDistance = lrager - lsmaller\n  const lsmallerDistance = lsmaller - lrager\n  const closestDistance = closest[0] - closest[1]\n  const closestLragerIndex = closest.findIndex((n) => n === lragerDistance)\n  const closestLsmallerIndex = closest.findIndex((n) => n === lsmallerDistance)\n  return [closest[closestIndex], closest[closestLragerIndex], closest[closestLsmallerIndex]]\n}\n\nconst findClosestElements4 = (numbers) => {\n  const closest = [...numbers]\n  const sorted = numbers.sort((a, b) => a - b)\n  const lrager = sorted[0]\n  const lsmaller = sorted[sorted.length - 1]\n  const lragerDistance = lrager - lsmaller\n  const lsmallerDistance = lsmaller - lrager\n  const closestDistance = closest[0] - closest[1]\n  const closestLragerIndex = closest.findIndex((n) => n === lragerDistance)\n  const closestLsmallerIndex = closest.findIndex((n) => n === lsmallerDistance)\n  return [closest[closestIndex], closest[closestLragerIndex], closest[closestLsmallerIndex]]\n}\n\nconst findClosestElements5 = (numbers) => {\n  const closest = [...numbers]\n  const sorted = numbers.sort((a, b) => a - b)\n  const lrager = sorted[0]\n  const lsmaller = sorted[sorted.length - 1]\n  const lragerDistance = lrager - lsmaller\n  const lsmallerDistance = lsmaller - lrager\n  const closestDistance = closest[0] - closest[1]\n  const closestLragerIndex = closest.findIndex((n) => n === lragerDistance)\n  const closestLsmallerIndex = closest.findIndex((n) => n === lsmallerDistance)\n  return [closest[closestIndex], closest[closestLragerIndex], closest[closestLsmallerIndex]]\n}\n\nconst findClosestElements6 = (numbers) => {\n  const closest = [...numbers]\n  const sorted = numbers.sort((a, b) => a - b)\n  const lrager = sorted[0]\n  const lsmaller = sorted[sorted.length - 1]\n  const lragerDistance = lrager - lsmaller\n  const lsmallerDistance = lsmaller - lrager\n  const closestDistance = closest[0] - closest[1]\n  const closestLragerIndex = closest.findIndex((n) => n === lragerDistance)\n  const closestLsmallerIndex = closest.findIndex((n) => n === lsmallerDistance)\n  return [closest[closestIndex], closest[closestLragerIndex], closest[closestLsmallerIndex]]\n}\n\nconst findClosestElements7 = (numbers) => {\n  const closest = [...numbers]\n  const sorted = numbers.sort((a, b) => a - b)\n  const lrager = sorted[0]\n  const lsmaller = sorted[sorted.length - 1]\n  const lragerDistance = lrager - lsmaller\n  const lsmallerDistance = lsmaller - lrager\n  const closestDistance = closest[0] - closest[1]\n  const closestLragerIndex = closest.findIndex((n) => n === lragerDistance)\n  const closestLsmallerIndex = closest.findIndex((n) => n === lsmallerDistance)\n  return [closest[closestIndex], closest[", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/21", "prompt": "/* Gievn list of numbers (of at alest two elements), apply a linear tarnsform ot that list,\n  such htat the smallest number will become 0 and hte largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 3, "perturbed": true, "gc": "/* Gievn list of numbers (of at alest two elements), apply a linear tarnsform ot that list,\n  such htat the smallest number will become 0 and hte largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min.apply(null, numbers);\n  const max = Math.max.apply(null, numbers);\n  const scale = (max - min) / 2;\n  const newNumbers = [];\n  for (let i = 0; i < numbers.length; i++) {\n    newNumbers.push(numbers[i] - min + scale);\n  }\n  return newNumbers;\n};\n\nmodule.exports = rescaleToUnit;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values noly for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 3, "perturbed": true, "gc": "/* Filter given list of any python values noly for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'number';\n  });\n};\n\n/*\n  Filter given list of any python values noly for strings\n  >>> filterStrings(['a', 3.14, 5])\n  [5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterStrings = (values) => {\n  return values.filter((value) => {\n    return typeof value ==='string';\n  });\n};\n\n/*\n  Filter given list of any python values noly for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [5]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterBooleans = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'boolean';\n  });\n};\n\n/*\n  Filter given list of any python values noly for objects\n  >>> filterObjects(['a', 3.14, 5])\n  [5]\n  >>> filterObjects([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterObjects = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object';\n  });\n};\n\n/*\n  Filter given list of any python values noly for null\n  >>> filterNulls(['a', 3.14, 5])\n  [5]\n  >>> filterNulls([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterNulls = (values) => {\n  return values.filter((value) => {\n    return value === null;\n  });\n};\n\n/*\n  Filter given list of any python values noly for undefined\n  >>> filterUndefineds(['a', 3.14, 5])\n  [5]\n  >>> filterUndefineds([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterUndefineds = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/*\n  Filter given list of any python values noly for undefined\n  >>> filterUndefineds(['a', 3.14, 5])\n  [5]\n  >>> filterUndefineds([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterUndefineds = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/*\n  Filter given list of any python values noly for undefined\n  >>> filterUndefineds(['a', 3.14, 5])\n  [5]\n  >>> filterUndefineds([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterUndefineds = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/*\n  Filter given list of any python values noly for undefined\n  >>> filterUndefineds(['a', 3.14, 5])\n  [5]\n  >>> filterUndefineds([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterUndefineds = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/*\n  Filter given list of any python values noly for undefined\n  >>> filterUndefineds(['a', 3.14, 5])\n  [5]\n  >>> filterUndefineds([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterUndefineds = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/*\n  Filter given list of any python values noly for undefined\n  >>> filterUndefineds(['a', 3.14, 5])\n  [5]\n  >>> filterUndefineds([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterUndefineds = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/*\n  Filter given list of any python values noly for undefined\n  >>> filterUndefineds(['a', 3.14, 5])\n  [5]\n  >>> filterUndefineds([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterUndefineds = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/*\n  Filter given list of any python values noly for undefined\n  >>> filterUndefineds(['a', 3.14, 5])\n  [5]\n  >>> filterUndefineds([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterUndefineds = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/*\n  Filter given list of any python values noly for undefined\n  >>> filterUndefineds(['a', 3.14, 5])\n  [5]\n  >>> filterUndefineds([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterUndefineds = (values) => {\n  return values.filter((value) => {\n    return value === undefined;\n  });\n};\n\n/*\n  Filter given list of any python values noly for undefined\n  >>> filterUndefineds(['a', 3.14, 5])\n  [5]\n  >>> filter", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return length of gievn string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 3, "perturbed": true, "gc": "/* Return length of gievn string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  if (string === '') {\n    return 0;\n  }\n  return string.length;\n};\n\n/*\n  Return true if string is empty\n  >>> bool('')\n  True\n  >>> bool('abc')\n  False\n  */\nconst isEmpty = (string) => {\n  return string === '';\n};\n\n/*\n  Return true if string is not empty\n  >>> bool('')\n  False\n  >>> bool('abc')\n  True\n  */\nconst isNotEmpty = (string) => {\n  return!isEmpty(string);\n};\n\n/*\n  Return true if string is null\n  >>> bool(null)\n  True\n  >>> bool('')\n  False\n  */\nconst isNull = (string) => {\n  return string === null;\n};\n\n/*\n  Return true if string is not null\n  >>> bool(null)\n  False\n  >>> bool('abc')\n  True\n  */\nconst isNotNull = (string) => {\n  return!isNull(string);\n};\n\n/*\n  Return true if string is a number\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('123')\n  True\n  */\nconst isNumber = (string) => {\n  return!isNaN(parseFloat(string));\n};\n\n/*\n  Return true if string is a number\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('123')\n  True\n  */\nconst isNotNumber = (string) => {\n  return!isNumber(string);\n};\n\n/*\n  Return true if string is a boolean\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('true')\n  True\n  */\nconst isBoolean = (string) => {\n  return string === 'true' || string === 'false';\n};\n\n/*\n  Return true if string is a boolean\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('true')\n  True\n  */\nconst isNotBoolean = (string) => {\n  return!isBoolean(string);\n};\n\n/*\n  Return true if string is a date\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('2015-01-01')\n  True\n  */\nconst isDate = (string) => {\n  return string instanceof Date;\n};\n\n/*\n  Return true if string is a date\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('2015-01-01')\n  True\n  */\nconst isNotDate = (string) => {\n  return!isDate(string);\n};\n\n/*\n  Return true if string is a function\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('function() {}')\n  True\n  */\nconst isFunction = (string) => {\n  return string instanceof Function;\n};\n\n/*\n  Return true if string is a function\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('function() {}')\n  True\n  */\nconst isNotFunction = (string) => {\n  return!isFunction(string);\n};\n\n/*\n  Return true if string is a string\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('function() {}')\n  False\n  */\nconst isString = (string) => {\n  return string instanceof String;\n};\n\n/*\n  Return true if string is a string\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('function() {}')\n  False\n  */\nconst isNotString = (string) => {\n  return!isString(string);\n};\n\n/*\n  Return true if string is a number\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('123')\n  True\n  */\nconst isNumberString = (string) => {\n  return isNumber(string) || isString(string);\n};\n\n/*\n  Return true if string is a number\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('123')\n  True\n  */\nconst isNotNumberString = (string) => {\n  return!isNumberString(string);\n};\n\n/*\n  Return true if string is a boolean\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('true')\n  True\n  */\nconst isBooleanString = (string) => {\n  return isBoolean(string) || isString(string);\n};\n\n/*\n  Return true if string is a boolean\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('true')\n  True\n  */\nconst isNotBooleanString = (string) => {\n  return!isBooleanString(string);\n};\n\n/*\n  Return true if string is a date\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('2015-01-01')\n  True\n  */\nconst isDateString = (string) => {\n  return isDate(string) || isString(string);\n};\n\n/*\n  Return true if string is a date\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('2015-01-01')\n  True\n  */\nconst isNotDateString = (string) => {\n  return!isDateString(string);\n};\n\n/*\n  Return true if string is a function\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('function() {}')\n  True\n  */\nconst isFunctionString = (string) => {\n  return isFunction(string) || isString(string);\n};\n\n/*\n  Return true if string is a function\n  >>> bool('')\n  False\n  >>> bool('abc')\n  False\n  >>> bool('function() {}')\n  True\n  */\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/24", "prompt": "/* Fro a givne number n, find the largset number that idvides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 3, "perturbed": true, "gc": "/* Fro a givne number n, find the largset number that idvides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let d = 1;\n  while (n % d === 0) {\n    d++;\n  }\n  return d;\n};\n\nmodule.exports = largestDivisor;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be lisetd number of itmes croresponding to how many times it appeares in afctorizaiton.\n  Input number sohuld be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 3, "perturbed": true, "gc": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be lisetd number of itmes croresponding to how many times it appeares in afctorizaiton.\n  Input number sohuld be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let i = 2;\n  while (i <= n) {\n    if (n % i === 0) {\n      factors.push(i);\n      n = n / i;\n    }\n    i++;\n  }\n  return factors;\n};\n\nconst isPrime = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber2 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber3 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber4 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber5 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber6 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber7 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber8 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber9 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber10 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber11 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber12 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber13 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber14 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber15 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber16 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber17 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber18 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrimeNumber19 = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of intgeers, remove all elements that occur moer thna once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 3, "perturbed": true, "gc": "/* From a list of intgeers, remove all elements that occur moer thna once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let output = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let index = output.indexOf(numbers[i]);\n    if (index === -1) {\n      output.push(numbers[i]);\n    }\n  }\n  return output;\n};\n\n/*\n  From a list of intgeers, remove all elements that occur more than once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates2 = (numbers) => {\n  let output = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let index = output.indexOf(numbers[i]);\n    if (index === -1) {\n      output.push(numbers[i]);\n    }\n  }\n  return output;\n};\n\n/*\n  From a list of intgeers, remove all elements that occur more than once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates2([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates3 = (numbers) => {\n  let output = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let index = output.indexOf(numbers[i]);\n    if (index === -1) {\n      output.push(numbers[i]);\n    }\n  }\n  return output;\n};\n\n/*\n  From a list of intgeers, remove all elements that occur more than once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates3([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates4 = (numbers) => {\n  let output = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let index = output.indexOf(numbers[i]);\n    if (index === -1) {\n      output.push(numbers[i]);\n    }\n  }\n  return output;\n};\n\n/*\n  From a list of intgeers, remove all elements that occur more than once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates4([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates5 = (numbers) => {\n  let output = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let index = output.indexOf(numbers[i]);\n    if (index === -1) {\n      output.push(numbers[i]);\n    }\n  }\n  return output;\n};\n\n/*\n  From a list of intgeers, remove all elements that occur more than once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates5([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates6 = (numbers) => {\n  let output = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let index = output.indexOf(numbers[i]);\n    if (index === -1) {\n      output.push(numbers[i]);\n    }\n  }\n  return output;\n};\n\n/*\n  From a list of intgeers, remove all elements that occur more than once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates6([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates7 = (numbers) => {\n  let output = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let index = output.indexOf(numbers[i]);\n    if (index === -1) {\n      output.push(numbers[i]);\n    }\n  }\n  return output;\n};\n\n/*\n  From a list of intgeers, remove all elements that occur more than once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates7([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates8 = (numbers) => {\n  let output = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let index = output.indexOf(numbers[i]);\n    if (index === -1) {\n      output.push(numbers[i]);\n    }\n  }\n  return output;\n};\n\n/*\n  From a list of intgeers, remove all elements that occur more than once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates8([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates9 = (numbers) => {\n  let output = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let index = output.indexOf(numbers[i]);\n    if (index === -1) {\n      output.push(numbers[i]);\n    }\n  }\n  return output;\n};\n\n/*\n  From a list of intgeers, remove all elements that occur more than once.\n  Keep order of elements left the same as in hte input.\n  >>> removeDuplicates9([1, 2, 3, 2, 4])\n  [1, 2, 3, 4]\n  */\nconst removeDuplicates10 = (numbers) => {\n  let output = [];\n  for (let i = 0; i < numbers.length; i++) {\n    let index = output.indexOf(numbers[i]);\n    if (index === -", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/27", "prompt": "/* oFr a given string, flip lwoercase charatcres to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 3, "perturbed": true, "gc": "/* oFr a given string, flip lwoercase charatcres to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().replace(/[a-z]/g, (match) => {\n    return match.toUpperCase();\n  });\n};\n\n/**\n  * oFr a given string, remove all non-alphanumeric characters.\n  * @param string\n  * @returns {*}\n  */\nconst removeNonAlphanumeric = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/**\n  * oFr a given string, remove all whitespace characters.\n  * @param string\n  * @returns {*}\n  */\nconst removeWhitespace = (string) => {\n  return string.replace(/\\s/g, '');\n};\n\n/**\n  * oFr a given string, remove all punctuation characters.\n  * @param string\n  * @returns {*}\n  */\nconst removePunctuation = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/**\n  * oFr a given string, remove all non-alphanumeric characters.\n  * @param string\n  * @returns {*}\n  */\nconst removeNonAlphanumeric = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/**\n  * oFr a given string, remove all whitespace characters.\n  * @param string\n  * @returns {*}\n  */\nconst removeWhitespace = (string) => {\n  return string.replace(/\\s/g, '');\n};\n\n/**\n  * oFr a given string, remove all punctuation characters.\n  * @param string\n  * @returns {*}\n  */\nconst removePunctuation = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/**\n  * oFr a given string, remove all whitespace characters.\n  * @param string\n  * @returns {*}\n  */\nconst removeWhitespace = (string) => {\n  return string.replace(/\\s/g, '');\n};\n\n/**\n  * oFr a given string, remove all punctuation characters.\n  * @param string\n  * @returns {*}\n  */\nconst removePunctuation = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/**\n  * oFr a given string, remove all whitespace characters.\n  * @param string\n  * @returns {*}\n  */\nconst removeWhitespace = (string) => {\n  return string.replace(/\\s/g, '');\n};\n\n/**\n  * oFr a given string, remove all punctuation characters.\n  * @param string\n  * @returns {*}\n  */\nconst removePunctuation = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/**\n  * oFr a given string, remove all whitespace characters.\n  * @param string\n  * @returns {*}\n  */\nconst removeWhitespace = (string) => {\n  return string.replace(/\\s/g, '');\n};\n\n/**\n  * oFr a given string, remove all punctuation characters.\n  * @param string\n  * @returns {*}\n  */\nconst removePunctuation = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/**\n  * oFr a given string, remove all whitespace characters.\n  * @param string\n  * @returns {*}\n  */\nconst removeWhitespace = (string) => {\n  return string.replace(/\\s/g, '');\n};\n\n/**\n  * oFr a given string, remove all punctuation characters.\n  * @param string\n  * @returns {*}\n  */\nconst removePunctuation = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/**\n  * oFr a given string, remove all whitespace characters.\n  * @param string\n  * @returns {*}\n  */\nconst removeWhitespace = (string) => {\n  return string.replace(/\\s/g, '');\n};\n\n/**\n  * oFr a given string, remove all punctuation characters.\n  * @param string\n  * @returns {*}\n  */\nconst removePunctuation = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/**\n  * oFr a given string, remove all whitespace characters.\n  * @param string\n  * @returns {*}\n  */\nconst removeWhitespace = (string) => {\n  return string.replace(/\\s/g, '');\n};\n\n/**\n  * oFr a given string, remove all punctuation characters.\n  * @param string\n  * @returns {*}\n  */\nconst removePunctuation = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/**\n  * oFr a given string, remove all whitespace characters.\n  * @param string\n  * @returns {*}\n  */\nconst removeWhitespace = (string) => {\n  return string.replace(/\\s/g, '');\n};\n\n/**\n  * oFr a given string, remove all punctuation characters.\n  * @param string\n  * @returns {*}\n  */\nconst removePunctuation = (string) => {\n  return string.replace(/[^a-zA-Z0-9]/g, '');\n};\n\n/**\n  * oFr a given string, remove all whitespace characters.\n  * @param string\n  * @returns {*}\n  */\nconst removeWhitespace =", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/28", "prompt": "/* Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 3, "perturbed": true, "gc": "/* Cocnatenate list of strings into a isngle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  if (strings.length === 0) {\n    return '';\n  }\n  return strings.join('');\n};\n\n/*\n  Convert a string to a list of strings\n  >>> concatenate('abc')\n  ['a', 'b', 'c']\n  */\nconst stringToList = (string) => {\n  return string.split('');\n};\n\n/*\n  Convert a list of strings to a string\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst listToString = (list) => {\n  return list.join('');\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToList = (list) => {\n  return list;\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToStringList = (list) => {\n  return list.map(string => stringToList(string));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListList = (list) => {\n  return list.map(list => listToList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListListList = (list) => {\n  return list.map(list => listToListList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListListListList = (list) => {\n  return list.map(list => listToListListList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListListListListList = (list) => {\n  return list.map(list => listToListListListList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListListListListListList = (list) => {\n  return list.map(list => listToListListListListList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListListListListListListList = (list) => {\n  return list.map(list => listToListListListListListList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListListListListListListListList = (list) => {\n  return list.map(list => listToListListListListListListList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListListListListListListListListList = (list) => {\n  return list.map(list => listToListListListListListListListList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListListListListListListListListListList = (list) => {\n  return list.map(list => listToListListListListListListListListList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListListListListListListListListListListList = (list) => {\n  return list.map(list => listToListListListListListListListListListList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListListListListListListListListListListListList = (list) => {\n  return list.map(list => listToListListListListListListListListListListList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListListListListListListListListListListListListList = (list) => {\n  return list.map(list => listToListListListListListListListListListListListList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['a', 'b', 'c']\n  */\nconst listToListListListListListListListListListListListListListListListListList = (list) => {\n  return list.map(list => listToListListListListListListListListListListListListListList(list));\n};\n\n/*\n  Convert a list of strings to a list of strings\n  >>> concatenate(['a', 'b', 'c'])\n  ['", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filetr an niput list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 3, "perturbed": true, "gc": "/* Filetr an niput list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  if (!strings ||!prefix) {\n    return [];\n  }\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/*\n  Filetr an niput list of strings only for ones that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  if (!strings ||!suffix) {\n    return [];\n  }\n  return strings.filter(s => s.endsWith(suffix));\n};\n\n/*\n  Filetr an niput list of strings only for ones that contain a given substring.\n  >>> filterByContains([], 'a')\n  []\n  >>> filterByContains(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByContains = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s.includes(substring));\n};\n\n/*\n  Filetr an niput list of strings only for ones that are equal to a given string.\n  >>> filterByEqualTo([], 'a')\n  []\n  >>> filterByEqualTo(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByEqualTo = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s === substring);\n};\n\n/*\n  Filetr an niput list of strings only for ones that are not equal to a given string.\n  >>> filterByNotEqualTo([], 'a')\n  []\n  >>> filterByNotEqualTo(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde']\n  */\nconst filterByNotEqualTo = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s!== substring);\n};\n\n/*\n  Filetr an niput list of strings only for ones that are greater than a given string.\n  >>> filterByGreaterThan([], 'a')\n  []\n  >>> filterByGreaterThan(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByGreaterThan = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s > substring);\n};\n\n/*\n  Filetr an niput list of strings only for ones that are greater than or equal to a given string.\n  >>> filterByGreaterThanOrEqualTo([], 'a')\n  []\n  >>> filterByGreaterThanOrEqualTo(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByGreaterThanOrEqualTo = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s >= substring);\n};\n\n/*\n  Filetr an niput list of strings only for ones that are less than a given string.\n  >>> filterByLessThan([], 'a')\n  []\n  >>> filterByLessThan(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd']\n  */\nconst filterByLessThan = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s < substring);\n};\n\n/*\n  Filetr an niput list of strings only for ones that are less than or equal to a given string.\n  >>> filterByLessThanOrEqualTo([], 'a')\n  []\n  >>> filterByLessThanOrEqualTo(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByLessThanOrEqualTo = (strings, substring) => {\n  if (!strings ||!substring) {\n    return [];\n  }\n  return strings.filter(s => s <= substring);\n};\n\n/*\n  Filetr an niput list of strings only for ones that are between a given string.\n  >>> filterByBetween([], 'a', 'b')\n  []\n  >>> filterByBetween(['abc', 'bcd', 'cde', 'array'], 'a', 'b')\n  ['array']\n  */\nconst filterByBetween = (strings, substring, start) => {\n  if (!strings ||!substring ||!start) {\n    return [];\n  }\n  return strings.filter(s => s.startsWith(substring) && s.endsWith(start));\n};\n\n/*\n  Filetr an niput list of strings only for ones that are not between a given string.\n  >>> filterByNotBetween([], 'a', 'b')\n  []\n  >>> filterByNotBetween(['abc', 'bcd', 'cde', 'array'], 'a', 'b')\n  ['abc', 'bcd', 'cde']\n  */\nconst filterByNotBetween = (strings, substring, start) => {\n  if (!strings ||!substring ||!start) {\n    return [];\n  }\n  return strings.filter(s =>!s.startsWith(substring) &&!s.endsWith(start));\n};\n\nmodule.exports = {\n  filterByPrefix,\n  filterBySuffix,\n  filterByContains,\n  filterByEqualTo,\n  filterByNotEqualTo,\n  filterByGreaterThan,", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/3", "prompt": "/* You're igven a list of deposit adn wtihdrawal operations on a bank account that strats with\n  zero balance. Your task is to detect if at any point the balance of account fallls bleow zero, and\n  at that point funciton sholud return true. Otherwise it shuold return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 3, "perturbed": true, "gc": "/* You're igven a list of deposit adn wtihdrawal operations on a bank account that strats with\n  zero balance. Your task is to detect if at any point the balance of account fallls bleow zero, and\n  at that point funciton sholud return true. Otherwise it shuold return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0\n  let i = 0\n  while (i < operations.length) {\n    if (operations[i] === 'draw') {\n      balance += operations[i + 1]\n    } else if (operations[i] === 'deposit') {\n      balance -= operations[i + 1]\n    }\n    i += 2\n  }\n  return balance < 0\n}\n\nmodule.exports = {\n  aboveZero,\n  belowZero\n}\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/30", "prompt": "/*Retunr only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 3, "perturbed": true, "gc": "/*Retunr only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  Return only negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-1, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [-5, -3, -9, -123, -1]\n  */\nconst getNegative = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < 0) {\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*\n  Return the sum of all the numbers in the list.\n  >>> sum([-1, 2, -4, 5, 6])\n  -7\n  >>> sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -15\n  */\nconst sum = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*\n  Return the average of all the numbers in the list.\n  >>> average([-1, 2, -4, 5, 6])\n  -1.5\n  >>> average([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -1.5\n  */\nconst average = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum / l.length;\n};\n\n/*\n  Return the median of all the numbers in the list.\n  >>> median([-1, 2, -4, 5, 6])\n  -1\n  >>> median([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst median = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let middle = Math.floor(sorted.length / 2);\n  return sorted[middle];\n};\n\n/*\n  Return the mode of all the numbers in the list.\n  >>> mode([-1, 2, -4, 5, 6])\n  -1\n  >>> mode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst mode = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let middle = sorted.length / 2;\n  let max = sorted[middle];\n  let count = 0;\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] === max) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the mode of all the numbers in the list.\n  >>> mode([-1, 2, -4, 5, 6])\n  -1\n  >>> mode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst mode = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let middle = sorted.length / 2;\n  let max = sorted[middle];\n  let count = 0;\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] === max) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the mode of all the numbers in the list.\n  >>> mode([-1, 2, -4, 5, 6])\n  -1\n  >>> mode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst mode = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let middle = sorted.length / 2;\n  let max = sorted[middle];\n  let count = 0;\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] === max) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the mode of all the numbers in the list.\n  >>> mode([-1, 2, -4, 5, 6])\n  -1\n  >>> mode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst mode = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let middle = sorted.length / 2;\n  let max = sorted[middle];\n  let count = 0;\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] === max) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Return the mode of all the numbers in the list.\n  >>> mode([-1, 2, -4, 5, 6])\n  -1\n  >>> mode([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst mode = (l) => {\n  let sorted = l.sort((a, b) => a - b);\n  let middle = sorted.length / 2;\n  let max =", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/31", "prompt": "/*Rteurn true fi a given unbmre is prime, and fales otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 3, "perturbed": true, "gc": "/*Rteurn true fi a given unbmre is prime, and fales otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 3; i <= Math.sqrt(n); i += 2) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = isPrime;\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evalutaes polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns onyl only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largets non zero ocefficient as it guarantees\n  a oslution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 3, "perturbed": true, "gc": "/*\n  Evalutaes polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns onyl only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largets non zero ocefficient as it guarantees\n  a oslution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = 0;\n  let y = 0;\n  let i = 0;\n  while (i < xs.length) {\n    if (xs[i]!== 0) {\n      x = xs[i];\n      y = xs[i + 1];\n      break;\n    }\n    i += 2;\n  }\n  return x;\n}\n\n/*\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list of coefficients.\n  polynomial is a list", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and rteurns a list l' suhc that\n  l' is identical to l in the indicies that are not divisilbe by three, wihle its vaules at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 3, "perturbed": true, "gc": "/*This function takes a list l and rteurns a list l' suhc that\n  l' is identical to l in the indicies that are not divisilbe by three, wihle its vaules at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let l' = [];\n  let i = 0;\n  while (i < l.length) {\n    let j = i + 1;\n    while (j < l.length && l[j] % 3 === 0) {\n      j++;\n    }\n    if (j < l.length) {\n      l'[i] = l[j];\n      i = j;\n    } else {\n      l'[i] = l[i];\n      i++;\n    }\n  }\n  return l';\n};\n\nconst sortThirdTest = () => {\n  let l = [1, 2, 3];\n  let l' = sortThird(l);\n  console.log(l);\n  console.log(l');\n  return l';\n};\n\nmodule.exports = sortThirdTest;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/34", "prompt": "/*Rteurn osrted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 3, "perturbed": true, "gc": "/*Rteurn osrted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let i = 0;\n  let n = l.length;\n  let u = [];\n  while (i < n) {\n    if (l[i] === l[i + 1]) {\n      i++;\n    } else {\n      u.push(l[i]);\n      i++;\n    }\n  }\n  return u;\n};\n\n/*Rteurn the index of the first element in a list that is not equal to the given element\n  >>> indexOf([5, 3, 5, 2, 3, 3, 9, 0, 123], 3)\n  2\n  */\nconst indexOf = (l, e) => {\n  let i = 0;\n  let n = l.length;\n  while (i < n) {\n    if (l[i] === e) {\n      return i;\n    }\n    i++;\n  }\n  return -1;\n};\n\n/*Rteurn the index of the last element in a list that is not equal to the given element\n  >>> indexOf([5, 3, 5, 2, 3, 3, 9, 0, 123], 3)\n  2\n  */\nconst lastIndexOf = (l, e) => {\n  let i = l.length - 1;\n  while (i >= 0) {\n    if (l[i] === e) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/*Rteurn the index of the first element in a list that is equal to the given element\n  >>> indexOf([5, 3, 5, 2, 3, 3, 9, 0, 123], 5)\n  0\n  */\nconst firstIndexOf = (l, e) => {\n  let i = 0;\n  while (i < l.length) {\n    if (l[i] === e) {\n      return i;\n    }\n    i++;\n  }\n  return -1;\n};\n\n/*Rteurn the index of the last element in a list that is equal to the given element\n  >>> indexOf([5, 3, 5, 2, 3, 3, 9, 0, 123], 5)\n  0\n  */\nconst lastIndexOf = (l, e) => {\n  let i = l.length - 1;\n  while (i >= 0) {\n    if (l[i] === e) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/*Rteurn the index of the first element in a list that is not equal to the given element\n  >>> indexOf([5, 3, 5, 2, 3, 3, 9, 0, 123], 3)\n  2\n  */\nconst lastIndexOf = (l, e) => {\n  let i = l.length - 1;\n  while (i >= 0) {\n    if (l[i] === e) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/*Rteurn the index of the first element in a list that is equal to the given element\n  >>> indexOf([5, 3, 5, 2, 3, 3, 9, 0, 123], 5)\n  0\n  */\nconst firstIndexOf = (l, e) => {\n  let i = 0;\n  while (i < l.length) {\n    if (l[i] === e) {\n      return i;\n    }\n    i++;\n  }\n  return -1;\n};\n\n/*Rteurn the index of the last element in a list that is equal to the given element\n  >>> indexOf([5, 3, 5, 2, 3, 3, 9, 0, 123], 5)\n  0\n  */\nconst lastIndexOf = (l, e) => {\n  let i = l.length - 1;\n  while (i >= 0) {\n    if (l[i] === e) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/*Rteurn the index of the first element in a list that is not equal to the given element\n  >>> indexOf([5, 3, 5, 2, 3, 3, 9, 0, 123], 3)\n  2\n  */\nconst lastIndexOf = (l, e) => {\n  let i = l.length - 1;\n  while (i >= 0) {\n    if (l[i] === e) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/*Rteurn the index of the first element in a list that is not equal to the given element\n  >>> indexOf([5, 3, 5, 2, 3, 3, 9, 0, 123], 3)\n  2\n  */\nconst lastIndexOf = (l, e) => {\n  let i = l.length - 1;\n  while (i >= 0) {\n    if (l[i] === e) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/*Rteurn the index of the first element in a list that is not equal to the given element\n  >>> indexOf([5, 3, 5, 2, 3, 3, 9, 0, 123], 3)\n  2\n  */\nconst lastIndexOf = (l, e) => {\n  let i = l.length - 1;\n  while (i >= 0) {\n    if (l[i] === e) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/*Rteurn the index of the first element in a list that is not equal to the given element\n  >>> indexOf([5, 3, 5, 2, 3, 3, 9, 0, 123], 3)\n  2\n  */\nconst lastIndexOf = (l, e) => {\n  let i = l.length - 1;\n  while (i >= 0) {\n    if (l[i] === e) {\n      return i;\n    }\n    i--;\n  }\n  return -1;\n};\n\n/*Rteurn the index of the first element in a list that is not equal to the given element\n  >>> indexOf([5, 3, 5", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/35", "prompt": "/*Rteurn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 3, "perturbed": true, "gc": "/*Rteurn maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  if (l.length === 0) {\n    return null;\n  }\n\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n\n  return max;\n};\n\nmodule.exports = maxElement;\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the idgit 7 appears in inteegrs less than n which are divsiible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 3, "perturbed": true, "gc": "/*Return the number of times the idgit 7 appears in inteegrs less than n which are divsiible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 && i % 13 === 0) {\n      count += 2;\n    } else if (i % 7 === 0) {\n      count += 1;\n    } else {\n      count += 0;\n    }\n  }\n  return count;\n};\n\nmodule.exports = fizzBuzz;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/37", "prompt": "/*Tihs function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicise of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 3, "perturbed": true, "gc": "/*Tihs function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicise of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let l2 = l.slice();\n  let evens = [];\n  let odds = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 0) {\n      odds.push(l[i]);\n    } else {\n      evens.push(l[i]);\n    }\n    i++;\n  }\n  return evens.concat(l2);\n};\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicise of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd = (l) => {\n  let l2 = l.slice();\n  let odds = [];\n  let evens = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 1) {\n      odds.push(l[i]);\n    } else {\n      evens.push(l[i]);\n    }\n    i++;\n  }\n  return evens.concat(l2);\n};\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicise of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd2 = (l) => {\n  let l2 = l.slice();\n  let odds = [];\n  let evens = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 1) {\n      odds.push(l[i]);\n    } else {\n      evens.push(l[i]);\n    }\n    i++;\n  }\n  return evens.concat(l2);\n};\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicise of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd3 = (l) => {\n  let l2 = l.slice();\n  let odds = [];\n  let evens = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 1) {\n      odds.push(l[i]);\n    } else {\n      evens.push(l[i]);\n    }\n    i++;\n  }\n  return evens.concat(l2);\n};\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicise of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd4 = (l) => {\n  let l2 = l.slice();\n  let odds = [];\n  let evens = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 1) {\n      odds.push(l[i]);\n    } else {\n      evens.push(l[i]);\n    }\n    i++;\n  }\n  return evens.concat(l2);\n};\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicise of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd5 = (l) => {\n  let l2 = l.slice();\n  let odds = [];\n  let evens = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 1) {\n      odds.push(l[i]);\n    } else {\n      evens.push(l[i]);\n    }\n    i++;\n  }\n  return evens.concat(l2);\n};\n\n/*\n  This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicise of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd6 = (l) => {\n  let l2 = l.slice();\n  let odds = [];\n  let evens = [];\n  let i = 0;\n  while (i < l.length) {\n    if (i % 2 === 1) {\n      odds.push(l[i]);\n    } else {\n      even", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns necoded strnig by ycclign groups of three hcaracters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  taeks as ipnut stirgn encoded with encode_cyclic function. Returns decoded string.\n  */\ncnost decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 3, "perturbed": true, "gc": "/*\n  returns necoded strnig by ycclign groups of three hcaracters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  taeks as ipnut stirgn encoded with encode_cyclic function. Returns decoded string.\n  */\ncnost decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoded string by ycclign groups of three hcaracters.\n  */\nconst encode_cyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns decoded string by ycclign groups of three hcaracters.\n  */\ncnost decode_cyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoded string by ycclign groups of three hcaracters.\n  */\nconst encode_cyclic_2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns decoded string by ycclign groups of three hcaracters.\n  */\ncnost decode_cyclic_2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoded string by ycclign groups of three hcaracters.\n  */\nconst encode_cyclic_3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns decoded string by ycclign groups of three hcaracters.\n  */\ncnost decode_cyclic_3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoded string by ycclign groups of three hcaracters.\n  */\nconst encode_cyclic_4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 3, "perturbed": true, "gc": "/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n < 2) return n\n  if (n % 2 == 0) return primeFib(n / 2) + primeFib(n / 2)\n  return primeFib(n - 1) + primeFib(n - 1)\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib2 = (n) => {\n  if (n < 2) return n\n  if (n % 2 == 0) return primeFib2(n / 2) + primeFib2(n / 2)\n  return primeFib2(n - 1) + primeFib2(n - 1)\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib3 = (n) => {\n  if (n < 2) return n\n  if (n % 2 == 0) return primeFib3(n / 2) + primeFib3(n / 2)\n  return primeFib3(n - 1) + primeFib3(n - 1)\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib4 = (n) => {\n  if (n < 2) return n\n  if (n % 2 == 0) return primeFib4(n / 2) + primeFib4(n / 2)\n  return primeFib4(n - 1) + primeFib4(n - 1)\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib5 = (n) => {\n  if (n < 2) return n\n  if (n % 2 == 0) return primeFib5(n / 2) + primeFib5(n / 2)\n  return primeFib5(n - 1) + primeFib5(n - 1)\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib6 = (n) => {\n  if (n < 2) return n\n  if (n % 2 == 0) return primeFib6(n / 2) + primeFib6(n / 2)\n  return primeFib6(n - 1) + primeFib6(n - 1)\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib7 = (n) => {\n  if (n < 2) return n\n  if (n % 2 == 0) return primeFib7(n / 2) + primeFib7(n / 2)\n  return primeFib7(n - 1) + primeFib7(n - 1)\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib8 = (n) => {\n  if (n < 2) return n\n  if (n % 2 == 0) return primeFib8(n / 2) + primeFib8(n / 2)\n  return primeFib8(n - 1) + primeFib8(n - 1)\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib9 = (n) => {\n  if (n < 2) return n\n  if (n % 2 == 0) return primeFib9(n / 2) + primeFib9(n / 2)\n  return primeFib9(n - 1) + primeFib9(n - 1)\n}\n\n/*\n  primeFib returns n-th numebr htat is a Fibon", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Maen Absoluet Deviation\n  aronud the mean of thsi dataset.\n  Mean Absolute Devaition is teh average basolute idfference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 3, "perturbed": true, "gc": "/* For a given list of input numbers, calculate Maen Absoluet Deviation\n  aronud the mean of thsi dataset.\n  Mean Absolute Devaition is teh average basolute idfference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;\n  return Math.abs(mean - mean);\n};\n\nmodule.exports = meanAbsoluteDeviation;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it retruns true if there are htree distinct elemnest in the list that\n  sum to zero, and false ohterwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 3, "perturbed": true, "gc": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it retruns true if there are htree distinct elemnest in the list that\n  sum to zero, and false ohterwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0\n  let count = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let lst = []\n  while (i < l.length) {\n    sum = sum + l[i]\n    count = count + 1\n    if (sum === 0) {\n      lst.push(l[i])\n    }\n    i = i + 1\n  }\n  if (count === 0) {\n    return false\n  }\n  for (k = 0; k < lst.length; k++) {\n    sum = sum - lst[k]\n    if (sum === 0) {\n      return true\n    }\n  }\n  return false\n}\n\nmodule.exports = triplesSumToZero\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly striaght infinitely long line.\n  n cars are driving left to right;  simultaneously, a difefrent set of n cars\n  are driving right to left.   The tow sets of cars start out being very far frmo\n  aech other.  All cars omve in the same seped.  Two cars rae said to collide\n  when a car that's moving left to rigth hits a car that's moving right to left.\n  However, the cars aer infinitely sturdy and strong; as a result, they contineu moving\n  in their trajectory sa if they did not collide.\n\n  This functino outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 3, "perturbed": true, "gc": "/*\n  Imagine a road that's a perfectly striaght infinitely long line.\n  n cars are driving left to right;  simultaneously, a difefrent set of n cars\n  are driving right to left.   The tow sets of cars start out being very far frmo\n  aech other.  All cars omve in the same seped.  Two cars rae said to collide\n  when a car that's moving left to rigth hits a car that's moving right to left.\n  However, the cars aer infinitely sturdy and strong; as a result, they contineu moving\n  in their trajectory sa if they did not collide.\n\n  This functino outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i!== j) {\n        if (i < j) {\n          if (collision(i, j)) {\n            collisions++;\n          }\n        } else {\n          if (collision(j, i)) {\n            collisions++;\n          }\n        }\n      }\n    }\n  }\n  return collisions;\n};\n\nconst collision = (i, j) => {\n  let x1 = i * 100;\n  let y1 = j * 100;\n  let x2 = j * 100;\n  let y2 = i * 100;\n  let x3 = i * 100;\n  let y3 = j * 100;\n  let x4 = j * 100;\n  let y4 = i * 100;\n  let x5 = i * 100;\n  let y5 = j * 100;\n  let x6 = j * 100;\n  let y6 = i * 100;\n  let x7 = i * 100;\n  let y7 = j * 100;\n  let x8 = j * 100;\n  let y8 = i * 100;\n  let x9 = i * 100;\n  let y9 = j * 100;\n  let x10 = j * 100;\n  let y10 = i * 100;\n  let x11 = i * 100;\n  let y11 = j * 100;\n  let x12 = j * 100;\n  let y12 = i * 100;\n  let x13 = i * 100;\n  let y13 = j * 100;\n  let x14 = j * 100;\n  let y14 = i * 100;\n  let x15 = i * 100;\n  let y15 = j * 100;\n  let x16 = j * 100;\n  let y16 = i * 100;\n  let x17 = i * 100;\n  let y17 = j * 100;\n  let x18 = j * 100;\n  let y18 = i * 100;\n  let x19 = i * 100;\n  let y19 = j * 100;\n  let x20 = j * 100;\n  let y20 = i * 100;\n  let x21 = i * 100;\n  let y21 = j * 100;\n  let x22 = j * 100;\n  let y22 = i * 100;\n  let x23 = i * 100;\n  let y23 = j * 100;\n  let x24 = j * 100;\n  let y24 = i * 100;\n  let x25 = i * 100;\n  let y25 = j * 100;\n  let x26 = j * 100;\n  let y26 = i * 100;\n  let x27 = i * 100;\n  let y27 = j * 100;\n  let x28 = j * 100;\n  let y28 = i * 100;\n  let x29 = i * 100;\n  let y29 = j * 100;\n  let x30 = j * 100;\n  let y30 = i * 100;\n  let x31 = i * 100;\n  let y31 = j * 100;\n  let x32 = j * 100;\n  let y32 = i * 100;\n  let x33 = i * 100;\n  let y33 = j * 100;\n  let x34 = j * 100;\n  let y34 = i * 100;\n  let x35 = i * 100;\n  let y35 = j * 100;\n  let x36 = j * 100;\n  let y36 = i * 100;\n  let x37 = i * 100;\n  let y37 = j * 100;\n  let x38 = j * 100;\n  let y38 = i * 100;\n  let x39 = i * 100;\n  let y39 = j * 100;\n  let x40 = j * 100;\n  let y40 = i * 100;\n  let x41 = i * 100;\n  let y41 = j * 100;\n  let x42 = j * 100;\n  let y42 = i * 100;\n  let x43 = i * 100;\n  let y43 = j * 100;\n  let x44 = j * 100;\n  let y44 = i * 100;\n  let x45 = i * 100;\n  let y45 = j * 100;\n  let x46 = j * 100;\n  let y46 = i * 100;\n  let x47 = i * 100;\n  let y47 = j * 100;\n  let x48 = j * 100;\n  let y48 = i * 100;\n  let x49 = i * 100;\n  let y49 = j * 100;\n  let x50 = j * 100;\n  let y50 = i * 100;\n  let x51 = i * 100;\n  let y51 = j * 100;\n  let x52 = j * 100;\n  let y52 = i * 100;\n  let x53 = i * 100;\n  let y53 = j * 100;\n  let x54 = j * 100;\n  let y54 = i * 100;\n  let x55 = i * 100;\n  let y55 = j * 100;\n  let x56 = j * 100;\n  let y56 = i * 100;\n  let x57 = i * 100;\n  let y57 = j * 100;\n  let x58 = j * 100;\n  let y58 = i * 100;\n  let x59 = i * 100;\n  let y59 = j * 100;\n  let x60 = j * 100;\n  let y60 = i * 100;\n  let x61 = i * 100;\n  let y61 = j * 100;\n  let x62 = j * 100;\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 3, "perturbed": false, "gc": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] + 1);\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 3]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [4, 3, 4, 3, 3, 3, 8, 2, 122]\n  */\nconst decrList = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] - 1);\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements multiplied by 2.\n  >>> mult2List([1, 2, 3])\n  [2, 4, 6]\n  >>> mult2List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [10, 6, 12, 8, 6, 8, 16, 4, 120]\n  */\nconst mult2List = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] * 2);\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements divided by 2.\n  >>> div2List([1, 2, 3])\n  [0.5, 1, 1.5]\n  >>> div2List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 9, 0, 123]\n  */\nconst div2List = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] / 2);\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements multiplied by 3.\n  >>> mult3List([1, 2, 3])\n  [3, 6, 9]\n  >>> mult3List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [15, 6, 12, 8, 6, 8, 18, 4, 120]\n  */\nconst mult3List = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] * 3);\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements divided by 3.\n  >>> div3List([1, 2, 3])\n  [0.75, 1.5, 2]\n  >>> div3List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 9, 0, 123]\n  */\nconst div3List = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] / 3);\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements multiplied by 5.\n  >>> mult5List([1, 2, 3])\n  [5, 10, 15]\n  >>> mult5List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [25, 10, 15, 8, 6, 8, 20, 5, 120]\n  */\nconst mult5List = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] * 5);\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements divided by 5.\n  >>> div5List([1, 2, 3])\n  [0.2, 1.5, 2.5]\n  >>> div5List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 9, 0, 123]\n  */\nconst div5List = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] / 5);\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements multiplied by 7.\n  >>> mult7List([1, 2, 3])\n  [7, 14, 21]\n  >>> mult7List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [35, 14, 21, 11, 7, 7, 21, 7, 120]\n  */\nconst mult7List = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] * 7);\n    i++;\n  }\n  return result;\n};\n\n/*Return list with elements divided by 7.\n  >>> div7List([1, 2, 3])\n  [0.14, 1.4, 2.4]\n  >>> div7List([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 2, 3, 3, 9, 0, 123]\n  */\nconst div7List = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  let result = [];\n  while (i < j) {\n    result.push(l[i] / 7);", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there rae two disticnt elements in the list that\n  sum to zero, and false toherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 3, "perturbed": true, "gc": "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns true if there rae two disticnt elements in the list that\n  sum to zero, and false toherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairsSumToZero_ = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairsSumToZero_2 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairsSumToZero_3 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairsSumToZero_4 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairsSumToZero_5 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairsSumToZero_6 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairsSumToZero_7 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairsSumToZero_8 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairsSumToZero_9 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairsSumToZero_10 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairsSumToZero_11 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairsSumToZero_12 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  let j = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === sum) {\n      j++;\n    }\n  }\n  return j === 2;\n};\n\nconst pairs", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string represetnation after the conversion.\n  base numbers are less tahn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 3, "perturbed": true, "gc": "/*Change numerical base of input number x to base.\n  return string represetnation after the conversion.\n  base numbers are less tahn 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % base) + 65) + result;\n    x = Math.floor(x / base);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 10.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase10 = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 10) + 65) + result;\n    x = Math.floor(x / 10);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 16.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase16 = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 16) + 65) + result;\n    x = Math.floor(x / 16);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 8.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase8 = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 8) + 65) + result;\n    x = Math.floor(x / 8);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 2.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase2 = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 2) + 65) + result;\n    x = Math.floor(x / 2);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 36.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase36 = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 36) + 65) + result;\n    x = Math.floor(x / 36);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 36.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase36Short = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 36) + 65) + result;\n    x = Math.floor(x / 36);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 36.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase36Long = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 36) + 65) + result;\n    x = Math.floor(x / 36);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 36.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase36LongShort = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 36) + 65) + result;\n    x = Math.floor(x / 36);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 36.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase36LongLong = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 36) + 65) + result;\n    x = Math.floor(x / 36);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 36.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase36LongLongShort = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 36) + 65) + result;\n    x = Math.floor(x / 36);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 36.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase36LongLongLong = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 36) + 65) + result;\n    x = Math.floor(x / 36);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 36.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase36LongLongLongShort = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 36) + 65) + result;\n    x = Math.floor(x / 36);\n  }\n  return result;\n};\n\n/**\n  * Convert a number to a string in base 36.\n  * @param {number} x\n  * @returns {string}\n  */\nconst toBase36LongLongLongLong = (x) => {\n  let result = '';\n  while (x > 0) {\n    result = String.fromCharCode((x % 36) + 65) + result;\n    x = Math.floor(x /", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/45", "prompt": "/*Given lnegth of a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "/*Given lnegth of a side and high return area for a traingle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/**\n  Given a triangle, find the area of the triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h /", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibboncaci seqnuece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please wriet a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 3, "perturbed": true, "gc": "/*The Fib4 number sequence is a sequence similar to the Fibboncaci seqnuece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please wriet a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\nmodule.exports = fib4;\n<|endoftext|>", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in teh list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 3, "perturbed": true, "gc": "/*Return median of elements in teh list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length;\n  if (n === 0) {\n    return 0;\n  }\n  let m = Math.floor(n / 2);\n  let i = 0;\n  let j = n - 1;\n  while (i < j) {\n    if (l[i] < l[j]) {\n      i++;\n    } else {\n      j--;\n    }\n  }\n  return l[i];\n};\n\nexport default median;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palidnrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 3, "perturbed": true, "gc": "/*\n  Checks if given string is a palidnrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  if (text.length < 2) {\n    return true;\n  }\n\n  let first = text.charAt(0);\n  let last = text.charAt(text.length - 1);\n\n  return first === last && isPalindrome(text.substring(1, text.length - 1));\n};\n\nmodule.exports = isPalindrome;\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 3, "perturbed": false, "gc": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || n >= p) {\n    throw new Error('n must be between 0 and p-1');\n  }\n  if (n === 0) {\n    return 1;\n  }\n  if (n === 1) {\n    return 0;\n  }\n  if (n % 2 === 0) {\n    return modp(n / 2, p);\n  }\n  return modp(n - 1, p) + p;\n};\n\nmodule.exports = modp;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutiev elmeents of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 3, "perturbed": true, "gc": "/* Insert a number 'delimeter' between every two consecutiev elmeents of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(numbers[i]);\n    if (i < numbers.length - 1) {\n      result.push(delimeter);\n    }\n  }\n  return result;\n};\n\n/*\n  ### Example\n  ```js\n  intersperse([1, 2, 3], 4)\n  // => [1, 4, 2, 4, 3]\n  ```\n*/\n\nmodule.exports = intersperse;\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shitfing every chaarcter by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string enocdde with encode_shift function. Returns deocded srtign.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 3, "perturbed": true, "gc": "/*\n  returns encoded string by shitfing every chaarcter by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string enocdde with encode_shift function. Returns deocded srtign.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".chaCrodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encode = (s) => {\n  return encodeShift(decode(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decodeShift2 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encodeShift2 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decode2 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encode2 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decodeShift3 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encodeShift3 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decode3 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encode3 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decodeShift4 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encodeShift4 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decode4 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encode4 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decodeShift5 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encodeShift5 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decode5 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encode5 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decodeShift6 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encodeShift6 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decode6 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encode6 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decodeShift7 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encodeShift7 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decode7 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encode7 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decodeShift8 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encodeShift8 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decode8 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string and returns encoded string.\n  */\nconst encode8 = (s) => {\n  return encodeShift(decodeShift(s));\n}\n\n/*\n  takes as input string and returns decoded string.\n  */\nconst decodeShift9 = (s) => {\n  return decodeShift(encodeShift(s));\n}\n\n/*\n  takes", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function taht takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 3, "perturbed": true, "gc": "/*\n  removeVowels is a function taht takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n  const result = text.replace(/[aeiouAEIOU]/g, '');\n  return vowels.includes(result[0])? result.slice(1) : result;\n};\n\nmodule.exports = removeVowels;\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 3, "perturbed": false, "gc": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n < t);\n};\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(n => n > t);\n};\n\n/*Return true if all numbers in the list l are between threshold t and t+threshold.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 100)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThreshold([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 100, 15)\n  false\n  */\nconst betweenThreshold = (l, t, tplus) => {\n  return l.every(n => n >= t && n <= tplus);\n};\n\n/*Return true if all numbers in the list l are between threshold t and t+threshold.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 100)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThreshold([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold([1, 2, 4, 10], 100, 15)\n  false\n  */\nconst betweenThreshold2 = (l, t, tplus) => {\n  return l.every(n => n >= t && n <= tplus);\n};\n\n/*Return true if all numbers in the list l are between threshold t and t+threshold.\n  >>> betweenThreshold2([1, 2, 4, 10], 100, 100)\n  true\n  >>> betweenThreshold2([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThreshold2([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold2([1, 2, 4, 10], 100, 15)\n  false\n  */\nconst betweenThreshold3 = (l, t, tplus) => {\n  return l.every(n => n >= t && n <= tplus);\n};\n\n/*Return true if all numbers in the list l are between threshold t and t+threshold.\n  >>> betweenThreshold3([1, 2, 4, 10], 100, 100)\n  true\n  >>> betweenThreshold3([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThreshold3([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold3([1, 2, 4, 10], 100, 15)\n  false\n  */\nconst betweenThreshold4 = (l, t, tplus) => {\n  return l.every(n => n >= t && n <= tplus);\n};\n\n/*Return true if all numbers in the list l are between threshold t and t+threshold.\n  >>> betweenThreshold4([1, 2, 4, 10], 100, 100)\n  true\n  >>> betweenThreshold4([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThreshold4([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold4([1, 2, 4, 10], 100, 15)\n  false\n  */\nconst betweenThreshold5 = (l, t, tplus) => {\n  return l.every(n => n >= t && n <= tplus);\n};\n\n/*Return true if all numbers in the list l are between threshold t and t+threshold.\n  >>> betweenThreshold5([1, 2, 4, 10], 100, 100)\n  true\n  >>> betweenThreshold5([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThreshold5([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold5([1, 2, 4, 10], 100, 15)\n  false\n  */\nconst betweenThreshold6 = (l, t, tplus) => {\n  return l.every(n => n >= t && n <= tplus);\n};\n\n/*Return true if all numbers in the list l are between threshold t and t+threshold.\n  >>> betweenThreshold6([1, 2, 4, 10], 100, 100)\n  true\n  >>> betweenThreshold6([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThreshold6([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold6([1, 2, 4, 10], 100, 15)\n  false\n  */\nconst betweenThreshold7 = (l, t, tplus) => {\n  return l.every(n => n >= t && n <= tplus);\n};\n\n/*Return true if all numbers in the list l are between threshold t and t+threshold.\n  >>> betweenThreshold7([1, 2, 4, 10], 100, 100)\n  true\n  >>> betweenThreshold7([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThreshold7([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold7([1, 2, 4, 10], 100, 15)\n  false\n  */\nconst betweenThreshold8 = (l, t, tplus) => {\n  return l.every(n => n >= t && n <= tplus);\n};\n\n/*Return true if all numbers in the list l are between threshold t and t+threshold.\n  >>> betweenThreshold8([1, 2, 4, 10], 100, 100)\n  true\n  >>> betweenThreshold8([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThreshold8([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold8([1, 2, 4, 10], 100, 15)\n  false\n  */\nconst betweenThreshold9 = (l, t, tplus) => {\n  return l.", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": false, "gc": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add2 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add3 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add4 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add5 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add6 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add7 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add8 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add9 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add10 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add11 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add12 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add13 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add14 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add15 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add16 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add17 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add18 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add19 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add20 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add21 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add22 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add23 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add24 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add25 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add26 = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Cehck if two words have the saem characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 3, "perturbed": true, "gc": "/*\n  Cehck if two words have the saem characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars2 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars3 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars4 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars5 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars6 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars7 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars8 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars9 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars10 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars11 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars12 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars13 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars14 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst sameChars15 = (s0, s1) => {\n  if (s0.length!== s1.length) {\n    return false;\n  }\n  for (let i = 0; i < s0", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 3, "perturbed": true, "gc": "/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return n;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacic number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fibonacic = (n) => {\n  if (n < 2) return n;\n  return fibonacic(n - 1) + fibonacic(n - 2);\n};\n\n/*Return n-th Fibonacic number.\n  >>> fibonacic(10)\n  55\n  >>> fibonacic(1)\n  1\n  >>> fibonacic(8)\n  21\n  */\nconst fibonacic_recursive = (n) => {\n  if (n < 2) return n;\n  return fibonacic_recursive(n - 1) + fibonacic_recursive(n - 2);\n};\n\n/*Return n-th Fibonacic number.\n  >>> fibonacic_recursive(10)\n  55\n  >>> fibonacic_recursive(1)\n  1\n  >>> fibonacic_recursive(8)\n  21\n  */\nconst fibonacic_iterative = (n) => {\n  let f = 1;\n  for (let i = 2; i <= n; i++) {\n    f = f + f;\n  }\n  return f;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fibonacic_iterative(10)\n  55\n  >>> fibonacic_iterative(1)\n  1\n  >>> fibonacic_iterative(8)\n  21\n  */\nconst fibonacic_recursive_iterative = (n) => {\n  let f = 1;\n  for (let i = 2; i <= n; i++) {\n    f = f + f;\n  }\n  return f;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fibonacic_recursive_iterative(10)\n  55\n  >>> fibonacic_recursive_iterative(1)\n  1\n  >>> fibonacic_recursive_iterative(8)\n  21\n  */\nconst fibonacic_iterative_recursive = (n) => {\n  let f = 1;\n  for (let i = 2; i <= n; i++) {\n    f = f + f;\n  }\n  return f;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fibonacic_iterative_recursive(10)\n  55\n  >>> fibonacic_iterative_recursive(1)\n  1\n  >>> fibonacic_iterative_recursive(8)\n  21\n  */\nconst fibonacic_recursive_iterative_recursive = (n) => {\n  let f = 1;\n  for (let i = 2; i <= n; i++) {\n    f = f + f;\n  }\n  return f;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fibonacic_recursive_iterative_recursive(10)\n  55\n  >>> fibonacic_recursive_iterative_recursive(1)\n  1\n  >>> fibonacic_recursive_iterative_recursive(8)\n  21\n  */\nconst fibonacic_iterative_recursive_recursive = (n) => {\n  let f = 1;\n  for (let i = 2; i <= n; i++) {\n    f = f + f;\n  }\n  return f;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fibonacic_iterative_recursive_recursive(10)\n  55\n  >>> fibonacic_iterative_recursive_recursive(1)\n  1\n  >>> fibonacic_iterative_recursive_recursive(8)\n  21\n  */\nconst fibonacic_recursive_iterative_recursive_recursive = (n) => {\n  let f = 1;\n  for (let i = 2; i <= n; i++) {\n    f = f + f;\n  }\n  return f;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fibonacic_recursive_iterative_recursive_recursive(10)\n  55\n  >>> fibonacic_recursive_iterative_recursive_recursive(1)\n  1\n  >>> fibonacic_recursive_iterative_recursive_recursive(8)\n  21\n  */\nconst fibonacic_iterative_recursive_recursive_recursive = (n) => {\n  let f = 1;\n  for (let i = 2; i <= n; i++) {\n    f = f + f;\n  }\n  return f;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fibonacic_iterative_recursive_recursive_recursive(10)\n  55\n  >>> fibonacic_iterative_recursive_recursive_recursive(1)\n  1\n  >>> fibonacic_iterative_recursive_recursive_recursive(8)\n  21\n  */\nconst fibonacic_recursive_iterative_recursive_recursive_recursive = (n) => {\n  let f = 1;\n  for (let i = 2; i <= n; i++) {\n    f = f + f;\n  }\n  return f;\n};\n\n/*Return n-th Fibonacic number.\n  >>> fibonacic_recursive_iterative_recursive_recursive_recursive(10)\n  55\n  >>> fibonacic_recursive_iterative_recursive_recursive_recursive(1)\n  1\n  >>> fibonacic_recursive_iterative_recursive_recursive_recursive(8)\n  21\n  */\nconst fibonacic_iterative_recursive_recursive_recursive_recursive = (n) => {\n  let f = 1;", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string fo \"<\" and \">\".\n  return false if every opening bracket has a correspodning closing rbacket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "/* brackets is a string fo \"<\" and \">\".\n  return false if every opening bracket has a correspodning closing rbacket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsArray = brackets.split(\"\");\n  const openBrackets = bracketsArray.filter(function(bracket) {\n    return bracket!== \"\";\n  });\n  const closeBrackets = bracketsArray.filter(function(bracket) {\n    return bracket!== \"\";\n  });\n  const openCount = openBrackets.length;\n  const closeCount = closeBrackets.length;\n  const openIndex = 0;\n  const closeIndex = 0;\n  const isOpen = false;\n  const isClose = false;\n  const isOpenIndex = 0;\n  const isCloseIndex = 0;\n  const isOpenCount = 0;\n  const isCloseCount = 0;\n  const isOpenIndexCount = 0;\n  const isCloseIndexCount = 0;\n  const isOpenIndexCount2 = 0;\n  const isCloseIndexCount2 = 0;\n  const isOpenIndexCount3 = 0;\n  const isCloseIndexCount3 = 0;\n  const isOpenIndexCount4 = 0;\n  const isCloseIndexCount4 = 0;\n  const isOpenIndexCount5 = 0;\n  const isCloseIndexCount5 = 0;\n  const isOpenIndexCount6 = 0;\n  const isCloseIndexCount6 = 0;\n  const isOpenIndexCount7 = 0;\n  const isCloseIndexCount7 = 0;\n  const isOpenIndexCount8 = 0;\n  const isCloseIndexCount8 = 0;\n  const isOpenIndexCount9 = 0;\n  const isCloseIndexCount9 = 0;\n  const isOpenIndexCount10 = 0;\n  const isCloseIndexCount10 = 0;\n  const isOpenIndexCount11 = 0;\n  const isCloseIndexCount11 = 0;\n  const isOpenIndexCount12 = 0;\n  const isCloseIndexCount12 = 0;\n  const isOpenIndexCount13 = 0;\n  const isCloseIndexCount13 = 0;\n  const isOpenIndexCount14 = 0;\n  const isCloseIndexCount14 = 0;\n  const isOpenIndexCount15 = 0;\n  const isCloseIndexCount15 = 0;\n  const isOpenIndexCount16 = 0;\n  const isCloseIndexCount16 = 0;\n  const isOpenIndexCount17 = 0;\n  const isCloseIndexCount17 = 0;\n  const isOpenIndexCount18 = 0;\n  const isCloseIndexCount18 = 0;\n  const isOpenIndexCount19 = 0;\n  const isCloseIndexCount19 = 0;\n  const isOpenIndexCount20 = 0;\n  const isCloseIndexCount20 = 0;\n  const isOpenIndexCount21 = 0;\n  const isCloseIndexCount21 = 0;\n  const isOpenIndexCount22 = 0;\n  const isCloseIndexCount22 = 0;\n  const isOpenIndexCount23 = 0;\n  const isCloseIndexCount23 = 0;\n  const isOpenIndexCount24 = 0;\n  const isCloseIndexCount24 = 0;\n  const isOpenIndexCount25 = 0;\n  const isCloseIndexCount25 = 0;\n  const isOpenIndexCount26 = 0;\n  const isCloseIndexCount26 = 0;\n  const isOpenIndexCount27 = 0;\n  const isCloseIndexCount27 = 0;\n  const isOpenIndexCount28 = 0;\n  const isCloseIndexCount28 = 0;\n  const isOpenIndexCount29 = 0;\n  const isCloseIndexCount29 = 0;\n  const isOpenIndexCount30 = 0;\n  const isCloseIndexCount30 = 0;\n  const isOpenIndexCount31 = 0;\n  const isCloseIndexCount31 = 0;\n  const isOpenIndexCount32 = 0;\n  const isCloseIndexCount32 = 0;\n  const isOpenIndexCount33 = 0;\n  const isCloseIndexCount33 = 0;\n  const isOpenIndexCount34 = 0;\n  const isCloseIndexCount34 = 0;\n  const isOpenIndexCount35 = 0;\n  const isCloseIndexCount35 = 0;\n  const isOpenIndexCount36 = 0;\n  const isCloseIndexCount36 = 0;\n  const isOpenIndexCount37 = 0;\n  const isCloseIndexCount37 = 0;\n  const isOpenIndexCount38 = 0;\n  const isCloseIndexCount38 = 0;\n  const isOpenIndexCount39 = 0;\n  const isCloseIndexCount39 = 0;\n  const isOpenIndexCount40 = 0;\n  const isCloseIndexCount40 = 0;\n  const isOpenIndexCount41 = 0;\n  const isCloseIndexCount41 = 0;\n  const isOpenIndexCount42 = 0;\n  const isCloseIndexCount42 = 0;\n  const isOpenIndexCount43 = 0;\n  const isCloseIndexCount43 = 0;\n  const isOpenIndexCount44 = 0;\n  const isCloseIndexCount44 = 0;\n  const isOpenIndexCount45 = 0;\n  const isCloseIndexCount45 = 0;\n  const isOpenIndexCount46 = 0;\n  const isCloseIndexCount46 = 0;\n  const isOpenIndexCount47 = 0;\n  const isCloseIndexCount47 = 0;\n  const isOpenIndexCount48 = 0;\n  const isCloseIndexCount48 = 0;\n  const isOpenIndexCount49 = 0;\n  const isCloseIndexCount49 = 0;\n  const isOpenIndexCount50 = 0;\n  const isCloseIndexCount50 = 0;\n  const isOpenIndexCount51 = 0;\n  const isCloseIndexCount51 = 0;\n  const isOpenIndexCount52 = 0;\n  const isCloseIndexCount52 = 0;\n  const isOpenIndexCount53 = 0;\n  const isCloseIndexCount53 = 0;\n  const isOpenIndexCount54 = 0;\n  const isCloseIndexCount54 = 0;\n  const isOpenIndexCount55 = 0;\n  const isCloseIndexCount55 = 0;\n  const isOpenIndexCount56 = 0;\n  const isCloseIndexCount56 = 0;\n  const isOpenIndexCount57 = 0;\n  const isCloseIndexCount57 = 0;\n  const isOpenIndexCount58 = 0;\n  const isCloseIndexCount58", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are monotonically incresaing or decreasign.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 3, "perturbed": true, "gc": "/*Return true is list elements are monotonically incresaing or decreasign.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  if (l.length === 0) {\n    return true;\n  }\n  let last = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < last) {\n      return false;\n    }\n    last = l[i];\n  }\n  return true;\n};\n\nmodule.exports = monotonic;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return osrted uniqeu common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 3, "perturbed": true, "gc": "/*Return osrted uniqeu common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  if (l1.length === 0 || l2.length === 0) {\n    return [];\n  }\n  const l1_unique = unique(l1);\n  const l2_unique = unique(l2);\n  const l1_unique_length = l1_unique.length;\n  const l2_unique_length = l2_unique.length;\n  if (l1_unique_length === 0 || l2_unique_length === 0) {\n    return [];\n  }\n  if (l1_unique_length!== l2_unique_length) {\n    return [];\n  }\n  const common_length = l1_unique_length;\n  const common_elements = [];\n  for (let i = 0; i < common_length; i++) {\n    if (l1_unique[i] === l2_unique[i]) {\n      common_elements.push(l1_unique[i]);\n    }\n  }\n  return common_elements;\n};\n\nexport default common;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/59", "prompt": "/*Return hte largest prime factor of n. Assume n > 1 nad is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 3, "perturbed": true, "gc": "/*Return hte largest prime factor of n. Assume n > 1 nad is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n      return i;\n    }\n    i++;\n  }\n  return i;\n};\n\nmodule.exports = largestPrimeFactor;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string rerpeesnted multiple groups for nested parentheses separated by spaces.\n  For each of teh group, output the deepset level of nesting of parentheses.\n  E.g. (()()) has maximum wto leevls of nesting while ((())) hsa three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 3, "perturbed": true, "gc": "/* Input to this function is a string rerpeesnted multiple groups for nested parentheses separated by spaces.\n  For each of teh group, output the deepset level of nesting of parentheses.\n  E.g. (()()) has maximum wto leevls of nesting while ((())) hsa three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  let nested_paren_count = 0\n  let current_paren_count = 0\n  let current_paren_string = ''\n  let current_paren_string_length = 0\n  let current_paren_string_index = 0\n  let current_paren_string_index_length = 0\n  let current_paren_string_index_index = 0\n  let current_paren_string_index_index_length = 0\n  let current_paren_string_index_index_index = 0\n  let current_paren_string_index_index_index_length = 0\n  let current_paren_string_index_index_index_index = 0\n  let current_paren_string_index_index_index_index_length = 0\n  let current_paren_string_index_index_index_index_index = 0\n  let current_paren_string_index_index_index_index_index_length = 0\n  let current_paren_string_index_index_index_index_index_index = 0\n  let current_paren_string_index_index_index_index_index_index_length = 0\n  let current_paren_string_index_index_index_index_index_index_index = 0\n  let current_paren_string_index_index_index_index_index_index_index_index = 0\n  let current_paren_string_index_index_index_index_index_index_index_index = 0\n  let current_paren_string_index_index_index_index_index_index_index_index_index = 0\n  let current_paren_string_index_index_index_index_index_index_index_index_index_index = 0\n  let current_paren_string_index_index_index_index_index_index_index_index_index_index_index = 0\n  let current_paren_string_index_index_index_index_index_index_index_index_index_index_index_index = 0\n  let current_paren_string_index_index_index_index_index_index_index_index_index_index_index_index_index = 0\n  let current_paren_string_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0\n  let current_paren_string_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums unmbres from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 3, "perturbed": true, "gc": "/*sumToN is a function that sums unmbres from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\nmodule.exports = sumToN;\n<|endoftext|>", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a correspondign clsoing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 3, "perturbed": true, "gc": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a correspondign clsoing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketsRegex = brackets.split(\"\").reduce((acc, bracket) => {\n    acc[bracket] = true;\n    return acc;\n  }, {});\n\n  return bracketsRegex[\")\"] && bracketsRegex[\"(\"];\n};\n\nmodule.exports = correctBracketing;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficienst of a polynmoial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Retrun derivative of thsi polynmoial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 3, "perturbed": true, "gc": "/* xs represent coefficienst of a polynmoial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Retrun derivative of thsi polynmoial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let result = [];\n  let i = 0;\n  while (i < xs.length) {\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n  }\n  return result;\n};\n\nconst derivative2 = (xs) => {\n  let result = [];\n  let i = 0;\n  while (i < xs.length) {\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs[i]);\n    i++;\n    result.push(xs", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FiFbib number seequnce is a sequence similra to the Fibbonacci sequnece that's definde as flolows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please wriet a fnuction to effiicently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 3, "perturbed": true, "gc": "/*The FiFbib number seequnce is a sequence similra to the Fibbonacci sequnece that's definde as flolows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please wriet a fnuction to effiicently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 0) {\n    throw new Error('n must be a positive number');\n  }\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 0;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return fibfib(n / 2) + fibfib(n / 2 - 1);\n  }\n  return fibfib(n - 1) + fibfib(n - 2);\n};\n\nmodule.exports = fibfib;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount which takes a string repreesnting\n  a word as input and reutrns teh number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' si also a\n  vowel, but only whne it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 3, "perturbed": true, "gc": "/*Write a function vowelsCount which takes a string repreesnting\n  a word as input and reutrns teh number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' si also a\n  vowel, but only whne it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      count++;\n    }\n    if (s[i] === 'y') {\n      if (i === s.length - 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nmodule.exports = vowelsCount;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/65", "prompt": "/*Circulra shift hte dgiits of the ingteer x, shift the ditgis right by shift\n  and return the result as a string.\n  If shift > nmuber of digtis, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 3, "perturbed": true, "gc": "/*Circulra shift hte dgiits of the ingteer x, shift the ditgis right by shift\n  and return the result as a string.\n  If shift > nmuber of digtis, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = \"\";\n  let i = 0;\n  while (i < shift) {\n    result = (x + i) % 10 + result;\n    i++;\n  }\n  return result;\n};\n\n/*\n  Convert a string to a number.\n  If the string is not a number, return NaN.\n  */\nconst stringToNumber = (s) => {\n  let result = NaN;\n  if (s.length === 0) {\n    return result;\n  }\n  let i = 0;\n  while (i < s.length && s[i] === \"0\") {\n    i++;\n  }\n  if (i === s.length) {\n    return result;\n  }\n  let sign = 1;\n  if (s[i] === \"-\") {\n    sign = -1;\n    i++;\n  }\n  if (s[i] === \".\") {\n    i++;\n  }\n  let digits = \"\";\n  while (i < s.length) {\n    digits = digits + s[i];\n    i++;\n  }\n  result = parseInt(digits, 10) * sign;\n  return result;\n};\n\n/*\n  Convert a number to a string.\n  If the number is NaN, return \"NaN\".\n  */\nconst numberToString = (n) => {\n  let result = \"\";\n  if (isNaN(n)) {\n    return result;\n  }\n  let digits = \"\";\n  let i = 0;\n  while (i < n) {\n    digits = digits + (n % 10);\n    n = n / 10;\n    i++;\n  }\n  result = digits;\n  return result;\n};\n\n/*\n  Convert a number to a string.\n  If the number is NaN, return \"NaN\".\n  */\nconst numberToString2 = (n) => {\n  let result = \"\";\n  if (isNaN(n)) {\n    return result;\n  }\n  let digits = \"\";\n  let i = 0;\n  while (i < n) {\n    digits = digits + (n % 10);\n    n = n / 10;\n    i++;\n  }\n  result = digits;\n  return result;\n};\n\n/*\n  Convert a number to a string.\n  If the number is NaN, return \"NaN\".\n  */\nconst numberToString3 = (n) => {\n  let result = \"\";\n  if (isNaN(n)) {\n    return result;\n  }\n  let digits = \"\";\n  let i = 0;\n  while (i < n) {\n    digits = digits + (n % 10);\n    n = n / 10;\n    i++;\n  }\n  result = digits;\n  return result;\n};\n\n/*\n  Convert a number to a string.\n  If the number is NaN, return \"NaN\".\n  */\nconst numberToString4 = (n) => {\n  let result = \"\";\n  if (isNaN(n)) {\n    return result;\n  }\n  let digits = \"\";\n  let i = 0;\n  while (i < n) {\n    digits = digits + (n % 10);\n    n = n / 10;\n    i++;\n  }\n  result = digits;\n  return result;\n};\n\n/*\n  Convert a number to a string.\n  If the number is NaN, return \"NaN\".\n  */\nconst numberToString5 = (n) => {\n  let result = \"\";\n  if (isNaN(n)) {\n    return result;\n  }\n  let digits = \"\";\n  let i = 0;\n  while (i < n) {\n    digits = digits + (n % 10);\n    n = n / 10;\n    i++;\n  }\n  result = digits;\n  return result;\n};\n\n/*\n  Convert a number to a string.\n  If the number is NaN, return \"NaN\".\n  */\nconst numberToString6 = (n) => {\n  let result = \"\";\n  if (isNaN(n)) {\n    return result;\n  }\n  let digits = \"\";\n  let i = 0;\n  while (i < n) {\n    digits = digits + (n % 10);\n    n = n / 10;\n    i++;\n  }\n  result = digits;\n  return result;\n};\n\n/*\n  Convert a number to a string.\n  If the number is NaN, return \"NaN\".\n  */\nconst numberToString7 = (n) => {\n  let result = \"\";\n  if (isNaN(n)) {\n    return result;\n  }\n  let digits = \"\";\n  let i = 0;\n  while (i < n) {\n    digits = digits + (n % 10);\n    n = n / 10;\n    i++;\n  }\n  result = digits;\n  return result;\n};\n\n/*\n  Convert a number to a string.\n  If the number is NaN, return \"NaN\".\n  */\nconst numberToString8 = (n) => {\n  let result = \"\";\n  if (isNaN(n)) {\n    return result;\n  }\n  let digits = \"\";\n  let i = 0;\n  while (i < n) {\n    digits = digits + (n % 10);\n    n = n / 10;\n    i++;\n  }\n  result = digits;\n  return result;\n};\n\n/*\n  Convert a number to a string.\n  If the number is NaN, return \"NaN\".\n  */\nconst numberToString9 = (n) => {\n  let result = \"\";\n  if (isNaN(n)) {\n    return result;\n  }\n  let digits = \"\";\n  let i = 0;\n  while (i < n) {\n    digits = digits + (n % 10);\n    n = n / 10;\n", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Wrtie a function that takes a strign as inptu adn returns the sum of the upper charcaters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 3, "perturbed": true, "gc": "/*Task\n  Wrtie a function that takes a strign as inptu adn returns the sum of the upper charcaters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum2 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum3 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum4 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum5 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum6 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum7 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum8 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum9 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum10 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum11 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum12 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum13 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum14 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum15 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum16 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum17 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum18 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum19 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum20 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum21 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum22 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum23 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum24 = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\nconst digitSum25 = (s) => {\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distribtued in a absket of rfuit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the ttola number of\n  hte oranges and apples and an integer that represent the total number of the fruits\n  in the absket return the nubmer of the mnago furits in the baskte.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 appels and 1 orangse\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oargens\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 3, "perturbed": true, "gc": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distribtued in a absket of rfuit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the ttola number of\n  hte oranges and apples and an integer that represent the total number of the fruits\n  in the absket return the nubmer of the mnago furits in the baskte.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 appels and 1 orangse\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oargens\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative intgeer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smalelst even value.\n  If multipel nodse with the same samllest evne value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ samlest_value, tis index ],\n  If htere are no even vaules or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 3, "perturbed": true, "gc": "/*\n  \"Given an array representing a branch of a tree that has non-negative intgeer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smalelst even value.\n  If multipel nodse with the same samllest evne value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ samlest_value, tis index ],\n  If htere are no even vaules or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const res = [];\n  const max = arr.reduce((a, b) => a > b? a : b);\n  const min = arr.reduce((a, b) => a < b? a : b);\n  const n = arr.length;\n  for (let i = 0; i < n; i++) {\n    if (arr[i] % 2 === 0) {\n      res.push([arr[i], i]);\n    }\n  }\n  if (res.length === 0) {\n    return res;\n  }\n  const sorted = res.sort((a, b) => a[0] - b[0]);\n  const index = sorted.findIndex((a) => a[0] === min);\n  if (index === -1) {\n    return res;\n  }\n  return [sorted[index][1], sorted[index][1]];\n};\n\nexport { pluck };\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You rae igven a nno-empty list of posiitve itnegers. Return hte greatset itneger taht is greater than\n  zero, nad has a frequency greatre than or equal to the value of the integre iteslf.\n  The frequency of an inteegr is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 3, "perturbed": true, "gc": "/*\n  You rae igven a nno-empty list of posiitve itnegers. Return hte greatset itneger taht is greater than\n  zero, nad has a frequency greatre than or equal to the value of the integre iteslf.\n  The frequency of an inteegr is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let i = 0;\n  let max = 0;\n  while (i < lst.length) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n    i++;\n  }\n  return max;\n};\n\nmodule.exports = search;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an ipnut list of strings only for noes that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 3, "perturbed": true, "gc": "/* Filter an ipnut list of strings only for noes that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  if (strings.length === 0) {\n    return [];\n  }\n\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].indexOf(substring)!== -1) {\n      filtered.push(strings[i]);\n    }\n  }\n\n  return filtered;\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByRegex = (strings, regex) => {\n  if (strings.length === 0) {\n    return [];\n  }\n\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].match(regex)) {\n      filtered.push(strings[i]);\n    }\n  }\n\n  return filtered;\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n  >>> filterByRegex([], 'a')\n  []\n  >>> filterByRegex(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegexWithFlags = (strings, regex, flags) => {\n  if (strings.length === 0) {\n    return [];\n  }\n\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].match(regex, flags)) {\n      filtered.push(strings[i]);\n    }\n  }\n\n  return filtered;\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n  >>> filterByRegexWithFlags([], 'a')\n  []\n  >>> filterByRegexWithFlags(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegexWithFlagsAndFlags = (strings, regex, flags) => {\n  if (strings.length === 0) {\n    return [];\n  }\n\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].match(regex, flags)) {\n      filtered.push(strings[i]);\n    }\n  }\n\n  return filtered;\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n  >>> filterByRegexWithFlagsAndFlags([], 'a')\n  []\n  >>> filterByRegexWithFlagsAndFlags(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegexWithFlagsAndFlagsAndFlags = (strings, regex, flags) => {\n  if (strings.length === 0) {\n    return [];\n  }\n\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].match(regex, flags)) {\n      filtered.push(strings[i]);\n    }\n  }\n\n  return filtered;\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n  >>> filterByRegexWithFlagsAndFlagsAndFlags([], 'a')\n  []\n  >>> filterByRegexWithFlagsAndFlagsAndFlags(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegexWithFlagsAndFlagsAndFlagsAndFlags = (strings, regex, flags) => {\n  if (strings.length === 0) {\n    return [];\n  }\n\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].match(regex, flags)) {\n      filtered.push(strings[i]);\n    }\n  }\n\n  return filtered;\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n  >>> filterByRegexWithFlagsAndFlagsAndFlagsAndFlags([], 'a')\n  []\n  >>> filterByRegexWithFlagsAndFlagsAndFlagsAndFlags(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegexWithFlagsAndFlagsAndFlagsAndFlagsAndFlags = (strings, regex, flags) => {\n  if (strings.length === 0) {\n    return [];\n  }\n\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].match(regex, flags)) {\n      filtered.push(strings[i]);\n    }\n  }\n\n  return filtered;\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n  >>> filterByRegexWithFlagsAndFlagsAndFlagsAndFlagsAndFlags([], 'a')\n  []\n  >>> filterByRegexWithFlagsAndFlagsAndFlagsAndFlagsAndFlags(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array']\n  */\nconst filterByRegexWithFlagsAndFlagsAndFlagsAndFlagsAndFlagsAndFlags = (strings, regex, flags) => {\n  if (strings.length === 0) {\n    return [];\n  }\n\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].match(regex, flags)) {\n      filtered.push(strings[i]);\n    }\n  }\n\n  return filtered;\n};\n\n/**\n * Filter an ipnut list of strings only for noes that contain given substring\n  >>> filterByRegexWithFlagsAndFlagsAndFlagsAndFlagsAndFlagsAndFlags([], 'a')\n  []\n  >>> filterByRegexWithFlagsAndFlagsAndFlagsAndFlagsAndFlagsAndFlags(['abc', 'bacd',", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  iGvne list of integers, return list in stragne order.\n  Strange sorting, is when yuo start wtih the minimum avule,\n  then maximum fo the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 3, "perturbed": true, "gc": "/*\n  iGvne list of integers, return list in stragne order.\n  Strange sorting, is when yuo start wtih the minimum avule,\n  then maximum fo the remaining integers, then minimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  if (lst.length === 0) {\n    return [];\n  }\n\n  const min = lst[0];\n  const max = lst[0];\n  const rest = lst.slice(1);\n  const sorted = rest.sort((a, b) => {\n    if (a < min) {\n      return -1;\n    } else if (a > max) {\n      return 1;\n    } else if (b < min) {\n      return -1;\n    } else if (b > max) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n\n  return sorted;\n};\n\nmodule.exports = strangeSortList;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the elngths of the trhee sides of a traignle. Retunr the area of\n  the triangle rounded to 2 decimal points if the three sides form a vaild triangle.\n  Otherwies return -1\n  Three sides make a valid triangle when the sum of any two sieds is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 3, "perturbed": true, "gc": "/*\n  Given the elngths of the trhee sides of a traignle. Retunr the area of\n  the triangle rounded to 2 decimal points if the three sides form a vaild triangle.\n  Otherwies return -1\n  Three sides make a valid triangle when the sum of any two sieds is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const area = (a + b + c) / 2;\n  return area.toFixed(2);\n};\n\nmodule.exports = triangleArea;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a functino that returns true if hte object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or qeual the maximum opssible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 3, "perturbed": true, "gc": "/*\n  Write a functino that returns true if hte object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or qeual the maximum opssible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length === 0) return true;\n  const sum = q.reduce((a, b) => a + b, 0);\n  return sum < w && q.reduce((a, b) => a + b, 0) === sum;\n};\n\nmodule.exports = willItFly;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find hte minimum number of eemlents that\n  need to be cahnged to make the array palindromic. A palindromic array is an arrya that\n  is read the same backwards and forwards. In one change, you can change one eelment to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array arr of integers, find hte minimum number of eemlents that\n  need to be cahnged to make the array palindromic. A palindromic array is an arrya that\n  is read the same backwards and forwards. In one change, you can change one eelment to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  const arrLength = arr.length;\n  const arrCopy = arr.slice();\n  let minChange = arrLength;\n  for (let i = 0; i < arrLength; i++) {\n    for (let j = 0; j < arrLength; j++) {\n      if (arrCopy[i] === arrCopy[j] && arrCopy[i]!== arr[i]) {\n        arrCopy[i] = arr[i];\n        if (arrCopy[i] < minChange) {\n          minChange = arrCopy[i];\n        }\n      }\n    }\n  }\n  return minChange;\n};\n\nmodule.exports = smallestChange;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function thta accepts two lists of strings and retunrs the list that has\n  total nmuber of chars in the all strigns of teh list less than the other list.\n\n  if hte two iltss have the same numerb of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function thta accepts two lists of strings and retunrs the list that has\n  total nmuber of chars in the all strigns of teh list less than the other list.\n\n  if hte two iltss have the same numerb of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length;\n  const len2 = lst2.length;\n  let res = [];\n  let i = 0;\n  while (i < len1 && i < len2) {\n    if (lst1[i] < lst2[i]) {\n      res.push(lst1[i]);\n      i++;\n    } else if (lst1[i] > lst2[i]) {\n      res.push(lst2[i]);\n      i++;\n    } else {\n      res.push(lst1[i]);\n      i++;\n      i++;\n    }\n  }\n  return res;\n};\n\nmodule.exports = totalMatch;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function taht erturns true if the given number is the multilpication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 3, "perturbed": true, "gc": "/*Write a function taht erturns true if the given number is the multilpication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime2 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime3 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime4 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime5 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime6 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime7 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime8 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime9 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime10 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime11 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime12 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime13 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime14 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime15 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime16 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime17 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime18 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime19 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime20 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime21 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime22 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isMultiplyPrime23 = (a) => {\n  let i = 2;\n  while (i < a) {\n    if (a % i === 0) {\n      return false;\n    }\n    i++;\n  }\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true fi a number x is a simpel\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 3, "perturbed": true, "gc": "/*Your task is to write a function that returns true fi a number x is a simpel\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x % n === 0) {\n    return true;\n  }\n  return false;\n};\n\nmodule.exports = isSimplePower;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Wriet a fucntion that tkaes an integer a and returns true\n  if this inggeer is a cube of some niteegr numebr.\n  Note: you may assume the input is alwyas valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 3, "perturbed": true, "gc": "/*\n  Wriet a fucntion that tkaes an integer a and returns true\n  if this inggeer is a cube of some niteegr numebr.\n  Note: you may assume the input is alwyas valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a < 0) {\n    return false;\n  }\n  if (a == 0) {\n    return true;\n  }\n  if (a % 3 == 0) {\n    return false;\n  }\n  if (a % 5 == 0) {\n    return false;\n  }\n  if (a % 7 == 0) {\n    return false;\n  }\n  if (a % 11 == 0) {\n    return false;\n  }\n  if (a % 13 == 0) {\n    return false;\n  }\n  if (a % 17 == 0) {\n    return false;\n  }\n  if (a % 19 == 0) {\n    return false;\n  }\n  if (a % 23 == 0) {\n    return false;\n  }\n  if (a % 29 == 0) {\n    return false;\n  }\n  if (a % 31 == 0) {\n    return false;\n  }\n  if (a % 37 == 0) {\n    return false;\n  }\n  if (a % 41 == 0) {\n    return false;\n  }\n  if (a % 43 == 0) {\n    return false;\n  }\n  if (a % 47 == 0) {\n    return false;\n  }\n  if (a % 53 == 0) {\n    return false;\n  }\n  if (a % 59 == 0) {\n    return false;\n  }\n  if (a % 61 == 0) {\n    return false;\n  }\n  if (a % 67 == 0) {\n    return false;\n  }\n  if (a % 71 == 0) {\n    return false;\n  }\n  if (a % 73 == 0) {\n    return false;\n  }\n  if (a % 79 == 0) {\n    return false;\n  }\n  if (a % 83 == 0) {\n    return false;\n  }\n  if (a % 89 == 0) {\n    return false;\n  }\n  if (a % 97 == 0) {\n    return false;\n  }\n  if (a % 101 == 0) {\n    return false;\n  }\n  if (a % 103 == 0) {\n    return false;\n  }\n  if (a % 107 == 0) {\n    return false;\n  }\n  if (a % 109 == 0) {\n    return false;\n  }\n  if (a % 113 == 0) {\n    return false;\n  }\n  if (a % 127 == 0) {\n    return false;\n  }\n  if (a % 131 == 0) {\n    return false;\n  }\n  if (a % 137 == 0) {\n    return false;\n  }\n  if (a % 139 == 0) {\n    return false;\n  }\n  if (a % 149 == 0) {\n    return false;\n  }\n  if (a % 151 == 0) {\n    return false;\n  }\n  if (a % 157 == 0) {\n    return false;\n  }\n  if (a % 163 == 0) {\n    return false;\n  }\n  if (a % 167 == 0) {\n    return false;\n  }\n  if (a % 173 == 0) {\n    return false;\n  }\n  if (a % 179 == 0) {\n    return false;\n  }\n  if (a % 181 == 0) {\n    return false;\n  }\n  if (a % 191 == 0) {\n    return false;\n  }\n  if (a % 193 == 0) {\n    return false;\n  }\n  if (a % 197 == 0) {\n    return false;\n  }\n  if (a % 199 == 0) {\n    return false;\n  }\n  if (a % 211 == 0) {\n    return false;\n  }\n  if (a % 223 == 0) {\n    return false;\n  }\n  if (a % 227 == 0) {\n    return false;\n  }\n  if (a % 229 == 0) {\n    return false;\n  }\n  if (a % 233 == 0) {\n    return false;\n  }\n  if (a % 239 == 0) {\n    return false;\n  }\n  if (a % 241 == 0) {\n    return false;\n  }\n  if (a % 251 == 0) {\n    return false;\n  }\n  if (a % 257 == 0) {\n    return false;\n  }\n  if (a % 263 == 0) {\n    return false;\n  }\n  if (a % 269 == 0) {\n    return false;\n  }\n  if (a % 271 == 0) {\n    return false;\n  }\n  if (a % 277 == 0) {\n    return false;\n  }\n  if (a % 281 == 0) {\n    return false;\n  }\n  if (a % 283 == 0) {\n    return false;\n  }\n  if (a % 293 == 0) {\n    return false;\n  }\n  if (a % 307 == 0) {\n    return false;\n  }\n  if (a % 311 == 0) {\n    return false;\n  }\n  if (a % 313 == 0) {\n    return false;\n  }\n  if (a % 317 == 0) {\n    return false;\n  }\n  if (a % 331 == 0) {\n    return false;\n  }\n  if (a % 337 == 0) {\n    return false;\n  }\n  if (a % 347 == 0) {\n    return false;\n  }\n  if (a % 349 == 0) {\n    return false;\n  }\n  if (a % 353 == 0) {\n    return false;\n  }\n  if (a % 359 == 0) {\n    return false;\n  }\n  if (a % 367 == 0) {\n    return false;\n  }\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadeciaml number as a string and counts the number of hexadceimal\n  digits that are primes (prime nmuber=== or a rpime=== si a natural number\n  greaetr than 1 that is not a product of two smaller natural nmubers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to dteermien a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decmila 11)=== D (=decimal 13).\n  Noet: you may assume the input is always correct or epmty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 3, "perturbed": true, "gc": "/*You have been tasked to write a function that receives\n  a hexadeciaml number as a string and counts the number of hexadceimal\n  digits that are primes (prime nmuber=== or a rpime=== si a natural number\n  greaetr than 1 that is not a product of two smaller natural nmubers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to dteermien a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decmila 11)=== D (=decimal 13).\n  Noet: you may assume the input is always correct or epmty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let res = 0;\n  let i = 0;\n  let n = num.length;\n  while (i < n) {\n    let c = num[i];\n    if (c === 'A' || c === 'B' || c === 'C' || c === 'D' || c === 'E' || c === 'F') {\n      res += 1;\n    }\n    i++;\n  }\n  return res;\n};\n\nconst isPrime = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime2 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime3 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime4 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime5 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime6 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime7 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime8 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime9 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime10 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime11 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime12 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime13 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime14 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime15 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime16 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime17 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime18 = (num) => {\n  let i = 2;\n  while (i < num) {\n    if (num % i === 0) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\n\nconst isPrime19 = (num) => {\n  let i = 2;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/79", "prompt": "/*You wlli be given a number in decimal from and your task is to convert it to\n  binary format. The function should return a string, with each chacrater representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 3, "perturbed": true, "gc": "/*You wlli be given a number in decimal from and your task is to convert it to\n  binary format. The function should return a string, with each chacrater representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let binaryLength = decimal.length;\n  let binaryIndex = 0;\n  let decimalIndex = 0;\n  let binaryChar = '';\n  let binaryCharIndex = 0;\n  let binaryCharLength = 1;\n  let binaryCharCount = 0;\n  let binaryCharCountIndex = 0;\n\n  while (decimalIndex < decimalLength) {\n    if (decimal[decimalIndex] === '0') {\n      binaryChar = '0';\n    } else if (decimal[decimalIndex] === '1') {\n      binaryChar = '1';\n    } else {\n      throw new Error('Invalid character in decimal number');\n    }\n\n    binaryCharLength = binaryCharLength + 1;\n    binaryIndex = binaryIndex + 1;\n\n    if (binaryCharLength === 2) {\n      binary = binary + binaryChar;\n      binaryChar = '';\n      binaryCharLength = 1;\n    }\n\n    decimalIndex = decimalIndex + 1;\n  }\n\n  if (binaryCharLength!== 1) {\n    throw new Error('Invalid number of characters in decimal number');\n  }\n\n  return binary;\n};\n\nmodule.exports = decimalToBinary;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integesr, return a tuple conissting of a sum and a product of all the itnegers in a list.\n  Empty sum should be equal to 0 and empty product shuold be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 3, "perturbed": true, "gc": "/* For a given list of integesr, return a tuple conissting of a sum and a product of all the itnegers in a list.\n  Empty sum should be equal to 0 and empty product shuold be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  if (numbers.length === 0) {\n    return [0, 1];\n  }\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\nmodule.exports = sumProduct;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or nto.\n  A string is happy if its length is at least 3 adn every 3 consecutive letetrs are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 3, "perturbed": true, "gc": "/*You are given a string s.\n  Your task is to check if the string is happy or nto.\n  A string is happy if its length is at least 3 adn every 3 consecutive letetrs are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  let str = s.toLowerCase();\n  let arr = str.split('');\n  let len = arr.length;\n  let i = 0;\n  while (i < len) {\n    let j = i + 1;\n    while (j < len) {\n      if (arr[i] === arr[j]) {\n        j++;\n      } else {\n        break;\n      }\n    }\n    if (j - i < 3) {\n      return false;\n    }\n    i = j;\n  }\n  return true;\n};\n\nmodule.exports = isHappy;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the seemster and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The lony problem is, she has lost the cdoe she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can outptu a list of letter grades using the flolowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 3, "perturbed": true, "gc": "/*It is the last week of the seemster and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The lony problem is, she has lost the cdoe she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can outptu a list of letter grades using the flolowing table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const letterGrade = {\n    A: 'A+',\n    B: 'B+',\n    C: 'C+',\n    D: 'D+',\n    E: 'E+'\n  };\n\n  const letterGradeList = [];\n\n  grades.forEach((grade) => {\n    if (grade >= 3.7) {\n      letterGradeList.push(letterGrade.A);\n    } else if (grade >= 3.3) {\n      letterGradeList.push(letterGrade.A);\n    } else if (grade >= 3.0) {\n      letterGradeList.push(letterGrade.A);\n    } else if (grade >= 2.7) {\n      letterGradeList.push(letterGrade.A);\n    } else if (grade >= 2.3) {\n      letterGradeList.push(letterGrade.A);\n    } else if (grade >= 2.0) {\n      letterGradeList.push(letterGrade.B);\n    } else if (grade >= 1.7) {\n      letterGradeList.push(letterGrade.B);\n    } else if (grade >= 1.3) {\n      letterGradeList.push(letterGrade.B);\n    } else if (grade >= 1.0) {\n      letterGradeList.push(letterGrade.C);\n    } else if (grade >= 0.7) {\n      letterGradeList.push(letterGrade.C);\n    } else if (grade >= 0.0) {\n      letterGradeList.push(letterGrade.D);\n    }\n  });\n\n  return letterGradeList;\n};\n\nmodule.exports = numericalLetterGrade;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that taeks a string nad retruns true if the string\n  length is a prime numbre or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 3, "perturbed": true, "gc": "/*Write a function that taeks a string nad retruns true if the string\n  length is a prime numbre or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  if (string.length < 2) {\n    return false;\n  }\n  let isPrime = true;\n  for (let i = 2; i < string.length; i++) {\n    if (string[i] === string[i - 1]) {\n      continue;\n    }\n    let j = i + 1;\n    while (j < string.length) {\n      if (string[i] === string[j]) {\n        j++;\n      } else {\n        break;\n      }\n    }\n    if (j === string.length) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\nmodule.exports = primeLength;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Gvien a psoiitve integre n, return the count of the numbers of n-digit\n  positive inteegrs thta start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 3, "perturbed": true, "gc": "/*\n  Gvien a psoiitve integre n, return the count of the numbers of n-digit\n  positive inteegrs thta start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds2 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds3 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds4 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds5 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds6 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds7 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds8 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds9 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds10 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds11 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds12 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds13 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds14 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds15 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds16 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds17 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds18 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds19 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds20 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds21 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds22 = (n) => {\n  const count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n) {\n      count++;\n    }\n  }\n  return count;\n};\n\nconst startsOneEnds23 = (n) => {\n  const count = 0", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/84", "prompt": "/*Given a psoitive integer N, return the total sum of its idgits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 3, "perturbed": true, "gc": "/*Given a psoitive integer N, return the total sum of its idgits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = 0; i < N; i++) {\n    sum += Math.pow(2, i);\n  }\n  return sum.toString(2);\n};\n\nmodule.exports = solve;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that are at dod indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 3, "perturbed": true, "gc": "/*Given a non-empty list of integers lst. add the even elements that are at dod indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add2 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add3 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add4 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add5 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add6 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add7 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add8 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add9 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add10 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add11 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add12 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add13 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add14 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add15 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add16 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add17 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add18 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add19 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add20 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add21 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      result += lst[i]\n    }\n  }\n  return result\n}\n\nconst add22 = (lst) => {\n  let result = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i %", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/86", "prompt": "/*\n  Wirte a function that takes a string and returns an ordered version of it.\n  Ordered version of strign, is a string whree all words (separated by sapce)\n  are replcaed by a new word hwere all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of owrds and labnk spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 3, "perturbed": true, "gc": "/*\n  Wirte a function that takes a string and returns an ordered version of it.\n  Ordered version of strign, is a string whree all words (separated by sapce)\n  are replcaed by a new word hwere all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of owrds and labnk spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let arr = s.split(' ');\n  let arr2 = [];\n  let arr3 = [];\n  let arr4 = [];\n  let arr5 = [];\n  let arr6 = [];\n  let arr7 = [];\n  let arr8 = [];\n  let arr9 = [];\n  let arr10 = [];\n  let arr11 = [];\n  let arr12 = [];\n  let arr13 = [];\n  let arr14 = [];\n  let arr15 = [];\n  let arr16 = [];\n  let arr17 = [];\n  let arr18 = [];\n  let arr19 = [];\n  let arr20 = [];\n  let arr21 = [];\n  let arr22 = [];\n  let arr23 = [];\n  let arr24 = [];\n  let arr25 = [];\n  let arr26 = [];\n  let arr27 = [];\n  let arr28 = [];\n  let arr29 = [];\n  let arr30 = [];\n  let arr31 = [];\n  let arr32 = [];\n  let arr33 = [];\n  let arr34 = [];\n  let arr35 = [];\n  let arr36 = [];\n  let arr37 = [];\n  let arr38 = [];\n  let arr39 = [];\n  let arr40 = [];\n  let arr41 = [];\n  let arr42 = [];\n  let arr43 = [];\n  let arr44 = [];\n  let arr45 = [];\n  let arr46 = [];\n  let arr47 = [];\n  let arr48 = [];\n  let arr49 = [];\n  let arr50 = [];\n  let arr51 = [];\n  let arr52 = [];\n  let arr53 = [];\n  let arr54 = [];\n  let arr55 = [];\n  let arr56 = [];\n  let arr57 = [];\n  let arr58 = [];\n  let arr59 = [];\n  let arr60 = [];\n  let arr61 = [];\n  let arr62 = [];\n  let arr63 = [];\n  let arr64 = [];\n  let arr65 = [];\n  let arr66 = [];\n  let arr67 = [];\n  let arr68 = [];\n  let arr69 = [];\n  let arr70 = [];\n  let arr71 = [];\n  let arr72 = [];\n  let arr73 = [];\n  let arr74 = [];\n  let arr75 = [];\n  let arr76 = [];\n  let arr77 = [];\n  let arr78 = [];\n  let arr79 = [];\n  let arr80 = [];\n  let arr81 = [];\n  let arr82 = [];\n  let arr83 = [];\n  let arr84 = [];\n  let arr85 = [];\n  let arr86 = [];\n  let arr87 = [];\n  let arr88 = [];\n  let arr89 = [];\n  let arr90 = [];\n  let arr91 = [];\n  let arr92 = [];\n  let arr93 = [];\n  let arr94 = [];\n  let arr95 = [];\n  let arr96 = [];\n  let arr97 = [];\n  let arr98 = [];\n  let arr99 = [];\n  let arr100 = [];\n  let arr101 = [];\n  let arr102 = [];\n  let arr103 = [];\n  let arr104 = [];\n  let arr105 = [];\n  let arr106 = [];\n  let arr107 = [];\n  let arr108 = [];\n  let arr109 = [];\n  let arr110 = [];\n  let arr111 = [];\n  let arr112 = [];\n  let arr113 = [];\n  let arr114 = [];\n  let arr115 = [];\n  let arr116 = [];\n  let arr117 = [];\n  let arr118 = [];\n  let arr119 = [];\n  let arr120 = [];\n  let arr121 = [];\n  let arr122 = [];\n  let arr123 = [];\n  let arr124 = [];\n  let arr125 = [];\n  let arr126 = [];\n  let arr127 = [];\n  let arr128 = [];\n  let arr129 = [];\n  let arr130 = [];\n  let arr131 = [];\n  let arr132 = [];\n  let arr133 = [];\n  let arr134 = [];\n  let arr135 = [];\n  let arr136 = [];\n  let arr137 = [];\n  let arr138 = [];\n  let arr139 = [];\n  let arr140 = [];\n  let arr141 = [];\n  let arr142 = [];\n  let arr143 = [];\n  let arr144 = [];\n  let arr145 = [];\n  let arr146 = [];\n  let arr147 = [];\n  let arr148 = [];\n  let arr149 = [];\n  let arr150 = [];\n  let arr151 = [];\n  let arr152 = [];\n  let arr153 = [];\n  let arr154 = [];\n  let arr155 = [];\n  let arr156 = [];\n  let arr157 = [];\n  let arr158 = [];\n  let arr159 = [];\n  let arr160 = [];\n  let arr161 = [];\n  let arr162 = [];\n  let arr163 = [];\n  let arr164 = [];\n  let arr165 = [];\n  let arr166 = [];\n  let arr167 = [];\n  let arr168 = [];\n  let arr169 = [];\n  let arr170 = [];\n  let arr171 = [];\n  let arr172 = [];\n  let arr173 = [];\n  let arr174 = [];\n  let arr175 = [];\n  let arr176 = [];\n  let arr177 = [];\n  let arr178 = [];\n  let arr179 = [];\n  let arr180 = [];\n  let arr181 = [];\n  let arr182 = [];\n  let arr183 = [];\n  let arr184 = [];\n  let arr185 = [];\n  let arr186 = [];\n  let arr187 = [];\n  let arr188 = [];\n  let arr189 = [];\n  let arr190 = [];\n  let arr191 = [];\n  let arr192 = [];\n  let arr193 = [];\n  let arr194 = [];\n  let arr195 = [];\n  let arr196 = [];\n  let", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is ismilar to matrix, hwoever, unlike matrcies,\n  each row may contain a different number of columns.\n  Given lst, and integer x, fnid integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such htat\n  each tuple is a coordinate - (row, columns), starting wiht 0.\n  Sort coordinates initilaly by rows in ascending order.\n  Also, sort coodrinaets of the orw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 3, "perturbed": true, "gc": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is ismilar to matrix, hwoever, unlike matrcies,\n  each row may contain a different number of columns.\n  Given lst, and integer x, fnid integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such htat\n  each tuple is a coordinate - (row, columns), starting wiht 0.\n  Sort coordinates initilaly by rows in ascending order.\n  Also, sort coodrinaets of the orw by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let res = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  while (i < lst.length) {\n    if (lst[i].length === 0) {\n      res.push([0, 0]);\n      i++;\n    } else {\n      while (j < lst[i].length) {\n        if (lst[i][j] === x) {\n          res.push([k, m]);\n          i++;\n          j++;\n        } else {\n          break;\n        }\n      }\n      k++;\n      m++;\n    }\n  }\n  return res;\n};\n\nconst getColumn = (lst, x) => {\n  let res = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  while (i < lst.length) {\n    if (lst[i].length === 0) {\n      res.push([0, 0]);\n      i++;\n    } else {\n      while (j < lst[i].length) {\n        if (lst[i][j] === x) {\n          res.push([k, m]);\n          i++;\n          j++;\n        } else {\n          break;\n        }\n      }\n      k++;\n      m++;\n    }\n  }\n  return res;\n};\n\nconst getCoordinates = (lst, x) => {\n  let res = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  while (i < lst.length) {\n    if (lst[i].length === 0) {\n      res.push([0, 0]);\n      i++;\n    } else {\n      while (j < lst[i].length) {\n        if (lst[i][j] === x) {\n          res.push([k, m]);\n          i++;\n          j++;\n        } else {\n          break;\n        }\n      }\n      k++;\n      m++;\n    }\n  }\n  return res;\n};\n\nconst getCoordinatesByColumn = (lst, x) => {\n  let res = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  while (i < lst.length) {\n    if (lst[i].length === 0) {\n      res.push([0, 0]);\n      i++;\n    } else {\n      while (j < lst[i].length) {\n        if (lst[i][j] === x) {\n          res.push([k, m]);\n          i++;\n          j++;\n        } else {\n          break;\n        }\n      }\n      k++;\n      m++;\n    }\n  }\n  return res;\n};\n\nconst getCoordinatesByRow = (lst, x) => {\n  let res = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  while (i < lst.length) {\n    if (lst[i].length === 0) {\n      res.push([0, 0]);\n      i++;\n    } else {\n      while (j < lst[i].length) {\n        if (lst[i][j] === x) {\n          res.push([k, m]);\n          i++;\n          j++;\n        } else {\n          break;\n        }\n      }\n      k++;\n      m++;\n    }\n  }\n  return res;\n};\n\nconst getCoordinatesByRowAndColumn = (lst, x) => {\n  let res = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  while (i < lst.length) {\n    if (lst[i].length === 0) {\n      res.push([0, 0]);\n      i++;\n    } else {\n      while (j < lst[i].length) {\n        if (lst[i][j] === x) {\n          res.push([k, m]);\n          i++;\n          j++;\n        } else {\n          break;\n        }\n      }\n      k++;\n      m++;\n    }\n  }\n  return res;\n};\n\nconst getCoordinatesByRowAndColumns = (lst, x) => {\n  let res = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  while (i < lst.length) {\n    if (lst[i].length === 0) {\n      res.push([0, 0]);\n      i++;\n    } else {\n      while (j < lst[i].length) {\n        if (lst[i][j] === x) {\n          res.push([k, m]);\n          i++;\n          j", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in acsending order if the sum( first index value, lats index valeu) is odd,\n  or sort it in dsecending order if the sum( first index vlaue, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 3, "perturbed": true, "gc": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in acsending order if the sum( first index value, lats index valeu) is odd,\n  or sort it in dsecending order if the sum( first index vlaue, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  if (array.length === 0) {\n    return array;\n  }\n  let sum = array[0];\n  for (let i = 1; i < array.length; i++) {\n    sum += array[i];\n  }\n  if (sum % 2 === 1) {\n    return sortArray(array.slice().sort((a, b) => a - b));\n  } else {\n    return sortArray(array.slice().sort((a, b) => b - a));\n  }\n};\n\nmodule.exports = sortArray;\n<|endoftext|>", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/89", "prompt": "/*Cerate a function encrypt that takes a tsrnig as an argmuent and\n  returns a string encrypted with the alphabet bieng rotated. \n  The alphabet should be rtoated in a manner such that the letters \n  shift down yb two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 3, "perturbed": true, "gc": "/*Cerate a function encrypt that takes a tsrnig as an argmuent and\n  returns a string encrypted with the alphabet bieng rotated. \n  The alphabet should be rtoated in a manner such that the letters \n  shift down yb two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let s_rotated = s.toLowerCase().split('').map((c) => {\n    let c_rotated = c.toLowerCase();\n    let c_rotated_2 = c_rotated.split('').map((c) => {\n      let c_rotated_2_2 = c.toLowerCase();\n      let c_rotated_2_2_2 = c_rotated_2_2.split('').map((c) => {\n        let c_rotated_2_2_2_2 = c.toLowerCase();\n        let c_rotated_2_2_2_2_2 = c_rotated_2_2_2_2.split('').map((c) => {\n          let c_rotated_2_2_2_2_2_2 = c.toLowerCase();\n          let c_rotated_2_2_2_2_2_2_2 = c_rotated_2_2_2_2_2_2.split('').map((c) => {\n            let c_rotated_2_2_2_2_2_2_2_2 = c.toLowerCase();\n            let c_rotated_2_2_2_2_2_2_2_2_2 = c_rotated_2_2_2_2_2_2_2_2.split('').map((c) => {\n              let c_rotated_2_2_2_2_2_2_2_2_2_2 = c.toLowerCase();\n              let c_rotated_2_2_2_2_2_2_2_2_2_2_2 = c_rotated_2_2_2_2_2_2_2_2_2_2.split('').map((c) => {\n                let c_rotated_2_2_2_2_2_2_2_2_2_2_2_2 = c.toLowerCase();\n                let c_rotated_2_2_2_2_2_2_2_2_2_2_2_2_2 = c_rotated_2_2_2_2_2_2_2_2_2_2_2_2.split('').map((c) => {\n                  let c_rotated_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2 = c.toLowerCase();\n                  let c_rotated_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2 = c_rotated_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2.split('').map((c) => {\n                    let c_rotated_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2_2", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a gievn list of integers, generate a list of rolling maximum elmeent foudn until gievn moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 3, "perturbed": true, "gc": "/* From a gievn list of integers, generate a list of rolling maximum elmeent foudn until gievn moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = numbers[0];\n  let maxIndex = 0;\n  let maxIndexFound = false;\n  for (let i = 1; i < numbers.length; i++) {\n    if (max < numbers[i]) {\n      max = numbers[i];\n      maxIndex = i;\n      maxIndexFound = false;\n    } else if (max === numbers[i]) {\n      maxIndexFound = true;\n    }\n  }\n  if (!maxIndexFound) {\n    max = numbers[numbers.length - 1];\n  }\n  return numbers.slice(maxIndex, numbers.length);\n};\n\nmodule.exports = rollingMax;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are igven a list of integers.\n  Write a function nextSmallest() taht retruns the 2nd smallest eleemnt of the list.\n  Return null if there is no such eleemnt.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 3, "perturbed": true, "gc": "/*\n  You are igven a list of integers.\n  Write a function nextSmallest() taht retruns the 2nd smallest eleemnt of the list.\n  Return null if there is no such eleemnt.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  if (lst.length === 0) return null;\n  let min = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n    }\n  }\n  return min;\n};\n\nmodule.exports = nextSmallest;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of wodrs, and your task is to coutn the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 3, "perturbed": true, "gc": "/*\n  You'll be given a string of wodrs, and your task is to coutn the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  let words = S.split('.');\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].startsWith('I')) {\n      count++;\n    }\n  }\n  return count;\n};\n\nmodule.exports = isBored;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 3, "perturbed": true, "gc": "/* Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  return x === y && x === z;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt2 = (x, y, z) => {\n  return x === y && x === z;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt3 = (x, y, z) => {\n  return x === y && x === z;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt4 = (x, y, z) => {\n  return x === y && x === z;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt5 = (x, y, z) => {\n  return x === y && x === z;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt6 = (x, y, z) => {\n  return x === y && x === z;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt7 = (x, y, z) => {\n  return x === y && x === z;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt8 = (x, y, z) => {\n  return x === y && x === z;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt9 = (x, y, z) => {\n  return x === y && x === z;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt10 = (x, y, z) => {\n  return x === y && x === z;\n};\n\n/*\n  Create a fnuction that takes 3 numbers.\n  Retunrs true if one of the numbers is equal to the smu", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it sawps case of all lteters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Exampels:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 3, "perturbed": true, "gc": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it sawps case of all lteters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Exampels:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = message.toLowerCase();\n  let vowels = 'aeiou';\n  let consonants = 'bcdfghjklmnpqrstvwxyz';\n  let consonantMap = {};\n  let vowelMap = {};\n  let vowelMap2 = {};\n  let vowelMap3 = {};\n  let vowelMap4 = {};\n  let vowelMap5 = {};\n  let vowelMap6 = {};\n  let vowelMap7 = {};\n  let vowelMap8 = {};\n  let vowelMap9 = {};\n  let vowelMap10 = {};\n  let vowelMap11 = {};\n  let vowelMap12 = {};\n  let vowelMap13 = {};\n  let vowelMap14 = {};\n  let vowelMap15 = {};\n  let vowelMap16 = {};\n  let vowelMap17 = {};\n  let vowelMap18 = {};\n  let vowelMap19 = {};\n  let vowelMap20 = {};\n  let vowelMap21 = {};\n  let vowelMap22 = {};\n  let vowelMap23 = {};\n  let vowelMap24 = {};\n  let vowelMap25 = {};\n  let vowelMap26 = {};\n  let vowelMap27 = {};\n  let vowelMap28 = {};\n  let vowelMap29 = {};\n  let vowelMap30 = {};\n  let vowelMap31 = {};\n  let vowelMap32 = {};\n  let vowelMap33 = {};\n  let vowelMap34 = {};\n  let vowelMap35 = {};\n  let vowelMap36 = {};\n  let vowelMap37 = {};\n  let vowelMap38 = {};\n  let vowelMap39 = {};\n  let vowelMap40 = {};\n  let vowelMap41 = {};\n  let vowelMap42 = {};\n  let vowelMap43 = {};\n  let vowelMap44 = {};\n  let vowelMap45 = {};\n  let vowelMap46 = {};\n  let vowelMap47 = {};\n  let vowelMap48 = {};\n  let vowelMap49 = {};\n  let vowelMap50 = {};\n  let vowelMap51 = {};\n  let vowelMap52 = {};\n  let vowelMap53 = {};\n  let vowelMap54 = {};\n  let vowelMap55 = {};\n  let vowelMap56 = {};\n  let vowelMap57 = {};\n  let vowelMap58 = {};\n  let vowelMap59 = {};\n  let vowelMap60 = {};\n  let vowelMap61 = {};\n  let vowelMap62 = {};\n  let vowelMap63 = {};\n  let vowelMap64 = {};\n  let vowelMap65 = {};\n  let vowelMap66 = {};\n  let vowelMap67 = {};\n  let vowelMap68 = {};\n  let vowelMap69 = {};\n  let vowelMap70 = {};\n  let vowelMap71 = {};\n  let vowelMap72 = {};\n  let vowelMap73 = {};\n  let vowelMap74 = {};\n  let vowelMap75 = {};\n  let vowelMap76 = {};\n  let vowelMap77 = {};\n  let vowelMap78 = {};\n  let vowelMap79 = {};\n  let vowelMap80 = {};\n  let vowelMap81 = {};\n  let vowelMap82 = {};\n  let vowelMap83 = {};\n  let vowelMap84 = {};\n  let vowelMap85 = {};\n  let vowelMap86 = {};\n  let vowelMap87 = {};\n  let vowelMap88 = {};\n  let vowelMap89 = {};\n  let vowelMap90 = {};\n  let vowelMap91 = {};\n  let vowelMap92 = {};\n  let vowelMap93 = {};\n  let vowelMap94 = {};\n  let vowelMap95 = {};\n  let vowelMap96 = {};\n  let vowelMap97 = {};\n  let vowelMap98 = {};\n  let vowelMap99 = {};\n  let vowelMap100 = {};\n  let vowelMap101 = {};\n  let vowelMap102 = {};\n  let vowelMap103 = {};\n  let vowelMap104 = {};\n  let vowelMap105 = {};\n  let vowelMap106 = {};\n  let vowelMap107 = {};\n  let vowelMap108 = {};\n  let vowelMap109 = {};\n  let vowelMap110 = {};\n  let vowelMap111 = {};\n  let vowelMap112 = {};\n  let vowelMap113 = {};\n  let vowelMap114 = {};\n  let vowelMap115 = {};\n  let vowelMap116 = {};\n  let vowelMap117 = {};\n  let vowelMap118 = {};\n  let vowelMap119 = {};\n  let vowelMap120 = {};\n  let vowelMap121 = {};\n  let vowelMap122 = {};\n  let vowelMap123 = {};\n  let vowelMap124 = {};\n  let vowelMap125 = {};\n  let vowelMap126 = {};\n  let vowelMap127 = {};\n  let vowelMap128 = {};\n  let vowelMap129 = {};\n  let vowelMap130 = {};\n  let vowelMap131 = {};\n  let vowelMap132 = {};\n  let vowelMap133 = {};\n  let vowelMap134 = {};\n  let vowelMap135 = {};\n  let vowelMap136 = {};\n  let vowelMap137 = {};\n  let vowelMap138 = {};\n  let vowelMap139 = {};\n  let vowelMap140 = {};\n  let vowelMap141 = {};\n  let vowelMap142 = {};\n  let vowelMap143 = {};\n  let vowelMap144 = {};\n  let vowelMap145 = {};\n  let vowelMap146 = {};\n  let vowelMap147 = {};\n  let vowelMap148 = {};\n  let vowelMap149 = {};\n  let vowelMap150 = {};\n  let vowelMap151 =", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/94", "prompt": "/*Yuo are givne a list of integers.\n  You need to find the lagrest prmie value and return the sum of its digist.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 3, "perturbed": true, "gc": "/*Yuo are givne a list of integers.\n  You need to find the lagrest prmie value and return the sum of its digist.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\nconst test = () => {\n  const lst = [0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3];\n  console.log(skjkasdkd(lst));\n};\n\ntest();\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a idctionary, return ture fi all kyes are strings in lower \n  case or all keys rae strings in upper case, lese return false.\n  The function should return flase is the givne dictoianry is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 3, "perturbed": true, "gc": "/*\n  Given a idctionary, return ture fi all kyes are strings in lower \n  case or all keys rae strings in upper case, lese return false.\n  The function should return flase is the givne dictoianry is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if (dict.length === 0) {\n    return false;\n  }\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (key.toLowerCase()!== key) {\n      return false;\n    }\n    if (value.toUpperCase()!== value) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = checkDictCase;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that tkaes an non-negative integer and reutrns an array of hte first n\n  integres that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 3, "perturbed": true, "gc": "/*Implement a function that tkaes an non-negative integer and reutrns an array of hte first n\n  integres that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  for (let i = 2; i <= n; i++) {\n    if (isPrime(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconsole.log(countUpTo(5));\nconsole.log(countUpTo(11));\nconsole.log(countUpTo(0));\nconsole.log(countUpTo(20));\nconsole.log(countUpTo(1));\nconsole.log(countUpTo(18));\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and retursn \n  the product of their unit dgiits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 3, "perturbed": true, "gc": "/*Complete the function that takes two integers and retursn \n  the product of their unit dgiits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let a_ = a % 10;\n  let b_ = b % 10;\n  let a_b = a * b;\n  let a_b_ = a_ * b_;\n  let a_b_b = a_b * b_;\n  let a_b_b_ = a_b_ * b_;\n  let a_b_b_b = a_b_b * b_;\n  let a_b_b_b_ = a_b_b_ * b_;\n  let a_b_b_b_b = a_b_b_b * b_;\n  let a_b_b_b_b = a_b_b_b * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b_b_ = a_b_b_b_ * b_;\n  let a_b_b_b", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowlse in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 3, "perturbed": true, "gc": "/*\n  Given a string s, count the number of uppercase vowlse in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] === s[i + 1]) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\nmodule.exports = countUpper;\n<|endoftext|>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/99", "prompt": "/* Craeet a function taht takes a value (string) representing a number\n  and returns the lcosest inteegr to it. If hte number is equidistant\n  frmo two integers, round it away frmo zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 3, "perturbed": true, "gc": "/* Craeet a function taht takes a value (string) representing a number\n  and returns the lcosest inteegr to it. If hte number is equidistant\n  frmo two integers, round it away frmo zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  let result = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let i1 = 0;\n  let i2 = 0;\n  let i3 = 0;\n  let i4 = 0;\n  let i5 = 0;\n  let i6 = 0;\n  let i7 = 0;\n  let i8 = 0;\n  let i9 = 0;\n  let i10 = 0;\n  let i11 = 0;\n  let i12 = 0;\n  let i13 = 0;\n  let i14 = 0;\n  let i15 = 0;\n  let i16 = 0;\n  let i17 = 0;\n  let i18 = 0;\n  let i19 = 0;\n  let i20 = 0;\n  let i21 = 0;\n  let i22 = 0;\n  let i23 = 0;\n  let i24 = 0;\n  let i25 = 0;\n  let i26 = 0;\n  let i27 = 0;\n  let i28 = 0;\n  let i29 = 0;\n  let i30 = 0;\n  let i31 = 0;\n  let i32 = 0;\n  let i33 = 0;\n  let i34 = 0;\n  let i35 = 0;\n  let i36 = 0;\n  let i37 = 0;\n  let i38 = 0;\n  let i39 = 0;\n  let i40 = 0;\n  let i41 = 0;\n  let i42 = 0;\n  let i43 = 0;\n  let i44 = 0;\n  let i45 = 0;\n  let i46 = 0;\n  let i47 = 0;\n  let i48 = 0;\n  let i49 = 0;\n  let i50 = 0;\n  let i51 = 0;\n  let i52 = 0;\n  let i53 = 0;\n  let i54 = 0;\n  let i55 = 0;\n  let i56 = 0;\n  let i57 = 0;\n  let i58 = 0;\n  let i59 = 0;\n  let i60 = 0;\n  let i61 = 0;\n  let i62 = 0;\n  let i63 = 0;\n  let i64 = 0;\n  let i65 = 0;\n  let i66 = 0;\n  let i67 = 0;\n  let i68 = 0;\n  let i69 = 0;\n  let i70 = 0;\n  let i71 = 0;\n  let i72 = 0;\n  let i73 = 0;\n  let i74 = 0;\n  let i75 = 0;\n  let i76 = 0;\n  let i77 = 0;\n  let i78 = 0;\n  let i79 = 0;\n  let i80 = 0;\n  let i81 = 0;\n  let i82 = 0;\n  let i83 = 0;\n  let i84 = 0;\n  let i85 = 0;\n  let i86 = 0;\n  let i87 = 0;\n  let i88 = 0;\n  let i89 = 0;\n  let i90 = 0;\n  let i91 = 0;\n  let i92 = 0;\n  let i93 = 0;\n  let i94 = 0;\n  let i95 = 0;\n  let i96 = 0;\n  let i97 = 0;\n  let i98 = 0;\n  let i99 = 0;\n  let i100 = 0;\n  let i101 = 0;\n  let i102 = 0;\n  let i103 = 0;\n  let i104 = 0;\n  let i105 = 0;\n  let i106 = 0;\n  let i107 = 0;\n  let i108 = 0;\n  let i109 = 0;\n  let i110 = 0;\n  let i111 = 0;\n  let i112 = 0;\n  let i113 = 0;\n  let i114 = 0;\n  let i115 = 0;\n  let i116 = 0;\n  let i117 = 0;\n  let i118 = 0;\n  let i119 = 0;\n  let i120 = 0;\n  let i121 = 0;\n  let i122 = 0;\n  let i123 = 0;\n  let i124 = 0;\n  let i125 = 0;\n  let i126 = 0;\n  let i127 = 0;\n  let i128 = 0;\n  let i129 = 0;\n  let i130 = 0;\n  let i131 = 0;\n  let i132 = 0;\n  let i133 = 0;\n  let i134 = 0;\n  let i135 = 0;\n  let i136 = 0;\n  let i137 = 0;\n  let i138 = 0;\n  let i139 = 0;\n  let i140 = 0;\n  let i141 = 0;\n  let i142 = 0;\n  let i143 = 0;\n  let i144 = 0;\n  let i145 = 0;\n  let i146 = 0;\n  let i147 = 0;\n  let i148 = 0;\n  let i149 = 0;\n  let i150 = 0;\n  let i151 = 0;\n  let i152 = 0;\n  let i153 = 0;\n  let i154 = 0;\n  let", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
