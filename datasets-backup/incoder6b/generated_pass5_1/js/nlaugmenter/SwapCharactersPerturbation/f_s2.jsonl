{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers colser to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers colser to each other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  for (let i = 0; i < numbers.length - 1; i++) {\n    for (let j = i + 1; j < numbers.length; j++) {\n      if (numbers[i] > numbers[j] && numbers[i] < numbers[j] + threshold) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElements = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV2 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV3 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV4 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV5 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV6 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV7 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV8 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV9 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV10 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV11 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV12 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV13 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV14 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV15 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV16 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV17 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV18 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV19 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\nconst hasOnlyUniqueElementsV20 = (arr) => {\n  const set = new Set();\n  for (let i = 0; i < arr.length; i++) {\n    if (set.has(arr[i])) {\n      return false;\n    }\n    set.add(arr[i]);\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has only unique elements\n * @param {Array} arr\n * @returns {boolean}\n */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested parentheess. Your goal is to\n  separate those group into separate strings and return the list of thoes.\n  Separate groups are balanced (each open rbace is properly closed) and ont nested withni each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested parentheess. Your goal is to\n  separate those group into separate strings and return the list of thoes.\n  Separate groups are balanced (each open rbace is properly closed) and ont nested withni each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const groups = [];\n  let opening_paren = 0;\n  let closing_paren = 0;\n  let current_group = [];\n  let current_group_length = 0;\n  let current_group_opening = false;\n  let current_group_closing = false;\n  let current_group_opening_paren = 0;\n  let current_group_closing_paren = 0;\n\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      if (current_group_opening) {\n        current_group_opening_paren++;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ',') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_closing = true;\n        current_group_closing_paren = 1;\n      }\n    } else if (char ==='') {\n      if (current_group_opening) {\n        current_group_opening_paren--;\n      } else {\n        current_group_opening = true;\n        current_group_opening_paren = 1;\n      }\n    } else if (char === ')') {\n      if (current_group_opening) {", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins iwth a supplied string.\n  Algorithm idea is sipmle:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - pApend to the end of the string revesre of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins iwth a supplied string.\n  Algorithm idea is sipmle:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - pApend to the end of the string revesre of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromeIndex = 0;\n  let longestPalindromePrefix = [];\n  let longestPalindromeSuffix = [];\n  for (let i = 0; i < string.length; i++) {\n    let currentChar = string[i];\n    let currentPalindrome = currentChar + currentChar;\n    if (isPalindrome(currentPalindrome)) {\n      let currentPalindromeLength = currentPalindrome.length;\n      if (currentPalindromeLength > longestPalindromeLength) {\n        longestPalindrome = currentPalindrome;\n        longestPalindromeLength = currentPalindromeLength;\n        longestPalindromeIndex = i;\n        longestPalindromePrefix = [];\n        longestPalindromeSuffix = [];\n      }\n      longestPalindromePrefix.push(currentChar);\n      longestPalindromeSuffix.push(currentPalindrome);\n    }\n  }\n  return longestPalindromePrefix.reverse().concat(longestPalindrome).concat(longestPalindromeSuffix.reverse());\n}\n\n/* Find the longest palindrome that begins iwth a supplied string.\n  Algorithm idea is sipmle:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - pApend to the end of the string revesre of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromeIndex = 0;\n  let longestPalindromePrefix = [];\n  let longestPalindromeSuffix = [];\n  for (let i = 0; i < string.length; i++) {\n    let currentChar = string[i];\n    let currentPalindrome = currentChar + currentChar;\n    if (isPalindrome(currentPalindrome)) {\n      let currentPalindromeLength = currentPalindrome.length;\n      if (currentPalindromeLength > longestPalindromeLength) {\n        longestPalindrome = currentPalindrome;\n        longestPalindromeLength = currentPalindromeLength;\n        longestPalindromeIndex = i;\n        longestPalindromePrefix = [];\n        longestPalindromeSuffix = [];\n      }\n      longestPalindromePrefix.push(currentChar);\n      longestPalindromeSuffix.push(currentPalindrome);\n    }\n  }\n  return longestPalindromePrefix.reverse().concat(longestPalindrome).concat(longestPalindromeSuffix.reverse());\n}\n\n/* Find the longest palindrome that begins iwth a supplied string.\n  Algorithm idea is sipmle:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - pApend to the end of the string revesre of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromeIndex = 0;\n  let longestPalindromePrefix = [];\n  let longestPalindromeSuffix = [];\n  for (let i = 0; i < string.length; i++) {\n    let currentChar = string[i];\n    let currentPalindrome = currentChar + currentChar;\n    if (isPalindrome(currentPalindrome)) {\n      let currentPalindromeLength = currentPalindrome.length;\n      if (currentPalindromeLength > longestPalindromeLength) {\n        longestPalindrome = currentPalindrome;\n        longestPalindromeLength = currentPalindromeLength;\n        longestPalindromeIndex = i;\n        longestPalindromePrefix = [];\n        longestPalindromeSuffix = [];\n      }\n      longestPalindromePrefix.push(currentChar);\n      longestPalindromeSuffix.push(currentPalindrome);\n    }\n  }\n  return longestPalindromePrefix.reverse().concat(longestPalindrome).concat(longestPalindromeSuffix.reverse());\n}\n\n/* Find the longest palindrome that begins iwth a supplied string.\n  Algorithm idea is sipmle:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - pApend to the end of the string revesre of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromeIndex = 0;\n  let longestPalindromePrefix = [];\n  let longestPalindromeSuffix = [];\n  for (let i = 0; i < string.length; i++) {\n    let currentChar = string[i];\n    let currentPalindrome = currentChar + currentChar;\n    if (isPalindrome(currentPalindrome)) {\n      let currentPalindromeLength = currentPalindrome.length;\n      if (currentPalindromeLength > longestPalindromeLength) {\n        longestPalindrome = currentPalindrome;\n        longestPalindromeLength = currentPalindromeLength;\n        longestPalindromeIndex = i;\n        longestPalindromePrefix = [];\n        longestPalindromeSuffix = [];\n      }\n      longestPalindromePrefix.push(currentChar);\n      longestPalindromeSuffix.push(currentPalindrome);\n    }\n  }\n  return longestPalindromePrefix.reverse().concat(longestPalindrome).concat(longestPalindromeSuffix.reverse());\n}\n\n/* Find the longest palindrome that begins iwth a supplied string.\n  Algorithm idea is sipmle:\n  - Find the longest postfix of supplied string that ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in the next level is:\n      - the netx odd number if n is odd.\n      - the next even numbre if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in the next level is:\n      - the netx odd number if n is odd.\n      - the next even numbre if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(n - i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in the next level is:\n      - the netx odd number if n is odd.\n      - the next even numbre if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(n - i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in the next level is:\n      - the netx odd number if n is odd.\n      - the next even numbre if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(n - i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in the next level is:\n      - the netx odd number if n is odd.\n      - the next even numbre if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(n - i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in the next level is:\n      - the netx odd number if n is odd.\n      - the next even numbre if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(n - i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in the next level is:\n      - the netx odd number if n is odd.\n      - the next even numbre if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(n - i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in the next level is:\n      - the netx odd number if n is odd.\n      - the next even numbre if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(n - i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in the next level is:\n      - the netx odd number if n is odd.\n      - the next even numbre if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(n - i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in the next level is:\n      - the netx odd number if n is odd.\n      - the next even numbre if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(n - i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in the next level is:\n      - the netx odd number if n is odd.\n      - the next even numbre if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(n - i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first levle has n stones.\n  The number of stones in the next level is:\n      - the netx odd number if n is odd.\n      - the next even numbre if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be gievn a string of words separated by commas or sapecs. Your atsk is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You will be gievn a string of words separated by commas or sapecs. Your atsk is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(',').map(word => word.trim());\n};\n\n/*\n  You will be given an array of numbers and a number k. Your task is to return an array of\n  the numbers that sum to k. For example:\n  \n  sumArray([1, 2, 3, 4], 3) == [3, 7]\n  sumArray([1, 2, 3, 4], 4) == [4, 6]\n  sumArray([1, 2, 3, 4], 5) == []\n  sumArray([1, 2, 3, 4], 0) == []\n  sumArray([1, 2, 3, 4], -1) == []\n  sumArray([1, 2, 3, 4], -2) == []\n  sumArray([1, 2, 3, 4], -3) == []\n  sumArray([1, 2, 3, 4], -4) == []\n  sumArray([1, 2, 3, 4], -5) == []\n  sumArray([1, 2, 3, 4], -6) == []\n  sumArray([1, 2, 3, 4], -7) == []\n  sumArray([1, 2, 3, 4], -8) == []\n  sumArray([1, 2, 3, 4], -9) == []\n  sumArray([1, 2, 3, 4], -10) == []\n  sumArray([1, 2, 3, 4], -11) == []\n  sumArray([1, 2, 3, 4], -12) == []\n  sumArray([1, 2, 3, 4], -13) == []\n  sumArray([1, 2, 3, 4], -14) == []\n  sumArray([1, 2, 3, 4], -15) == []\n  sumArray([1, 2, 3, 4], -16) == []\n  sumArray([1, 2, 3, 4], -17) == []\n  sumArray([1, 2, 3, 4], -18) == []\n  sumArray([1, 2, 3, 4], -19) == []\n  sumArray([1, 2, 3, 4], -20) == []\n  sumArray([1, 2, 3, 4], -21) == []\n  sumArray([1, 2, 3, 4], -22) == []\n  sumArray([1, 2, 3, 4], -23) == []\n  sumArray([1, 2, 3, 4], -24) == []\n  sumArray([1, 2, 3, 4], -25) == []\n  sumArray([1, 2, 3, 4], -26) == []\n  sumArray([1, 2, 3, 4], -27) == []\n  sumArray([1, 2, 3, 4], -28) == []\n  sumArray([1, 2, 3, 4], -29) == []\n  sumArray([1, 2, 3, 4], -30) == []\n  sumArray([1, 2, 3, 4], -31) == []\n  sumArray([1, 2, 3, 4], -32) == []\n  sumArray([1, 2, 3, 4], -33) == []\n  sumArray([1, 2, 3, 4], -34) == []\n  sumArray([1, 2, 3, 4], -35) == []\n  sumArray([1, 2, 3, 4], -36) == []\n  sumArray([1, 2, 3, 4], -37) == []\n  sumArray([1, 2, 3, 4], -38) == []\n  sumArray([1, 2, 3, 4], -39) == []\n  sumArray([1, 2, 3, 4], -40) == []\n  sumArray([1, 2, 3, 4], -41) == []\n  sumArray([1, 2, 3, 4], -42) == []\n  sumArray([1, 2, 3, 4], -43) == []\n  sumArray([1, 2, 3, 4], -44) == []\n  sumArray([1, 2, 3, 4], -45) == []\n  sumArray([1, 2, 3, 4], -46) == []\n  sumArray([1, 2, 3, 4], -47) == []\n  sumArray([1, 2, 3, 4], -48) == []\n  sumArray([1, 2, 3, 4], -49) == []\n  sumArray([1, 2, 3, 4], -50) == []\n  sumArray([1, 2, 3, 4], -51) == []\n  sumArray([1, 2, 3, 4], -52) == []\n  sumArray([1, 2, 3, 4], -53) == []\n  sumArray([1, 2, 3, 4], -54) == []\n  sumArray([1, 2, 3, 4], -55) == []\n  sumArray([1, 2, 3, 4], -56) == []\n  sumArray([1, 2, 3, 4], -57) == []\n  sumArray([1, 2, 3, 4], -58) == []\n  sumArray([1, 2, 3, 4], -59) == []\n  sumArray([1, 2, 3, 4], -60) == []\n  sumArray([1, 2, 3, 4], -61) == []\n  sumArray([1, 2, 3, 4], -62) == []\n  sumArray([1, 2, 3, 4], -63) == []\n  sumArray([1, 2, 3, 4], -64) == []\n  sumArray([1, 2, 3, 4], -65) == []\n  sumArray([1, 2, 3, 4], -66) == []\n  sumArray([1, 2, 3, 4], -67) == []\n  sumArray([1, 2, 3, 4], -68) == []\n  sumArray([1, 2, 3, 4], -69) == []\n  sumArray([1, 2, 3, 4], -70) == []\n  sumArray([1, 2, 3, 4], -71) == []\n  sumArray([1, 2, 3, 4], -72) == []\n  sumArray([1, 2, 3, 4], -73) == []\n  sumArray([1, 2, 3, 4], -74) == []\n  sumArray([1, 2, 3, 4], -75) == []\n  sumArray([1, 2, 3, 4], -76) == []\n  sumArray([1, 2, 3, 4], -77) == []\n  sumArray([1, 2, 3, 4], -78) == []\n  sumArray([1, 2, 3, 4], -79) == []\n  sumArray([1, 2, 3, 4], -80) == []\n  sumArray([1, 2, 3, 4], -81) == []\n  sumArray([1, 2, 3, 4], -82) == []\n  sumArray([1, 2, 3, 4], -83) == []\n  sumArray([1, 2, 3, 4], -84) == []\n  sumArray([1, 2, 3, 4], -85) == []\n  sumArray([1, 2, 3, 4], -86) == []\n  sumArray([1, 2, 3, 4], -87) == []\n  sumArray([1, 2, 3, 4], -88) == []\n  sumArray([1, 2, 3, 4], -89) == []\n  sumArray([1, 2, 3, 4], -90) == []\n  sumArray([1, 2, 3, 4], -91) == []\n  sumArray([1, 2, 3, 4], -92) == []\n  sumArray([1, 2, 3, 4], -93) == []\n  sumArray([1, 2, 3, 4], -94) == []\n  sumArray([1, 2, 3, 4], -95) == []\n  sumArray([1, 2, 3, 4], -96) == []\n  sumArray([1, 2, 3, 4], -97) == []\n  sumArray([1, 2, 3, 4], -98) == []\n  sumArray([1, 2, 3, 4], -99) == []\n  sumArray([1, 2, 3, 4], -100) == []\n  sumArray([1, 2, 3, 4], -101) == []\n  sumArray([1, 2, 3, 4], -102) == []\n  sumArray([1, 2, 3, 4], -103) == []\n  sumArray([1, 2, 3, 4], -104) == []\n  sumArray([1, 2, 3, 4], -105) == []\n  sumArray([1, 2, 3, 4], -106) == []\n  sumArray([1, 2, 3, 4], -107) == []\n  sumArray([1, 2, 3, 4], -108) == []\n  sumArray([1, 2, 3, 4], -109) == []\n  sumArray([1, 2, 3, 4], -110) == []\n  sumArray([1, 2, 3, 4], -111) == []\n  sumArray([1, 2, 3, 4], -112) == []\n  sumArray([1, 2, 3, 4], -113) == []\n  sumArray([1, 2, 3, 4], -114) == []\n  sumArray([1, 2, 3, 4], -115) == []\n  sumArray([1, 2, 3, 4], -116) == []\n  sumArray([1, 2, 3, 4], -117) == []\n  sumArray([1, 2, 3, 4], -118) == []\n  sumArray([1, 2, 3, 4], -119) == []\n  sumArray([1, 2, 3, 4], -120) == []\n  sumArray([1, 2, 3, 4], -121) == []\n  sumArray([1, 2, 3, 4], -122) == []\n  sumArray([1, 2, 3, 4], -123) == []\n  sumArray([1, 2, 3, 4], -124) == []\n  sumArray([1, 2, 3, 4], -125", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two postiive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no scuh numbre, thne the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*This function takes two postiive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no scuh numbre, thne the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0) {\n    return y;\n  }\n  if (y % 2 === 0) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return x + y;\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return x;\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return y;\n  }\n};\n\n/*This function takes two postiive numbers x and y and returns the\n  biggest odd integer number that is in the range [x, y] inclusive. If \n  there's no scuh numbre, thne the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 13\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0) {\n    return y;\n  }\n  if (y % 2 === 0) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return x + y;\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return x;\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return y;\n  }\n};\n\n/*This function takes two postiive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no scuh numbre, thne the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0) {\n    return y;\n  }\n  if (y % 2 === 0) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return x + y;\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return x;\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return y;\n  }\n};\n\n/*This function takes two postiive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no scuh numbre, thne the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0) {\n    return y;\n  }\n  if (y % 2 === 0) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return x + y;\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return x;\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return y;\n  }\n};\n\n/*This function takes two postiive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no scuh numbre, thne the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0) {\n    return y;\n  }\n  if (y % 2 === 0) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return x + y;\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return x;\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return y;\n  }\n};\n\n/*This function takes two postiive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no scuh numbre, thne the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0) {\n    return y;\n  }\n  if (y % 2 === 0) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return x + y;\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return x;\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return y;\n  }\n};\n\n/*This function takes two postiive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no scuh numbre, thne the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0) {\n    return y;\n  }\n  if (y % 2 === 0) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return x + y;\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return x;\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return y;\n  }\n};\n\n/*This function takes two postiive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no scuh numbre, thne the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  if (x % 2 === 0) {\n    return y;\n  }\n  if (y % 2 === 0) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x + y;\n  }\n  if (x % 2 === 0 && y % 2!== 0) {\n    return x + y;\n  }\n  if (x % 2!== 0 && y % 2 === 0) {\n    return x;\n  }\n  if (x % 2!== 0 && y % 2!== 0) {\n    return y;\n  }\n};\n\n/*This function takes two postiive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no scuh numbre, thne the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x === y) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are given two opsitive integers n and m, and yoru taks is to compute the\n  average of the nitegers form n trhough m (including n and m). \n  oRund the answer to the nearest inetger and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given two opsitive integers n and m, and yoru taks is to compute the\n  average of the nitegers form n trhough m (including n and m). \n  oRund the answer to the nearest inetger and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  if (count === 0) {\n    return -1;\n  }\n  return sum / count;\n};\n\n/*You are given two opsitive integers n and m, and yoru taks is to compute the\n  average of the nitegers form n trhough m (including n and m). \n  oRund the answer to the nearest inetger and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  if (count === 0) {\n    return -1;\n  }\n  return sum / count;\n};\n\n/*You are given two opsitive integers n and m, and yoru taks is to compute the\n  average of the nitegers form n trhough m (including n and m). \n  oRund the answer to the nearest inetger and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  if (count === 0) {\n    return -1;\n  }\n  return sum / count;\n};\n\n/*You are given two opsitive integers n and m, and yoru taks is to compute the\n  average of the nitegers form n trhough m (including n and m). \n  oRund the answer to the nearest inetger and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  if (count === 0) {\n    return -1;\n  }\n  return sum / count;\n};\n\n/*You are given two opsitive integers n and m, and yoru taks is to compute the\n  average of the nitegers form n trhough m (including n and m). \n  oRund the answer to the nearest inetger and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  if (count === 0) {\n    return -1;\n  }\n  return sum / count;\n};\n\n/*You are given two opsitive integers n and m, and yoru taks is to compute the\n  average of the nitegers form n trhough m (including n and m). \n  oRund the answer to the nearest inetger and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  if (count === 0) {\n    return -1;\n  }\n  return sum / count;\n};\n\n/*You are given two opsitive integers n and m, and yoru taks is to compute the\n  average of the nitegers form n trhough m (including n and m). \n  oRund the answer to the nearest inetger and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  if (count === 0) {\n    return -1;\n  }\n  return sum / count;\n};\n\n/*You are given two opsitive integers n and m, and yoru taks is to compute the\n  average of the nitegers form n trhough m (including n and m). \n  oRund the answer to the nearest inetger and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  if (count === 0) {\n    return -1;\n  }\n  return sum / count;\n};\n\n/*You are given two opsitive integers n and m, and yoru taks is to compute the\n  average of the nitegers form n trhough m (including n and m). \n  oRund the answer to the nearest inetger and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = n; i <= m; i++) {\n    sum += i;\n    count++;\n  }\n  if (count === 0) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of lal \n  elements that hasn't any even digit.\n\n  Note: Returned list should eb sorted in incresaing odrer.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of lal \n  elements that hasn't any even digit.\n\n  Note: Returned list should eb sorted in incresaing odrer.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  const result = [];\n  \n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    \n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*Given a list of positive integers x. return a sorted list of lal \n  elements that hasn't any odd digit.\n\n  Note: Returned list should eb sorted in incresaing odrer.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsOdd = (x) => {\n  const result = [];\n  \n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    \n    if (digit % 2!== 0) {\n      result.push(digit);\n    }\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*Given a list of positive integers x. return a sorted list of lal \n  elements that hasn't any even digit and odd digit.\n\n  Note: Returned list should eb sorted in incresaing odrer.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsEvenOdd = (x) => {\n  const result = [];\n  \n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    \n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    }\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*Given a list of positive integers x. return a sorted list of lal \n  elements that hasn't any even digit and odd digit.\n\n  Note: Returned list should eb sorted in incresaing odrer.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsEvenOddOdd = (x) => {\n  const result = [];\n  \n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    \n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        if (digit % 2!== 0) {\n          result.push(digit);\n        }\n      }\n    }\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*Given a list of positive integers x. return a sorted list of lal \n  elements that hasn't any even digit and odd digit.\n\n  Note: Returned list should eb sorted in incresaing odrer.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsEvenOddOddOdd = (x) => {\n  const result = [];\n  \n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    \n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        if (digit % 2!== 0) {\n          if (digit % 2!== 0) {\n            result.push(digit);\n          }\n        }\n      }\n    }\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*Given a list of positive integers x. return a sorted list of lal \n  elements that hasn't any even digit and odd digit.\n\n  Note: Returned list should eb sorted in incresaing odrer.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsEvenOddOddOddOdd = (x) => {\n  const result = [];\n  \n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    \n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        if (digit % 2!== 0) {\n          if (digit % 2!== 0) {\n            if (digit % 2!== 0) {\n              result.push(digit);\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*Given a list of positive integers x. return a sorted list of lal \n  elements that hasn't any even digit and odd digit.\n\n  Note: Returned list should eb sorted in incresaing odrer.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsEvenOddOddOddOddOdd = (x) => {\n  const result = [];\n  \n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    \n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        if (digit % 2!== 0) {\n          if (digit % 2!== 0) {\n            if (digit % 2!== 0) {\n              if (digit % 2!== 0) {\n                if (digit % 2!== 0) {\n                  result.push(digit);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*Given a list of positive integers x. return a sorted list of lal \n  elements that hasn't any even digit and odd digit.\n\n  Note: Returned list should eb sorted in incresaing odrer.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsEvenOddOddOddOddOdd = (x) => {\n  const result = [];\n  \n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    \n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        if (digit % 2!== 0) {\n          if (digit % 2!== 0) {\n            if (digit % 2!== 0) {\n              if (digit % 2!== 0) {\n                if (digit % 2!== 0) {\n                  if (digit % 2!== 0) {\n                    if (digit % 2!== 0) {\n                      result.push(digit);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return result.sort((a, b) => a - b);\n};\n\n/*Given a list of positive integers x. return a sorted list of lal \n  elements that hasn't any even digit and odd digit.\n\n  Note: Returned list should eb sorted in incresaing odrer.\n  \n  For example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigitsEvenOddOddOddOddOddOdd = (x) => {\n  const result = [];\n  \n  for (let i = 0; i < x.length; i++) {\n    const digit = x[i];\n    \n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        if (digit % 2!== 0) {\n          if (digit % 2!== 0) {\n            if (digit % 2!== 0) {\n              if (digit % 2!== 0) {\n                if (digit % 2!== 0) {\n                  if (digit % 2!== 0) {\n                    if (digit % 2!== 0) {\n                      if (digit ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of niteegrs, sort the integers that are between 1 and 9 inclusive,\n  reevrse the reuslting array, and then replace each digit yb tis correspondnig name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of niteegrs, sort the integers that are between 1 and 9 inclusive,\n  reevrse the reuslting array, and then replace each digit yb tis correspondnig name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  if(arr.length === 0) return [];\n  \n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const ones = reversed.filter((num) => num === 1);\n  const tens = reversed.filter((num) => num === 10);\n  const hundreds = reversed.filter((num) => num === 100);\n  const thousands = reversed.filter((num) => num === 1000);\n  const tenThousands = reversed.filter((num) => num === 10000);\n  const oneThousands = reversed.filter((num) => num === 100000);\n  const oneHundreds = reversed.filter((num) => num === 1000000);\n  const oneThousandHundreds = reversed.filter((num) => num === 10000000);\n  const oneThousandThousands = reversed.filter((num) => num === 100000000);\n  const oneHundredThousands = reversed.filter((num) => num === 1000000000);\n  const oneThousandHundredThousands = reversed.filter((num) => num === 10000000000);\n  const oneThousandThousandHundreds = reversed.filter((num) => num === 100000000000);\n  const oneHundredThousandHundreds = reversed.filter((num) => num === 1000000000000);\n  const oneThousandThousandHundredThousands = reversed.filter((num) => num === 10000000000000);\n  const oneHundredThousandHundredThousands = reversed.filter((num) => num === 100000000000000);\n  const oneThousandThousandHundredThousandHundreds = reversed.filter((num) => num === 1000000000000000);\n  const oneHundredThousandHundredThousandHundreds = reversed.filter((num) => num === 10000000000000000);\n  const oneThousandThousandHundredThousandHundredThousands = reversed.filter((num) => num === 100000000000000000);\n  const oneHundredThousandHundredThousandHundredThousands = reversed.filter((num) => num === 1000000000000000000);\n  const oneThousandThousandHundredThousandHundredThousandHundreds = reversed.filter((num) => num === 10000000000000000000);\n  const oneHundredThousandHundredThousandHundredThousandHundredThousands = reversed.filter((num) => num === 100000000000000000000);\n  const oneThousandThousandHundredThousandHundredThousandHundredThousandHundreds = reversed.filter((num) => num === 1000000000000000000000);\n  const oneHundredThousandHundredThousandHundredThousandHundredThousandHundredThousands = reversed.filter((num) => num === 10000000000000000000000);\n  const oneThousandThousandHundredThousandHundredThousandHundredThousandHundredThousandHundreds = reversed.filter((num) => num === 100000000000000000000000);\n  const oneHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousands = reversed.filter((num) => num === 1000000000000000000000000);\n  const oneThousandThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundreds = reversed.filter((num) => num === 10000000000000000000000000);\n  const oneHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousands = reversed.filter((num) => num === 100000000000000000000000000);\n  const oneThousandThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundreds = reversed.filter((num) => num === 1000000000000000000000000000);\n  const oneHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousands = reversed.filter((num) => num === 10000000000000000000000000000);\n  const oneThousandThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundreds = reversed.filter((num) => num === 1000000000000000000000000000000);\n  const oneHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousands = reversed.filter((num) => num === 100000000000000000000000000000000);\n  const oneThousandThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundreds = reversed.filter((num) => num === 1000000000000000000000000000000000);\n  const oneHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousands = reversed.filter((num) => num === 10000000000000000000000000000000000);\n  const oneThousandThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundredThousandHundreds = reversed.filter((num) => num === 100000000000000000000000000000000000);\n  const oneHund", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implemetn the function f that takes n as a parmaeter,\n  and returns a list of size n, such that the vlaue of teh eleenmt at indxe i is the factorial of i if i is even\n  or the smu of nmubers form 1 to i otheriwse.\n  i starts from 1.\n  the factorial of i is hte multiplication of the unmbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Implemetn the function f that takes n as a parmaeter,\n  and returns a list of size n, such that the vlaue of teh eleenmt at indxe i is the factorial of i if i is even\n  or the smu of nmubers form 1 to i otheriwse.\n  i starts from 1.\n  the factorial of i is hte multiplication of the unmbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const res = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      res.push(1);\n    } else {\n      res.push(...Array(n - i).fill(0));\n    }\n  }\n  return res;\n};\n\n// TEST\nconst result = f(5);\nconsole.log(result);</code>\n<|/ a tags=factorial,arrays,javascript |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));</code>\n<|/ a tags=factorial,arrays,javascript |>\n<| a |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));</code>\n<|/ a dscore=0 tags=factorial,arrays,javascript |>\n<| a tags=factorial,arrays,javascript |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a tags=factorial,arrays,javascript |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a tags=factorial,arrays,javascript |>\n<| a tags=factorial,arrays,javascript |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a tags=factorial,arrays,javascript |>\n<| a |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a tags=factorial,arrays,javascript dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a tags=factorial,arrays,javascript |>\n<| a tags=factorial,arrays,javascript |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a dscore=0 |>\n<| a tags=factorial,arrays,javascript |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a dscore=0 |>\n<| a tags=factorial,arrays,javascript |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a dscore=0 |>\n<| a tags=factorial,arrays,javascript |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a dscore=0 |>\n<| a tags=factorial,arrays,javascript |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a tags=factorial,arrays,javascript |>\n<| c |>\nPlease don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes\n<|/ c |>\n<| a tags=factorial,arrays,javascript |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a dscore=0 tags=factorial,arrays,javascript |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a tags=factorial,arrays,javascript |>\n<| a tags=factorial,arrays,javascript |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a dscore=0 |>\n<| a tags=factorial,arrays,javascript |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a dscore=0 |>\n<| a tags=factorial,arrays,javascript |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction factorial(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nconsole.log(factorial(5));\n</code>\n<|/ a tags=factorial,", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even nad odd\n  integer palinrdomes that fall within the range(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number of even nad odd\n  integer palinrdomes that fall within the range(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n\n  for (let i = 1; i <= n; i++) {\n    const isEven = i % 2 === 0;\n    const isOdd =!isEven;\n\n    if (isEven) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n\n  return [evenPalindromes, oddPalindromes];\n};\n\nexport { evenOddPalindrome };\n\n/*\n  Given a positive integer n, return a tuple that has the number of even nad odd\n  integer palindromes that fall within the range(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n\n  for (let i = 1; i <= n; i++) {\n    const isEven = i % 2 === 0;\n    const isOdd =!isEven;\n\n    if (isEven) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n\n  return [evenPalindromes, oddPalindromes];\n};\n\nexport { evenOddPalindrome };\n\n/*\n  Given a positive integer n, return a tuple that has the number of even nad odd\n  integer palindromes that fall within the range(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n\n  for (let i = 1; i <= n; i++) {\n    const isEven = i % 2 === 0;\n    const isOdd =!isEven;\n\n    if (isEven) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n\n  return [evenPalindromes, oddPalindromes];\n};\n\nexport { evenOddPalindrome };\n\n/*\n  Given a positive integer n, return a tuple that has the number of even nad odd\n  integer palindromes that fall within the range(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n\n  for (let i = 1; i <= n; i++) {\n    const isEven = i % 2 === 0;\n    const isOdd =!isEven;\n\n    if (isEven) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n\n  return [evenPalindromes, oddPalindromes];\n};\n\nexport { evenOddPalindrome };\n\n/*\n  Given a positive integer n, return a tuple that has the number of even nad odd\n  integer palindromes that fall within the range(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n\n  for (let i = 1; i <= n; i++) {\n    const isEven = i % 2 === 0;\n    const isOdd =!isEven;\n\n    if (isEven) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n\n  return [evenPalindromes, oddPalindromes];\n};\n\nexport { evenOddPalindrome };\n\n/*\n  Given a positive integer n, return a tuple that has the number of even nad odd\n  integer palindromes that fall within the range(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n\n  for (let i = 1; i <= n; i++) {\n    const isEven = i % 2 === 0;\n    const isOdd =!isEven;\n\n    if (isEven) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a funciton countNums which takes an array of integers and reutrns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thne its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a funciton countNums which takes an array of integers and reutrns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, thne its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits([]) == 0\n  >>> sumDigits([-1, 11, -11]) == -1\n  >>> sumDigits([1, 1, 2]) == 3\n  */\nconst sumDigits = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits2 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits2([]) == 0\n  >>> sumDigits2([-1, 11, -11]) == -1\n  >>> sumDigits2([1, 1, 2]) == 3\n  */\nconst sumDigits2 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits3 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits3([]) == 0\n  >>> sumDigits3([-1, 11, -11]) == -1\n  >>> sumDigits3([1, 1, 2]) == 3\n  */\nconst sumDigits3 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits4 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits4([]) == 0\n  >>> sumDigits4([-1, 11, -11]) == -1\n  >>> sumDigits4([1, 1, 2]) == 3\n  */\nconst sumDigits4 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits5 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits5([]) == 0\n  >>> sumDigits5([-1, 11, -11]) == -1\n  >>> sumDigits5([1, 1, 2]) == 3\n  */\nconst sumDigits5 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits6 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits6([]) == 0\n  >>> sumDigits6([-1, 11, -11]) == -1\n  >>> sumDigits6([1, 1, 2]) == 3\n  */\nconst sumDigits6 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits7 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits7([]) == 0\n  >>> sumDigits7([-1, 11, -11]) == -1\n  >>> sumDigits7([1, 1, 2]) == 3\n  */\nconst sumDigits7 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits8 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits8([]) == 0\n  >>> sumDigits8([-1, 11, -11]) == -1\n  >>> sumDigits8([1, 1, 2]) == 3\n  */\nconst sumDigits8 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits9 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits9([]) == 0\n  >>> sumDigits9([-1, 11, -11]) == -1\n  >>> sumDigits9([1, 1, 2]) == 3\n  */\nconst sumDigits9 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits10 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits10([]) == 0\n  >>> sumDigits10([-1, 11, -11]) == -1\n  >>> sumDigits10([1, 1, 2]) == 3\n  */\nconst sumDigits10 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits11 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits11([]) == 0\n  >>> sumDigits11([-1, 11, -11]) == -1\n  >>> sumDigits11([1, 1, 2]) == 3\n  */\nconst sumDigits11 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits12 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits12([]) == 0\n  >>> sumDigits12([-1, 11, -11]) == -1\n  >>> sumDigits12([1, 1, 2]) == 3\n  */\nconst sumDigits12 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits13 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits13([]) == 0\n  >>> sumDigits13([-1, 11, -11]) == -1\n  >>> sumDigits13([1, 1, 2]) == 3\n  */\nconst sumDigits13 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits14 which takes an array of integers and returns\n  the sum of the digits in each number.\n  >>> sumDigits14([]) == 0\n  >>> sumDigits14([-1, 11, -11]) == -1\n  >>> sumDigits14([1, 1, 2]) == 3\n  */\nconst sumDigits14 = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] % 10;\n  }\n  return sum;\n};\n\n/*\n  Write a funciton sumDigits15 which takes an array of integer", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the arary will be randomly ordered. Yoru task is to dteermine if\n  it is possible ot get an array sotred in non-decresaing odrer by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any nmuber of tiems.\n  \n  One right shift opeartion means shifting all eleemnts of the array by one\n  postiion in the irght direction. The last element of the array will be moved to\n  the statring position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true lsee return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have nuique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the arary will be randomly ordered. Yoru task is to dteermine if\n  it is possible ot get an array sotred in non-decresaing odrer by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any nmuber of tiems.\n  \n  One right shift opeartion means shifting all eleemnts of the array by one\n  postiion in the irght direction. The last element of the array will be moved to\n  the statring position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true lsee return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have nuique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let n = arr.length;\n  \n  for(let i = 1; i < n; i++){\n    if(arr[i] > arr[i-1]){\n      for(let j = i; j > 0; j--){\n        arr[j] = arr[j-1];\n      }\n      arr[0] = arr[i-1];\n      i--;\n    }\n  }\n  return arr.length === 0;\n}\n\n/*\n  You are given an array arr of N integers. Your task is to find out the\n  number of ways of arranging the given array in non-decreasing order by\n  performing right shift operations.\n  \n  One right shift opeartion means shifting all eleemnts of the array by one\n  postiion in the irght direction. The last element of the array will be moved to\n  the statring position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true lsee return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have nuique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let n = arr.length;\n  \n  for(let i = 1; i < n; i++){\n    if(arr[i] > arr[i-1]){\n      for(let j = i; j > 0; j--){\n        arr[j] = arr[j-1];\n      }\n      arr[0] = arr[i-1];\n      i--;\n    }\n  }\n  return arr.length === 0;\n}\n\n/*\n  You are given an array arr of N integers. Your task is to find out the\n  number of ways of arranging the given array in non-decreasing order by\n  performing right shift operations.\n  \n  One right shift opeartion means shifting all eleemnts of the array by one\n  postiion in the irght direction. The last element of the array will be moved to\n  the statring position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true lsee return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have nuique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let n = arr.length;\n  \n  for(let i = 1; i < n; i++){\n    if(arr[i] > arr[i-1]){\n      for(let j = i; j > 0; j--){\n        arr[j] = arr[j-1];\n      }\n      arr[0] = arr[i-1];\n      i--;\n    }\n  }\n  return arr.length === 0;\n}\n\n/*\n  You are given an array arr of N integers. Your task is to find out the\n  number of ways of arranging the given array in non-decreasing order by\n  performing right shift operations.\n  \n  One right shift opeartion means shifting all eleemnts of the array by one\n  postiion in the irght direction. The last element of the array will be moved to\n  the statring position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true lsee return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have nuique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let n = arr.length;\n  \n  for(let i = 1; i < n; i++){\n    if(arr[i] > arr[i-1]){\n      for(let j = i; j > 0; j--){\n        arr[j] = arr[j-1];\n      }\n      arr[0] = arr[i-1];\n      i--;\n    }\n  }\n  return arr.length === 0;\n}\n\n/*\n  You are given an array arr of N integers. Your task is to find out the\n  number of ways of arranging the given array in non-decreasing order by\n  performing right shift operations.\n  \n  One right shift opeartion means shifting all eleemnts of the array by one\n  postiion in the irght direction. The last element of the array will be moved to\n  the statring position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true lsee return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have nuique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let n = arr.length;\n  \n  for(let i = 1; i < n; i++){\n    if(arr[i] > arr[i-1]){\n      for(let j = i; j > 0; j--){\n        arr[j] = arr[j-1];\n      }", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/11", "prompt": "/* Input rae two strings a and b consisting only of 1s and 0s.\n  Perform bianry XOR on htese inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input rae two strings a and b consisting only of 1s and 0s.\n  Perform bianry XOR on htese inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/* Input a binary string and return the decimal equivalent of it.\n  >>> binaryToDecimal('1100')\n  5\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    decimal += binaryToDecimalDigit(binary[i]);\n  }\n  return decimal;\n};\n\n/* Input a binary string and return the decimal equivalent of it.\n  >>> binaryToDecimalDigit('0')\n  0\n  */\nconst binaryToDecimalDigit = (binary) => {\n  if (binary === '0') {\n    return 0;\n  }\n  if (binary === '1') {\n    return 1;\n  }\n  return binaryToDecimalDigit(binary[0]) * 2 + binaryToDecimalDigit(binary[1]);\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinaryDigit = (decimal) => {\n  if (decimal < 2) {\n    return decimal.toString(2);\n  }\n  return decimalToBinaryDigit(decimal / 2) + decimal.toString(2);\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinary = (decimal) => {\n  const binary = decimalToBinaryDigit(decimal);\n  return binary;\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinary = function (decimal) {\n  const binary = decimalToBinary(decimal);\n  return binary;\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinaryDigit = function (decimal) {\n  const binary = decimalToBinaryDigit(decimal);\n  return binary;\n};\n\n/* Input a binary string and return the decimal equivalent of it.\n  >>> binaryToDecimal('1100')\n  5\n  */\nconst binaryToDecimalDigit = (binary) => {\n  if (binary === '0') {\n    return 0;\n  }\n  if (binary === '1') {\n    return 1;\n  }\n  return binaryToDecimalDigit(binary[0]) * 2 + binaryToDecimalDigit(binary[1]);\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinaryDigit = (decimal) => {\n  if (decimal < 2) {\n    return decimal.toString(2);\n  }\n  return decimalToBinaryDigit(decimal / 2) + decimal.toString(2);\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinary = (decimal) => {\n  const binary = decimalToBinaryDigit(decimal);\n  return binary;\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinary = function (decimal) {\n  const binary = decimalToBinary(decimal);\n  return binary;\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinaryDigit = function (decimal) {\n  const binary = decimalToBinaryDigit(decimal);\n  return binary;\n};\n\n/* Input a binary string and return the decimal equivalent of it.\n  >>> binaryToDecimal('1100')\n  5\n  */\nconst binaryToDecimalDigit = (binary) => {\n  if (binary === '0') {\n    return 0;\n  }\n  if (binary === '1') {\n    return 1;\n  }\n  return binaryToDecimalDigit(binary[0]) * 2 + binaryToDecimalDigit(binary[1]);\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinaryDigit = (decimal) => {\n  if (decimal < 2) {\n    return decimal.toString(2);\n  }\n  return decimalToBinaryDigit(decimal / 2) + decimal.toString(2);\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinary = (decimal) => {\n  const binary = decimalToBinaryDigit(decimal);\n  return binary;\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinaryDigit = function (decimal) {\n  const binary = decimalToBinaryDigit(decimal);\n  return binary;\n};\n\n/* Input a binary string and return the decimal equivalent of it.\n  >>> binaryToDecimal('1100')\n  5\n  */\nconst binaryToDecimalDigit = (binary) => {\n  if (binary === '0') {\n    return 0;\n  }\n  if (binary === '1') {\n    return 1;\n  }\n  return binaryToDecimalDigit(binary[0]) * 2 + binaryToDecimalDigit(binary[1]);\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinaryDigit = (decimal) => {\n  if (decimal < 2) {\n    return decimal.toString(2);\n  }\n  return decimalToBinaryDigit(decimal / 2) + decimal.toString(2);\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinary = (decimal) => {\n  const binary = decimalToBinaryDigit(decimal);\n  return binary;\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinaryDigit = function (decimal) {\n  const binary = decimalToBinaryDigit(decimal);\n  return binary;\n};\n\n/* Input a binary string and return the decimal equivalent of it.\n  >>> binaryToDecimal('1100')\n  5\n  */\nconst binaryToDecimalDigit = (binary) => {\n  if (binary === '0') {\n    return 0;\n  }\n  if (binary === '1') {\n    return 1;\n  }\n  return binaryToDecimalDigit(binary[0]) * 2 + binaryToDecimalDigit(binary[1]);\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinaryDigit = (decimal) => {\n  if (decimal < 2) {\n    return decimal.toString(2);\n  }\n  return decimalToBinaryDigit(decimal / 2) + decimal.toString(2);\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinary = (decimal) => {\n  const binary = decimalToBinaryDigit(decimal);\n  return binary;\n};\n\n/* Input a decimal number and return the binary equivalent of it.\n  >>> decimalToBinaryDigit(5)\n  '1100'\n  */\nconst decimalToBinaryDigit = function (decimal) {\n  const binary = decimalToBinaryDigit(decimal);\n  return binary;\n};\n\n/* Input a binary string and return the decimal equivalent of it.\n  >>> binaryToDecimal('1100')\n  5\n  */\nconst binaryToDecimalDigit = (binary) => {\n  if (binary === '0') {\n    return 0;\n  }\n  if (binary === '1') {\n    return 1;\n  }\n  return binaryToDecimalDigit(binary[0]) * 2 + binaryToDecimalDigit(binary[1]);\n};\n\n/* Input a decimal number and ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possilbe to perform an exchange of elements\n  betewen them to make lst1 a list of only veen numbers.\n  There is no limit on the number of exchanged elements bewteen lst1 and lst2.\n  If it is possible to exchange elements betwene the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otehrwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possilbe to perform an exchange of elements\n  betewen them to make lst1 a list of only veen numbers.\n  There is no limit on the number of exchanged elements bewteen lst1 and lst2.\n  If it is possible to exchange elements betwene the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otehrwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even.push(lst1[i])\n    } else {\n      odd.push(lst1[i])\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even.push(lst2[i])\n    } else {\n      odd.push(lst2[i])\n    }\n  }\n  if (even.length!== lst1.length && odd.length!== lst2.length) {\n    return \"NO\"\n  }\n  if (even.length!== lst1.length) {\n    return \"NO\"\n  }\n  if (odd.length!== lst2.length) {\n    return \"NO\"\n  }\n  for (let i = 0; i < even.length; i++) {\n    if (even[i] > odd[i]) {\n      return \"NO\"\n    }\n  }\n  return \"YES\"\n}\n\n/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possilbe to perform an exchange of elements\n  betewen them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchanged elements bewteen lst1 and lst2.\n  If it is possible to exchange elements betwene the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otehrwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchangeEven = (lst1, lst2) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even.push(lst1[i])\n    } else {\n      odd.push(lst1[i])\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even.push(lst2[i])\n    } else {\n      odd.push(lst2[i])\n    }\n  }\n  if (even.length!== lst1.length && odd.length!== lst2.length) {\n    return \"NO\"\n  }\n  if (even.length!== lst1.length) {\n    return \"NO\"\n  }\n  if (odd.length!== lst2.length) {\n    return \"NO\"\n  }\n  for (let i = 0; i < even.length; i++) {\n    if (even[i] < odd[i]) {\n      return \"NO\"\n    }\n  }\n  return \"YES\"\n}\n\n/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possilbe to perform an exchange of elements\n  betewen them to make lst1 a list of only odd numbers.\n  There is no limit on the number of exchanged elements bewteen lst1 and lst2.\n  If it is possible to exchange elements betwene the lst1 and lst2 to make\n  all the elements of lst1 to be odd, return \"YES\".\n  Otehrwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchangeOdd = (lst1, lst2) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even.push(lst1[i])\n    } else {\n      odd.push(lst1[i])\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even.push(lst2[i])\n    } else {\n      odd.push(lst2[i])\n    }\n  }\n  if (even.length!== lst1.length && odd.length!== lst2.length) {\n    return \"NO\"\n  }\n  if (even.length!== lst1.length) {\n    return \"NO\"\n  }\n  if (odd.length!== lst2.length) {\n    return \"NO\"\n  }\n  for (let i = 0; i < even.length; i++) {\n    if (even[i] > odd[i]) {\n      return \"NO\"\n    }\n  }\n  return \"YES\"\n}\n\n/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possilbe to perform an exchange of elements\n  betewen them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchanged elements bewteen lst1 and lst2.\n  If it is possible to exchange elements betwene the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otehrwise, return \"NO\".\n  For example:\n  exchangeEven([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchangeEven([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchangeEvenOdd = (lst1, lst2) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even.push(lst1[i])\n    } else {\n      odd.push(lst1[i])\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even.push(lst2[i])\n    } else {\n      odd.push(lst2[i])\n    }\n  }\n  if (even.length!== lst1.length && odd.length!== lst2.length) {\n    return \"NO\"\n  }\n  if (even.length!== lst1.length) {\n    return \"NO\"\n  }\n  if (odd.length!== lst2.length) {\n    return \"NO\"\n  }\n  for (let i = 0; i < even.length; i++) {\n    if (even[i] < odd[i]) {\n      return \"NO\"\n    }\n  }\n  return \"YES\"\n}\n\n/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possilbe to perform an exchange of elements\n  betewen them to make lst1 a list of only odd numbers.\n  There is no limit on the number of exchanged elements bewteen lst1 and lst2.\n  If it is possible to exchange elements betwene the lst1 and lst2 to make\n  all the elements of lst1 to be odd, return \"YES\".\n  Otehrwise, return \"NO\".\n  For example:\n  exchangeOdd([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchangeOdd([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchangeOddEven = (lst1, lst2) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even.push(lst1[i])\n    } else {\n      odd.push(lst1[i])\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even.push(lst2[i])\n    } else {\n      odd.push(lst2[i])\n    }\n  }\n  if (even.length!== lst1.length && odd.length!== lst2.length) {\n    return \"NO\"\n  }", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a strign representing a spaec separatde loerwcase letters, return a dictionray\n  of the letter with the most repetitoin and containing hte corresponding count.\n  fI several letters have eth same occurrence, return all of thme.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a strign representing a spaec separatde loerwcase letters, return a dictionray\n  of the letter with the most repetitoin and containing hte corresponding count.\n  fI several letters have eth same occurrence, return all of thme.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a dictionary representing a histogram of letters, return a dictionary \n  of the letter with the most repetitoin and containing hte corresponding count.\n  fI several letters have eth same occurrence, return all of thme.\n  \n  Example:\n  histogram({'a': 1, 'b': 1, 'c': 1}) == {'a': 1, 'b': 1, 'c': 1}\n  histogram({'a': 2, 'b': 2}) == {'a': 2, 'b': 2}\n  histogram({'a': 2, 'b': 2, 'c': 1}) == {'a': 2, 'b': 2}\n  histogram({'b': 4}) == {'b': 4}\n  histogram({}) == {}\n\n  */\nconst mostFrequent = (histogram) => {\n  let mostFrequent = {}\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      if (mostFrequent.hasOwnProperty(key) && histogram[key] > mostFrequent[key]) {\n        mostFrequent[key] = histogram[key]\n      }\n    }\n  }\n  return mostFrequent\n}\n\n/*Given a dictionary representing a histogram of letters, return a dictionary \n  of the letter with the most repetitoin and containing hte corresponding count.\n  fI several letters have eth same occurrence, return all of thme.\n  \n  Example:\n  histogram({'a': 1, 'b': 1, 'c': 1}) == {'a': 1, 'b': 1, 'c': 1}\n  histogram({'a': 2, 'b': 2}) == {'a': 2, 'b': 2}\n  histogram({'a': 2, 'b': 2, 'c': 1}) == {'a': 2, 'b': 2}\n  histogram({'b': 4}) == {'b': 4}\n  histogram({}) == {}\n\n  */\nconst mostFrequentLetter = (histogram) => {\n  let mostFrequent = {}\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      if (mostFrequent.hasOwnProperty(key) && histogram[key] > mostFrequent[key]) {\n        mostFrequent[key] = key\n      }\n    }\n  }\n  return mostFrequent\n}\n\n/*Given a dictionary representing a histogram of letters, return a dictionary \n  of the letter with the most repetitoin and containing hte corresponding count.\n  fI several letters have eth same occurrence, return all of thme.\n  \n  Example:\n  histogram({'a': 1, 'b': 1, 'c': 1}) == {'a': 1, 'b': 1, 'c': 1}\n  histogram({'a': 2, 'b': 2}) == {'a': 2, 'b': 2}\n  histogram({'a': 2, 'b': 2, 'c': 1}) == {'a': 2, 'b': 2}\n  histogram({'b': 4}) == {'b': 4}\n  histogram({}) == {}\n\n  */\nconst mostFrequentLetters = (histogram) => {\n  let mostFrequent = {}\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      if (mostFrequent.hasOwnProperty(key) && histogram[key] > mostFrequent[key]) {\n        mostFrequent[key] = key\n      }\n    }\n  }\n  return mostFrequent\n}\n\n/*Given a dictionary representing a histogram of letters, return a dictionary \n  of the letter with the most repetitoin and containing hte corresponding count.\n  fI several letters have eth same occurrence, return all of thme.\n  \n  Example:\n  histogram({'a': 1, 'b': 1, 'c': 1}) == {'a': 1, 'b': 1, 'c': 1}\n  histogram({'a': 2, 'b': 2}) == {'a': 2, 'b': 2}\n  histogram({'a': 2, 'b': 2, 'c': 1}) == {'a': 2, 'b': 2}\n  histogram({'b': 4}) == {'b': 4}\n  histogram({}) == {}\n\n  */\nconst mostFrequentLettersCount = (histogram) => {\n  let mostFrequent = {}\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      if (mostFrequent.hasOwnProperty(key) && histogram[key] > mostFrequent[key]) {\n        mostFrequent[key] = key\n      }\n    }\n  }\n  return mostFrequent\n}\n\n/*Given a dictionary representing a histogram of letters, return a dictionary \n  of the letter with the most repetitoin and containing hte corresponding count.\n  fI several letters have eth same occurrence, return all of thme.\n  \n  Example:\n  histogram({'a': 1, 'b': 1, 'c': 1}) == {'a': 1, 'b': 1, 'c': 1}\n  histogram({'a': 2, 'b': 2}) == {'a': 2, 'b': 2}\n  histogram({'a': 2, 'b': 2, 'c': 1}) == {'a': 2, 'b': 2}\n  histogram({'b': 4}) == {'b': 4}\n  histogram({}) == {}\n\n  */\nconst mostFrequentLettersCounts = (histogram) => {\n  let mostFrequent = {}\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      if (mostFrequent.hasOwnProperty(key) && histogram[key] > mostFrequent[key]) {\n        mostFrequent[key] = key\n      }\n    }\n  }\n  return mostFrequent\n}\n\n/*Given a dictionary representing a histogram of letters, return a dictionary \n  of the letter with the most repetitoin and containing hte corresponding count.\n  fI several letters have eth same occurrence, return all of thme.\n  \n  Example:\n  histogram({'a': 1, 'b': 1, 'c': 1}) == {'a': 1, 'b': 1, 'c': 1}\n  histogram({'a': 2, 'b': 2}) == {'a': 2, 'b': 2}\n  histogram({'a': 2, 'b': 2, 'c': 1}) == {'a': 2, 'b': 2}\n  histogram({'b': 4}) == {'b': 4}\n  histogram({}) == {}\n\n  */\nconst mostFrequentLettersCount = (histogram) => {\n  let mostFrequent = {}\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      if (mostFrequent.hasOwnProperty(key) && histogram[key] > mostFrequent[key]) {\n        mostFrequent[key] = key\n      }\n    }\n  }\n  return mostFrequent\n}\n\n/*Given a dictionary representing a histogram of letters, return a dictionary \n  of the letter with the most repetitoin and containing hte corresponding count.\n  fI several letters have eth same occurrence, return all of thme.\n  \n  Example:\n  histogram({'a': 1, 'b': 1, 'c': 1}) == {'a': 1, 'b': 1, 'c': 1}\n  histogram({'a': 2, 'b': 2}) == {'a': 2, 'b': 2}\n  histogram({'a': 2, 'b': 2, 'c': 1}) == {'a': 2, 'b': 2}\n  histogram({'b': 4}) == {'b': 4}\n  histogram({}) == {}\n\n  */\nconst mostFrequentLettersCounts = (histogram) => {\n  let mostFrequent = {}\n  for (let key in histogram) {\n    if (histogram.hasOwnProperty(key)) {\n      if (mostFrequent.hasOwnProperty(key) && histogram[key] > mostFrequent[key]) {\n        mostFrequent[key] = key\n      }\n    }\n  }\n  return mostFrequent\n}\n\n/*Given a dictionary representing a histogram of letters, return a dictionary \n  of the letter with the most repetitoin and containing hte corresponding count.\n  fI several letters have eth same occurrence, return all of thme.\n  \n  Example:\n  histogram({'a': 1, 'b': 1, 'c': 1}) == {'a': 1, 'b': 1, 'c': 1}\n  histogram({'a': 2, 'b': 2}) == {'a': 2, 'b': 2}\n  histogram({'a': 2, 'b': 2, 'c': 1}) == {'a': 2, 'b': 2}\n  histogram({'b': 4}) == {'b': 4}\n  histogram({}) == {}\n\n  */\nconst ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s taht are euqal to any character in c\n  then check if the result string is palinrdome.\n  A string is aclled palindrome if it reads the same backward as forward.\n  You should return a tuple ctonaining the result stirng and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have to deleted all the characters in s taht are euqal to any character in c\n  then check if the result string is palinrdome.\n  A string is aclled palindrome if it reads the same backward as forward.\n  You should return a tuple ctonaining the result stirng and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let newS = \"\";\n  let newC = \"\";\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      newS += s[i];\n    }\n  }\n  for (let i = 0; i < c.length; i += 1) {\n    if (newS.includes(c[i])) {\n      newS += c[i];\n    }\n  }\n  return [newS, newS === newS.reverse()];\n};\n\n/*Task\n  You are given a string s and a number k. You have to delete all the characters in s taht are less than or equal to k then check if the result string is palindrome.\n  A string is aclled palindrome if it reads the same backward as forward.\n  You should return a tuple ctonaining the result stirng and true/false for the check.\n  Example\n  For s = \"abcde\", k = 3, the result should be ('abcde',true)\n  For s = \"abcde\", k = 2  the result should be ('abcde',false)\n  For s = \"abcde\", k = 1  the result should be ('abcde',false)\n  For s = \"abcde\", k = 0  the result should be ('abcde',false)\n  For s = \"abcde\", k = -1  the result should be ('abcde',false)\n  For s = \"abcde\", k = -2  the result should be ('abcde',false)\n  For s = \"abcde\", k = -5  the result should be ('abcde',false)\n  For s = \"abcde\", k = -6  the result should be ('abcde',false)\n  For s = \"abcde\", k = -7  the result should be ('abcde',false)\n  For s = \"abcde\", k = -8  the result should be ('abcde',false)\n  For s = \"abcde\", k = -9  the result should be ('abcde',false)\n  For s = \"abcde\", k = -10  the result should be ('abcde',false)\n  For s = \"abcde\", k = -11  the result should be ('abcde',false)\n  For s = \"abcde\", k = -12  the result should be ('abcde',false)\n  For s = \"abcde\", k = -13  the result should be ('abcde',false)\n  For s = \"abcde\", k = -14  the result should be ('abcde',false)\n  For s = \"abcde\", k = -15  the result should be ('abcde',false)\n  For s = \"abcde\", k = -16  the result should be ('abcde',false)\n  For s = \"abcde\", k = -17  the result should be ('abcde',false)\n  For s = \"abcde\", k = -18  the result should be ('abcde',false)\n  For s = \"abcde\", k = -19  the result should be ('abcde',false)\n  For s = \"abcde\", k = -20  the result should be ('abcde',false)\n  For s = \"abcde\", k = -21  the result should be ('abcde',false)\n  For s = \"abcde\", k = -22  the result should be ('abcde',false)\n  For s = \"abcde\", k = -23  the result should be ('abcde',false)\n  For s = \"abcde\", k = -24  the result should be ('abcde',false)\n  For s = \"abcde\", k = -25  the result should be ('abcde',false)\n  For s = \"abcde\", k = -26  the result should be ('abcde',false)\n  For s = \"abcde\", k = -27  the result should be ('abcde',false)\n  For s = \"abcde\", k = -28  the result should be ('abcde',false)\n  For s = \"abcde\", k = -29  the result should be ('abcde',false)\n  For s = \"abcde\", k = -30  the result should be ('abcde',false)\n  For s = \"abcde\", k = -31  the result should be ('abcde',false)\n  For s = \"abcde\", k = -32  the result should be ('abcde',false)\n  For s = \"abcde\", k = -33  the result should be ('abcde',false)\n  For s = \"abcde\", k = -34  the result should be ('abcde',false)\n  For s = \"abcde\", k = -35  the result should be ('abcde',false)\n  For s = \"abcde\", k = -36  the result should be ('abcde',false)\n  For s = \"abcde\", k = -37  the result should be ('abcde',false)\n  For s = \"abcde\", k = -38  the result should be ('abcde',false)\n  For s = \"abcde\", k = -39  the result should be ('abcde',false)\n  For s = \"abcde\", k = -40  the result should be ('abcde',false)\n  For s = \"abcde\", k = -41  the result should be ('abcde',false)\n  For s = \"abcde\", k = -42  the result should be ('abcde',false)\n  For s = \"abcde\", k = -43  the result should be ('abcde',false)\n  For s = \"abcde\", k = -44  the result should be ('abcde',false)\n  For s = \"abcde\", k = -45  the result should be ('abcde',false)\n  For s = \"abcde\", k = -46  the result should be ('abcde',false)\n  For s = \"abcde\", k = -47  the result should be ('abcde',false)\n  For s = \"abcde\", k = -48  the result should be ('abcde',false)\n  For s = \"abcde\", k = -49  the result should be ('abcde',false)\n  For s = \"abcde\", k = -50  the result should be ('abcde',false)\n  For s = \"abcde\", k = -51  the result should be ('abcde',false)\n  For s = \"abcde\", k = -52  the result should be ('abcde',false)\n  For s = \"abcde\", k = -53  the result should be ('abcde',false)\n  For s = \"abcde\", k = -54  the result should be ('abcde',false)\n  For s = \"abcde\", k = -55  the result should be ('abcde',false)\n  For s = \"abcde\", k = -56  the result should be ('abcde',false)\n  For s = \"abcde\", k = -57  the result should be ('abcde',false)\n  For s = \"abcde\", k = -58  the result should be ('abcde',false)\n  For s = \"abcde\", k = -59  the result should be ('abcde',false)\n  For s = \"abcde\", k = -60  the result should be ('abcde',false)\n  For s = \"abcde\", k = -61  the result should be ('abcde',false)\n  For s = \"abcde\", k = -62  the result should be ('abcde',false)\n  For s = \"abcde\", k = -63  the result should be ('abcde',false)\n  For s = \"abcde\", k = -64  the result should be ('abcde',false)\n  For s = \"abcde\", k = -65  the result should be ('abcde',false", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each tsring consists of onyl idigts, return a list.\n  Each element i of the outptu shuold be \"the number fo odd elements in the\n  string i of the input.\" where all hte i's shoudl eb replaced by the number\n  of odd digits in the i'th string of the ipnut.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a list of strings, where each tsring consists of onyl idigts, return a list.\n  Each element i of the outptu shuold be \"the number fo odd elements in the\n  string i of the input.\" where all hte i's shoudl eb replaced by the number\n  of odd digits in the i'th string of the ipnut.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let count = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2 === 0) {\n        count++;\n      }\n    }\n    oddCountArr.push(count);\n  }\n  return oddCountArr;\n};\n\n/*Given a list of strings, where each tsring consists of onyl idigts, return a list.\n  Each element i of the outptu shuold be \"the number fo even elements in the\n  string i of the input.\" where all hte i's shoudl eb replaced by the number\n  of even digits in the i'th string of the ipnut.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let count = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2!== 0) {\n        count++;\n      }\n    }\n    evenCountArr.push(count);\n  }\n  return evenCountArr;\n};\n\n/*Given a list of strings, where each tsring consists of onyl idigts, return a list.\n  Each element i of the outptu shuold be \"the number fo even elements in the\n  string i of the input.\" where all hte i's shoudl eb replaced by the number\n  of even digits in the i'th string of the ipnut.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let count = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2!== 0) {\n        count++;\n      }\n    }\n    evenCountArr.push(count);\n  }\n  return evenCountArr;\n};\n\n/*Given a list of strings, where each tsring consists of onyl idigts, return a list.\n  Each element i of the outptu shuold be \"the number fo even elements in the\n  string i of the input.\" where all hte i's shoudl eb replaced by the number\n  of even digits in the i'th string of the ipnut.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let count = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2!== 0) {\n        count++;\n      }\n    }\n    evenCountArr.push(count);\n  }\n  return evenCountArr;\n};\n\n/*Given a list of strings, where each tsring consists of onyl idigts, return a list.\n  Each element i of the outptu shuold be \"the number fo even elements in the\n  string i of the input.\" where all hte i's shoudl eb replaced by the number\n  of even digits in the i'th string of the ipnut.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let count = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2!== 0) {\n        count++;\n      }\n    }\n    evenCountArr.push(count);\n  }\n  return evenCountArr;\n};\n\n/*Given a list of strings, where each tsring consists of onyl idigts, return a list.\n  Each element i of the outptu shuold be \"the number fo even elements in the\n  string i of the input.\" where all hte i's shoudl eb replaced by the number\n  of even digits in the i'th string of the ipnut.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let count = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2!== 0) {\n        count++;\n      }\n    }\n    evenCountArr.push(count);\n  }\n  return evenCountArr;\n};\n\n/*Given a list of strings, where each tsring consists of onyl idigts, return a list.\n  Each element i of the outptu shuold be \"the number fo even elements in the\n  string i of the input.\" where all hte i's shoudl eb replaced by the number\n  of even digits in the i'th string of the ipnut.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let count = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2!== 0) {\n        count++;\n      }\n    }\n    evenCountArr.push(count);\n  }\n  return evenCountArr;\n};\n\n/*Given a list of strings, where each tsring consists of onyl idigts, return a list.\n  Each element ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an arrya fo integers nums, find the minimum sum of nay non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an arrya fo integers nums, find the minimum sum of nay non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let min = Number.MAX_SAFE_INTEGER;\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < min) {\n      min = sum;\n    }\n  }\n  return min;\n};\n\n/*\n  Given an arrya fo integers nums, find the maximum sum of nay non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 6\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst maxSubArraySum = (nums) => {\n  let max = Number.MIN_SAFE_INTEGER;\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > max) {\n      max = sum;\n    }\n  }\n  return max;\n};\n\n/*\n  Given an arrya fo integers nums, find the maximum product of nay non-empty sub-array\n  of nums.\n  Example\n  maxSubArrayProduct([2, 3, 4, 1, 2, 4]) == 24\n  maxSubArrayProduct([-1, -2, -3]) == -6\n  */\nconst maxSubArrayProduct = (nums) => {\n  let max = Number.MIN_SAFE_INTEGER;\n  let prod = 1;\n  for (let i = 0; i < nums.length; i++) {\n    prod *= nums[i];\n    if (prod > max) {\n      max = prod;\n    }\n  }\n  return max;\n};\n\n/*\n  Given an arrya fo integers nums, find the minimum product of nay non-empty sub-array\n  of nums.\n  Example\n  minSubArrayProduct([2, 3, 4, 1, 2, 4]) == 24\n  minSubArrayProduct([-1, -2, -3]) == -6\n  */\nconst minSubArrayProduct = (nums) => {\n  let min = Number.MAX_SAFE_INTEGER;\n  let prod = 1;\n  for (let i = 0; i < nums.length; i++) {\n    prod *= nums[i];\n    if (prod < min) {\n      min = prod;\n    }\n  }\n  return min;\n};\n\n/*\n  Given an arrya fo integers nums, find the sum of all integers in nums.\n  Example\n  sumOfArray([1, 2, 3, 4, 5]) == 15\n  sumOfArray([-1, -2, -3]) == 3\n  */\nconst sumOfArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/*\n  Given an arrya fo integers nums, find the product of all integers in nums.\n  Example\n  productOfArray([1, 2, 3, 4, 5]) == 120\n  productOfArray([-1, -2, -3]) == -6\n  */\nconst productOfArray = (nums) => {\n  let prod = 1;\n  for (let i = 0; i < nums.length; i++) {\n    prod *= nums[i];\n  }\n  return prod;\n};\n\n/*\n  Given an arrya fo integers nums, find the sum of all integers in nums whose squares are less than or equal to n.\n  Example\n  sumOfArrayLessThanOrEqualToN([1, 2, 3, 4, 5], 3) == 6\n  sumOfArrayLessThanOrEqualToN([-1, -2, -3], 3) == 3\n  */\nconst sumOfArrayLessThanOrEqualToN = (nums, n) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] <= n) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an arrya fo integers nums, find the product of all integers in nums whose squares are less than or equal to n.\n  Example\n  productOfArrayLessThanOrEqualToN([1, 2, 3, 4, 5], 3) == 24\n  productOfArrayLessThanOrEqualToN([-1, -2, -3], 3) == -6\n  */\nconst productOfArrayLessThanOrEqualToN = (nums, n) => {\n  let prod = 1;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] <= n) {\n      prod *= nums[i];\n    }\n  }\n  return prod;\n};\n\n/*\n  Given an arrya fo integers nums, find the sum of all integers in nums whose squares are greater than n.\n  Example\n  sumOfArrayGreaterThanN([1, 2, 3, 4, 5], 3) == 9\n  sumOfArrayGreaterThanN([-1, -2, -3], 3) == 3\n  */\nconst sumOfArrayGreaterThanN = (nums, n) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > n) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an arrya fo integers nums, find the product of all integers in nums whose squares are greater than n.\n  Example\n  productOfArrayGreaterThanN([1, 2, 3, 4, 5], 3) == 120\n  productOfArrayGreaterThanN([-1, -2, -3], 3) == -6\n  */\nconst productOfArrayGreaterThanN = (nums, n) => {\n  let prod = 1;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > n) {\n      prod *= nums[i];\n    }\n  }\n  return prod;\n};\n\n/*\n  Given an arrya fo integers nums, find the sum of all integers in nums whose squares are less than n.\n  Example\n  sumOfArrayLessThanN([1, 2, 3, 4, 5], 3) == 6\n  sumOfArrayLessThanN([-1, -2, -3], 3) == 3\n  */\nconst sumOfArrayLessThanN = (nums, n) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < n) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an arrya fo integers nums, find the product of all integers in nums whose squares are less than n.\n  Example\n  productOfArrayLessThanN([1, 2, 3, 4, 5], 3) == 24\n  productOfArrayLessThanN([-1, -2, -3], 3) == -6\n  */\nconst productOfArrayLessThanN = (nums, n) => {\n  let prod = 1;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < n) {\n      prod *= nums[i];\n    }\n  }\n  return prod;\n};\n\n/*\n  Given an arrya fo integers nums, find the sum of all integers in nums whose squares are greater than or equal to n.\n  Example\n  sumOfArrayGreaterThanOrEqualToN([1, 2, 3, 4, 5], 3) == 9\n  sumOfArrayGreaterThanOrEqualToN([-1, -2, -3], 3) == 3\n  */\nconst sumOfArrayGreaterThanOrEqualToN = (nums, n) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= n) {\n      sum += nums[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an arrya fo integers nums, find the product of all integers in nums whose squares are greater than or equal to n.\n  Example\n  productOfArrayGreaterThanOrEqualToN([1, 2, 3, 4, 5], 3) == 120\n  productOfArrayGreaterThanOrEqualToN([-1, -2, -3], 3) == -6\n  */\nconst productOfArrayGreaterThanOrEqualToN = (nums, n) => {\n  let prod = 1;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= n) {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangluar grid fo wells. Each row repreesnts a singel well,\n  adn each 1 in a row repersenst a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all bucekts have the same capacity.\n  Your task is to use the buckets to empty hte wells.\n  Output the number of times you ende to lower the ubckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a rectangluar grid fo wells. Each row repreesnts a singel well,\n  adn each 1 in a row repersenst a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all bucekts have the same capacity.\n  Your task is to use the buckets to empty hte wells.\n  Output the number of times you ende to lower the ubckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const buckets = new Array(capacity).fill(0);\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        buckets[grid[i][j]] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < buckets.length; i++) {\n    if (buckets[i] <= 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\nconsole.log(maxFill(grid, 1));\nconsole.log(maxFill(grid, 2));\nconsole.log(maxFill(grid, 5));\nconsole.log(maxFill(grid, 10));</code>\n<|/ a tags=arrays,algorithm,javascript |>\n<| c |>\nThis doesn't seem to work. Try it on the example I gave in the question. `[[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]` returns `5` instead of `6`.\n<|/ c |>\n<| c |>\nI fixed the bug, please check it again.\n<|/ c |>\n<| c |>\nI fixed the bug, please check it again.\n<|/ c |>\n<| c |>\nI fixed the bug, please check it again.\n<|/ c |>\n<| a |>\n<code>\nfunction maxFill(grid, capacity) {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += 1;\n      }\n    }\n  }\n  let buckets = new Array(capacity).fill(0);\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        buckets[grid[i][j]] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < buckets.length; i++) {\n    if (buckets[i] <= 0) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nconsole.log(maxFill(grid, 1));\nconsole.log(maxFill(grid, 2));\nconsole.log(maxFill(grid, 5));\nconsole.log(maxFill(grid, 10));</code>\n<|/ a tags=arrays,algorithm,javascript dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction maxFill(grid, capacity) {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += 1;\n      }\n    }\n  }\n  let buckets = new Array(capacity).fill(0);\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        buckets[grid[i][j]] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < buckets.length; i++) {\n    if (buckets[i] <= 0) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nconsole.log(maxFill(grid, 1));\nconsole.log(maxFill(grid, 2));\nconsole.log(maxFill(grid, 5));\nconsole.log(maxFill(grid, 10));</code>\n<|/ a tags=arrays,algorithm,javascript |>\n<| a dscore=0 |>\n<code>\nfunction maxFill(grid, capacity) {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += 1;\n      }\n    }\n  }\n  let buckets = new Array(capacity).fill(0);\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        buckets[grid[i][j]] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < buckets.length; i++) {\n    if (buckets[i] <= 0) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nconsole.log(maxFill(grid, 1));\nconsole.log(maxFill(grid, 2));\nconsole.log(maxFill(grid, 5));\nconsole.log(maxFill(grid, 10));</code>\n<|/ a tags=arrays,algorithm,javascript |>\n<| a dscore=0 |>\n<code>\nfunction maxFill(grid, capacity) {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += 1;\n      }\n    }\n  }\n  let buckets = new Array(capacity).fill(0);\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        buckets[grid[i][j]] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < buckets.length; i++) {\n    if (buckets[i] <= 0) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nconsole.log(maxFill(grid, 1));\nconsole.log(maxFill(grid, 2));\nconsole.log(maxFill(grid, 5));\nconsole.log(maxFill(grid, 10));</code>\n<|/ a tags=arrays,algorithm,javascript |>\n<| c |>\nPlease don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxFill(grid, capacity) {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += 1;\n      }\n    }\n  }\n  let buckets = new Array(capacity).fill(0);\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        buckets[grid[i][j]] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < buckets.length; i++) {\n    if (buckets[i] <= 0) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nconsole.log(maxFill(grid, 1));\nconsole.log(maxFill(grid, 2));\nconsole.log(maxFill(grid, 5));\nconsole.log(maxFill(grid, 10));</code>\n<|/ a tags=arrays,algorithm,javascript |>\n<| c |>\nPlease don't post only code as an answer, but also provide an explanation of what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxFill(grid, capacity) {\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += 1;\n      }\n    }\n  }\n  let buckets = new Array(capacity).fill(0);\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        buckets[grid[i][j]] += 1;\n      }\n    }\n  }\n  let count = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  nbumer of nose in their bianyr reprseentation in ascending order.\n  For similar number of ones, sort based on decimal avlue.\n\n  It must be imlpemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  nbumer of nose in their bianyr reprseentation in ascending order.\n  For similar number of ones, sort based on decimal avlue.\n\n  It must be imlpemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let nbumber = 0;\n  let nbones = 0;\n  let arr2 = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) arr2.push(arr[i]);\n    if (arr[i] == 1) nbones++;\n    if (arr[i] == 0) nbumber++;\n  }\n  if (nbones > nbumber) {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] == 1) arr2.push(arr[i]);\n    }\n  } else {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] == 0) arr2.push(arr[i]);\n    }\n  }\n  return arr2;\n};\n\n// Tests\nconst tests = [\n  {\n    name: \"sortArray\",\n    tests: [\n      {\n        name: \"should sort array ascending\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {\n        name: \"should sort array descending if there are more ones\",\n        fn: sortArray,\n        args: [-2, -3, -4, -5, -6],\n        exp: [-6, -5, -4, -3, -2]\n      },\n      {\n        name: \"should sort array ascending if there are more ones\",\n        fn: sortArray,\n        args: [1, 5, 2, 3, 4],\n        exp: [1, 2, 3, 4, 5]\n      },\n      {", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a strnig s and a ntaural number n, you have been tasked to implmeent \n  a function that returns a list of all words from srting s that cotnain exactly \n  n consonants, in order these words appear in the string s.\n  If the tsring s is empty then the function hsould return an empty list.\n  Note: you may assume hte input string contains only letetrs and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a strnig s and a ntaural number n, you have been tasked to implmeent \n  a function that returns a list of all words from srting s that cotnain exactly \n  n consonants, in order these words appear in the string s.\n  If the tsring s is empty then the function hsould return an empty list.\n  Note: you may assume hte input string contains only letetrs and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  const result = [];\n  let i = 0;\n  while (i < s.length && n > 0) {\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n    }\n    if (s.charAt(i) === \" \") {\n      i++;\n      continue;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to fndi the closest vowel that stands between \n  two consonants from the right side of the word (caes sensitive).\n  \n  Vowels in the beginning and ending doesn't ocunt. Rteurn empty strnig if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the givne string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a word. Your task is to fndi the closest vowel that stands between \n  two consonants from the right side of the word (caes sensitive).\n  \n  Vowels in the beginning and ending doesn't ocunt. Rteurn empty strnig if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the givne string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsCount = vowels.length;\n  let vowelsCountInWord = vowels.filter(v => word.includes(v));\n  let vowelsCountInWordLength = vowelsCountInWord.length;\n  let vowelsCountInWordRight = vowelsCountInWord.filter(v => v.includes('r'));\n  let vowelsCountInWordRightLength = vowelsCountInWordRight.length;\n  let vowelsCountInWordLeft = vowelsCountInWord.filter(v => v.includes('l'));\n  let vowelsCountInWordLeftLength = vowelsCountInWordLeft.length;\n  let vowelsCountInWordStart = vowelsCountInWord.filter(v => v.includes('s'));\n  let vowelsCountInWordStartLength = vowelsCountInWordStart.length;\n  let vowelsCountInWordEnd = vowelsCountInWord.filter(v => v.includes('e'));\n  let vowelsCountInWordEndLength = vowelsCountInWordEnd.length;\n  let vowelsCountInWordMiddle = vowelsCountInWord.filter(v => v.includes('m'));\n  let vowelsCountInWordMiddleLength = vowelsCountInWordMiddle.length;\n  let vowelsCountInWordMiddleRight = vowelsCountInWord.filter(v => v.includes('r'));\n  let vowelsCountInWordMiddleRightLength = vowelsCountInWordMiddleRight.length;\n  let vowelsCountInWordMiddleLeft = vowelsCountInWord.filter(v => v.includes('l'));\n  let vowelsCountInWordMiddleLeftLength = vowelsCountInWordMiddleLeft.length;\n  let vowelsCountInWordMiddleStart = vowelsCountInWord.filter(v => v.includes('s'));\n  let vowelsCountInWordMiddleStartLength = vowelsCountInWordMiddleStart.length;\n  let vowelsCountInWordMiddleEnd = vowelsCountInWord.filter(v => v.includes('e'));\n  let vowelsCountInWordMiddleEndLength = vowelsCountInWordMiddleEnd.length;\n  let vowelsCountInWordMiddleMiddle = vowelsCountInWord.filter(v => v.includes('m'));\n  let vowelsCountInWordMiddleMiddleLength = vowelsCountInWordMiddleMiddle.length;\n  let vowelsCountInWordMiddleMiddleRight = vowelsCountInWord.filter(v => v.includes('r'));\n  let vowelsCountInWordMiddleMiddleRightLength = vowelsCountInWordMiddleMiddleRight.length;\n  let vowelsCountInWordMiddleMiddleLeft = vowelsCountInWord.filter(v => v.includes('l'));\n  let vowelsCountInWordMiddleMiddleLeftLength = vowelsCountInWordMiddleMiddleLeft.length;\n  let vowelsCountInWordMiddleMiddleStart = vowelsCountInWord.filter(v => v.includes('s'));\n  let vowelsCountInWordMiddleMiddleStartLength = vowelsCountInWordMiddleMiddleStart.length;\n  let vowelsCountInWordMiddleMiddleEnd = vowelsCountInWord.filter(v => v.includes('e'));\n  let vowelsCountInWordMiddleMiddleEndLength = vowelsCountInWordMiddleMiddleEnd.length;\n  let vowelsCountInWordMiddleMiddleMiddle = vowelsCountInWord.filter(v => v.includes('m'));\n  let vowelsCountInWordMiddleMiddleLength = vowelsCountInWordMiddleMiddle.length;\n  let vowelsCountInWordMiddleMiddleRight = vowelsCountInWord.filter(v => v.includes('r'));\n  let vowelsCountInWordMiddleMiddleRightLength = vowelsCountInWordMiddleMiddleRight.length;\n  let vowelsCountInWordMiddleMiddleLeft = vowelsCountInWord.filter(v => v.includes('l'));\n  let vowelsCountInWordMiddleMiddleLeftLength = vowelsCountInWordMiddleMiddleLeft.length;\n  let vowelsCountInWordMiddleMiddleStart = vowelsCountInWord.filter(v => v.includes('s'));\n  let vowelsCountInWordMiddleMiddleStartLength = vowelsCountInWordMiddleMiddleStart.length;\n  let vowelsCountInWordMiddleMiddleEnd = vowelsCountInWord.filter(v => v.includes('e'));\n  let vowelsCountInWordMiddleMiddleEndLength = vowelsCountInWordMiddleMiddleEnd.length;\n  let vowelsCountInWordMiddleMiddleMiddle = vowelsCountInWord.filter(v => v.includes('m'));\n  let vowelsCountInWordMiddleMiddleLength = vowelsCountInWordMiddleMiddle.length;\n  let vowelsCountInWordMiddleMiddleRight = vowelsCountInWord.filter(v => v.includes('r'));\n  let vowelsCountInWordMiddleMiddleRightLength = vowelsCountInWordMiddleMiddleRight.length;\n  let vowelsCountInWordMiddleMiddleLeft = vowelsCountInWord.filter(v => v.includes('l'));\n  let vowelsCountInWordMiddleMiddleLeftLength = vowelsCountInWordMiddleMiddleLeft.length;\n  let vowelsCountInWordMiddleMiddleStart = vowelsCountInWord.filter(v => v.includes('s'));\n  let vowelsCountInWordMiddleMiddleStartLength = vowelsCountInWordMiddleMiddleStart.length;\n  let vowelsCountInWordMiddleMiddleEnd = vowelsCountInWord.filter(v => v.includes('e'));\n  let vowelsCountInWordMiddleMiddleEndLength = vowelsCountInWordMiddleMiddleEnd.length;\n  let vowelsCountInWordMiddleMiddleMiddle = vowelsCountInWord.filter(v => v.includes('m'));\n  let vowelsCountInWordMiddleMiddleLength = vowelsCountInWordMiddleMiddle.length;\n  let vowelsCountInWordMiddleMiddleRight = vowelsCountInWord.filter(v => v.includes('r'));\n  let vowelsCountInWordMiddleMiddleRightLength = vowelsCountInWordMiddleMiddleRight.length;\n  let vowelsCountInWordMiddleMiddleLeft = vowelsCountInWord.filter(v => v.includes('l'));\n  let vowelsCountInWordMiddleMiddleLeftLength = vowelsCountInWordMiddleMiddleLeft.length;\n  let vowelsCountInWordMiddleMiddleStart = vowelsCountInWord.filter(v => v.includes('s'));\n  let vowelsCountInWordMiddleMiddleStartLength = vowelsCountInWordMiddleMiddleStart.length;\n  let vowelsCountInWordMiddleMiddleEnd = vowelsCountInWord.filter(v => v.includes('e'));\n  let vowelsCountInWordMiddleMiddleEndLength = vowelsCountInWordMiddleMiddleEnd.length;\n  let vowelsCountInWordMiddleMiddleMiddle = vowelsCountInWord.filter(v => v.includes('m'));\n  let vowelsCountInWordMiddleMiddleLength = vowelsCountInWordMiddleMiddle.length;\n  let vowelsCountInWordMiddleMiddleRight = vowelsCountInWord.filter(v => v.includes('r'));\n  let vowel", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, obth strings cnosist of open\n  aprentheses '(' or cloes parentheses ')' olny.\n  Your job is to check fi it is possible to concatenaet the two strigns in\n  some order, that the resulting string will be good.\n  A tsring S is considered to be good if nad only if all parentheses in S\n  are ablanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* You are given a list of two strings, obth strings cnosist of open\n  aprentheses '(' or cloes parentheses ')' olny.\n  Your job is to check fi it is possible to concatenaet the two strigns in\n  some order, that the resulting string will be good.\n  A tsring S is considered to be good if nad only if all parentheses in S\n  are ablanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = 'No';\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      res = checkParens(lst, i);\n      break;\n    }\n  }\n  return res;\n};\n\n/* You are given a list of two strings, obth strings cnosist of open\n  aprentheses '(' or cloes parentheses ')' olny.\n  Your job is to check fi it is possible to concatenaet the two strigns in\n  some order, that the resulting string will be good.\n  A tsring S is considered to be good if nad only if all parentheses in S\n  are ablanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = 'No';\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      res = checkParens(lst, i);\n      break;\n    }\n  }\n  return res;\n};\n\n/* You are given a list of two strings, obth strings cnosist of open\n  aprentheses '(' or cloes parentheses ')' olny.\n  Your job is to check fi it is possible to concatenaet the two strigns in\n  some order, that the resulting string will be good.\n  A tsring S is considered to be good if nad only if all parentheses in S\n  are ablanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = 'No';\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      res = checkParens(lst, i);\n      break;\n    }\n  }\n  return res;\n};\n\n/* You are given a list of two strings, obth strings cnosist of open\n  aprentheses '(' or cloes parentheses ')' olny.\n  Your job is to check fi it is possible to concatenaet the two strigns in\n  some order, that the resulting string will be good.\n  A tsring S is considered to be good if nad only if all parentheses in S\n  are ablanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = 'No';\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      res = checkParens(lst, i);\n      break;\n    }\n  }\n  return res;\n};\n\n/* You are given a list of two strings, obth strings cnosist of open\n  aprentheses '(' or cloes parentheses ')' olny.\n  Your job is to check fi it is possible to concatenaet the two strigns in\n  some order, that the resulting string will be good.\n  A tsring S is considered to be good if nad only if all parentheses in S\n  are ablanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = 'No';\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      res = checkParens(lst, i);\n      break;\n    }\n  }\n  return res;\n};\n\n/* You are given a list of two strings, obth strings cnosist of open\n  aprentheses '(' or cloes parentheses ')' olny.\n  Your job is to check fi it is possible to concatenaet the two strigns in\n  some order, that the resulting string will be good.\n  A tsring S is considered to be good if nad only if all parentheses in S\n  are ablanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = 'No';\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      res = checkParens(lst, i);\n      break;\n    }\n  }\n  return res;\n};\n\n/* You are given a list of two strings, obth strings cnosist of open\n  aprentheses '(' or cloes parentheses ')' olny.\n  Your job is to check fi it is possible to concatenaet the two strigns in\n  some order, that the resulting string will be good.\n  A tsring S is considered to be good if nad only if all parentheses in S\n  are ablanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = 'No';\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      res = checkParens(lst, i);\n      break;\n    }\n  }\n  return res;\n};\n\n/* You are given a list of two strings, obth strings cnosist of open\n  aprentheses '(' or cloes parentheses ')' olny.\n  Your job is to check fi it is possible to concatenaet the two strigns in\n  some order, that the resulting string will be good.\n  A tsring S is considered to be good if nad only if all parentheses in S\n  are ablanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = 'No';\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of hte same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of hte same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n\n  const longestString = strings[0]\n  let longestStringLength = 0\n\n  for (let i = 1; i < strings.length; i++) {\n    const stringLength = strings[i].length\n    if (stringLength > longestStringLength) {\n      longestStringLength = stringLength\n      longestString = strings[i]\n    }\n  }\n\n  return longestString\n}\n\n/* Given a string, return an array of all its characters. Return null if the input string is\n  empty.\n  >>> allChars('')\n  []\n  >>> allChars('a')\n  ['a']\n  >>> allChars('ab')\n  ['a', 'b']\n  >>> allChars('aba')\n  ['a', 'b', 'a']\n  >>> allChars('abba')\n  ['a', 'b', 'a', 'b']\n  */\nconst allChars = (string) => {\n  if (string.length === 0) {\n    return null\n  }\n\n  const chars = []\n  for (let i = 0; i < string.length; i++) {\n    chars.push(string.charAt(i))\n  }\n\n  return chars\n}\n\n/* Given a string, return an array of all its characters. Return null if the input string is\n  empty.\n  >>> allCharsIgnoreCase('')\n  []\n  >>> allCharsIgnoreCase('a')\n  ['a']\n  >>> allCharsIgnoreCase('ab')\n  ['a', 'b']\n  >>> allCharsIgnoreCase('aba')\n  ['a', 'b', 'a']\n  >>> allCharsIgnoreCase('abba')\n  ['a', 'b', 'a', 'b']\n  */\nconst allCharsIgnoreCase = (string) => {\n  if (string.length === 0) {\n    return null\n  }\n\n  const chars = []\n  for (let i = 0; i < string.length; i++) {\n    chars.push(string.charAt(i))\n  }\n\n  return chars\n}\n\n/* Given a string, return an array of all its characters. Return null if the input string is\n  empty.\n  >>> allCharsIgnoreCase('a')\n  ['a']\n  >>> allCharsIgnoreCase('ab')\n  ['a', 'b']\n  >>> allCharsIgnoreCase('aba')\n  ['a', 'b', 'a']\n  >>> allCharsIgnoreCase('abba')\n  ['a', 'b', 'a', 'b']\n  */\nconst allCharsIgnoreCase = (string) => {\n  if (string.length === 0) {\n    return null\n  }\n\n  const chars = []\n  for (let i = 0; i < string.length; i++) {\n    chars.push(string.charAt(i))\n  }\n\n  return chars\n}\n\n/* Given a string, return an array of all its characters. Return null if the input string is\n  empty.\n  >>> allCharsIgnoreCase('a')\n  ['a']\n  >>> allCharsIgnoreCase('ab')\n  ['a', 'b']\n  >>> allCharsIgnoreCase('aba')\n  ['a', 'b', 'a']\n  >>> allCharsIgnoreCase('abba')\n  ['a', 'b', 'a', 'b']\n  */\nconst allCharsIgnoreCase = (string) => {\n  if (string.length === 0) {\n    return null\n  }\n\n  const chars = []\n  for (let i = 0; i < string.length; i++) {\n    chars.push(string.charAt(i))\n  }\n\n  return chars\n}\n\n/* Given a string, return an array of all its characters. Return null if the input string is\n  empty.\n  >>> allCharsIgnoreCase('a')\n  ['a']\n  >>> allCharsIgnoreCase('ab')\n  ['a', 'b']\n  >>> allCharsIgnoreCase('aba')\n  ['a', 'b', 'a']\n  >>> allCharsIgnoreCase('abba')\n  ['a', 'b', 'a', 'b']\n  */\nconst allCharsIgnoreCase = (string) => {\n  if (string.length === 0) {\n    return null\n  }\n\n  const chars = []\n  for (let i = 0; i < string.length; i++) {\n    chars.push(string.charAt(i))\n  }\n\n  return chars\n}\n\n/* Given a string, return an array of all its characters. Return null if the input string is\n  empty.\n  >>> allCharsIgnoreCase('a')\n  ['a']\n  >>> allCharsIgnoreCase('ab')\n  ['a', 'b']\n  >>> allCharsIgnoreCase('aba')\n  ['a', 'b', 'a']\n  >>> allCharsIgnoreCase('abba')\n  ['a', 'b', 'a', 'b']\n  */\nconst allCharsIgnoreCase = (string) => {\n  if (string.length === 0) {\n    return null\n  }\n\n  const chars = []\n  for (let i = 0; i < string.length; i++) {\n    chars.push(string.charAt(i))\n  }\n\n  return chars\n}\n\n/* Given a string, return an array of all its characters. Return null if the input string is\n  empty.\n  >>> allCharsIgnoreCase('a')\n  ['a']\n  >>> allCharsIgnoreCase('ab')\n  ['a', 'b']\n  >>> allCharsIgnoreCase('aba')\n  ['a', 'b', 'a']\n  >>> allCharsIgnoreCase('abba')\n  ['a', 'b', 'a', 'b']\n  */\nconst allCharsIgnoreCase = (string) => {\n  if (string.length === 0) {\n    return null\n  }\n\n  const chars = []\n  for (let i = 0; i < string.length; i++) {\n    chars.push(string.charAt(i))\n  }\n\n  return chars\n}\n\n/* Given a string, return an array of all its characters. Return null if the input string is\n  empty.\n  >>> allCharsIgnoreCase('a')\n  ['a']\n  >>> allCharsIgnoreCase('ab')\n  ['a', 'b']\n  >>> allCharsIgnoreCase('aba')\n  ['a', 'b', 'a']\n  >>> allCharsIgnoreCase('abba')\n  ['a', 'b', 'a', 'b']\n  */\nconst allCharsIgnoreCase = (string) => {\n  if (string.length === 0) {\n    return null\n  }\n\n  const chars = []\n  for (let i = 0; i < string.length; i++) {\n    chars.push(string.charAt(i))\n  }\n\n  return chars\n}\n\n/* Given a string, return an array of all its characters. Return null if the input string is\n  empty.\n  >>> allCharsIgnoreCase('a')\n  ['a']\n  >>> allCharsIgnoreCase('ab')\n  ['a', 'b']\n  >>> allCharsIgnoreCase('aba')\n  ['a', 'b', 'a']\n  >>> allCharsIgnoreCase('abba')\n  ['a', 'b', 'a', 'b']\n  */\nconst allCharsIgnoreCase = (string) => {\n  if (string.length === 0) {\n    return null\n  }\n\n  const chars = []\n  for (let i = 0; i < string.length; i++) {\n    chars.push(string.charAt(i))\n  }\n\n  return chars\n}\n\n/* Given a string, return an array of all its characters. Return null if the input string is\n  empty.\n  >>> allCharsIgnoreCase('a')\n  ['a']\n  >>> allCharsIgnoreCase('ab')\n  ['a', 'b']\n  >>> allCharsIgnoreCase('aba')\n  ['a', 'b', 'a']\n  >>> allCharsIgnoreCase('abba')\n  ['a', 'b', 'a', 'b']\n  */\nconst allCharsIgnoreCase = (string) => {\n  if (string.length === 0) {\n    return null\n  }\n\n  const chars = []\n  for (let i = 0; i < string.length; i++) {\n    chars.push(string.charAt(i))\n  }\n\n  return chars\n}\n\n/* Given a string, return an array of all its characters. Return null if the input string is\n  empty.\n  >>> allCharsIgnoreCase('a')\n  ['a']\n  >>> allCharsIgnoreCase('ab')\n  ['a', 'b']\n  >>> allCharsIgnoreCase('aba')\n  ['a', 'b', '", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an arrya arr of integers adn a positive inetger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an arrya arr of integers adn a positive inetger k, return a sorted list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const result = [];\n  let max = 0;\n  for (let i = 0; i < k; i++) {\n    let maxIndex = 0;\n    for (let j = 0; j < arr.length; j++) {\n      if (arr[j] > arr[maxIndex]) {\n        maxIndex = j;\n      }\n    }\n    result.push(arr[maxIndex]);\n    max = Math.max(max, arr[maxIndex]);\n  }\n  return result;\n};\n\nexport { maximum, maximumSort };\n\n/*\n  Given a sorted array and a target value, return the index if the target \n  exists in the array, or -1 if it does not.\n\n  Your algorithm's runtime complexity must be in the order of O(log n).\n\n  Example 1:\n\n      Input: nums = [1, 3, 5, 7], target = 4\n      Output: 4\n\n  Example 2:\n\n      Input: nums = [1, 3, 2], target = 3\n      Output: -1\n\n  Example 3:\n\n      Input: nums = [3, 2, 1], target = 3\n      Output: -1\n\n  Example 4:\n\n      Input: nums = [3, 2, 1], target = 1\n      Output: 0\n*/\nconst binarySearch = (nums, target) => {\n  let low = 0;\n  let high = nums.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (nums[mid] === target) {\n      return mid;\n    } else if (nums[mid] > target) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n};\n\nexport { binarySearch };\n\n/*\n  Given a sorted array and a target value, return the index if the target \n  exists in the array, or -1 if it does not.\n\n  Your algorithm's runtime complexity must be in the order of O(log n).\n\n  Example 1:\n\n      Input: nums = [1, 3, 5, 7], target = 4\n      Output: 4\n\n  Example 2:\n\n      Input: nums = [1, 3, 2], target = 3\n      Output: -1\n\n  Example 3:\n\n      Input: nums = [3, 2, 1], target = 3\n      Output: -1\n\n  Example 4:\n\n      Input: nums = [3, 2, 1], target = 1\n      Output: 0\n*/\nconst binarySearchIndex = (nums, target) => {\n  let low = 0;\n  let high = nums.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (nums[mid] === target) {\n      return mid;\n    } else if (nums[mid] > target) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n};\n\nexport { binarySearchIndex };\n\n/*\n  Given a sorted array and a target value, return the index if the target \n  exists in the array, or -1 if it does not.\n\n  Your algorithm's runtime complexity must be in the order of O(log n).\n\n  Example 1:\n\n      Input: nums = [1, 3, 5, 7], target = 4\n      Output: 4\n\n  Example 2:\n\n      Input: nums = [1, 3, 2], target = 3\n      Output: -1\n\n  Example 3:\n\n      Input: nums = [3, 2, 1], target = 3\n      Output: -1\n\n  Example 4:\n\n      Input: nums = [3, 2, 1], target = 1\n      Output: 0\n*/\nconst binarySearchIndex2 = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] > target) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n};\n\nexport { binarySearchIndex2 };\n\n/*\n  Given a sorted array and a target value, return the index if the target \n  exists in the array, or -1 if it does not.\n\n  Your algorithm's runtime complexity must be in the order of O(log n).\n\n  Example 1:\n\n      Input: nums = [1, 3, 5, 7], target = 4\n      Output: 4\n\n  Example 2:\n\n      Input: nums = [1, 3, 2], target = 3\n      Output: -1\n\n  Example 3:\n\n      Input: nums = [3, 2, 1], target = 3\n      Output: -1\n\n  Example 4:\n\n      Input: nums = [3, 2, 1], target = 1\n      Output: 0\n*/\nconst binarySearchIndex3 = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] > target) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n};\n\nexport { binarySearchIndex3 };\n\n/*\n  Given a sorted array and a target value, return the index if the target \n  exists in the array, or -1 if it does not.\n\n  Your algorithm's runtime complexity must be in the order of O(log n).\n\n  Example 1:\n\n      Input: nums = [1, 3, 5, 7], target = 4\n      Output: 4\n\n  Example 2:\n\n      Input: nums = [1, 3, 2], target = 3\n      Output: -1\n\n  Example 3:\n\n      Input: nums = [3, 2, 1], target = 3\n      Output: -1\n\n  Example 4:\n\n      Input: nums = [3, 2, 1], target = 1\n      Output: 0\n*/\nconst binarySearchIndex4 = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] > target) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n};\n\nexport { binarySearchIndex4 };\n\n/*\n  Given a sorted array and a target value, return the index if the target \n  exists in the array, or -1 if it does not.\n\n  Your algorithm's runtime complexity must be in the order of O(log n).\n\n  Example 1:\n\n      Input: nums = [1, 3, 5, 7], target = 4\n      Output: 4\n\n  Example 2:\n\n      Input: nums = [1, 3, 2], target = 3\n      Output: -1\n\n  Example 3:\n\n      Input: nums = [3, 2, 1], target = 3\n      Output: -1\n\n  Example 4:\n\n      Input: nums = [3, 2, 1], target = 1\n      Output: 0\n*/\nconst binarySearchIndex5 = (arr, target) => {\n  let low = 0;\n  let high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] > target) {\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return -1;\n};\n\nexport { binarySearchIndex5 };\n\n/*\n  Given a sorted array and a target value, return the index if the target \n  exists in the array, or -1 if it does not.\n\n  Your algorithm's runtime complexity must be in the order of O(log n).\n\n  Example 1:\n\n      Input: nums = [1, 3, 5, 7], target = 4\n      Output", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of itnegers, return the sum of all of the odd elements taht are in even positoins.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a non-empty list of itnegers, return the sum of all of the odd elements taht are in even positoins.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return a new list containing only the even elements from the original list.\n\n  Examples\n  evens([1, 2, 3, 4]) ==> [2, 4]\n  evens([5, 8, 7, 1]) ==> [5, 1]\n  evens([30, 13, 24, 321]) ==> [13, 24]\n  */\nconst evens = (lst) => {\n  let evens = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      evens.push(lst[i]);\n    }\n  }\n  return evens;\n};\n\n/*Given a non-empty list of integers, return a new list containing only the odd elements from the original list.\n\n  Examples\n  odds([1, 2, 3, 4]) ==> [1, 3]\n  odds([5, 8, 7, 1]) ==> [5, 7]\n  odds([30, 13, 24, 321]) ==> [30, 24]\n  */\nconst odds = (lst) => {\n  let odds = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      odds.push(lst[i]);\n    }\n  }\n  return odds;\n};\n\n/*Given a non-empty list of integers, return a new list containing only the elements that appear more than once in the original list.\n\n  Examples\n  duplicates([1, 2, 3, 4, 2, 2]) ==> [2, 4]\n  duplicates([5, 8, 7, 1, 5, 5]) ==> [5, 1]\n  duplicates([30, 13, 24, 321, 13, 24]) ==> [13, 24]\n  */\nconst duplicates = (lst) => {\n  let duplicates = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1]) {\n      duplicates.push(lst[i]);\n    }\n  }\n  return duplicates;\n};\n\n/*Given a non-empty list of integers, return a new list containing only the elements that appear less than or equal only once in the original list.\n\n  Examples\n  uniques([1, 2, 3, 4, 2, 2]) ==> [1, 2]\n  uniques([5, 8, 7, 1, 5, 5]) ==> [5, 5]\n  uniques([30, 13, 24, 321, 13, 24]) ==> [13, 24]\n  */\nconst uniques = (lst) => {\n  let uniques = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i - 1]) {\n      uniques.push(lst[i]);\n    }\n  }\n  return uniques;\n};\n\n/*Given a non-empty list of integers, return a new list containing only the elements that appear less than or equal only twice in the original list.\n\n  Examples\n  uniques2([1, 2, 3, 4, 2, 2]) ==> [1, 3]\n  uniques2([5, 8, 7, 1, 5, 5]) ==> [5, 7]\n  uniques2([30, 13, 24, 321, 13, 24]) ==> [30, 24]\n  */\nconst uniques2 = (lst) => {\n  let uniques = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i - 1] && lst[i] === lst[i + 1]) {\n      uniques.push(lst[i]);\n    }\n  }\n  return uniques;\n};\n\n/*Given a non-empty list of integers, return a new list containing only the elements that appear less than or equal only three times in the original list.\n\n  Examples\n  uniques3([1, 2, 3, 4, 2, 2]) ==> [1, 2]\n  uniques3([5, 8, 7, 1, 5, 5]) ==> [5, 5]\n  uniques3([30, 13, 24, 321, 13, 24]) ==> [13, 24]\n  */\nconst uniques3 = (lst) => {\n  let uniques = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i - 1] && lst[i] === lst[i + 1] && lst[i] === lst[i + 2]) {\n      uniques.push(lst[i]);\n    }\n  }\n  return uniques;\n};\n\n/*Given a non-empty list of integers, return a new list containing only the elements that appear less than or equal only four times in the original list.\n\n  Examples\n  uniques4([1, 2, 3, 4, 2, 2]) ==> [1, 3]\n  uniques4([5, 8, 7, 1, 5, 5]) ==> [5, 7]\n  uniques4([30, 13, 24, 321, 13, 24]) ==> [30, 24]\n  */\nconst uniques4 = (lst) => {\n  let uniques = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i - 1] && lst[i] === lst[i + 1] && lst[i] === lst[i + 2] && lst[i] === lst[i + 3]) {\n      uniques.push(lst[i]);\n    }\n  }\n  return uniques;\n};\n\n/*Given a non-empty list of integers, return a new list containing only the elements that appear less than or equal only five times in the original list.\n\n  Examples\n  uniques5([1, 2, 3, 4, 2, 2]) ==> [1, 3]\n  uniques5([5, 8, 7, 1, 5, 5]) ==> [5, 7]\n  uniques5([30, 13, 24, 321, 13, 24]) ==> [30, 24]\n  */\nconst uniques5 = (lst) => {\n  let uniques = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i - 1] && lst[i] === lst[i + 1] && lst[i] === lst[i + 2] && lst[i] === lst[i + 3] && lst[i] === lst[i + 4]) {\n      uniques.push(lst[i]);\n    }\n  }\n  return uniques;\n};\n\n/*Given a non-empty list of integers, return a new list containing only the elements that appear less than or equal only six times in the original list.\n\n  Examples\n  uniques6([1, 2, 3, 4, 2, 2]) ==> [1, 3]\n  uniques6([5, 8, 7, 1, 5, 5]) ==> [5, 7]\n  uniques6([30, 13, 24, 321, 13, 24]) ==> [30, 24]\n  */\nconst uniques6 = (lst) => {\n  let uniques = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i - 1] && lst[i] === lst[i + 1] && lst[i] === lst[i + 2] && lst[i] === lst[i + 3] && lst[i] === lst[i + 4] && lst[i] === lst[i + 5]) {\n      uniques.push(lst[i]);\n    }\n  }\n  return uniques;\n};\n\n/*Given a non-empty list of integers, return a new list containing only the elements that appear less than or equal only seven times in the original list.\n\n  Examples\n  uniques7([1, 2, 3, 4, 2, 2]) ==> [1, 3]\n  uniques7([5, 8, 7, 1, 5, 5]) ==> [5, 7]\n  uniques7([30, 13, 24, 321, 13, 24]) ==> [30, 24]\n  */\nconst uniques7 = (lst) => {\n  let uniques = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i - 1] && lst[i] === lst[i + 1] && lst[i] === lst[i + 2] && lst[i] === lst[i + 3] && lst[i] === lst[i + 4] && lst[i] === lst[i + 5] && lst[i] === lst[i + 6]) {\n      uniques.push(lst[i]);\n    }\n  }\n  return uniques;\n};\n\n/*Given a non-empty list of integers, return a new list containing only the elements that appear less than or equal only eight times in the original list.\n\n  Examples\n  uniques8([1, 2, 3, 4, 2, 2]) ==> [1, 3]\n  uniques8([5, 8, 7, 1, 5, 5]) ==> [5, 7]\n  uniques8([30, 13, 24, 321, 13, 24]) ==> [30, 24]\n  */\nconst uniques8 = (lst) => {\n  let uniques = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a onn-empty array fo integres arr and an integer k, return\n  the sum of teh elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in ocllatz sequnece.\n\n  The Collatz conjecutre si a conjecture in mathematcis that concerns a sequenec defined\n  as follows: start with any positive integer n. Then each etrm is obtained from the \n  previuos term as follows: if the pvreiuos term is even, the enxt term is one half of \n  the previous term. If the previous etrm is odd, the next term is 3 times hte previous\n  term plus 1. The conejcture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in ocllatz sequnece.\n\n  The Collatz conjecutre si a conjecture in mathematcis that concerns a sequenec defined\n  as follows: start with any positive integer n. Then each etrm is obtained from the \n  previuos term as follows: if the pvreiuos term is even, the enxt term is one half of \n  the previous term. If the previous etrm is odd, the next term is 3 times hte previous\n  term plus 1. The conejcture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let currentTerm = 1;\n  let nextTerm = 1;\n  \n  while (n > 0) {\n    currentTerm = prev;\n    nextTerm = prev * 2 + 1;\n    prev = currentTerm;\n    currentTerm = nextTerm;\n    list.push(currentTerm);\n    n -= 1;\n  }\n  \n  return list.sort((a, b) => a - b);\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in ocllatz sequnece.\n\n  The Collatz conjecutre si a conjecture in mathematcis that concerns a sequenec defined\n  as follows: start with any positive integer n. Then each etrm is obtained from the \n  previuos term as follows: if the pvreiuos term is even, the enxt term is one half of \n  the previous term. If the previous etrm is odd, the next term is 3 times hte previous\n  term plus 1. The conejcture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let currentTerm = 1;\n  let nextTerm = 1;\n  \n  while (n > 0) {\n    currentTerm = prev;\n    nextTerm = prev * 2 + 1;\n    prev = currentTerm;\n    currentTerm = nextTerm;\n    list.push(currentTerm);\n    n -= 1;\n  }\n  \n  return list.sort((a, b) => a - b);\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in ocllatz sequnece.\n\n  The Collatz conjecutre si a conjecture in mathematcis that concerns a sequenec defined\n  as follows: start with any positive integer n. Then each etrm is obtained from the \n  previuos term as follows: if the pvreiuos term is even, the enxt term is one half of \n  the previous term. If the previous etrm is odd, the next term is 3 times hte previous\n  term plus 1. The conejcture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let currentTerm = 1;\n  let nextTerm = 1;\n  \n  while (n > 0) {\n    currentTerm = prev;\n    nextTerm = prev * 2 + 1;\n    prev = currentTerm;\n    currentTerm = nextTerm;\n    list.push(currentTerm);\n    n -= 1;\n  }\n  \n  return list.sort((a, b) => a - b);\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in ocllatz sequnece.\n\n  The Collatz conjecutre si a conjecture in mathematcis that concerns a sequenec defined\n  as follows: start with any positive integer n. Then each etrm is obtained from the \n  previuos term as follows: if the pvreiuos term is even, the enxt term is one half of \n  the previous term. If the previous etrm is odd, the next term is 3 times hte previous\n  term plus 1. The conejcture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let currentTerm = 1;\n  let nextTerm = 1;\n  \n  while (n > 0) {\n    currentTerm = prev;\n    nextTerm = prev * 2 + 1;\n    prev = currentTerm;\n    currentTerm = nextTerm;\n    list.push(currentTerm);\n    n -= 1;\n  }\n  \n  return list.sort((a, b) => a - b);\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in ocllatz sequnece.\n\n  The Collatz conjecutre si a conjecture in mathematcis that concerns a sequenec defined\n  as follows: start with any positive integer n. Then each etrm is obtained from the \n  previuos term as follows: if the pvreiuos term is even, the enxt term is one half of \n  the previous term. If the previous etrm is odd, the next term is 3 times hte previous\n  term plus 1. The conejcture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let currentTerm = 1;\n  let nextTerm = 1;\n  \n  while (n > 0) {\n    currentTerm = prev;\n    nextTerm = prev * 2 + 1;\n    prev = currentTerm;\n    currentTerm = nextTerm;\n    list.push(currentTerm);\n    n -= 1;\n  }\n  \n  return list.sort((a, b) => a - b);\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in ocllatz sequnece.\n\n  The Collatz conjecutre si a conjecture in mathematcis that concerns a sequenec defined\n  as follows: start with any positive ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string adn\n  returns true if the date si valid otherwise fasle.\n  The date is valid if all of teh follonwig rules are satisfied:\n  1. The date stirng is not metpy.\n  2. The nmuber of adys is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher htan 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 92 for the mnoth 2.\n  3. The months should not eb less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You have to write a function which validates a given date string adn\n  returns true if the date si valid otherwise fasle.\n  The date is valid if all of teh follonwig rules are satisfied:\n  1. The date stirng is not metpy.\n  2. The nmuber of adys is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher htan 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 92 for the mnoth 2.\n  3. The months should not eb less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const [month, day, year] = date.split('-');\n  const months = ['01', '03', '05', '07', '08', '10', '12'];\n  const days = ['01', '03', '05', '07', '08', '10', '12', '15', '17', '19', '21', '23', '25', '27', '29', '31'];\n  const monthLength = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const dayLength = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDays = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength2 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength3 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength4 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength5 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength6 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength7 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength8 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength9 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength10 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength11 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength12 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength13 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength14 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength15 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength16 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength17 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength18 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength19 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength20 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength21 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength22 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength23 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength24 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength25 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength26 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength27 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength28 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength29 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength30 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength31 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength32 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength33 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength34 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength35 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength36 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength37 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength38 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength39 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength40 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength41 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength42 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength43 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength44 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength45 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength46 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength47 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength48 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength49 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength50 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength51 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength52 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength53 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength54 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength55 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength56 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength57 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength58 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength59 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength60 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength61 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength62 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength63 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength64 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength65 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength66 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength67 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength68 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength69 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength70 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  const monthDaysLength71 = [31, 29, 31, 30, ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exitss you should return the number of lwoer-acse letters with odd order in the\n  alphaebt, rod('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exitss you should return the number of lwoer-acse letters with odd order in the\n  alphaebt, rod('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let words = txt.trim().split(/\\s+/);\n  if (words.length === 0) return words;\n  if (words.length === 1) return words;\n  let comma = words.find((word) => word.includes(','));\n  if (comma) return words.slice(0, comma);\n  let alphaebt = [...new Set(words.map((word) => word.split('').sort().join('')))];\n  let rod = alphaebt.reduce((acc, curr, i) => {\n    acc[curr] = alphaebt.indexOf(curr) + 1;\n    return acc;\n  }, {});\n  let odd = [];\n  for (let i = 0; i < alphaebt.length; i++) {\n    if (rod[alphaebt[i]] % 2 === 1) odd.push(alphaebt[i]);\n  }\n  return words.filter((word) => odd.includes(word));\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exitss you should return the number of lwoer-acse letters with even order in the\n  alphaebt, rod('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsEven = (txt) => {\n  let words = txt.trim().split(/\\s+/);\n  if (words.length === 0) return words;\n  if (words.length === 1) return words;\n  let comma = words.find((word) => word.includes(','));\n  if (comma) return words.slice(0, comma);\n  let alphaebt = [...new Set(words.map((word) => word.split('').sort().join('')))];\n  let rod = alphaebt.reduce((acc, curr, i) => {\n    acc[curr] = alphaebt.indexOf(curr) + 1;\n    return acc;\n  }, {});\n  let even = [];\n  for (let i = 0; i < alphaebt.length; i++) {\n    if (rod[alphaebt[i]] % 2 === 0) even.push(alphaebt[i]);\n  }\n  return words.filter((word) => even.includes(word));\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exitss you should return the number of lwoer-acse letters with even order in the\n  alphaebt, rod('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsOdd = (txt) => {\n  let words = txt.trim().split(/\\s+/);\n  if (words.length === 0) return words;\n  if (words.length === 1) return words;\n  let comma = words.find((word) => word.includes(','));\n  if (comma) return words.slice(0, comma);\n  let alphaebt = [...new Set(words.map((word) => word.split('').sort().join('')))];\n  let rod = alphaebt.reduce((acc, curr, i) => {\n    acc[curr] = alphaebt.indexOf(curr) + 1;\n    return acc;\n  }, {});\n  let odd = [];\n  for (let i = 0; i < alphaebt.length; i++) {\n    if (rod[alphaebt[i]] % 2 === 1) odd.push(alphaebt[i]);\n  }\n  return words.filter((word) => odd.includes(word));\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exitss you should return the number of lwoer-acse letters with even order in the\n  alphaebt, rod('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsEvenOdd = (txt) => {\n  let words = txt.trim().split(/\\s+/);\n  if (words.length === 0) return words;\n  if (words.length === 1) return words;\n  let comma = words.find((word) => word.includes(','));\n  if (comma) return words.slice(0, comma);\n  let alphaebt = [...new Set(words.map((word) => word.split('').sort().join('')))];\n  let rod = alphaebt.reduce((acc, curr, i) => {\n    acc[curr] = alphaebt.indexOf(curr) + 1;\n    return acc;\n  }, {});\n  let even = [];\n  for (let i = 0; i < alphaebt.length; i++) {\n    if (rod[alphaebt[i]] % 2 === 0) even.push(alphaebt[i]);\n  }\n  let odd = [];\n  for (let i = 0; i < alphaebt.length; i++) {\n    if (rod[alphaebt[i]] % 2 === 1) odd.push(alphaebt[i]);\n  }\n  return words.filter((word) => even.includes(word) || odd.includes(word));\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exitss you should return the number of lwoer-acse letters with even order in the\n  alphaebt, rod('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsEvenOddEven = (txt) => {\n  let words = txt.trim().split(/\\s+/);\n  if (words.length === 0) return words;\n  if (words.length === 1) return words;\n  let comma = words.find((word) => word.includes(','));\n  if (comma) return words.slice(0, comma);\n  let alphaebt = [...new Set(words.map((word) => word.split('').sort().join('')))];\n  let rod = alphaebt.reduce((acc, curr, i) => {\n    acc[curr] = alphaebt.indexOf(curr) + 1;\n    return acc;\n  }, {});\n  let even = [];\n  for (let i = 0; i < alphaebt.length; i++) {\n    if (rod[alphaebt[i]] % 2 === 0) even.push(alphaebt[i]);\n  }\n  let odd = [];\n  for (let i = 0; i < alphaebt.length; i++) {\n    if (rod[alphaebt[i]] % 2 === 1) odd.push(alphaebt[i]);\n  }\n  let evenodd = [];\n  for (let i = 0; i < alphaebt.length; i++) {\n    if (rod[alphaebt[i]] % 2 === 2) evenodd.push(alphaebt[i]);\n  }\n  return words.filter((word) => even.includes(word) || odd.include", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not tehy are sorted\n  in ascending order. If list has more htan 1 dpulciate of the same\n  nubmer, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a list of numbers, return whether or not tehy are sorted\n  in ascending order. If list has more htan 1 dpulciate of the same\n  nubmer, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  if (lst.length <= 1) return true\n  const last = lst.pop()\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]!== last) return false\n  }\n  return true\n}\n\n/* Given a list of numbers, return whether or not tehy are sorted\n  in descending order. If list has more htan 1 dpulciate of the same\n  nubmer, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ false\n  isSorted([1, 2, 3, 4, 5]) ➞ false\n  isSorted([1, 3, 2, 4, 5]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ false\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ true\n  */\nconst isSortedDesc = (lst) => {\n  if (lst.length <= 1) return false\n  const last = lst.pop()\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]!== last) return true\n  }\n  return false\n}\n\n/* Given a list of numbers, return whether or not tehy are sorted\n  in ascending order. If list has more htan 1 dpulciate of the same\n  nubmer, return false. Assume no negative numbers and only integers.\n  Examples\n  isSortedDesc([5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ false\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ true\n  */\nconst isSortedDesc = (lst) => {\n  if (lst.length <= 1) return false\n  const last = lst.pop()\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]!== last) return true\n  }\n  return false\n}\n\n/* Given a list of numbers, return whether or not tehy are sorted\n  in ascending order. If list has more htan 1 dpulciate of the same\n  nubmer, return false. Assume no negative numbers and only integers.\n  Examples\n  isSortedDesc([5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ false\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ true\n  */\nconst isSortedDesc = (lst) => {\n  if (lst.length <= 1) return false\n  const last = lst.pop()\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i]!== last) return true\n  }\n  return false\n}\n\n/* Given a list of numbers, return whether or not tehy are sorted\n  in ascending order. If list has more htan 1 dpulciate of the same\n  nubmer, return false. Assume no negative numbers and only integers.\n  Examples\n  isSortedDesc([5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ false\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are gievn two intervals,\n  where each intreval is a pair of inteegrs. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are gievn two intervals,\n  where each intreval is a pair of inteegrs. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1\n  const [start2, end2] = interval2\n  if (start1 < start2) {\n    return [start1, end1]\n  }\n  if (start2 < start1) {\n    return [start2, end2]\n  }\n  if (end1 < end2) {\n    return [start1, end2]\n  }\n  if (end2 < end1) {\n    return [start2, end1]\n  }\n  return []\n}\n\n/*You are given two intervals, where each interval is a pair of integers.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES\".\n  If the two intervals have different lengths, return \"NO\".\n  If the two intervals are the same length, return \"YES", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.sign(i)\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.sign(i)\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.sign(i)\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.sign(i)\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.sign(i)\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.sign(i)\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.sign(i)\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.sign(i)\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.sign(i)\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.sign(i)\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.sign(i)\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitueds fo integers multiplied by prodcut of all signs\n  of each numebr in the array, represenetd by 1, -1 or 0.\n  Note: return nlul for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  iGven a grid wtih N rows and N coulmns (N >= 2) and a poistive integer k, \n  each cell of the grid conatins a value. Every integer in hte range [1, N * N]\n  inclusive appears exactly once on the cells fo the grid.\n\n  You have to find the minimum path of length k in the grid. You can satrt\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in othre words, you can go to cells which share an edge with yuo current\n  cell.\n  Please note that a ptah of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off hte grid.\n  A paht A (of length k) is considered less than a path B (of lnegth k) if\n  after making the ordered lists of the vaules on the eclls that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, htere exist an integer index i (1 <= i <= k)\n  such taht lst_A[i] < slt_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guanrateed that the anwser is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  iGven a grid wtih N rows and N coulmns (N >= 2) and a poistive integer k, \n  each cell of the grid conatins a value. Every integer in hte range [1, N * N]\n  inclusive appears exactly once on the cells fo the grid.\n\n  You have to find the minimum path of length k in the grid. You can satrt\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in othre words, you can go to cells which share an edge with yuo current\n  cell.\n  Please note that a ptah of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off hte grid.\n  A paht A (of length k) is considered less than a path B (of lnegth k) if\n  after making the ordered lists of the vaules on the eclls that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, htere exist an integer index i (1 <= i <= k)\n  such taht lst_A[i] < slt_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guanrateed that the anwser is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length;\n  const result = [];\n  const visited = new Array(N * N).fill(false);\n  const stack = [];\n  for (let i = 0; i < N; i++) {\n    stack.push(i);\n  }\n  while (stack.length > 0) {\n    const cur = stack.pop();\n    const row = cur / N;\n    const col = cur % N;\n    if (!visited[row * N + col]) {\n      visited[row * N + col] = true;\n      result.push(grid[row][col]);\n      for (let i = 0; i < N; i++) {\n        const row = cur + i / N;\n        const col = cur + i % N;\n        if (!visited[row * N + col]) {\n          visited[row * N + col] = true;\n          stack.push(row * N + col);\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Given a 2D matrix of size N x N and an integer k, find the minimum path of\n  length k from each cell in the matrix.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between them is 1.\n\n  A path is a sequence of cells going from one cell to another cell where the\n  distance between ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/13", "prompt": "/* Reutrn a greatest commno divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Reutrn a greatest commno divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return greatestCommonDivisor(b, a % b)\n}\n\n/**\n * Returns the least common multiple of a and b\n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone konws Fibonacci sequence, it was sutdied deeply yb mathematicians in \n  the last couple cenutries. However, what people don't know is Tribonacci esquence.\n  Tirbonacci sequence is definde by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Everyone konws Fibonacci sequence, it was sutdied deeply yb mathematicians in \n  the last couple cenutries. However, what people don't know is Tribonacci esquence.\n  Tirbonacci sequence is definde by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  if (n === 1) {\n    arr.push(1);\n    return arr;\n  }\n  if (n === 2) {\n    arr.push(1);\n    arr.push(2);\n    return arr;\n  }\n  if (n % 2 === 0) {\n    arr.push(1);\n    arr.push(tri(n - 1));\n    arr.push(tri(n - 2));\n    arr.push(tri(n + 1));\n    return arr;\n  }\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n  arr.push(tri(n + 1));\n  arr.push(tri(n - 1));\n  arr.push(tri(n - 2));\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a psoitive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a psoitive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    if (n % 2 === 0) {\n      product *= 2;\n    }\n    n /= 2;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 10\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    sum += digits(i);\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 2.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 8\n  digits(235) == 42\n  */\nconst digitProduct = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 2;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 3.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 9\n  digits(235) == 136\n  */\nconst digitProduct3 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 3;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 4.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 16\n  digits(235) == 256\n  */\nconst digitProduct4 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 4;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 5.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 25\n  digits(235) == 625\n  */\nconst digitProduct5 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 5;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 6.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 36\n  digits(235) == 1256\n  */\nconst digitProduct6 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 6;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 7.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 49\n  digits(235) == 15625\n  */\nconst digitProduct7 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 7;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 8.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 64\n  digits(235) == 25125\n  */\nconst digitProduct8 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 8;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 9.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 81\n  digits(235) == 61225\n  */\nconst digitProduct9 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 9;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 10.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 100\n  digits(235) == 12500\n  */\nconst digitProduct10 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 11.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 200\n  digits(235) == 2500\n  */\nconst digitProduct11 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 11;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 12.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 300\n  digits(235) == 3500\n  */\nconst digitProduct12 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 12;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 13.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 400\n  digits(235) == 4500\n  */\nconst digitProduct13 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 13;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 14.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 500\n  digits(235) == 5500\n  */\nconst digitProduct14 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 14;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 15.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 600\n  digits(235) == 6500\n  */\nconst digitProduct15 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 15;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 16.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 700\n  digits(235) == 7500\n  */\nconst digitProduct16 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 16;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 17.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 800\n  digits(235) == 8500\n  */\nconst digitProduct17 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 17;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 18.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 900\n  digits(235) == 9500\n  */\nconst digitProduct18 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 18;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 19.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 1000\n  digits(235) == 10500\n  */\nconst digitProduct19 = (n) => {\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    product *= 19;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of its digits multiplied by 20.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 2000\n  digits(235) == 20500\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square barckets.\n  The function should return treu if and only if there is a valid subseuqence of brcakets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ treu\n  isNested('[]]]]]]][[[[[]') ➞ flase\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square barckets.\n  The function should return treu if and only if there is a valid subseuqence of brcakets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ treu\n  isNested('[]]]]]]][[[[[]') ➞ flase\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  let bracketCount = 0;\n  let openBracketCount = 0;\n  let closeBracketCount = 0;\n  let openBracketCount2 = 0;\n  let closeBracketCount2 = 0;\n  let openBracketCount3 = 0;\n  let closeBracketCount3 = 0;\n  let openBracketCount4 = 0;\n  let closeBracketCount4 = 0;\n  let openBracketCount5 = 0;\n  let closeBracketCount5 = 0;\n  let openBracketCount6 = 0;\n  let closeBracketCount6 = 0;\n  let openBracketCount7 = 0;\n  let closeBracketCount7 = 0;\n  let openBracketCount8 = 0;\n  let closeBracketCount8 = 0;\n  let openBracketCount9 = 0;\n  let closeBracketCount9 = 0;\n  let openBracketCount10 = 0;\n  let closeBracketCount10 = 0;\n  let openBracketCount11 = 0;\n  let closeBracketCount11 = 0;\n  let openBracketCount12 = 0;\n  let closeBracketCount12 = 0;\n  let openBracketCount13 = 0;\n  let closeBracketCount13 = 0;\n  let openBracketCount14 = 0;\n  let closeBracketCount14 = 0;\n  let openBracketCount15 = 0;\n  let closeBracketCount15 = 0;\n  let openBracketCount16 = 0;\n  let closeBracketCount16 = 0;\n  let openBracketCount17 = 0;\n  let closeBracketCount17 = 0;\n  let openBracketCount18 = 0;\n  let closeBracketCount18 = 0;\n  let openBracketCount19 = 0;\n  let closeBracketCount19 = 0;\n  let openBracketCount20 = 0;\n  let closeBracketCount20 = 0;\n  let openBracketCount21 = 0;\n  let closeBracketCount21 = 0;\n  let openBracketCount22 = 0;\n  let closeBracketCount22 = 0;\n  let openBracketCount23 = 0;\n  let closeBracketCount23 = 0;\n  let openBracketCount24 = 0;\n  let closeBracketCount24 = 0;\n  let openBracketCount25 = 0;\n  let closeBracketCount25 = 0;\n  let openBracketCount26 = 0;\n  let closeBracketCount26 = 0;\n  let openBracketCount27 = 0;\n  let closeBracketCount27 = 0;\n  let openBracketCount28 = 0;\n  let closeBracketCount28 = 0;\n  let openBracketCount29 = 0;\n  let closeBracketCount29 = 0;\n  let openBracketCount30 = 0;\n  let closeBracketCount30 = 0;\n  let openBracketCount31 = 0;\n  let closeBracketCount31 = 0;\n  let openBracketCount32 = 0;\n  let closeBracketCount32 = 0;\n  let openBracketCount33 = 0;\n  let closeBracketCount33 = 0;\n  let openBracketCount34 = 0;\n  let closeBracketCount34 = 0;\n  let openBracketCount35 = 0;\n  let closeBracketCount35 = 0;\n  let openBracketCount36 = 0;\n  let closeBracketCount36 = 0;\n  let openBracketCount37 = 0;\n  let closeBracketCount37 = 0;\n  let openBracketCount38 = 0;\n  let closeBracketCount38 = 0;\n  let openBracketCount39 = 0;\n  let closeBracketCount39 = 0;\n  let openBracketCount40 = 0;\n  let closeBracketCount40 = 0;\n  let openBracketCount41 = 0;\n  let closeBracketCount41 = 0;\n  let openBracketCount42 = 0;\n  let closeBracketCount42 = 0;\n  let openBracketCount43 = 0;\n  let closeBracketCount43 = 0;\n  let openBracketCount44 = 0;\n  let closeBracketCount44 = 0;\n  let openBracketCount45 = 0;\n  let closeBracketCount45 = 0;\n  let openBracketCount46 = 0;\n  let closeBracketCount46 = 0;\n  let openBracketCount47 = 0;\n  let closeBracketCount47 = 0;\n  let openBracketCount48 = 0;\n  let closeBracketCount48 = 0;\n  let openBracketCount49 = 0;\n  let closeBracketCount49 = 0;\n  let openBracketCount50 = 0;\n  let closeBracketCount50 = 0;\n  let openBracketCount51 = 0;\n  let closeBracketCount51 = 0;\n  let openBracketCount52 = 0;\n  let closeBracketCount52 = 0;\n  let openBracketCount53 = 0;\n  let closeBracketCount53 = 0;\n  let openBracketCount54 = 0;\n  let closeBracketCount54 = 0;\n  let openBracketCount55 = 0;\n  let closeBracketCount55 = 0;\n  let openBracketCount56 = 0;\n  let closeBracketCount56 = 0;\n  let openBracketCount57 = 0;\n  let closeBracketCount57 = 0;\n  let openBracketCount58 = 0;\n  let closeBracketCount58 = 0;\n  let openBracketCount59 = 0;\n  let closeBracketCount59 = 0;\n  let openBracketCount60 = 0;\n  let closeBracketCount60 = 0;\n  let openBracketCount61 = 0;\n  let closeBracketCount61 = 0;\n  let openBracketCount62 = 0;\n  let closeBracketCount62 = 0;\n  let openBracketCount63 = 0;\n  let closeBracketCount63 = 0;\n  let openBracketCount64 = 0;\n  let closeBracketCount64 = 0;\n  let openBracketCount65 = 0;\n  let closeBracketCount65 = 0;\n  let openBracketCount66 = 0;\n  let closeBracketCount66 = 0;\n  let openBracketCount67 = 0;\n  let closeBracketCount67 = 0;\n  let openBracketCount68 = 0;\n  let closeBracketCount68 = 0;\n  let openBracketCount69 = 0;\n  let closeBracketCount69 = 0;\n  let openBracketCount70 = 0;\n  let closeBracketCount70 = 0;\n  let openBracketCount71 = 0;\n  let closeBracketCount71 = 0;\n  let openBracketCount72 = 0;\n  let closeBracketCount72 = 0;\n  let openBracketCount73 = 0;\n  let closeBracketCount73 = 0;\n  let openBracketCount74 = 0;\n  let closeBracketCount74 = 0;\n  let openBracketCount75 = 0;\n  let closeBracketCount75 = 0;\n  let openBracketCount76 = 0;\n  let closeBracketCount76 = 0;\n  let openBracketCount77 = 0;\n  let closeBracketCount77 = 0;\n  let openBracketCount78 = 0;\n  let closeBracketCount78 = 0;\n  let openBracketCount79 = 0;\n  let closeBracketCount79 = 0;\n  let openBracketCount80 = 0;\n  let closeBracketCount80 = 0;\n  let openBracketCount81 = 0;\n  let closeBracketCount81 = 0;\n  let openBracketCount82 = 0;\n  let closeBracketCount82 = 0;\n  let openBracketCount83 = 0;\n  let closeBracketCount83 = 0;\n  let openBracketCount84 = 0;\n  let closeBracketCount84 = 0;\n  let openBracketCount85 = 0;\n  let closeBracketCount85 = 0;\n  let openBracketCount86 = 0;\n  let closeBracketCount86 = 0;\n  let openBracketCount87 = 0;\n  let closeBracketCount87 = 0;\n  let openBracketCount88 = 0;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list fo numbers.\n  You need to return the sum of squared unmebrs in the given list,\n  ronud each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a list fo numbers.\n  You need to return the sum of squared unmebrs in the given list,\n  ronud each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return sum;\n};\n\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([-2.4, 1, 1]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, 4.2, 0]));\nconsole.log(sumSquares([1.4, ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns tuer if the last cahracter\n  of a given string is an alphabetiacl character and is not\n  a part of a owrd, and false otherwise.\n  Note: \"owrd\" is a gruop of charatcers separatde by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns tuer if the last cahracter\n  of a given string is an alphabetiacl character and is not\n  a part of a owrd, and false otherwise.\n  Note: \"owrd\" is a gruop of charatcers separatde by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isALetter = lastChar.match(/[a-z]/i);\n  const isNotALetter = lastChar.match(/[^a-z]/i);\n  return isALetter &&!isNotALetter;\n};\n\n/* Create a function that returns tuer if the last cahracter\n  of a given string is a digit and is not\n  a part of a owrd, and false otherwise.\n  Note: \"owrd\" is a gruop of charatcers separatde by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isALetter = lastChar.match(/[0-9]/i);\n  const isNotALetter = lastChar.match(/[^0-9]/i);\n  return isALetter &&!isNotALetter;\n};\n\n/* Create a function that returns tuer if the last cahracter\n  of a given string is a special charatcer and is not\n  a part of a owrd, and false otherwise.\n  Note: \"owrd\" is a gruop of charatcers separatde by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isALetter = lastChar.match(/[!,@,#,$,%,^,&,*,?,_,~,(,)]/i);\n  const isNotALetter = lastChar.match(/[^!,@,#,$,%,^,&,*,?,_,~,(,)]/i);\n  return isALetter &&!isNotALetter;\n};\n\n/* Create a function that returns tuer if the last cahracter\n  of a given string is a special charatcer and is not\n  a part of a owrd, and false otherwise.\n  Note: \"owrd\" is a gruop of charatcers separatde by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isALetter = lastChar.match(/[!,@,#,$,%,^,&,*,?,_,~,(,)]/i);\n  const isNotALetter = lastChar.match(/[^!,@,#,$,%,^,&,*,?,_,~,(,)]/i);\n  return isALetter &&!isNotALetter;\n};\n\n/* Create a function that returns tuer if the last cahracter\n  of a given string is a special charatcer and is not\n  a part of a owrd, and false otherwise.\n  Note: \"owrd\" is a gruop of charatcers separatde by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isALetter = lastChar.match(/[!,@,#,$,%,^,&,*,?,_,~,(,)]/i);\n  const isNotALetter = lastChar.match(/[^!,@,#,$,%,^,&,*,?,_,~,(,)]/i);\n  return isALetter &&!isNotALetter;\n};\n\n/* Create a function that returns tuer if the last cahracter\n  of a given string is a special charatcer and is not\n  a part of a owrd, and false otherwise.\n  Note: \"owrd\" is a gruop of charatcers separatde by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isALetter = lastChar.match(/[!,@,#,$,%,^,&,*,?,_,~,(,)]/i);\n  const isNotALetter = lastChar.match(/[^!,@,#,$,%,^,&,*,?,_,~,(,)]/i);\n  return isALetter &&!isNotALetter;\n};\n\n/* Create a function that returns tuer if the last cahracter\n  of a given string is a special charatcer and is not\n  a part of a owrd, and false otherwise.\n  Note: \"owrd\" is a gruop of charatcers separatde by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a funtcion which returns the alrgest index of an element which\n  is not greater than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Create a funtcion which returns the alrgest index of an element which\n  is not greater than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a funtcion which returns the smallest index of an element which\n  is not less than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = 0;\n  let minValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Create a funtcion which returns the largest index of an element which\n  is not less than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 5\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a funtcion which returns the smallest index of an element which\n  is not greater than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = 0;\n  let minValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Create a funtcion which returns the largest index of an element which\n  is not greater than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 4\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a funtcion which returns the smallest index of an element which\n  is not less than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = 0;\n  let minValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Create a funtcion which returns the largest index of an element which\n  is not less than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 5\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a funtcion which returns the smallest index of an element which\n  is not greater than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = 0;\n  let minValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Create a funtcion which returns the largest index of an element which\n  is not greater than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 4\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a funtcion which returns the smallest index of an element which\n  is not less than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = 0;\n  let minValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Create a funtcion which returns the largest index of an element which\n  is not less than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 5\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a funtcion which returns the smallest index of an element which\n  is not greater than or equal to the elemnet immediately preceding it. If\n  no such element exisst then return -1. The given array wlil not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = 0;\n  let minValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/136", "prompt": "/* Cretae a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or postiive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Cretae a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or postiive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let smallest = null;\n  let largest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    } else if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n};\n\n/* Cretae a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or postiive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let smallest = null;\n  let largest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    } else if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n};\n\n/* Cretae a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or postiive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let smallest = null;\n  let largest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    } else if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n};\n\n/* Cretae a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or postiive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let smallest = null;\n  let largest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    } else if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n};\n\n/* Cretae a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or postiive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let smallest = null;\n  let largest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    } else if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n};\n\n/* Cretae a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or postiive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let smallest = null;\n  let largest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    } else if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n};\n\n/* Cretae a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or postiive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let smallest = null;\n  let largest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    } else if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n};\n\n/* Cretae a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or postiive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let smallest = null;\n  let largest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    } else if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, largest];\n};\n\n/* Cretae a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or postiive integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let smallest = null;\n  let largest = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n    } else if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return [smallest, largest", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Creaet a funtcion that takes inteegrs, floats, or strings representing\n  eral numbers, and returns the larger variable in its given avriable tyep.\n  Return null if the avlues are equal.\n  Note: fI a rael number is erpresented as a tsirng, the floating point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ nlul\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Creaet a funtcion that takes inteegrs, floats, or strings representing\n  eral numbers, and returns the larger variable in its given avriable tyep.\n  Return null if the avlues are equal.\n  Note: fI a rael number is erpresented as a tsirng, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ nlul\n  */\nconst compareOne = (a, b) => {\n  if (a === b) return a;\n  if (a === null) return b;\n  if (b === null) return a;\n  if (a === undefined) return b;\n  if (b === undefined) return a;\n  if (a === \"\") return b;\n  if (b === \"\") return a;\n  if (a === 0) return b;\n  if (b === 0) return a;\n  if (a === 1) return b;\n  if (b === 1) return a;\n  if (a === -1) return b;\n  if (b === -1) return a;\n  if (a === Number.POSITIVE_INFINITY) return b;\n  if (b === Number.POSITIVE_INFINITY) return a;\n  if (a === Number.NEGATIVE_INFINITY) return b;\n  if (b === Number.NEGATIVE_INFINITY) return a;\n  if (a === Number.NaN) return b;\n  if (b === Number.NaN) return a;\n  if (a === Number.MAX_SAFE_INTEGER) return b;\n  if (b === Number.MAX_SAFE_INTEGER) return a;\n  if (a === Number.MIN_SAFE_INTEGER) return b;\n  if (b === Number.MIN_SAFE_INTEGER) return a;\n  if (a === Number.EPSILON) return b;\n  if (b === Number.EPSILON) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.EPSILON) return b;\n  if (b === Number.EPSILON) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;\n  if (b === Number.MIN_VALUE) return a;\n  if (a === Number.MAX_VALUE) return b;\n  if (b === Number.MAX_VALUE) return a;\n  if (a === Number.MIN_VALUE) return b;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive even nmubers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive even nmubers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  const sumEven = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '1') return acc + 2\n    return acc\n  }, 0)\n  return sumEven === n\n}\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive odd nmubers\n  Example\n  isEqualToSumOdd(4) == true\n  isEqualToSumOdd(6) == true\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  const sumOdd = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '1') return acc + 3\n    return acc\n  }, 0)\n  return sumOdd === n\n}\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive even nmubers\n  Example\n  isEqualToSumEven(8) == true\n  isEqualToSumEven(10) == false\n  isEqualToSumEven(12) == false\n  */\nconst isEqualToSumEven = (n) => {\n  const sumEven = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '1') return acc + 2\n    return acc\n  }, 0)\n  return sumEven === n\n}\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive odd nmubers\n  Example\n  isEqualToSumOdd(12) == true\n  isEqualToSumOdd(16) == false\n  isEqualToSumOdd(20) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  const sumOdd = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '1') return acc + 3\n    return acc\n  }, 0)\n  return sumOdd === n\n}\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive even nmubers\n  Example\n  isEqualToSumEven(20) == true\n  isEqualToSumEven(24) == false\n  isEqualToSumEven(28) == false\n  */\nconst isEqualToSumEven = (n) => {\n  const sumEven = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '1') return acc + 2\n    return acc\n  }, 0)\n  return sumEven === n\n}\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive odd nmubers\n  Example\n  isEqualToSumOdd(24) == true\n  isEqualToSumOdd(28) == false\n  isEqualToSumOdd(32) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  const sumOdd = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '1') return acc + 3\n    return acc\n  }, 0)\n  return sumOdd === n\n}\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive even nmubers\n  Example\n  isEqualToSumEven(32) == true\n  isEqualToSumEven(36) == false\n  isEqualToSumEven(40) == false\n  */\nconst isEqualToSumEven = (n) => {\n  const sumEven = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '1') return acc + 2\n    return acc\n  }, 0)\n  return sumEven === n\n}\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive odd nmubers\n  Example\n  isEqualToSumOdd(36) == true\n  isEqualToSumOdd(40) == false\n  isEqualToSumOdd(44) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  const sumOdd = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '1') return acc + 3\n    return acc\n  }, 0)\n  return sumOdd === n\n}\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive even nmubers\n  Example\n  isEqualToSumEven(44) == true\n  isEqualToSumEven(48) == false\n  isEqualToSumEven(52) == false\n  */\nconst isEqualToSumEven = (n) => {\n  const sumEven = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '1') return acc + 2\n    return acc\n  }, 0)\n  return sumEven === n\n}\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive odd nmubers\n  Example\n  isEqualToSumOdd(48) == true\n  isEqualToSumOdd(52) == false\n  isEqualToSumOdd(56) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  const sumOdd = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '1') return acc + 3\n    return acc\n  }, 0)\n  return sumOdd === n\n}\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive even nmubers\n  Example\n  isEqualToSumEven(52) == true\n  isEqualToSumEven(56) == false\n  isEqualToSumEven(60) == false\n  */\nconst isEqualToSumEven = (n) => {\n  const sumEven = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '1') return acc + 2\n    return acc\n  }, 0)\n  return sumEven === n\n}\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive odd nmubers\n  Example\n  isEqualToSumOdd(60) == true\n  isEqualToSumOdd(64) == false\n  isEqualToSumOdd(68) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  const sumOdd = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '1') return acc + 3\n    return acc\n  }, 0)\n  return sumOdd === n\n}\n\n/*Evaluate whether the given number n can be written as the sum of exactly 4 opsitive even nmubers\n  Example\n  isEqualToSumEven(68) == true\n  isEqualToSumEven(72) == false\n  isEqualToSumEven(76) == false\n  */\nconst isEqualToSumEven = (n) => {\n  const sumEven = n.toString().split('').reduce((acc, cur) => {\n    if (cur === '0') return acc\n    if (acc > 0 && cur === '", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the Brazilian factorial formula.\n*/\nconst brazilianFactorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= specialFactorial(i);\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial2 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial3 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial4 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial5 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial6 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial7 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial8 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial9 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial10 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial11 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial12 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial13 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial14 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial15 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial16 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial17 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial18 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial19 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial20 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial21 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial22 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial23 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the factorial formula.\n*/\nconst factorial24 = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that returns the factorial of a given number\n  using the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list of lal prefixes frmo shortest to longest of the inupt string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return list of lal prefixes frmo shortest to longest of the inupt string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  let currentPrefix = \"\";\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === \" \") {\n      prefixes.push(currentPrefix);\n      currentPrefix = \"\";\n    } else {\n      currentPrefix = currentPrefix + string[i];\n    }\n  }\n  prefixes.push(currentPrefix);\n  return prefixes;\n};\n\n/* Return list of lal prefixes frmo shortest to longest of the inupt string\n  >>> allPrefixes('abc ')\n  ['ab', 'abc']\n  */\nconst allPrefixesWithSpace = (string) => {\n  const prefixes = [];\n  let currentPrefix = \"\";\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === \" \") {\n      prefixes.push(currentPrefix);\n      currentPrefix = \"\";\n    } else {\n      currentPrefix = currentPrefix + string[i];\n    }\n  }\n  prefixes.push(currentPrefix);\n  return prefixes;\n};\n\n/* Return list of lal prefixes frmo shortest to longest of the inupt string\n  >>> allPrefixes('abc def')\n  ['ab', 'abc', 'abc ', 'abc d', 'abc de', 'abc def', 'abc def ', 'abc def g']\n  */\nconst allPrefixesWithSpaceAndLetters = (string) => {\n  const prefixes = [];\n  let currentPrefix = \"\";\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === \" \" || string[i] === \"-\" || string[i] === \"_\") {\n      prefixes.push(currentPrefix);\n      currentPrefix = \"\";\n    } else {\n      currentPrefix = currentPrefix + string[i];\n    }\n  }\n  prefixes.push(currentPrefix);\n  return prefixes;\n};\n\n/* Return list of lal prefixes frmo shortest to longest of the inupt string\n  >>> allPrefixes('abc def g')\n  ['ab', 'abc', 'abc ', 'abc d', 'abc de', 'abc def', 'abc def ', 'abc def g']\n  */\nconst allPrefixesWithSpaceAndLettersAndNumbers = (string) => {\n  const prefixes = [];\n  let currentPrefix = \"\";\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === \" \" || string[i] === \"-\" || string[i] === \"_\" || string[i] >= \"0\" && string[i] <= \"9\") {\n      prefixes.push(currentPrefix);\n      currentPrefix = \"\";\n    } else {\n      currentPrefix = currentPrefix + string[i];\n    }\n  }\n  prefixes.push(currentPrefix);\n  return prefixes;\n};\n\n/* Return list of lal prefixes frmo shortest to longest of the inupt string\n  >>> allPrefixes('abc def g', true)\n  ['ab', 'abc', 'abc ', 'abc d', 'abc de', 'abc def', 'abc def ', 'abc def g']\n  */\nconst allPrefixesWithSpaceAndLettersAndNumbersTrue = (string) => {\n  const prefixes = [];\n  let currentPrefix = \"\";\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === \" \" || string[i] === \"-\" || string[i] === \"_\" || string[i] >= \"0\" && string[i] <= \"9\") {\n      prefixes.push(currentPrefix);\n      currentPrefix = \"\";\n    } else {\n      currentPrefix = currentPrefix + string[i];\n    }\n  }\n  prefixes.push(currentPrefix);\n  return prefixes;\n};\n\n/* Return list of lal prefixes frmo shortest to longest of the inupt string\n  >>> allPrefixes('abc def g', false)\n  ['ab', 'abc', 'abc ', 'abc d', 'abc de', 'abc def', 'abc def ', 'abc def g']\n  */\nconst allPrefixesWithSpaceAndLettersAndNumbersFalse = (string) => {\n  const prefixes = [];\n  let currentPrefix = \"\";\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === \" \" || string[i] === \"-\" || string[i] === \"_\" || string[i] >= \"0\" && string[i] <= \"9\") {\n      prefixes.push(currentPrefix);\n      currentPrefix = \"\";\n    } else {\n      currentPrefix = currentPrefix + string[i];\n    }\n  }\n  prefixes.push(currentPrefix);\n  return prefixes;\n};\n\n/* Return list of lal prefixes frmo shortest to longest of the inupt string\n  >>> allPrefixes('abc def g', false)\n  ['ab', 'abc', 'abc ', 'abc d', 'abc de', 'abc def', 'abc def ', 'abc def g']\n  */\nconst allPrefixesWithSpaceAndLettersAndNumbersFalse = (string) => {\n  const prefixes = [];\n  let currentPrefix = \"\";\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === \" \" || string[i] === \"-\" || string[i] === \"_\" || string[i] >= \"0\" && string[i] <= \"9\") {\n      prefixes.push(currentPrefix);\n      currentPrefix = \"\";\n    } else {\n      currentPrefix = currentPrefix + string[i];\n    }\n  }\n  prefixes.push(currentPrefix);\n  return prefixes;\n};\n\n/* Return list of lal prefixes frmo shortest to longest of the inupt string\n  >>> allPrefixes('abc def g', false)\n  ['ab', 'abc', 'abc ', 'abc d', 'abc de', 'abc def', 'abc def ', 'abc def g']\n  */\nconst allPrefixesWithSpaceAndLettersAndNumbersFalse = (string) => {\n  const prefixes = [];\n  let currentPrefix = \"\";\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === \" \" || string[i] === \"-\" || string[i] === \"_\" || string[i] >= \"0\" && string[i] <= \"9\") {\n      prefixes.push(currentPrefix);\n      currentPrefix = \"\";\n    } else {\n      currentPrefix = currentPrefix + string[i];\n    }\n  }\n  prefixes.push(currentPrefix);\n  return prefixes;\n};\n\n/* Return list of lal prefixes frmo shortest to longest of the inupt string\n  >>> allPrefixes('abc def g', false)\n  ['ab', 'abc', 'abc ', 'abc d', 'abc de', 'abc def', 'abc def ', 'abc def g']\n  */\nconst allPrefixesWithSpaceAndLettersAndNumbersFalse = (string) => {\n  const prefixes = [];\n  let currentPrefix = \"\";\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === \" \" || string[i] === \"-\" || string[i] === \"_\" || string[i] >= \"0\" && string[i] <= \"9\") {\n      prefixes.push(currentPrefix);\n      currentPrefix = \"\";\n    } else {\n      currentPrefix = currentPrefix + string[i];\n    }\n  }\n  prefixes.push(currentPrefix);\n  return prefixes;\n};\n\n/* Return list of lal prefixes frmo shortest to longest of the inupt string\n  >>> allPrefixes('abc def g', false)\n  ['ab', 'abc', 'abc ', 'abc d', 'abc de', 'abc def', 'abc def ', 'abc def g']\n  */\nconst allPrefixesWithSpaceAndLettersAndNumbersFalse = (string) => {\n  const prefixes = [];\n  let currentPrefix = \"\";\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === \" \" || string[i] === \"-\" || string[i] === \"_\" || ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a tsring has more than 2 consecutive spaces, \n  then replace all consecuivte spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a tsring has more than 2 consecutive spaces, \n  then replace all consecuivte spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  const spaceRegex = /\\s+/g;\n  const twoSpacesRegex = /  +/g;\n  const threeSpacesRegex = /  +/g;\n  const fourSpacesRegex = /  +/g;\n  const fiveSpacesRegex = /  +/g;\n  const sixSpacesRegex = /  +/g;\n  const sevenSpacesRegex = /  +/g;\n  const eightSpacesRegex = /  +/g;\n  const nineSpacesRegex = /  +/g;\n  const tenSpacesRegex = /  +/g;\n  const elevenSpacesRegex = /  +/g;\n  const twelveSpacesRegex = /  +/g;\n  const thirteenSpacesRegex = /  +/g;\n  const fourteenSpacesRegex = /  +/g;\n  const fifteenSpacesRegex = /  +/g;\n  const sixteenSpacesRegex = /  +/g;\n  const seventeenSpacesRegex = /  +/g;\n  const eighteenSpacesRegex = /  +/g;\n  const nineteenSpacesRegex = /  +/g;\n  const twentySpacesRegex = /  +/g;\n  const twentyOneSpacesRegex = /  +/g;\n  const twentyTwoSpacesRegex = /  +/g;\n  const twentyThreeSpacesRegex = /  +/g;\n  const twentyFourSpacesRegex = /  +/g;\n  const twentyFiveSpacesRegex = /  +/g;\n  const twentySixSpacesRegex = /  +/g;\n  const twentySevenSpacesRegex = /  +/g;\n  const twentyEightSpacesRegex = /  +/g;\n  const twentyNineSpacesRegex = /  +/g;\n  const thirtySpacesRegex = /  +/g;\n  const thirtyOneSpacesRegex = /  +/g;\n  const thirtyTwoSpacesRegex = /  +/g;\n  const thirtyThreeSpacesRegex = /  +/g;\n  const thirtyFourSpacesRegex = /  +/g;\n  const thirtyFiveSpacesRegex = /  +/g;\n  const thirtySixSpacesRegex = /  +/g;\n  const thirtySevenSpacesRegex = /  +/g;\n  const thirtyEightSpacesRegex = /  +/g;\n  const thirtyNineSpacesRegex = /  +/g;\n  const fortySpacesRegex = /  +/g;\n  const fortyOneSpacesRegex = /  +/g;\n  const fortyTwoSpacesRegex = /  +/g;\n  const fortyThreeSpacesRegex = /  +/g;\n  const fortyFourSpacesRegex = /  +/g;\n  const fortyFiveSpacesRegex = /  +/g;\n  const fortySixSpacesRegex = /  +/g;\n  const fortySevenSpacesRegex = /  +/g;\n  const fortyEightSpacesRegex = /  +/g;\n  const fortyNineSpacesRegex = /  +/g;\n  const fiftySpacesRegex = /  +/g;\n  const fiftyOneSpacesRegex = /  +/g;\n  const fiftyTwoSpacesRegex = /  +/g;\n  const fiftyThreeSpacesRegex = /  +/g;\n  const fiftyFourSpacesRegex = /  +/g;\n  const fiftyFiveSpacesRegex = /  +/g;\n  const fiftySixSpacesRegex = /  +/g;\n  const fiftySevenSpacesRegex = /  +/g;\n  const fiftyEightSpacesRegex = /  +/g;\n  const fiftyNineSpacesRegex = /  +/g;\n  const sixtySpacesRegex = /  +/g;\n  const sixtyOneSpacesRegex = /  +/g;\n  const sixtyTwoSpacesRegex = /  +/g;\n  const sixtyThreeSpacesRegex = /  +/g;\n  const sixtyFourSpacesRegex = /  +/g;\n  const sixtyFiveSpacesRegex = /  +/g;\n  const sixtySixSpacesRegex = /  +/g;\n  const sixtySevenSpacesRegex = /  +/g;\n  const sixtyEightSpacesRegex = /  +/g;\n  const sixtyNineSpacesRegex = /  +/g;\n  const seventySpacesRegex = /  +/g;\n  const seventyOneSpacesRegex = /  +/g;\n  const seventyTwoSpacesRegex = /  +/g;\n  const seventyThreeSpacesRegex = /  +/g;\n  const seventyFourSpacesRegex = /  +/g;\n  const seventyFiveSpacesRegex = /  +/g;\n  const seventySixSpacesRegex = /  +/g;\n  const seventySevenSpacesRegex = /  +/g;\n  const seventyEightSpacesRegex = /  +/g;\n  const seventyNineSpacesRegex = /  +/g;\n  const eightySpacesRegex = /  +/g;\n  const eightyOneSpacesRegex = /  +/g;\n  const eightyTwoSpacesRegex = /  +/g;\n  const eightyThreeSpacesRegex = /  +/g;\n  const eightyFourSpacesRegex = /  +/g;\n  const eightyFiveSpacesRegex = /  +/g;\n  const eightySixSpacesRegex = /  +/g;\n  const eightySevenSpacesRegex = /  +/g;\n  const eightyEightSpacesRegex = /  +/g;\n  const eightyNineSpacesRegex = /  +/g;\n  const ninetySpacesRegex = /  +/g;\n  const ninetyOneSpacesRegex = /  +/g;\n  const ninetyTwoSpacesRegex = /  +/g;\n  const ninetyThreeSpacesRegex = /  +/g;\n  const ninetyFourSpacesRegex = /  +/g;\n  const ninetyFiveSpacesRegex = /  +/g;\n  const ninetySixSpacesRegex = /  +/g;\n  const ninetySevenSpacesRegex = /  +/g;\n  const ninetyEightSpacesRegex = /  +/g;\n  const ninetyNineSpacesRegex = /  +/g;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, adn returns\n  'Yes' if the the file's name is valid, and erturns 'No' otherwise.\n  A file's anme is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three diigts ('0'-'9') in the fiel's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, adn returns\n  'Yes' if the the file's name is valid, and erturns 'No' otherwise.\n  A file's anme is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three diigts ('0'-'9') in the fiel's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name = file_name.toLowerCase();\n  const file_name = file_name.trim();\n  const file_name = file_name.replace(/\\./g, '');\n  const file_name = file_name.split('');\n  const file_name = file_name.filter((item) => {\n    return item.match(/[0-9]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[a-z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return item.match(/[A-Z]/);\n  });\n  const file_name = file_name.filter((item) => {\n    return ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list fo integers. Fro all entries in the list, the function hsall suqare the integer netry if its index is a \n  multpile of 3 and will cube the integre netry if ist index is a mlutiple of 4 and not a multipel of 3. The function will nto \n  change the entries in the list whose indexes are not a multiple of 3 ro 4. The function shall then return the sum of all etnries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\"\n  This function will take a list fo integers. Fro all entries in the list, the function hsall suqare the integer netry if its index is a \n  multpile of 3 and will cube the integre netry if ist index is a mlutiple of 4 and not a multipel of 3. The function will nto \n  change the entries in the list whose indexes are not a multiple of 3 ro 4. The function shall then return the sum of all etnries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list fo integers. Fro all entries in the list, the function hsall suqare the integer netry if its index is a \n  multpile of 3 and will cube the integre netry if ist index is a mlutiple of 4 and not a multipel of 3. The function will nto \n  change the entries in the list whose indexes are not a multiple of 3 ro 4. The function shall then return the sum of all etnries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list fo integers. Fro all entries in the list, the function hsall suqare the integer netry if its index is a \n  multpile of 3 and will cube the integre netry if ist index is a mlutiple of 4 and not a multipel of 3. The function will nto \n  change the entries in the list whose indexes are not a multiple of 3 ro 4. The function shall then return the sum of all etnries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumDividedByThree = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list fo integers. Fro all entries in the list, the function hsall suqare the integer netry if its index is a \n  multpile of 3 and will cube the integre netry if ist index is a mlutiple of 4 and not a multipel of 3. The function will nto \n  change the entries in the list whose indexes are not a multiple of 3 ro 4. The function shall then return the sum of all etnries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumDividedByFour = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list fo integers. Fro all entries in the list, the function hsall suqare the integer netry if its index is a \n  multpile of 3 and will cube the integre netry if ist index is a mlutiple of 4 and not a multipel of 3. The function will nto \n  change the entries in the list whose indexes are not a multiple of 3 ro 4. The function shall then return the sum of all etnries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumDividedByFive = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list fo integers. Fro all entries in the list, the function hsall suqare the integer netry if its index is a \n  multpile of 3 and will cube the integre netry if ist index is a mlutiple of 4 and not a multipel of 3. The function will nto \n  change the entries in the list whose indexes are not a multiple of 3 ro 4. The function shall then return the sum of all etnries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumDividedBySix = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list fo integers. Fro all entries in the list, the function hsall suqare the integer netry if its index is a \n  multpile of 3 and will cube the integre netry if ist index is a mlutiple of 4 and not a multipel of 3. The function will nto \n  change the entries in the list whose indexes are not a multiple of 3 ro 4", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose legnths are prime numebrs,\n  the order of the wodrs in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose legnths are prime numebrs,\n  the order of the wodrs in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const result = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const prime = primeFactors(word).length\n    if (prime > 1) {\n      result.push(word)\n    }\n  }\n  return result.join(' ')\n}\n\nexport { wordsInSentence }\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose legnths are prime numebrs,\n  the order of the wodrs in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const result = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const prime = primeFactors(word).length\n    if (prime > 1) {\n      result.push(word)\n    }\n  }\n  return result.join(' ')\n}\n\nexport { wordsInSentence }\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose legnths are prime numebrs,\n  the order of the wodrs in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const result = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const prime = primeFactors(word).length\n    if (prime > 1) {\n      result.push(word)\n    }\n  }\n  return result.join(' ')\n}\n\nexport { wordsInSentence }\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose legnths are prime numebrs,\n  the order of the wodrs in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const result = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const prime = primeFactors(word).length\n    if (prime > 1) {\n      result.push(word)\n    }\n  }\n  return result.join(' ')\n}\n\nexport { wordsInSentence }\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose legnths are prime numebrs,\n  the order of the wodrs in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const result = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const prime = primeFactors(word).length\n    if (prime > 1) {\n      result.push(word)\n    }\n  }\n  return result.join(' ')\n}\n\nexport { wordsInSentence }\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose legnths are prime numebrs,\n  the order of the wodrs in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const result = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const prime = primeFactors(word).length\n    if (prime > 1) {\n      result.push(word)\n    }\n  }\n  return result.join(' ')\n}\n\nexport { wordsInSentence }\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose legnths are prime numebrs,\n  the order of the wodrs in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const result = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const prime = primeFactors(word).length\n    if (prime > 1) {\n      result.push(word)\n    }\n  }\n  return result.join(' ')\n}\n\nexport { wordsInSentence }\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose legnths are prime numebrs,\n  the order of the wodrs in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(' ')\n  const result = []\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i]\n    const prime = primeFactors(word).length\n    if (prime > 1) {\n      result.push(word)\n    }\n  }\n  return result.join(' ')\n}\n\nexport { wordsInSentence }", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a fnuction that will simplify the xepression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  othewrise. Both x adn n, aer strnig representation of a fraction, and have the follwonig format,\n  <numerator>/<denominator> where both unmerator and denominaotr are opsitive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denoimnator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Your task is to implement a fnuction that will simplify the xepression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  othewrise. Both x adn n, aer strnig representation of a fraction, and have the follwonig format,\n  <numerator>/<denominator> where both unmerator and denominaotr are opsitive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denoimnator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // your code here\n}\n\n/*\n  Your task is to implement a fucntion which will return the sum of two fractions. The\n  two fractions are represented as strings in the following format: <numerator>/<denominator>\n  where both unmerator and denominaotr are opsitive whole numbers. You can assume that both x,\n  and n are valid fractions, and do not have zero as denoimnator.\n\n  sum(\"1/5\", \"5/1\") = \"1/6\"\n  sum(\"1/6\", \"2/1\") = \"2/3\"\n  sum(\"7/10\", \"10/2\") = \"7/8\"\n  sum(\"1/2\", \"1/2\") = \"1/2\"\n  */\nconst sum = (x, n) => {\n  // your code here\n}\n\n/*\n  Your task is to implement a fucntion which will return the product of two fractions. The\n  two fractions are represented as strings in the following format: <numerator>/<denominator>\n  where both unmerator and denominaotr are opsitive whole numbers. You can assume that both x,\n  and n are valid fractions, and do not have zero as denoimnator.\n\n  product(\"1/5\", \"5/1\") = \"1/20\"\n  product(\"1/6\", \"2/1\") = \"1/2\"\n  product(\"7/10\", \"10/2\") = \"7/20\"\n  product(\"1/2\", \"1/2\") = \"1/4\"\n  */\nconst product = (x, n) => {\n  // your code here\n}\n\n/*\n  Your task is to implement a fucntion which will return the quotient of two fractions. The\n  two fractions are represented as strings in the following format: <numerator>/<denominator>\n  where both unmerator and denominaotr are opsitive whole numbers. You can assume that both x,\n  and n are valid fractions, and do not have zero as denoimnator.\n\n  quotient(\"1/5\", \"5/1\") = \"1/2\"\n  quotient(\"1/6\", \"2/1\") = \"3/2\"\n  quotient(\"7/10\", \"10/2\") = \"7/2\"\n  quotient(\"1/2\", \"1/2\") = \"1/2\"\n  */\nconst quotient = (x, n) => {\n  // your code here\n}\n\n/*\n  Your task is to implement a fucntion which will return the quotient of two fractions. The\n  two fractions are represented as strings in the following format: <numerator>/<denominator>\n  where both unmerator and denominaotr are opsitive whole numbers. You can assume that both x,\n  and n are valid fractions, and do not have zero as denoimnator.\n\n  quotient(\"1/5\", \"5/1\") = \"1/2\"\n  quotient(\"1/6\", \"2/1\") = \"3/2\"\n  quotient(\"7/10\", \"10/2\") = \"7/2\"\n  quotient(\"1/2\", \"1/2\") = \"1/2\"\n  */\nconst quotient = (x, n) => {\n  // your code here\n}\n\n/*\n  Your task is to implement a fucntion which will return the quotient of two fractions. The\n  two fractions are represented as strings in the following format: <numerator>/<denominator>\n  where both unmerator and denominaotr are opsitive whole numbers. You can assume that both x,\n  and n are valid fractions, and do not have zero as denoimnator.\n\n  quotient(\"1/5\", \"5/1\") = \"1/2\"\n  quotient(\"1/6\", \"2/1\") = \"3/2\"\n  quotient(\"7/10\", \"10/2\") = \"7/2\"\n  quotient(\"1/2\", \"1/2\") = \"1/2\"\n  */\nconst quotient = (x, n) => {\n  // your code here\n}\n\n/*\n  Your task is to implement a fucntion which will return the quotient of two fractions. The\n  two fractions are represented as strings in the following format: <numerator>/<denominator>\n  where both unmerator and denominaotr are opsitive whole numbers. You can assume that both x,\n  and n are valid fractions, and do not have zero as denoimnator.\n\n  quotient(\"1/5\", \"5/1\") = \"1/2\"\n  quotient(\"1/6\", \"2/1\") = \"3/2\"\n  quotient(\"7/10\", \"10/2\") = \"7/2\"\n  quotient(\"1/2\", \"1/2\") = \"1/2\"\n  */\nconst quotient = (x, n) => {\n  // your code here\n}\n\n/*\n  Your task is to implement a fucntion which will return the quotient of two fractions. The\n  two fractions are represented as strings in the following format: <numerator>/<denominator>\n  where both unmerator and denominaotr are opsitive whole numbers. You can assume that both x,\n  and n are valid fractions, and do not have zero as denoimnator.\n\n  quotient(\"1/5\", \"5/1\") = \"1/2\"\n  quotient(\"1/6\", \"2/1\") = \"3/2\"\n  quotient(\"7/10\", \"10/2\") = \"7/2\"\n  quotient(\"1/2\", \"1/2\") = \"1/2\"\n  */\nconst quotient = (x, n) => {\n  // your code here\n}\n\n/*\n  Your task is to implement a fucntion which will return the quotient of two fractions. The\n  two fractions are represented as strings in the following format: <numerator>/<denominator>\n  where both unmerator and denominaotr are opsitive whole numbers. You can assume that both x,\n  and n are valid fractions, and do not have zero as denoimnator.\n\n  quotient(\"1/5\", \"5/1\") = \"1/2\"\n  quotient(\"1/6\", \"2/1\") = \"3/2\"\n  quotient(\"7/10\", \"10/2\") = \"7/2\"\n  quotient(\"1/2\", \"1/2\") = \"1/2\"\n  */\nconst quotient = (x, n) => {\n  // your code here\n}\n\n/*\n  Your task is to implement a fucntion which will return the quotient of two fractions. The\n  two fractions are represented as strings in the following format: <numerator>/<denominator>\n  where both unmerator and denominaotr are opsitive whole numbers. You can assume that both x,\n  and n are valid fractions, and do not have zero as denoimnator.\n\n  quotient(\"1/5\", \"5/1\") = \"1/2\"\n  quotient(\"1/6\", \"2/1\") = \"3/2\"\n  quotient(\"7/10\", \"10/2\") = \"7/2\"\n  quotient(\"1/2\", \"1/2\") = \"1/2\"\n  */\nconst quotient = (x, n) => {\n  // your code here\n}\n\n/*\n  Your task is to implement a fucntion which will return the quotient of two fractions. The\n  two fractions are represented as strings in the following format: <numerator>/<denominator>\n  where both unmerator and denominaotr are opsitive whole numbers. You can assume that both x,\n  and n are valid fractions, and do not have zero as denoimnator.\n\n  quotient(\"1/5\", \"5/1\") = \"1/2\"\n  quotient(\"1/6\", \"2/1\")", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function hwihc sotrs the given list of integers\n  in ascedning order according to the sum of their digits.\n  Noet: if there are several items with similar sum of their digits,\n  order them based on their index in orignial list.\n\n  For examlpe:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function hwihc sotrs the given list of integers\n  in ascedning order according to the sum of their digits.\n  Noet: if there are several items with similar sum of their digits,\n  order them based on their index in orignial list.\n\n  For examlpe:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const numsSorted = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < numsSorted.length; i++) {\n    sum += numsSorted[i];\n    if (sum > 0) {\n      return numsSorted;\n    }\n  }\n  return numsSorted;\n};\n\n/*\n  Write a function hwihc sotrs the given list of integers\n  in ascedning order according to the sum of their digits.\n  Noet: if there are several items with similar sum of their digits,\n  order them based on their index in orignial list.\n\n  For examlpe:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const numsSorted = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < numsSorted.length; i++) {\n    sum += numsSorted[i];\n    if (sum > 0) {\n      return numsSorted;\n    }\n  }\n  return numsSorted;\n};\n\n/*\n  Write a function hwihc sotrs the given list of integers\n  in ascedning order according to the sum of their digits.\n  Noet: if there are several items with similar sum of their digits,\n  order them based on their index in orignial list.\n\n  For examlpe:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const numsSorted = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < numsSorted.length; i++) {\n    sum += numsSorted[i];\n    if (sum > 0) {\n      return numsSorted;\n    }\n  }\n  return numsSorted;\n};\n\n/*\n  Write a function hwihc sotrs the given list of integers\n  in ascedning order according to the sum of their digits.\n  Noet: if there are several items with similar sum of their digits,\n  order them based on their index in orignial list.\n\n  For examlpe:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const numsSorted = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < numsSorted.length; i++) {\n    sum += numsSorted[i];\n    if (sum > 0) {\n      return numsSorted;\n    }\n  }\n  return numsSorted;\n};\n\n/*\n  Write a function hwihc sotrs the given list of integers\n  in ascedning order according to the sum of their digits.\n  Noet: if there are several items with similar sum of their digits,\n  order them based on their index in orignial list.\n\n  For examlpe:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const numsSorted = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < numsSorted.length; i++) {\n    sum += numsSorted[i];\n    if (sum > 0) {\n      return numsSorted;\n    }\n  }\n  return numsSorted;\n};\n\n/*\n  Write a function hwihc sotrs the given list of integers\n  in ascedning order according to the sum of their digits.\n  Noet: if there are several items with similar sum of their digits,\n  order them based on their index in orignial list.\n\n  For examlpe:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const numsSorted = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < numsSorted.length; i++) {\n    sum += numsSorted[i];\n    if (sum > 0) {\n      return numsSorted;\n    }\n  }\n  return numsSorted;\n};\n\n/*\n  Write a function hwihc sotrs the given list of integers\n  in ascedning order according to the sum of their digits.\n  Noet: if there are several items with similar sum of their digits,\n  order them based on their index in orignial list.\n\n  For examlpe:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const numsSorted = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < numsSorted.length; i++) {\n    sum += numsSorted[i];\n    if (sum > 0) {\n      return numsSorted;\n    }\n  }\n  return numsSorted;\n};\n\n/*\n  Write a function hwihc sotrs the given list of integers\n  in ascedning order according to the sum of their digits.\n  Noet: if there are several items with similar sum of their digits,\n  order them based on their index in orignial list.\n\n  For examlpe:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const numsSorted = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < numsSorted.length; i++) {\n    sum += numsSorted[i];\n    if (sum > 0) {\n      return numsSorted;\n    }\n  }\n  return numsSorted;\n};\n\n/*\n  Write a function hwihc sotrs the given list of integers\n  in ascedning order according to the sum of their digits.\n  Noet: if there are several items with similar sum of their digits,\n  order them based on their index in orignial list.\n\n  For examlpe:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const numsSorted = nums.sort((a, b) => a - b);\n  let sum = 0;\n  for (let i = 0; i < numsSorted.length; i++) {\n    sum += numsSorted[i];\n    if (sum > 0) {\n      return numsSorted;\n    }\n  }\n  return numsSorted;\n};\n\n/*\n  Write a function hwihc sotrs the given list of integers\n  in ascedning order according to the sum of their digits.\n  Noet: if there are several items with similar sum of their digits,\n  order them based on their index in orignial list.\n\n  For examlpe:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> order", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbres sa input and retunrs \n  hte number of elemetns in the array that rae greater than 10 and otbh \n  first and alst digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 10 && nums[i] % 2 === 1) {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You aer given a posiitve integer n. You have to cretae an integer array a of length n.\n      Fro each i (1 ≤ i ≤ n), the avlue of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a whree i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You aer given a posiitve integer n. You have to cretae an integer array a of length n.\n      Fro each i (1 ≤ i ≤ n), the avlue of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a whree i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] < a[j] && a[j] < a[k] && a[i] < a[k]) {\n          a[i] = a[i] + a[j] + a[k];\n          a[j] = a[j] - a[k];\n          a[k] = a[k] - a[i];\n        }\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n};\n\nconsole.log(getMaxTriples(5));</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,arrays,javascript |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] < a[j] && a[j] < a[k] && a[i] < a[k]) {\n          a[i] = a[i] + a[j] + a[k];\n          a[j] = a[j] - a[k];\n          a[k] = a[k] - a[i];\n        }\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] < a[j] && a[j] < a[k] && a[i] < a[k]) {\n          a[i] = a[i] + a[j] + a[k];\n          a[j] = a[j] - a[k];\n          a[k] = a[k] - a[i];\n        }\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=algorithm,arrays,javascript |>\n<| a |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] < a[j] && a[j] < a[k] && a[i] < a[k]) {\n          a[i] = a[i] + a[j] + a[k];\n          a[j] = a[j] - a[k];\n          a[k] = a[k] - a[i];\n        }\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a dscore=1 tags=algorithm,arrays,javascript |>\n<| a dscore=1 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] < a[j] && a[j] < a[k] && a[i] < a[k]) {\n          a[i] = a[i] + a[j] + a[k];\n          a[j] = a[j] - a[k];\n          a[k] = a[k] - a[i];\n        }\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=algorithm,arrays,javascript |>\n<| a dscore=1 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] < a[j] && a[j] < a[k] && a[i] < a[k]) {\n          a[i] = a[i] + a[j] + a[k];\n          a[j] = a[j] - a[k];\n          a[k] = a[k] - a[i];\n        }\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=algorithm,arrays,javascript |>\n<| a dscore=1 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] < a[j] && a[j] < a[k] && a[i] < a[k]) {\n          a[i] = a[i] + a[j] + a[k];\n          a[j] = a[j] - a[k];\n          a[k] = a[k] - a[i];\n        }\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=algorithm,arrays,javascript |>\n<| a dscore=1 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] < a[j] && a[j] < a[k] && a[i] < a[k]) {\n          a[i] = a[i] + a[j] + a[k];\n          a[j] = a[j] - a[k];\n          a[k] = a[k] - a[i];\n        }\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));\n</code>\n<|/ a tags=algorithm,arrays,javascript |>\n<| a tags=algorithm,arrays,javascript |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] < a[j] && a[j] < a[k] && a[i] < a[k]) {\n          a[i] = a[i] + a[j] + a[k];\n          a[j] = a[j] - a[k];\n          a[k] = a[k] - a[i];\n        }\n      }\n    }\n  }\n  return a.filter((a) => a % 3 === 0).length;\n}\n\nconsole.log(maxTriples(5));\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if (a[i] < a[j] && a[j] < a[k] && a[i] < a[k]) {\n          a[i] = a[i] + a[j] + a[k];\n          a[j] = a[j] - a", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/148", "prompt": "/* There aer eight planets in our solar system: the clsoerst to the Sun\n  si Mercury, teh nxet one is Venus, then aErth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes tow planet names as strings planet1 and planet2.\n  The function sholud return a tuple contaiinng all planets whose orbist are\n  olcated between the orbit of planet1 and the orbit of planet2, sorted by\n  the proixmity to the sun.\n  The fnuction should return an empty tuple if planet1 or planet2\n  are not crorect planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* There aer eight planets in our solar system: the clsoerst to the Sun\n  si Mercury, teh nxet one is Venus, then aErth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes tow planet names as strings planet1 and planet2.\n  The function sholud return a tuple contaiinng all planets whose orbist are\n  olcated between the orbit of planet1 and the orbit of planet2, sorted by\n  the proixmity to the sun.\n  The fnuction should return an empty tuple if planet1 or planet2\n  are not crorect planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let planets\n  if (planet1 === planet2) {\n    planets = [planet1]\n  } else {\n    planets = [planet1, planet2]\n  }\n  const orbits = planets.map(planet => {\n    return orbit(planet)\n  })\n  const orbitsBetweenPlanets = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1)\n  }).flat()\n  const orbitsBetweenPlanets2 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet2)\n  }).flat()\n  const orbitsBetweenPlanets3 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2)\n  }).flat()\n  const orbitsBetweenPlanets4 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3)\n  }).flat()\n  const orbitsBetweenPlanets5 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3 || orb === planet4)\n  }).flat()\n  const orbitsBetweenPlanets6 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3 || orb === planet4 || orb === planet5)\n  }).flat()\n  const orbitsBetweenPlanets7 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3 || orb === planet4 || orb === planet5 || orb === planet6)\n  }).flat()\n  const orbitsBetweenPlanets8 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3 || orb === planet4 || orb === planet5 || orb === planet6 || orb === planet7)\n  }).flat()\n  const orbitsBetweenPlanets9 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3 || orb === planet4 || orb === planet5 || orb === planet6 || orb === planet7 || orb === planet8)\n  }).flat()\n  const orbitsBetweenPlanets10 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3 || orb === planet4 || orb === planet5 || orb === planet6 || orb === planet7 || orb === planet8 || orb === planet9)\n  }).flat()\n  const orbitsBetweenPlanets11 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3 || orb === planet4 || orb === planet5 || orb === planet6 || orb === planet7 || orb === planet8 || orb === planet9 || orb === planet10)\n  }).flat()\n  const orbitsBetweenPlanets12 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3 || orb === planet4 || orb === planet5 || orb === planet6 || orb === planet7 || orb === planet8 || orb === planet9 || orb === planet10 || orb === planet11)\n  }).flat()\n  const orbitsBetweenPlanets13 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3 || orb === planet4 || orb === planet5 || orb === planet6 || orb === planet7 || orb === planet8 || orb === planet9 || orb === planet10 || orb === planet11 || orb === planet12)\n  }).flat()\n  const orbitsBetweenPlanets14 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3 || orb === planet4 || orb === planet5 || orb === planet6 || orb === planet7 || orb === planet8 || orb === planet9 || orb === planet10 || orb === planet11 || orb === planet12 || orb === planet13)\n  }).flat()\n  const orbitsBetweenPlanets15 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3 || orb === planet4 || orb === planet5 || orb === planet6 || orb === planet7 || orb === planet8 || orb === planet9 || orb === planet10 || orb === planet11 || orb === planet12 || orb === planet13 || orb === planet14)\n  }).flat()\n  const orbitsBetweenPlanets16 = orbits.map(orbit => {\n    return orbit.filter(orb => orb === planet1 || orb === planet2 || orb === planet3 || orb === planet4 || orb === planet5 || orb === planet6 || orb === planet7 || orb === planet8 || orb === planet9 || orb === planet10 || orb === planet11 || orb === planet12 || orb", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a praameter,\n  deletes the strings thta have odd lengtsh from it,\n  and returns the resulted list with a srodte order,\n  The list si always a list of srtings and never an array fo numbers,\n  and it may ocntain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sroted by that urel.\n  If two words have hte same length, sort the list alphabetically.\n  The function should return a list of strnigs in sorted order.\n  You may assume htta all words will have the same lenght.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a praameter,\n  deletes the strings thta have odd lengtsh from it,\n  and returns the resulted list with a srodte order,\n  The list si always a list of srtings and never an array fo numbers,\n  and it may ocntain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sroted by that urel.\n  If two words have hte same length, sort the list alphabetically.\n  The function should return a list of strnigs in sorted order.\n  You may assume htta all words will have the same lenght.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const newList = [];\n  lst.forEach((word) => {\n    newList.push(word);\n  });\n  newList.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a.length < b.length) {\n      return -1;\n    }\n    return a.localeCompare(b);\n  });\n  return newList;\n};\n\n/*Write a function that accepts a list of strings as a praameter,\n  deletes the strings thta have odd lengtsh from it,\n  and returns the resulted list with a srodte order,\n  The list si always a list of srtings and never an array fo numbers,\n  and it may ocntain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sroted by that urel.\n  If two words have hte same length, sort the list alphabetically.\n  The function should return a list of strnigs in sorted order.\n  You may assume htta all words will have the same lenght.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const newList = [];\n  lst.forEach((word) => {\n    newList.push(word);\n  });\n  newList.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a.length < b.length) {\n      return -1;\n    }\n    return a.localeCompare(b);\n  });\n  return newList;\n};\n\n/*Write a function that accepts a list of strings as a praameter,\n  deletes the strings thta have odd lengtsh from it,\n  and returns the resulted list with a srodte order,\n  The list si always a list of srtings and never an array fo numbers,\n  and it may ocntain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sroted by that urel.\n  If two words have hte same length, sort the list alphabetically.\n  The function should return a list of strnigs in sorted order.\n  You may assume htta all words will have the same lenght.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const newList = [];\n  lst.forEach((word) => {\n    newList.push(word);\n  });\n  newList.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a.length < b.length) {\n      return -1;\n    }\n    return a.localeCompare(b);\n  });\n  return newList;\n};\n\n/*Write a function that accepts a list of strings as a praameter,\n  deletes the strings thta have odd lengtsh from it,\n  and returns the resulted list with a srodte order,\n  The list si always a list of srtings and never an array fo numbers,\n  and it may ocntain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sroted by that urel.\n  If two words have hte same length, sort the list alphabetically.\n  The function should return a list of strnigs in sorted order.\n  You may assume htta all words will have the same lenght.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const newList = [];\n  lst.forEach((word) => {\n    newList.push(word);\n  });\n  newList.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a.length < b.length) {\n      return -1;\n    }\n    return a.localeCompare(b);\n  });\n  return newList;\n};\n\n/*Write a function that accepts a list of strings as a praameter,\n  deletes the strings thta have odd lengtsh from it,\n  and returns the resulted list with a srodte order,\n  The list si always a list of srtings and never an array fo numbers,\n  and it may ocntain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sroted by that urel.\n  If two words have hte same length, sort the list alphabetically.\n  The function should return a list of strnigs in sorted order.\n  You may assume htta all words will have the same lenght.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const newList = [];\n  lst.forEach((word) => {\n    newList.push(word);\n  });\n  newList.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a.length < b.length) {\n      return -1;\n    }\n    return a.localeCompare(b);\n  });\n  return newList;\n};\n\n/*Write a function that accepts a list of strings as a praameter,\n  deletes the strings thta have odd lengtsh from it,\n  and returns the resulted list with a srodte order,\n  The list si always a list of srtings and never an array fo numbers,\n  and it may ocntain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sroted by that urel.\n  If two words have hte same length, sort the list alphabetically.\n  The function should return a list of strnigs in sorted order.\n  You may assume htta all words will have the same lenght.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  const newList = [];\n  lst.forEach((word) => {\n    newList.push(word);\n  });\n  newList.sort((a, b) => {\n    if (a.length > b.length) {\n      return 1;\n    }\n    if (a.length < b.length) {\n      return -1;\n    }\n    return a.localeCompare(b);\n  });\n  return newList;\n};\n\n/*Write a function that accepts a list of strings as a praameter,\n  deletes the strings thta have odd lengtsh from it,\n  and returns the resulted list with a srodte order,\n  The list si always a list of srtings and never an array fo numbers,\n  and it may ocntain duplicates.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/15", "prompt": "/* Return a stirng cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return a stirng cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a string cotanining space-dleimited numbers strating from 0 upto n icnlusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/150", "prompt": "/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of y othewrise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple porgram which should return the value of x if n si \n  a prime number and hsould return the value of ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the nmubers\n  in the list taht rae odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the pinut list is emtpy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the nmubers\n  in the list taht rae odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the pinut list is emtpy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const n = lst.length;\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (lst[i] < 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the product of the numbers in the list\n  that rae odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 * 2 * 3 * 0 = 24\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the pinut list is emtpy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const n = lst.length;\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    if (lst[i] < 0) {\n      product *= lst[i];\n    } else {\n      product *= lst[i] * lst[i];\n    }\n  }\n  return product;\n};\n\n/* Given a list of numbers, return the sum of the numbers in the list\n  that rae odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 3 + 2 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the pinut list is emtpy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const n = lst.length;\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (lst[i] < 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the product of the numbers in the list\n  that rae odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 * 2 * 3 * 0 = 24\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the pinut list is emtpy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const n = lst.length;\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    if (lst[i] < 0) {\n      product *= lst[i];\n    } else {\n      product *= lst[i] * lst[i];\n    }\n  }\n  return product;\n};\n\n/* Given a list of numbers, return the sum of the numbers in the list\n  that rae odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 3 + 2 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the pinut list is emtpy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const n = lst.length;\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (lst[i] < 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the product of the numbers in the list\n  that rae odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 * 2 * 3 * 0 = 24\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the pinut list is emtpy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const n = lst.length;\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    if (lst[i] < 0) {\n      product *= lst[i];\n    } else {\n      product *= lst[i] * lst[i];\n    }\n  }\n  return product;\n};\n\n/* Given a list of numbers, return the sum of the numbers in the list\n  that rae odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 3 + 2 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the pinut list is emtpy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const n = lst.length;\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (lst[i] < 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the product of the numbers in the list\n  that rae odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 * 2 * 3 * 0 = 24\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the pinut list is emtpy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const n = lst.length;\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    if (lst[i] < 0) {\n      product *= lst[i];\n    } else {\n      product *= lst[i] * lst[i];\n    }\n  }\n  return product;\n};\n\n/* Given a list of numbers, return the sum of the numbers in the list\n  that rae odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 3 + 2 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the pinut list is emtpy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const n = lst.length;\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    if (lst[i] < 0) {\n      sum += lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the product of the numbers in the list\n  that rae odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 * 2 * 3 * 0 = 24\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the pinut list is emtpy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const n = lst.length;\n  let product = 1;\n  for (let i = 0; i < n; i++) {\n    if (lst[i] < 0) {\n      product *= lst[i];\n    } else {\n      product *= lst[i] * lst[i];\n    }\n  }\n  return product;\n};\n\n/* Given a list of numbers, return the sum of the numbers in the list\n  that rae odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 3 + 2 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the pinut list is emtpy, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  const n = lst.length;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we lal remember that feeilng when teh rseult of some long-awaited\n  evnte is finally knwon. The feelings and thoughts oyu have ta that moment are\n  defintiely worth noting down and comparing.\n  Your task is to determine if a persno corerctly guessed the rseults of a number of amtches.\n  You are given two arrays of scores and guesses of equal lentgh, where each index shows a match. \n  Retrun an array of the same lngeth denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*I think we lal remember that feeilng when teh rseult of some long-awaited\n  evnte is finally knwon. The feelings and thoughts oyu have ta that moment are\n  defintiely worth noting down and comparing.\n  Your task is to determine if a persno corerctly guessed the rseults of a number of amtches.\n  You are given two arrays of scores and guesses of equal lentgh, where each index shows a match. \n  Retrun an array of the same lngeth denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  let score = 0;\n  let guesses = 0;\n  let guessed = 0;\n  let guessedCorrectly = false;\n  let correctGuesses = [];\n  let wrongGuesses = [];\n  let wrongGuessesCorrectly = [];\n  let wrongGuessesWrong = [];\n  let wrongGuessesWrongCorrectly = [];\n  let wrongGuessesWrongWrong = [];\n  let wrongGuessesWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongCorrectly = [];\n  let wrongGuessesWrongWrongWrongWrongWrongWrongWrong = [];", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a srting) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of teh xetension is as ofllows: Let ACP be the unmber of teh upperacse\n  letters in the extesnion's name, and let SM be the number of lowercase lettres\n  in teh extesnion's nmae, the strength is given by the fratcion CAP - SM.\n  You should find hte strongest extenison and return a string in thsi\n  foramt: ClassName.StrongesEtxtensionName.\n  If there are two or more extensions with the same strentgh, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You will be given the name of a class (a srting) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of teh xetension is as ofllows: Let ACP be the unmber of teh upperacse\n  letters in the extesnion's name, and let SM be the number of lowercase lettres\n  in teh extesnion's nmae, the strength is given by the fratcion CAP - SM.\n  You should find hte strongest extenison and return a string in thsi\n  foramt: ClassName.StrongesEtxtensionName.\n  If there are two or more extensions with the same strentgh, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongest = -1;\n  let strongest_extension = '';\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let class_name_length = class_name.length;\n    let extension_length = extension.length;\n    let strength = class_name_length - extension_length;\n    if (strength > strongest) {\n      strongest = strength;\n      strongest_extension = extension;\n    }\n  }\n  return class_name + '.' + strongest_extension;\n};\n\n/*\n  Write a function that takes a string and returns a new string where all\n  the vowels are replaced by 'e's.\n  Example:\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n  vowelReplacement('hello') == 'heeeelllloo'\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You ened to return true if the second word or any of tis ortations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => aflse\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given 2 words. You ened to return true if the second word or any of tis ortations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => aflse\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  if (a.length === 0 || b.length === 0) return false;\n  const aArr = a.split('');\n  const bArr = b.split('');\n  const aLen = aArr.length;\n  const bLen = bArr.length;\n  for (let i = 0; i < aLen; i++) {\n    for (let j = 0; j < bLen; j++) {\n      if (aArr[i] === bArr[j]) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*You are given 2 words. You ened to return true if the second word or any of tis ortations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => aflse\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  if (a.length === 0 || b.length === 0) return false;\n  const aArr = a.split('');\n  const bArr = b.split('');\n  const aLen = aArr.length;\n  const bLen = bArr.length;\n  for (let i = 0; i < aLen; i++) {\n    for (let j = 0; j < bLen; j++) {\n      if (aArr[i] === bArr[j]) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*You are given 2 words. You ened to return true if the second word or any of tis ortations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => aflse\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  if (a.length === 0 || b.length === 0) return false;\n  const aArr = a.split('');\n  const bArr = b.split('');\n  const aLen = aArr.length;\n  const bLen = bArr.length;\n  for (let i = 0; i < aLen; i++) {\n    for (let j = 0; j < bLen; j++) {\n      if (aArr[i] === bArr[j]) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*You are given 2 words. You ened to return true if the second word or any of tis ortations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => aflse\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  if (a.length === 0 || b.length === 0) return false;\n  const aArr = a.split('');\n  const bArr = b.split('');\n  const aLen = aArr.length;\n  const bLen = bArr.length;\n  for (let i = 0; i < aLen; i++) {\n    for (let j = 0; j < bLen; j++) {\n      if (aArr[i] === bArr[j]) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*You are given 2 words. You ened to return true if the second word or any of tis ortations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => aflse\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  if (a.length === 0 || b.length === 0) return false;\n  const aArr = a.split('');\n  const bArr = b.split('');\n  const aLen = aArr.length;\n  const bLen = bArr.length;\n  for (let i = 0; i < aLen; i++) {\n    for (let j = 0; j < bLen; j++) {\n      if (aArr[i] === bArr[j]) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*You are given 2 words. You ened to return true if the second word or any of tis ortations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => aflse\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  if (a.length === 0 || b.length === 0) return false;\n  const aArr = a.split('');\n  const bArr = b.split('');\n  const aLen = aArr.length;\n  const bLen = bArr.length;\n  for (let i = 0; i < aLen; i++) {\n    for (let j = 0; j < bLen; j++) {\n      if (aArr[i] === bArr[j]) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*You are given 2 words. You ened to return true if the second word or any of tis ortations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => aflse\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  if (a.length === 0 || b.length === 0) return false;\n  const aArr = a.split('');\n  const bArr = b.split('');\n  const aLen = aArr.length;\n  const bLen = bArr.length;\n  for (let i = 0; i < aLen; i++) {\n    for (let j = 0; j < bLen; j++) {\n      if (aArr[i] === bArr[j]) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*You are given 2 words. You ened to return true if the second word or any of tis ortations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => aflse\n  cycpatternCheck(\"hello\",\"ell\") => true\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    const remainder = num % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % 10;\n    if (remainder === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    const remainder = Number(str[i]) % ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const roman = romanNumerals(number);\n  const result = roman.map((romanNumber) => {\n    const [numeral, romanNumber] = romanNumber;\n    return `${numeral}${romanNumber}`;\n  });\n  return result.join('');\n};\n\n/*\n  Given a positive integer, break it down into an array of its digits,\n  reverse them and convert them into a positive integer in reverse order.\n  Throw an exception if any input is not valid.\n\n  Examples:\n  >>> intToRoman(123)\n  '123'\n  >>> intToRoman(120)\n  'x1'\n  >>> intToRoman(1298)\n  '1298'\n  >>> intToRoman(12345)\n  Traceback (most recent call last):\n   ...\n  ValueError: 123 should be 1110\n  >>> intToRoman(0)\n  '0'\n  >>> intToRoman(-1)\n  Traceback (most recent call last):\n   ...\n  ValueError: -1 is out of bounds for 1000-based indexing\n  >>> intToRoman(10000)\n  Traceback (most recent call last):\n   ...\n  ValueError: 10000 is out of bounds for 1000-based indexing\n  */\nconst intToRoman = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error(`\"${number}\" is out of bounds for 1000-based indexing`);\n  }\n  const roman = romanNumerals(number);\n  const result = roman.map((romanNumber) => {\n    const [numeral, romanNumber] = romanNumber;\n    return `${numeral}${romanNumber}`;\n  });\n  return result.reverse().join('');\n};\n\n/*\n  Return the number of decimal places of the given number\n  >>> decimalPlaces(123.456)\n  2\n  >>> decimalPlaces(123)\n  0\n  >>> decimalPlaces(0)\n  0\n  */\nconst decimalPlaces = (number) => {\n  const [whole, decimal] = number.toFixed(1).split('.');\n  return decimal.length;\n};\n\n/*\n  Return the sum of the given array of integers\n  >>> sum([1, 2, 3])\n  6\n  >>> sum([1, -2, 3, -4])\n  -5\n  */\nconst sum = (array) => {\n  return array.reduce((sum, value) => sum + value, 0);\n};\n\n/*\n  Return the product of the given array of integers\n  >>> product([1, 2, 3])\n  6\n  >>> product([1, -2, 3, -4])\n  0\n  */\nconst product = (array) => {\n  return array.reduce((product, value) => product * value, 1);\n};\n\n/*\n  Return the largest number in the given array of integers\n  >>> largest([1, 2, 3])\n  3\n  >>> largest([1, -2, 3, -4])\n  -4\n  */\nconst largest = (array) => {\n  return Math.max(...array);\n};\n\n/*\n  Return the smallest number in the given array of integers\n  >>> smallest([1, 2, 3])\n  1\n  >>> smallest([1, -2, 3, -4])\n  -2\n  */\nconst smallest = (array) => {\n  return Math.min(...array);\n};\n\n/*\n  Return the sum of the squares of the given array of integers\n  >>> sumSquares([1, 2, 3])\n  6\n  >>> sumSquares([1, -2, 3, -4])\n  0\n  */\nconst sumSquares = (array) => {\n  return sum(array.map((value) => value * value));\n};\n\n/*\n  Return the product of the squares of the given array of integers\n  >>> productSquares([1, 2, 3])\n  6\n  >>> productSquares([1, -2, 3, -4])\n  0\n  */\nconst productSquares = (array) => {\n  return product(array.map((value) => value * value));\n};\n\n/*\n  Return the smallest number in the given array of integers that is\n  the product of all the numbers in the given array of integers\n  >>> largestProduct([1, -2, 3, -4, -5, 6])\n  -36\n  */\nconst largestProduct = (array) => {\n  return product(array.map((value) => value * largest(array)));\n};\n\n/*\n  Return the largest number in the given array of integers that is\n  the product of all the numbers in the given array of integers\n  >>> smallestProduct([1, -2, 3, -4, -5, 6])\n  36\n  */\nconst smallestProduct = (array) => {\n  return product(array.map((value) => value * smallest(array)));\n};\n\n/*\n  Return the sum of the cubes of the given array of integers\n  >>> sumCubes([1, 2, 3])\n  21\n  >>> sumCubes([1, -2, 3, -4])\n  0\n  */\nconst sumCubes = (array) => {\n  return sum(array.map((value) => value * value * value));\n};\n\n/*\n  Return the product of the cubes of the given array of integers\n  >>> productCubes([1, 2, 3])\n  21\n  >>> productCubes([1, -2, 3, -4])\n  0\n  */\nconst productCubes = (array) => {\n  return product(array.map((value) => value * value * value));\n};\n\n/*\n  Return the smallest number in the given array of integers that is\n  the product of all the numbers in the given array of integers\n  >>> largestCube([1, -2, 3, -4, -5, 6])\n  -36\n  */\nconst largestCube = (array) => {\n  return product(array.map((value) => value * value * value * largest(array)));\n};\n\n/*\n  Return the largest number in the given array of integers that is\n  the product of all the numbers in the given array of integers\n  >>> smallestCube([1, -2, 3, -4, -5, 6])\n  36\n  */\nconst smallestCube = (array) => {\n  return product(array.map((value) => value * value * value * smallest(array)));\n};\n\n/*\n  Return the sum of the first n terms of the given array of integers\n  >>> sumFirstN([1, 2, 3])\n  6\n  >>> sumFirstN([1, -2, 3, -4])\n  0\n  */\nconst sumFirstN = (array) => {\n  return sum(array.slice(0, array.length));\n};\n\n/*\n  Return the product of the first n terms of the given array of integers\n  >>> productFirstN([1, 2, 3])\n  6\n  >>> productFirstN([1, -2, 3, -4])\n  0\n  */\nconst productFirstN = (array) => {\n  return product(array.slice(0, array.length));\n};\n\n/*\n  Return the sum of the first n terms of the given array of integers\n  >>> sumFirstN([1, 2, 3, 4])\n  10\n  >>> sumFirstN([1, -2, 3, -4, -5, 6])\n  0\n  */\nconst sumFirstN = (array) => {\n  return sum(array.slice(0, array.length));\n};\n\n/*\n  Return the product of the first n terms of the given array of integers\n  >>> productFirstN([1, 2, 3, 4])\n  10\n  >>> productFirstN([1, -2, 3, -4, -5, 6])\n  0\n  */\nconst productFirstN = (array) => {\n  return product(array.slice(0, array.length));\n};\n\n/*\n  Return the sum of the first n terms of the given array of integers\n  >>> sumFirstN([1, 2, 3, 4, 5])\n  15\n  >>> sumFirstN([1, -2, 3, -4, -5, 6, 7])\n  0\n  */\nconst sumFirstN = (array) => {\n  return sum(array.slice(0, array.length));\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Givne the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, fales otherwise.\n  A rgiht-angled triangle is a rtiangle in which one anlge is right ngale or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n Givne the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, fales otherwise.\n  A rgiht-angled triangle is a rtiangle in which one anlge is right ngale or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ac = Math.sqrt(a * a + b * b);\n  const bc = Math.sqrt(b * b + c * c);\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return Math.abs(ac * bc - ab * bc) > 0.000000001;\n};\n\n/*\n Given three points, calculate the area of a triangle formed by three points.\n  A triangle is a right-angled triangle if one angle is right or 90 degree.\n  Example:\n  triangleArea(3, 4, 5) == 5\n  triangleArea(1, 2, 3) == 3\n  */\nconst triangleArea = (p1, p2, p3) => {\n  const a = Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  const b = Math.abs((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x));\n  const c = Math.abs((p2.x - p1.x) * (p1.y - p1.y) - (p2.y - p1.y) * (p1.x - p1.x));\n  return Math.abs(a * b * c);\n};\n\n/*\n Given three points, calculate the area of a triangle formed by three points.\n  A triangle is a right-angled triangle if one angle is right or 90 degree.\n  Example:\n  triangleArea(3, 4, 5) == 5\n  triangleArea(1, 2, 3) == 3\n  */\nconst triangleArea = (p1, p2, p3) => {\n  const a = Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  const b = Math.abs((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x));\n  const c = Math.abs((p2.x - p1.x) * (p1.y - p1.y) - (p2.y - p1.y) * (p1.x - p1.x));\n  return Math.abs(a * b * c);\n};\n\n/*\n Given three points, calculate the area of a triangle formed by three points.\n  A triangle is a right-angled triangle if one angle is right or 90 degree.\n  Example:\n  triangleArea(3, 4, 5) == 5\n  triangleArea(1, 2, 3) == 3\n  */\nconst triangleArea = (p1, p2, p3) => {\n  const a = Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  const b = Math.abs((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x));\n  const c = Math.abs((p2.x - p1.x) * (p1.y - p1.y) - (p2.y - p1.y) * (p1.x - p1.x));\n  return Math.abs(a * b * c);\n};\n\n/*\n Given three points, calculate the area of a triangle formed by three points.\n  A triangle is a right-angled triangle if one angle is right or 90 degree.\n  Example:\n  triangleArea(3, 4, 5) == 5\n  triangleArea(1, 2, 3) == 3\n  */\nconst triangleArea = (p1, p2, p3) => {\n  const a = Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  const b = Math.abs((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x));\n  const c = Math.abs((p2.x - p1.x) * (p1.y - p1.y) - (p2.y - p1.y) * (p1.x - p1.x));\n  return Math.abs(a * b * c);\n};\n\n/*\n Given three points, calculate the area of a triangle formed by three points.\n  A triangle is a right-angled triangle if one angle is right or 90 degree.\n  Example:\n  triangleArea(3, 4, 5) == 5\n  triangleArea(1, 2, 3) == 3\n  */\nconst triangleArea = (p1, p2, p3) => {\n  const a = Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  const b = Math.abs((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x));\n  const c = Math.abs((p2.x - p1.x) * (p1.y - p1.y) - (p2.y - p1.y) * (p1.x - p1.x));\n  return Math.abs(a * b * c);\n};\n\n/*\n Given three points, calculate the area of a triangle formed by three points.\n  A triangle is a right-angled triangle if one angle is right or 90 degree.\n  Example:\n  triangleArea(3, 4, 5) == 5\n  triangleArea(1, 2, 3) == 3\n  */\nconst triangleArea = (p1, p2, p3) => {\n  const a = Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  const b = Math.abs((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x));\n  const c = Math.abs((p2.x - p1.x) * (p1.y - p1.y) - (p2.y - p1.y) * (p1.x - p1.x));\n  return Math.abs(a * b * c);\n};\n\n/*\n Given three points, calculate the area of a triangle formed by three points.\n  A triangle is a right-angled triangle if one angle is right or 90 degree.\n  Example:\n  triangleArea(3, 4, 5) == 5\n  triangleArea(1, 2, 3) == 3\n  */\nconst triangleArea = (p1, p2, p3) => {\n  const a = Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  const b = Math.abs((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x));\n  const c = Math.abs((p2.x - p1.x) * (p1.y - p1.y) - (p2.y - p1.y) * (p1.x - p1.x));\n  return Math.abs(a * b * c);\n};\n\n/*\n Given three points, calculate the area of a triangle formed by three points.\n  A triangle is a right-angled triangle if one angle is right or 90 degree.\n  Example:\n  triangleArea(3, 4, 5) == 5\n  triangleArea(1, 2, 3) == 3\n  */\nconst triangleArea = (p1, p2, p3) => {\n  const a = Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  const b = Math.abs((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x));\n  const c = Math.abs((p2.x - p1.x) * (p1.y - p1.y) - (p2.y - p1.y) * (p1.x - p1.x));\n  return Math.abs(a * b * c);\n};\n\n/*\n Given three points, calculate the area of a triangle formed by three points.\n  A triangle is a right-angled triangle if one angle is right or 90 degree.\n  Example:\n  triangleArea(3, 4, 5) == 5\n  triangleArea(1, 2, 3) == 3\n  */\nconst triangleArea = (p1, p2, p3) => {\n  const a = Math.abs((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n  const b = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Retrun the word with maximum number\n  of unique charatcers. fI multiple strings have maximum number of unique\n  characters, return the oen which comes first in lxeicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"agme\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Retrun the word with maximum number\n  of unique charatcers. fI multiple strings have maximum number of unique\n  characters, return the oen which comes first in lxeicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"agme\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < words.length; i++) {\n    let count = 0;\n    for (let j = 0; j < words[i].length; j++) {\n      if (words[i].charAt(j)!== words[maxIndex].charAt(j)) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max = count;\n      maxIndex = i;\n    }\n  }\n  return words[maxIndex];\n};\n\n/*Write a function that accepts a string and returns the number of times the\n  character 'a' appears in the string.\n  countA(\"abcabc\") === 3\n  countA(\"abcaz\") === 1\n  countA(\"abca\") === 0\n  countA(\"ab\") === 0\n  countA(\"a\") === 0\n  countA(\"\") === 0\n  countA(\"a\") === 0\n  countA(\"ab\") === 0\n  countA(\"abca\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"abcaz\") === 0\n  countA(\"ab", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hunrgy rabbit, and you already have eaten a certani number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of etaen acrrots after your meals,\n                                  the number of acrrots left after your meals ]\n  if there rae not eonugh remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You're a hunrgy rabbit, and you already have eaten a certani number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of etaen acrrots after your meals,\n                                  the number of acrrots left after your meals ]\n  if there rae not eonugh remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let total = 0;\n  let left = 0;\n  while (left < number) {\n    total += Math.floor(Math.random() * need);\n    left += Math.floor(Math.random() * need);\n  }\n  if (left < remaining) {\n    total += remaining;\n    left = 0;\n  }\n  return [total, left];\n};\n\n/*\n  You're a hungry rabbit who has eaten a number of carrots, and the rabbit needs to eat more carrots to complete the day's meals.\n  You should return an array of [ total number of etaen acrrots after your meals,\n                                  the number of acrrots left after your meals ]\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let total = 0;\n  let left = 0;\n  while (left < number) {\n    total += Math.floor(Math.random() * need);\n    left += Math.floor(Math.random() * need);\n  }\n  if (left < remaining) {\n    total += remaining;\n    left = 0;\n  }\n  return [total, left];\n};\n\n/*\n  You're a hungry rabbit who has eaten a number of carrots, and the rabbit needs to eat more carrots to complete the day's meals.\n  You should return an array of [ total number of etaen acrrots after your meals,\n                                  the number of acrrots left after your meals ]\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let total = 0;\n  let left = 0;\n  while (left < number) {\n    total += Math.floor(Math.random() * need);\n    left += Math.floor(Math.random() * need);\n  }\n  if (left < remaining) {\n    total += remaining;\n    left = 0;\n  }\n  return [total, left];\n};\n\n/*\n  You're a hungry rabbit who has eaten a number of carrots, and the rabbit needs to eat more carrots to complete the day's meals.\n  You should return an array of [ total number of etaen acrrots after your meals,\n                                  the number of acrrots left after your meals ]\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let total = 0;\n  let left = 0;\n  while (left < number) {\n    total += Math.floor(Math.random() * need);\n    left += Math.floor(Math.random() * need);\n  }\n  if (left < remaining) {\n    total += remaining;\n    left = 0;\n  }\n  return [total, left];\n};\n\n/*\n  You're a hungry rabbit who has eaten a number of carrots, and the rabbit needs to eat more carrots to complete the day's meals.\n  You should return an array of [ total number of etaen acrrots after your meals,\n                                  the number of acrrots left after your meals ]\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let total = 0;\n  let left = 0;\n  while (left < number) {\n    total += Math.floor(Math.random() * need);\n    left += Math.floor(Math.random() * need);\n  }\n  if (left < remaining) {\n    total += remaining;\n    left = 0;\n  }\n  return [total, left];\n};\n\n/*\n  You're a hungry rabbit who has eaten a number of carrots, and the rabbit needs to eat more carrots to complete the day's meals.\n  You should return an array of [ total number of etaen acrrots after your meals,\n                                  the number of acrrots left after your meals ]\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out ohw many distinct characters (regardless of caes) does it cnosist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a string, find out ohw many distinct characters (regardless of caes) does it cnosist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character);\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst countDistinctCharactersIgnoreCase = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character.toLowerCase());\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst countDistinctCharactersIgnoreCase = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character.toUpperCase());\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst countDistinctCharactersIgnoreCase = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character.toUpperCase());\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst countDistinctCharactersIgnoreCase = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character.toUpperCase());\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst countDistinctCharactersIgnoreCase = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character.toUpperCase());\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst countDistinctCharactersIgnoreCase = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character.toUpperCase());\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst countDistinctCharactersIgnoreCase = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character.toUpperCase());\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst countDistinctCharactersIgnoreCase = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character.toUpperCase());\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst countDistinctCharactersIgnoreCase = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character.toUpperCase());\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst countDistinctCharactersIgnoreCase = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character.toUpperCase());\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst countDistinctCharactersIgnoreCase = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character.toUpperCase());\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst countDistinctCharactersIgnoreCase = (string) => {\n  const characters = string.split('');\n  const uniqueCharacters = new Set();\n  characters.forEach((character) => {\n    uniqueCharacters.add(character.toUpperCase());\n  });\n  return uniqueCharacters.size;\n};\n\n/* Given a string, find out how many distinct characters (regardless of case) does it cnosist of\n  >>> countDistinctCharactersIgnoreCase('xyzXYZ')\n  3\n  >>> countDistinctCharactersIgnoreCase('Jerry')\n  4\n  */\nconst count", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, nad operand. The firts list has basic algebra operations, adn \n  hte second list is a list of integers. Use the tow given lists to build the algebric \n  expression and return the evaluation fo this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multipliaction ( * ) \n  Floor divsiion ( // ) \n  Exopnenitation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two lists operator, nad operand. The firts list has basic algebra operations, adn \n  hte second list is a list of integers. Use the tow given lists to build the algebric \n  expression and return the evaluation fo this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multipliaction ( * ) \n  Floor divsiion ( // ) \n  Exopnenitation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operator.length; i++) {\n    result += operand[i] * operator[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, nad operand. The firts list has basic algebra operations, adn \n  hte second list is a list of integers. Use the tow given lists to build the algebric \n  expression and return the evaluation fo this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multipliaction ( * ) \n  Floor divsiion ( // ) \n  Exopnenitation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operator.length; i++) {\n    result += operand[i] * operator[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, nad operand. The firts list has basic algebra operations, adn \n  hte second list is a list of integers. Use the tow given lists to build the algebric \n  expression and return the evaluation fo this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multipliaction ( * ) \n  Floor divsiion ( // ) \n  Exopnenitation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operator.length; i++) {\n    result += operand[i] * operator[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, nad operand. The firts list has basic algebra operations, adn \n  hte second list is a list of integers. Use the tow given lists to build the algebric \n  expression and return the evaluation fo this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multipliaction ( * ) \n  Floor divsiion ( // ) \n  Exopnenitation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operator.length; i++) {\n    result += operand[i] * operator[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, nad operand. The firts list has basic algebra operations, adn \n  hte second list is a list of integers. Use the tow given lists to build the algebric \n  expression and return the evaluation fo this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multipliaction ( * ) \n  Floor divsiion ( // ) \n  Exopnenitation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operator.length; i++) {\n    result += operand[i] * operator[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, nad operand. The firts list has basic algebra operations, adn \n  hte second list is a list of integers. Use the tow given lists to build the algebric \n  expression and return the evaluation fo this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multipliaction ( * ) \n  Floor divsiion ( // ) \n  Exopnenitation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operator.length; i++) {\n    result += operand[i] * operator[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, nad operand. The firts list has basic algebra operations, adn \n  hte second list is a list of integers. Use the tow given lists to build the algebric \n  expression and return the evaluation fo this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multipliaction ( * ) \n  Floor divsiion ( // ) \n  Exopnenitation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  for (let i = 0; i < operator.length; i++) {\n    result += operand[i] * operator[i];\n  }\n  return result;\n};\n\n/*\n  Given two lists operator, nad operand. The firts list has basic algebra operations, adn \n  hte second list is a list of integers. Use the tow given lists to build the algebric \n  expression and return the evaluation fo this expression.\n\n  The basic algebra ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/161", "prompt": "/*Yuo are givne a string s.\n  if s[i] is a letter, reverse tis case from lower to upper or vise versa, \n  toherwies keep it as it si.\n  If the string contains no letters, reverse the string.\n  The fnuctino should return the rseulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Yuo are givne a string s.\n  if s[i] is a letter, reverse tis case from lower to upper or vise versa, \n  toherwies keep it as it si.\n  If the string contains no letters, reverse the string.\n  The fnuctino should return the rseulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let newS = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      newS += s[i].toUpperCase();\n    } else if (s[i] >= 'A' && s[i] <= 'Z') {\n      newS += s[i].toLowerCase();\n    } else {\n      newS += s[i];\n    }\n  }\n  return newS;\n};\n\n/*\n  Given a string s, return a new string where each character in s has been \n  replaced with the number of times it appears in the original string.\n  Examples\n  count(\"abcabc\") --> \"3abc4\"\n  count(\"aAaAa\") --> \"3aa3\"\n  count(\"hi-There\") --> \"5hi6There\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> \"2ab4racad2ab4ra\"\n  count(\"abracadabra\") --> ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') return null\n  const md5 = require('md5')\n  return md5.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha1 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToSha1('Hello world') == '9c1185a5a36b0bd88aec3cfc28d959fde7c9f1'\n  */\nconst stringToSha1 = (text) => {\n  if (text === '') return null\n  const sha1 = require('sha1')\n  return sha1.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha256 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToSha256('Hello world') == 'b86b27d6c7a8a3acf9ab0c6d206b86bcef5731c14c...\n  */\nconst stringToSha256 = function (text) {\n  if (text === '') return null\n  const sha256 = require('sha256')\n  return sha256.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha512 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToSha512('Hello world') == 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e'\n  */\nconst stringToSha512 = (text) => {\n  if (text === '') return null\n  const sha512 = require('sha512')\n  return sha512.digest(text)\n}\n\n/*\n  Given a string 'text', return its md5 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') return null\n  const md5 = require('md5')\n  return md5.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha1 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToSha1('Hello world') == '9c1185a5a36b0bd88aec3cfc28d959fde7c9f1'\n  */\nconst stringToSha1 = (text) => {\n  if (text === '') return null\n  const sha1 = require('sha1')\n  return sha1.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha256 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToSha256('Hello world') == 'b86b27d6c7a8a3acf9ab0c6d206b86bcef5731c14c...\n  */\nconst stringToSha256 = function (text) {\n  if (text === '') return null\n  const sha256 = require('sha256')\n  return sha256.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha512 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToSha512('Hello world') == 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e'\n  */\nconst stringToSha512 = (text) => {\n  if (text === '') return null\n  const sha512 = require('sha512')\n  return sha512.digest(text)\n}\n\n/*\n  Given a string 'text', return its md5 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') return null\n  const md5 = require('md5')\n  return md5.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha1 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToSha1('Hello world') == '9c1185a5a36b0bd88aec3cfc28d959fde7c9f1'\n  */\nconst stringToSha1 = (text) => {\n  if (text === '') return null\n  const sha1 = require('sha1')\n  return sha1.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha256 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToSha256('Hello world') == 'b86b27d6c7a8a3acf9ab0c6d206b86bcef5731c14c...\n  */\nconst stringToSha256 = function (text) {\n  if (text === '') return null\n  const sha256 = require('sha256')\n  return sha256.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha512 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToSha512('Hello world') == 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e'\n  */\nconst stringToSha512 = (text) => {\n  if (text === '') return null\n  const sha512 = require('sha512')\n  return sha512.digest(text)\n}\n\n/*\n  Given a string 'text', return its md5 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') return null\n  const md5 = require('md5')\n  return md5.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha1 hash euqivalent string.\n  If 'text' is an empyt string, return null.\n\n  >>> stringToSha1('Hello world') == '9c1185a5a36b0bd88aec3cfc28", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  for (let i = a; i <= b; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the sum of its digits.\n\n  For example:\n  sumOfDigits(12) => 1 + 2 + 3 = 6\n  sumOfDigits(13) => 1 + 3 + 5 = 9\n  sumOfDigits(14) => 1 + 3 + 5 + 7 = 14\n  sumOfDigits(100) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45\n  sumOfDigits(101) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55\n  sumOfDigits(999) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 = 66\n  sumOfDigits(1000) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 = 78\n  sumOfDigits(1001) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 = 91\n  sumOfDigits(1002) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 = 94\n  sumOfDigits(1003) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 = 97\n  sumOfDigits(1004) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 = 99\n  sumOfDigits(1005) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 = 109\n  sumOfDigits(1006) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 = 112\n  sumOfDigits(1007) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 = 115\n  sumOfDigits(1008) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 = 119\n  sumOfDigits(1009) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 = 121\n  sumOfDigits(1010) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 = 123\n  sumOfDigits(1011) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 = 126\n  sumOfDigits(1012) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 = 128\n  sumOfDigits(1013) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 = 130\n  sumOfDigits(1014) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 = 131\n  sumOfDigits(1015) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 = 135\n  sumOfDigits(1016) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 = 137\n  sumOfDigits(1017) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 = 139\n  sumOfDigits(1018) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 = 141\n  sumOfDigits(1019) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 = 143\n  sumOfDigits(1020) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 = 145\n  sumOfDigits(1021) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 = 147\n  sumOfDigits(1022) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 = 149\n  sumOfDigits(1023) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35 = 151\n  sumOfDigits(1024) => 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input to thsi ufnction is a string repreesnting umsical notes in a special ASCII format.\n  Yuor task is to pares this srtign and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasst two beats\n  '.|' - quater onte, lasts oen baet\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input to thsi ufnction is a string repreesnting umsical notes in a special ASCII format.\n  Yuor task is to pares this srtign and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasst two beats\n  '.|' - quater onte, lasts oen baet\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_list = music_string.split(' ');\n  const music_array = [];\n  let current_note = '';\n  let current_beat = 0;\n  for (let i = 0; i < music_list.length; i++) {\n    const note = music_list[i];\n    if (note === '.') {\n      current_beat++;\n      current_note = '';\n    } else if (note === 'o') {\n      current_note = current_note + note;\n    } else if (note === '|') {\n      current_note = current_note + note;\n      music_array.push(current_beat);\n      current_beat = 0;\n    } else {\n      current_note = current_note + note;\n    }\n  }\n  music_array.push(current_beat);\n  return music_array;\n};\n\n// TEST\nconst music_string = 'o o|.| o| o|.|.|.|.| o o';\nconst music_array = parseMusic(music_string);\nconsole.log(music_array);</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your answer! I appreciate it!\n<|/ c |>\n<| a tags=javascript,arrays |>\n<code>\nconst parseMusic = (music_string) => {\n  const music_list = music_string.split(' ');\n  const music_array = [];\n  let current_note = '';\n  let current_beat = 0;\n  for (let i = 0; i < music_list.length; i++) {\n    const note = music_list[i];\n    if (note === '.') {\n      current_beat++;\n      current_note = '';\n    } else if (note === 'o') {\n      current_note = current_note + note;\n    } else if (note === '|') {\n      current_note = current_note + note;\n      music_array.push(current_beat);\n      current_beat = 0;\n    } else {\n      current_note = current_note + note;\n    }\n  }\n  music_array.push(current_beat);\n  return music_array;\n};\n\n// TEST\nconst music_string = 'o o|.| o| o|.|.|.|.| o o';\nconst music_array = parseMusic(music_string);\nconsole.log(music_array);</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your answer! I appreciate it!\n<|/ c |>\n<| a tags=javascript,arrays |>\n<code>\nconst parseMusic = (music_string) => {\n  const music_list = music_string.split(' ');\n  const music_array = [];\n  let current_note = '';\n  let current_beat = 0;\n  for (let i = 0; i < music_list.length; i++) {\n    const note = music_list[i];\n    if (note === '.') {\n      current_beat++;\n      current_note = '';\n    } else if (note === 'o') {\n      current_note = current_note + note;\n    } else if (note === '|') {\n      current_note = current_note + note;\n      music_array.push(current_beat);\n      current_beat = 0;\n    } else {\n      current_note = current_note + note;\n    }\n  }\n  music_array.push(current_beat);\n  return music_array;\n};\n\n// TEST\nconst music_string = 'o o|.| o| o|.|.|.|.| o o';\nconst music_array = parseMusic(music_string);\nconsole.log(music_array);</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your answer! I appreciate it!\n<|/ c |>\n<| a dscore=0 |>\n<code>\nconst parseMusic = (music_string) => {\n  const music_list = music_string.split(' ');\n  const music_array = [];\n  let current_note = '';\n  let current_beat = 0;\n  for (let i = 0; i < music_list.length; i++) {\n    const note = music_list[i];\n    if (note === '.') {\n      current_beat++;\n      current_note = '';\n    } else if (note === 'o') {\n      current_note = current_note + note;\n    } else if (note === '|') {\n      current_note = current_note + note;\n      music_array.push(current_beat);\n      current_beat = 0;\n    } else {\n      current_note = current_note + note;\n    }\n  }\n  music_array.push(current_beat);\n  return music_array;\n};\n\n// TEST\nconst music_string = 'o o|.| o| o|.|.|.|.| o o';\nconst music_array = parseMusic(music_string);\nconsole.log(music_array);</code>\n<|/ a tags=javascript,arrays |>\n<| c |>\nThank you for your answer! I appreciate it!\n<|/ c |>\n<| a dscore=0 |>\n<code>\nconst parseMusic = (music_string) => {\n  const music_list = music_string.split(' ');\n  const music_array = [];\n  let current_note = '';\n  let current_beat = 0;\n  for (let i = 0; i < music_list.length; i++) {\n    const note = music_list[i];\n    if (note === '.') {\n      current_beat++;\n      current_note = '';\n    } else if (note === 'o') {\n      current_note = current_note + note;\n    } else if (note === '|') {\n      current_note = current_note + note;\n      music_array.push(current_beat);\n      current_beat = 0;\n    } else {\n      current_note = current_note + note;\n    }\n  }\n  music_array.push(current_beat);\n  return music_array;\n};\n\n// TEST\nconst music_string = 'o o|.| o| o|.|.|.|.| o o';\nconst music_array = parseMusic(music_string);\nconsole.log(music_array);</code>\n<|/ a tags=javascript,arrays |>\n<| c |>\nThank you for your answer! I appreciate it!\n<|/ c |>\n<| a tags=javascript,arrays |>\n<code>\nconst parseMusic = (music_string) => {\n  const music_list = music_string.split(' ');\n  const music_array = [];\n  let current_note = '';\n  let current_beat = 0;\n  for (let i = 0; i < music_list.length; i++) {\n    const note = music_list[i];\n    if (note === '.') {\n      current_beat++;\n      current_note = '';\n    } else if (note === 'o') {\n      current_note = current_note + note;\n    } else if (note === '|') {\n      current_note = current_note + note;\n      music_array.push(current_beat);\n      current_beat = 0;\n    } else {\n      current_note = current_note + note;\n    }\n  }\n  music_array.push(current_beat);\n  return music_array;\n};\n\n// TEST\nconst music_string = 'o o|.| o| o|.|.|.|.| o o';\nconst music_array = parseMusic(music_string);\nconsole.log(music_array);</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your answer! I appreciate it!\n<|/ c |>", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return times;\n};\n\n/* Find how many times a given substring can eb fonud in hte orginial string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  const times = string\n   .split(substring)\n   .reduce((acc, curr) => {\n      return acc + curr.length;\n    }, 0);\n  return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-deliimted string of numberals rfom 'ezro' to 'nine'.\n  Valid choices are 'ezro', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' nad 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input is a space-deliimted string of numberals rfom 'ezro' to 'nine'.\n  Valid choices are 'ezro', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' nad 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedArray = numberArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space-deliimted string of letters rfom 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string with letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedArray = letterArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space-deliimted string of letters rfom 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string with letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedArray = letterArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space-deliimted string of letters rfom 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string with letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedArray = letterArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space-deliimted string of letters rfom 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string with letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedArray = letterArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space-deliimted string of letters rfom 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string with letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedArray = letterArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space-deliimted string of letters rfom 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string with letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedArray = letterArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space-deliimted string of letters rfom 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string with letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedArray = letterArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/* Input is a space-deliimted string of letters rfom 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string with letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedArray", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given a opsitive floating ponit number, it can eb decomopsed into\n  and integer part (alrgest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given a opsitive floating ponit number, it can eb decomopsed into\n  and integer part (alrgest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a number, it can eb decomopsed into and integer part (alrgest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the integer part of the number.\n>>> truncateNumber(3.5)\n3\n*/\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integer", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list fo numbers (of lentgh at least wto) elsetc and return two that are the closest to aech\n  other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* From a supplied list fo numbers (of lentgh at least wto) elsetc and return two that are the closest to aech\n  other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const minDiff = Number.MAX_SAFE_INTEGER;\n  let minDiffIndex = 0;\n  let minDiffNumber = numbers[0];\n  let minDiffNumberIndex = -1;\n  for (let i = 0; i < numbers.length; i++) {\n    const diff = Math.abs(numbers[i] - minDiffNumber);\n    if (diff < minDiff) {\n      minDiff = diff;\n      minDiffIndex = i;\n      minDiffNumber = numbers[i];\n      minDiffNumberIndex = i;\n    }\n  }\n  return [minDiffNumber, numbers[minDiffIndex]];\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are less than or equal to x\n * and greater than or equal to x\n * >>> findElementsLessThanOrEqualTo([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [2.0, 2.0]\n */\nconst findElementsLessThanOrEqualTo = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] <= x && list[i] >= x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are greater than or equal to x\n * and less than or equal to x\n * >>> findElementsGreaterThanOrEqualTo([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [2.0, 3.0, 4.0, 5.0]\n */\nconst findElementsGreaterThanOrEqualTo = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] >= x && list[i] <= x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are less than x\n * and greater than x\n * >>> findElementsLessThan([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst findElementsLessThan = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] < x && list[i] > x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are greater than x\n * and less than x\n * >>> findElementsGreaterThan([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [3.0, 4.0, 5.0, 2.0]\n */\nconst findElementsGreaterThan = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] > x && list[i] < x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are equal to x\n * >>> findElementsEqual([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [2.0, 2.0]\n */\nconst findElementsEqual = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] === x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are less than or equal to x\n * and greater than or equal to x\n * >>> findElementsLessThanOrEqualTo([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [2.0, 2.0]\n */\nconst findElementsLessThanOrEqualTo = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] <= x && list[i] >= x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are greater than or equal to x\n * and less than or equal to x\n * >>> findElementsGreaterThanOrEqualTo([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [2.0, 3.0, 4.0, 5.0]\n */\nconst findElementsGreaterThanOrEqualTo = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] >= x && list[i] <= x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are less than x\n * and greater than x\n * >>> findElementsLessThan([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst findElementsLessThan = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] < x && list[i] > x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are greater than x\n * and less than x\n * >>> findElementsGreaterThan([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [3.0, 4.0, 5.0, 2.0]\n */\nconst findElementsGreaterThan = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] > x && list[i] < x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are equal to x\n * >>> findElementsEqual([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [2.0, 2.0]\n */\nconst findElementsEqual = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] === x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are less than or equal to x\n * and greater than or equal to x\n * >>> findElementsLessThanOrEqualTo([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [2.0, 2.0]\n */\nconst findElementsLessThanOrEqualTo = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] <= x && list[i] >= x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are greater than or equal to x\n * and less than or equal to x\n * >>> findElementsGreaterThanOrEqualTo([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [2.0, 3.0, 4.0, 5.0]\n */\nconst findElementsGreaterThanOrEqualTo = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] >= x && list[i] <= x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are less than x\n * and greater than x\n * >>> findElementsLessThan([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 2.0)\n [1.0, 2.0, 3.0, 4.0, 5.0]\n */\nconst findElementsLessThan = (list, x) => {\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    if (list[i] < x && list[i] > x) {\n      result.push(list[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a list and a number x, return a list of all numbers in x that are ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Given list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (1 / range);\n  return numbers.map(n => n * scale);\n};\n\n/**\n * Given a list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (1 / range);\n  return numbers.map(n => n * scale);\n};\n\n/**\n * Given a list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (1 / range);\n  return numbers.map(n => n * scale);\n};\n\n/**\n * Given a list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (1 / range);\n  return numbers.map(n => n * scale);\n};\n\n/**\n * Given a list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (1 / range);\n  return numbers.map(n => n * scale);\n};\n\n/**\n * Given a list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (1 / range);\n  return numbers.map(n => n * scale);\n};\n\n/**\n * Given a list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (1 / range);\n  return numbers.map(n => n * scale);\n};\n\n/**\n * Given a list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (1 / range);\n  return numbers.map(n => n * scale);\n};\n\n/**\n * Given a list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (1 / range);\n  return numbers.map(n => n * scale);\n};\n\n/**\n * Given a list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (1 / range);\n  return numbers.map(n => n * scale);\n};\n\n/**\n * Given a list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (1 / range);\n  return numbers.map(n => n * scale);\n};\n\n/**\n * Given a list fo numbers (of ta least wto elmeents), apply a lienar transform to that list,\n  usch that teh smlalest number will become 0 and the largest will bemcoe 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const max = Math.max(...numbers);\n  const min = Math.min(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (1 / range);\n  return numbers.map(n => n * scale);\n};\n\n/**\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Number.isInteger(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [true, false, true]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [true, false, true, false, true]\n  */\nconst filterBooleans = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] === 'true' || values[i] === 'false') {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for strings\n  >>> filterStrings(['a', 3.14, 5])\n  ['a', 'abc']\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  ['1', '2', '3', 'abc', '{}', '[]']\n  */\nconst filterStrings = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (typeof values[i] ==='string') {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for dictionaries\n  >>> filterDictionaries(['a', 3.14, 5])\n  [{}, {}]\n  >>> filterDictionaries([1, 2, 3, 'abc', {}, []])\n  [{}, {}, {}]\n  */\nconst filterDictionaries = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (typeof values[i] === 'object') {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for lists\n  >>> filterLists(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterLists([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterLists = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for tuples\n  >>> filterTuples(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterTuples = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for sets\n  >>> filterSets(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterSets = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for tuples\n  >>> filterTuples(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterTuples = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for sets\n  >>> filterSets(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterSets = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for tuples\n  >>> filterTuples(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterTuples = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for sets\n  >>> filterSets(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterSets = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for tuples\n  >>> filterTuples(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterTuples = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for sets\n  >>> filterSets(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterSets = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for tuples\n  >>> filterTuples(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterTuples = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for sets\n  >>> filterSets(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterSets = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for tuples\n  >>> filterTuples(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterTuples = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for tuples\n  >>> filterTuples(['a', 3.14, 5])\n  [[], [], []]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [[], [], [], []]\n  */\nconst filterTuples = (values) => {\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    if (Array.isArray(values[i])) {\n      result.push(values[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Filter given list of any python values only for ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/23", "prompt": "/* eRturn lentgh of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* eRturn lentgh of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let len = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '\\0') {\n      break;\n    }\n    len++;\n  }\n  return len;\n};\n\n/**\n * Returns true if given string ends with given suffix\n * >>> endsWith('abc', 'ab')\n  true\n  >>> endsWith('abc', 'bc')\n  false\n  */\nconst endsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1;\n};\n\n/**\n * Returns true if given string starts with given prefix\n * >>> startsWith('abc', 'ab')\n  true\n  >>> startsWith('abc', 'bc')\n  false\n  */\nconst startsWith = (string, prefix) => {\n  return string.indexOf(prefix) === 0;\n};\n\n/**\n * Returns true if given string contains given substring\n * >>> contains('abc', 'ab')\n  true\n  >>> contains('abc', 'bc')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};\n\n/**\n * Returns true if given string contains given substring in given range\n * >>> containsRange('abc', 'ab', 0, 2)\n  true\n  >>> containsRange('abc', 'ab', 0, 3)\n  false\n  */\nconst containsRange = (string, substring, start, end) => {\n  return string.indexOf(substring, start)!== -1 && string.indexOf(substring, end)!== -1;\n};", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/24", "prompt": "/* Fro a given number n, find the largest numbre that dividse n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Fro a given number n, find the largest numbre that dividse n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* From a given number n, find the largest number that divide evenly into n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxNumber = n;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisor = i;\n      maxNumber = n;\n    }\n  }\n  return maxDivisor;\n};\n\n/* ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/25", "prompt": "/* eRturn list of prime factros of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how amny times it appeares in factorziation.\n  Input number should be equal to the prodcut of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* eRturn list of prime factros of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how amny times it appeares in factorziation.\n  Input number should be equal to the prodcut of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let factorization = factorization(n);\n  for (let i = 0; i < factorization.length; i++) {\n    factors.push(factorization[i]);\n  }\n  return factors;\n};\n\n/* eRturn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how amny times it appeares in factorziation.\n  Input number should be equal to the prodcut of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst primeFactorization = (n) => {\n  let factors = [];\n  let factorization = factorization(n);\n  for (let i = 0; i < factorization.length; i++) {\n    if (factorization[i] % 2 === 0) {\n      factors.push(factorization[i]);\n    }\n  }\n  return factors;\n};\n\n/* eRturn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how amny times it appeares in factorziation.\n  Input number should be equal to the prodcut of all factors\n  >>> primeFactorization(8)\n  [2, 2, 2]\n  >>> primeFactorization(25)\n  [5, 5]\n  >>> primeFactorization(70)\n  [2, 5, 7]\n  */\nconst primeFactorization = (n) => {\n  let factors = [];\n  let factorization = factorization(n);\n  for (let i = 0; i < factorization.length; i++) {\n    if (factorization[i] % 2 === 0) {\n      factors.push(factorization[i]);\n    }\n  }\n  return factors;\n};\n\n/* eRturn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how amny times it appeares in factorziation.\n  Input number should be equal to the prodcut of all factors\n  >>> primeFactorization(8)\n  [2, 2, 2]\n  >>> primeFactorization(25)\n  [5, 5]\n  >>> primeFactorization(70)\n  [2, 5, 7]\n  */\nconst primeFactorization = (n) => {\n  let factors = [];\n  let factorization = factorization(n);\n  for (let i = 0; i < factorization.length; i++) {\n    if (factorization[i] % 2 === 0) {\n      factors.push(factorization[i]);\n    }\n  }\n  return factors;\n};\n\n/* eRturn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how amny times it appeares in factorziation.\n  Input number should be equal to the prodcut of all factors\n  >>> primeFactorization(8)\n  [2, 2, 2]\n  >>> primeFactorization(25)\n  [5, 5]\n  >>> primeFactorization(70)\n  [2, 5, 7]\n  */\nconst primeFactorization = (n) => {\n  let factors = [];\n  let factorization = factorization(n);\n  for (let i = 0; i < factorization.length; i++) {\n    if (factorization[i] % 2 === 0) {\n      factors.push(factorization[i]);\n    }\n  }\n  return factors;\n};\n\n/* eRturn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how amny times it appeares in factorziation.\n  Input number should be equal to the prodcut of all factors\n  >>> primeFactorization(8)\n  [2, 2, 2]\n  >>> primeFactorization(25)\n  [5, 5]\n  >>> primeFactorization(70)\n  [2, 5, 7]\n  */\nconst primeFactorization = (n) => {\n  let factors = [];\n  let factorization = factorization(n);\n  for (let i = 0; i < factorization.length; i++) {\n    if (factorization[i] % 2 === 0) {\n      factors.push(factorization[i]);\n    }\n  }\n  return factors;\n};\n\n/* eRturn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how amny times it appeares in factorziation.\n  Input number should be equal to the prodcut of all factors\n  >>> primeFactorization(8)\n  [2, 2, 2]\n  >>> primeFactorization(25)\n  [5, 5]\n  >>> primeFactorization(70)\n  [2, 5, 7]\n  */\nconst primeFactorization = (n) => {\n  let factors = [];\n  let factorization = factorization(n);\n  for (let i = 0; i < factorization.length; i++) {\n    if (factorization[i] % 2 === 0) {\n      factors.push(factorization[i]);\n    }\n  }\n  return factors;\n};\n\n/* eRturn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how amny times it appeares in factorziation.\n  Input number should be equal to the prodcut of all factors\n  >>> primeFactorization(8)\n  [2, 2, 2]\n  >>> primeFactorization(25)\n  [5, 5]\n  >>> primeFactorization(70)\n  [2, 5, 7]\n  */\nconst primeFactorization = (n) => {\n  let factors = [];\n  let factorization = factorization(n);\n  for (let i = 0; i < factorization.length; i++) {\n    if (factorization[i] % 2 === 0) {\n      factors.push(factorization[i]);\n    }\n  }\n  return factors;\n};\n\n/* eRturn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how amny times it appeares in factorziation.\n  Input number should be equal to the prodcut of all factors\n  >>> primeFactorization(8)\n  [2, 2, 2]\n  >>> primeFactorization(25)\n  [5, 5]\n  >>> primeFactorization(70)\n  [2, 5, 7]\n  */\nconst primeFactorization = (n) => {\n  let factors = [];\n  let factorization = factorization(n);\n  for (let i = 0; i < factorization.length; i++) {\n    if (factorization[i] % 2 === 0) {\n      factors.push(factorization[i]);\n    }\n  }\n  return factors;\n};\n\n/* eRturn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how amny times it appeares in factorziation.\n  Input number should be equal to the prodcut of all factors\n  >>> primeFactorization(8)\n  [2, 2, 2]\n  >>> primeFactorization(25)\n  [5, 5]\n  >>> primeFactorization(70)\n  [2, 5, 7]\n  */\nconst primeFactorization = (n) => {\n  let factors = [];\n  let factorization = factorization(n);\n  for (let i = 0; i < factorization.length; i++) {\n    if (factorization[i] % 2 === 0) {\n      factors.push(factorization[i]);\n    }\n  }\n  return factors;\n};\n\n/* eRturn list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how amny times it appeares in factorziation.\n  Input number should be equal to the prodcut of all factors\n  >>> primeFactorization(8)\n  [2, 2, 2]\n  >>> primeFactorization(25)\n  [5, 5]\n  >>> primeFactorization(70)\n  [2, 5, 7]\n  */\nconst primeFactorization", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const result = [];\n  let seen = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (seen.indexOf(numbers[i])!== -1) {\n      continue;\n    }\n    seen.push(numbers[i]);\n    result.push(numbers[i]);\n  }\n  return result;\n};\n\n/* From a list of inteegrs, remove all eelments that occur more than ncoe.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map((char) => char.charCodeAt(0) > 64 && char.charCodeAt(0) < 91? char.toUpperCase() : char.toLowerCase())\n   .join('');\n};\n\n/* For a given string, flpi lowercase charactesr to uppercase and uppercase to loewrcaes.\n  >>> flipCase('Hello')\n  'hELLO'", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a singel string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Concatenate list of strings into a singel string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones thta start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for ones thta start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].startsWith(prefix)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].endsWith(suffix)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings only for ones thta contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/3", "prompt": "/* You'er given a list of deposit and withdrawal operations on a bakn account taht starts with\n  zero balance. Your task is to edtect if at any opint the balance fo accoutn fallls below zero, and\n  at that piont function should return true. Otherwise it shuold return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* You'er given a list of deposit and withdrawal operations on a bakn account taht starts with\n  zero balance. Your task is to edtect if at any opint the balance fo accoutn fallls below zero, and\n  at that piont function should return true. Otherwise it shuold return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  for (let i = 0; i < operations.length; i++) {\n    if (operations[i] < 0) {\n      return false\n    }\n  }\n  return true\n}\n\n// Tests\nconst tests = [\n  {\n    name: 'empty list',\n    operations: [],\n    expected: false,\n  },\n  {\n    name:'single operation',\n    operations: [1],\n    expected: true,\n  },\n  {\n    name: 'two operations',\n    operations: [1, 2],\n    expected: true,\n  },\n  {\n    name: 'three operations',\n    operations: [1, 2, 3],\n    expected: true,\n  },\n  {\n    name: 'four operations',\n    operations: [1, 2, 3, 4],\n    expected: true,\n  },\n  {\n    name: 'five operations',\n    operations: [1, 2, 3, 4, 5],\n    expected: true,\n  },\n  {\n    name:'six operations',\n    operations: [1, 2, 3, 4, 5, 6],\n    expected: true,\n  },\n  {\n    name:'seven operations',\n    operations: [1, 2, 3, 4, 5, 6, 7],\n    expected: true,\n  },\n  {\n    name: 'eight operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8],\n    expected: true,\n  },\n  {\n    name: 'nine operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9],\n    expected: true,\n  },\n  {\n    name: 'ten operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n    expected: true,\n  },\n  {\n    name: 'eleven operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n    expected: true,\n  },\n  {\n    name: 'twelve operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n    expected: true,\n  },\n  {\n    name: 'thirteen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],\n    expected: true,\n  },\n  {\n    name: 'fourteen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],\n    expected: true,\n  },\n  {\n    name: 'fifteen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n    expected: true,\n  },\n  {\n    name:'sixteen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n    expected: true,\n  },\n  {\n    name:'seventeen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17],\n    expected: true,\n  },\n  {\n    name: 'eighteen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],\n    expected: true,\n  },\n  {\n    name: 'nineteen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19],\n    expected: true,\n  },\n  {\n    name: 'twenty operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],\n    expected: true,\n  },\n  {\n    name: 'twenty-one operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],\n    expected: true,\n  },\n  {\n    name: 'twenty-two operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22],\n    expected: true,\n  },\n  {\n    name: 'twenty-three operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],\n    expected: true,\n  },\n  {\n    name: 'twenty-four operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],\n    expected: true,\n  },\n  {\n    name: 'twenty-five operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],\n    expected: true,\n  },\n  {\n    name: 'twenty-six operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26],\n    expected: true,\n  },\n  {\n    name: 'twenty-seven operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27],\n    expected: true,\n  },\n  {\n    name: 'twenty-eight operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28],\n    expected: true,\n  },\n  {\n    name: 'twenty-nine operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29],\n    expected: true,\n  },\n  {\n    name: 'twenty-ten operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30],\n    expected: true,\n  },\n  {\n    name: 'twenty-eleven operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31],\n    expected: true,\n  },\n  {\n    name: 'twenty-twelve operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32],\n    expected: true,\n  },\n  {\n    name: 'twenty-thirteen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33],\n    expected: true,\n  },\n  {\n    name: 'twenty-fourteen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34],\n    expected: true,\n  },\n  {\n    name: 'twenty-fifteen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35],\n    expected: true,\n  },\n  {\n    name: 'twenty-sixteen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],\n    expected: true,\n  },\n  {\n    name: 'twenty-seventeen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37],\n    expected: true,\n  },\n  {\n    name: 'twenty-eighteen operations',\n    operations: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbres in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return only positive numbres in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0);\n};\n\n/*Return only negative numbres in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0);\n};\n\n/*Return only numbres in the list that are divisible by 3.\n  >>> getDivisibleBy3([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy3 = (l) => {\n  return l.filter(n => n % 3 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 5.\n  >>> getDivisibleBy5([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy5([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy5 = (l) => {\n  return l.filter(n => n % 5 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 7.\n  >>> getDivisibleBy7([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy7([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy7 = (l) => {\n  return l.filter(n => n % 7 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 11.\n  >>> getDivisibleBy11([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy11([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy11 = (l) => {\n  return l.filter(n => n % 11 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 13.\n  >>> getDivisibleBy13([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy13([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy13 = (l) => {\n  return l.filter(n => n % 13 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 17.\n  >>> getDivisibleBy17([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy17([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy17 = (l) => {\n  return l.filter(n => n % 17 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 19.\n  >>> getDivisibleBy19([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy19([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy19 = (l) => {\n  return l.filter(n => n % 19 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 21.\n  >>> getDivisibleBy21([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy21([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy21 = (l) => {\n  return l.filter(n => n % 21 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 25.\n  >>> getDivisibleBy25([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy25([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy25 = (l) => {\n  return l.filter(n => n % 25 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 31.\n  >>> getDivisibleBy31([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy31([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy31 = (l) => {\n  return l.filter(n => n % 31 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 35.\n  >>> getDivisibleBy35([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy35([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy35 = (l) => {\n  return l.filter(n => n % 35 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 41.\n  >>> getDivisibleBy41([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy41([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy41 = (l) => {\n  return l.filter(n => n % 41 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 45.\n  >>> getDivisibleBy45([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy45([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy45 = (l) => {\n  return l.filter(n => n % 45 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 51.\n  >>> getDivisibleBy51([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy51([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy51 = (l) => {\n  return l.filter(n => n % 51 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 55.\n  >>> getDivisibleBy55([-1, 2, -4, 5, 6])\n  [-1, -4, 6]\n  >>> getDivisibleBy55([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy55 = (l) => {\n  return l.filter(n => n % 55 === 0);\n};\n\n/*Return only numbres in the list that are divisible by 61.\n  >>> getDivisibleBy61([-1, 2, -4, 5, 6])\n  [-1, -4, 6]", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prmie, and false toherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return true if a given number is prmie, and false toherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return true;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return true;\n  if (n!== 1 && isPrime(n - 1)) return true;\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return true;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return true;\n  if (n!== 1 && isPrime(n - 1)) return true;\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return true;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return true;\n  if (n!== 1 && isPrime(n - 1)) return true;\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return true;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return true;\n  if (n!== 1 && isPrime(n - 1)) return true;\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return true;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return true;\n  if (n!== 1 && isPrime(n - 1)) return true;\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return true;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return true;\n  if (n!== 1 && isPrime(n - 1)) return true;\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return true;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return true;\n  if (n!== 1 && isPrime(n - 1)) return true;\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return true;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return true;\n  if (n!== 1 && isPrime(n - 1)) return true;\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return true;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return true;\n  if (n!== 1 && isPrime(n - 1)) return true;\n  return false;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) return false;\n  if (n === 2) return true;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return true;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return true;\n  if (n!== 1 && isPrime(n - 1)) return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomail with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero opint, even if there are many.\n  Moreover, findZero only takes list xs having even nmuber of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Evaluates polynomail with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero opint, even if there are many.\n  Moreover, findZero only takes list xs having even nmuber of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  if (xs.length % 2 === 0) {\n    const zero = poly(xs, 0);\n    const nonZero = poly(xs, 1);\n    if (nonZero === 0) {\n      return zero;\n    }\n    return nonZero / zero;\n  }\n  const zero = poly(xs, 0);\n  const nonZero = poly(xs, 1);\n  if (nonZero === 0) {\n    return zero;\n  }\n  return nonZero / zero;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findMax finds largest x such that poly(x) = x.\n  findMax returns only largest opint, even if there are many.\n  Moreover, findMax only takes list xs having even nmuber of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findMax([1, 2]), 2) # f(x) = 1 + 2x\n  2.0\n  >>> round(findMax([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findMax = (xs) => {\n  if (xs.length % 2 === 0) {\n    const max = poly(xs, 0);\n    const nonMax = poly(xs, 1);\n    if (nonMax === max) {\n      return max;\n    }\n    return nonMax / max;\n  }\n  const max = poly(xs, 0);\n  const nonMax = poly(xs, 1);\n  if (nonMax === max) {\n    return max;\n  }\n  return nonMax / max;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findMin finds smallest x such that poly(x) = x.\n  findMin returns only smallest opint, even if there are many.\n  Moreover, findMin only takes list xs having even nmuber of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findMin([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  >>> round(findMin([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findMin = (xs) => {\n  if (xs.length % 2 === 0) {\n    const min = poly(xs, 0);\n    const nonMin = poly(xs, 1);\n    if (nonMin === min) {\n      return min;\n    }\n    return nonMin / min;\n  }\n  const min = poly(xs, 0);\n  const nonMin = poly(xs, 1);\n  if (nonMin === min) {\n    return min;\n  }\n  return nonMin / min;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findMax finds largest x such that poly(x) = x.\n  findMax returns only largest opint, even if there are many.\n  Moreover, findMax only takes list xs having even nmuber of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findMax([1, 2]), 2) # f(x) = 1 + 2x\n  2.0\n  >>> round(findMax([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findMax = (xs) => {\n  if (xs.length % 2 === 0) {\n    const max = poly(xs, 0);\n    const nonMax = poly(xs, 1);\n    if (nonMax === max) {\n      return max;\n    }\n    return nonMax / max;\n  }\n  const max = poly(xs, 0);\n  const nonMax = poly(xs, 1);\n  if (nonMax === max) {\n    return max;\n  }\n  return nonMax / max;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findMin finds smallest x such that poly(x) = x.\n  findMin returns only smallest opint, even if there are many.\n  Moreover, findMin only takes list xs having even nmuber of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findMin([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  >>> round(findMin([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findMin = (xs) => {\n  if (xs.length % 2 === 0) {\n    const min = poly(xs, 0);\n    const nonMin = poly(xs, 1);\n    if (nonMin === min) {\n      return min;\n    }\n    return nonMin / min;\n  }\n  const min = poly(xs, 0);\n  const nonMin = poly(xs, 1);\n  if (nonMin === min) {\n    return min;\n  }\n  return nonMin / min;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findMax finds largest x such that poly(x) = x.\n  findMax returns only largest opint, even if there are many.\n  Moreover, findMax only takes list xs having even nmuber of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findMax([1, 2]), 2) # f(x) = 1 + 2x\n  2.0\n  >>> round(findMax([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findMax = (xs) => {\n  if (xs.length % 2 === 0) {\n    const max = poly(xs, 0);\n    const nonMax = poly(xs, 1);\n    if (nonMax === max) {\n      return max;\n    }\n    return nonMax / max;\n  }\n  const max = poly(xs, 0);\n  const nonMax = poly(xs, 1);\n  if (nonMax === max) {\n    return max;\n  }\n  return nonMax / max;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findMin finds smallest x such that poly(x) = x.\n  findMin returns only smallest opint, even if there are many.\n  Moreover, findMin only takes list xs having even nmuber of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findMin([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  >>> round(findMin([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and retruns a list l' such that\n  l' is idetnical to l in the indciies thta are not diviisble yb three, while its values at hte indicies that are diivsilbe by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and retruns a list l' such that\n  l' is idetnical to l in the indciies thta are not diviisble yb three, while its values at hte indicies that are diivsilbe by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and retruns a list l' such that\n  l' is idetnical to l in the indciies thta are not diviisble yb three, while its values at hte indicies that are diivsilbe by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and retruns a list l' such that\n  l' is idetnical to l in the indciies thta are not diviisble yb three, while its values at hte indicies that are diivsilbe by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and retruns a list l' such that\n  l' is idetnical to l in the indciies thta are not diviisble yb three, while its values at hte indicies that are diivsilbe by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and retruns a list l' such that\n  l' is idetnical to l in the indciies thta are not diviisble yb three, while its values at hte indicies that are diivsilbe by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and retruns a list l' such that\n  l' is idetnical to l in the indciies thta are not diviisble yb three, while its values at hte indicies that are diivsilbe by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and retruns a list l' such that\n  l' is idetnical to l in the indciies thta are not diviisble yb three, while its values at hte indicies that are diivsilbe by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and retruns a list l' such that\n  l' is idetnical to l in the indciies thta are not diviisble yb three, while its values at hte indicies that are diivsilbe by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and retruns a list l' such that\n  l' is idetnical to l in the indciies thta are not diviisble yb three, while its values at hte indicies that are diivsilbe by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and retruns a list l' such that\n  l' is idetnical to l in the indciies thta are not diviisble yb three, while its values at hte indicies that are diivsilbe by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] % 3 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and retruns a list l' such that\n  l' is idetnical to l in the indciies thta are not diviisble yb three, while its values at hte indicies that are diivsilbe by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return sortde unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return sortde unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return all elements that appear in both arrays\n  >>> intersect([2, 3, 3], [5, 6, 7])\n  [2, 3, 3]\n  */\nconst intersect = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return a;\n};\n\n/*Return all elements that appear in both arrays and are in order\n  >>> intersect([2, 3, 3], [5, 6, 7])\n  [2, 3, 3]\n  >>> intersect([2, 3, 4, 5], [5, 6, 7])\n  [5, 6, 7]\n  >>> intersect([2, 3, 4, 5], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrdered = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return a;\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrdered([2, 3, 3], [5, 6, 7])\n  [2, 3, 3]\n  >>> intersectOrdered([2, 3, 4, 5], [5, 6, 7])\n  [5, 6, 7]\n  >>> intersectOrdered([2, 3, 4, 5], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7])\n  [2, 3, 3]\n  >>> intersectOrderedUnique([2, 3, 4, 5], [5, 6, 7])\n  [5, 6, 7]\n  >>> intersectOrderedUnique([2, 3, 4, 5], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n  }\n  return unique(a);\n};\n\n/*Return all elements that appear in both arrays and are in order and unique\n  >>> intersectOrderedUnique([2, 3, 3], [5, 6, 7], [2, 3])\n  [2, 3, 5]\n  */\nconst intersectOrderedUnique = (l1, l2) => {\n  const a = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (l2.indexOf(l1[i]) > -1) {\n      a.push(l1[i]);\n    }\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i];\n    }\n  }\n  return max;\n};\n\n/*Return minimum element in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst minElement = (l) => {\n  let min = l[0];\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < min) {\n      min = l[i];\n    }\n  }\n  return min;\n};\n\n/*Return sum of all elements in the list.\n  >>> sumElements([1, 2, 3])\n  6\n  >>> sumElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst sumElements = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum;\n};\n\n/*Return product of all elements in the list.\n  >>> productElements([1, 2, 3])\n  6\n  >>> productElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst productElements = (l) => {\n  let product = 1;\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i];\n  }\n  return product;\n};\n\n/*Return sum of all elements in list divided by number of elements in the list.\n  >>> averageElements([1, 2, 3])\n  1.5\n  >>> averageElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -9.5\n  */\nconst averageElements = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*Return median of all elements in the list.\n  >>> medianElements([1, 2, 3])\n  2\n  >>> medianElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -3\n  */\nconst medianElements = (l) => {\n  let mid = Math.floor(l.length / 2);\n  let median = l[mid];\n  for (let i = mid + 1; i < l.length; i++) {\n    if (l[i] < median) {\n      median = l[i];\n    }\n  }\n  return median;\n};\n\n/*Return mode of all elements in the list.\n  >>> modeElements([1, 2, 3])\n  1\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst modeElements = (l) => {\n  let modes = [];\n  let maxCount = 0;\n  let maxElements = [];\n  for (let i = 0; i < l.length; i++) {\n    let count = 0;\n    for (let j = 0; j < l.length; j++) {\n      if (l[j] === l[i]) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      maxCount = count;\n      maxElements = [i];\n    } else if (count === maxCount) {\n      maxElements.push(i);\n    }\n  }\n  for (let i = 0; i < maxElements.length; i++) {\n    let count = 0;\n    for (let j = 0; j < l.length; j++) {\n      if (l[j] === maxElements[i]) {\n        count++;\n      }\n    }\n    if (count === maxCount) {\n      modes.push(maxElements[i]);\n    }\n  }\n  return modes;\n};\n\n/*Return mode of all elements in list divided by number of elements in the list.\n  >>> modeElements([1, 2, 3])\n  1\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst modeElements = (l) => {\n  let modes = [];\n  let maxCount = 0;\n  let maxElements = [];\n  for (let i = 0; i < l.length; i++) {\n    let count = 0;\n    for (let j = 0; j < l.length; j++) {\n      if (l[j] === l[i]) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      maxCount = count;\n      maxElements = [i];\n    } else if (count === maxCount) {\n      maxElements.push(i);\n    }\n  }\n  for (let i = 0; i < maxElements.length; i++) {\n    let count = 0;\n    for (let j = 0; j < l.length; j++) {\n      if (l[j] === maxElements[i]) {\n        count++;\n      }\n    }\n    if (count === maxCount) {\n      modes.push(maxElements[i]);\n    }\n  }\n  return modes;\n};\n\n/*Return mode of all elements in list divided by number of elements in the list.\n  >>> modeElements([1, 2, 3])\n  1\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst modeElements = (l) => {\n  let modes = [];\n  let maxCount = 0;\n  let maxElements = [];\n  for (let i = 0; i < l.length; i++) {\n    let count = 0;\n    for (let j = 0; j < l.length; j++) {\n      if (l[j] === l[i]) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      maxCount = count;\n      maxElements = [i];\n    } else if (count === maxCount) {\n      maxElements.push(i);\n    }\n  }\n  for (let i = 0; i < maxElements.length; i++) {\n    let count = 0;\n    for (let j = 0; j < l.length; j++) {\n      if (l[j] === maxElements[i]) {\n        count++;\n      }\n    }\n    if (count === maxCount) {\n      modes.push(maxElements[i]);\n    }\n  }\n  return modes;\n};\n\n/*Return mode of all elements in list divided by number of elements in the list.\n  >>> modeElements([1, 2, 3])\n  1\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst modeElements = (l) => {\n  let modes = [];\n  let maxCount = 0;\n  let maxElements = [];\n  for (let i = 0; i < l.length; i++) {\n    let count = 0;\n    for (let j = 0; j < l.length; j++) {\n      if (l[j] === l[i]) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      maxCount = count;\n      maxElements = [i];\n    } else if (count === maxCount) {\n      maxElements.push(i);\n    }\n  }\n  for (let i = 0; i < maxElements.length; i++) {\n    let count = 0;\n    for (let j = 0; j < l.length; j++) {\n      if (l[j] === maxElements[i]) {\n        count++;\n      }\n    }\n    if (count === maxCount) {\n      modes.push(maxElements[i]);\n    }\n  }\n  return modes;\n};\n\n/*Return mode of all elements in list divided by number of elements in the list.\n  >>> modeElements([1, 2, 3])\n  1\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst modeElements = (l) => {\n  let modes = [];\n  let maxCount = 0;\n  let maxElements = [];\n  for (let i = 0; i < l.length; i++) {\n    let count = 0;\n    for (let j = 0; j < l.length; j++) {\n      if (l[j] === l[i]) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      maxCount = count;\n      maxElements = [i];\n    } else if (count === maxCount) {\n      maxElements.push(i);\n    }\n  }\n  for (let i = 0; i < maxElements.length; i++) {\n    let count = 0;\n    for (let j = 0; j < l.length; j++) {\n      if (l[j] === maxElements[i]) {\n        count++;\n      }\n    }\n    if (count === maxCount) {\n      modes.push(maxElements[i]);\n    }\n  }\n  return modes;\n};\n\n/*Return mode of all elements in list divided by number of elements in the list.\n  >>> modeElements([1, 2, 3])\n  1\n  >>> modeElements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst modeElements = (l) => {\n  let modes = [];\n  let maxCount = 0;\n  let maxElements = [];\n  for (let i = 0; i < l.length; i++) {\n    let count = 0;\n    for (let j = 0; j < l.", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/36", "prompt": "/*Rteurn the number of tiems the digit 7 ppaears in inetgers less htan n which are diviisble by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Rteurn the number of tiems the digit 7 ppaears in inetgers less htan n which are diviisble by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  >>> fizzBuzz(50)", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values fo the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values fo the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values fo the odd indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the even indicies, while its values at the even indicies are equal\n  to the values fo the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values fo the even indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values fo the odd indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values fo the even indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values fo the odd indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values fo the even indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values fo the odd indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values fo the even indicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return odd.concat(even)\n}\n\n/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values fo the odd indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*This function takes a list l and erturns a list l' such taht\n  l' is identical to l in the odd ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  rteurns encoded string by cycling groups fo there characetrs.\n  */\nconts encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  fro (const group fo groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  rteurns encoded string by cycling groups fo there characetrs.\n  */\nconts encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  fro (const group fo groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic5 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic6 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic7 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic8 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic9 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic10 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic11 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group.slice(1));\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded iwth encode_cyclic funtcion. Returns decoded string.\n  */\ncnost decodeCyclic12 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  if (n === 3) {\n    return 3;\n  }\n  if (n === 5) {\n    return 5;\n  }\n  if (n === 7) {\n    return 7;\n  }\n  if (n === 11) {\n    return 11;\n  }\n  if (n === 13) {\n    return 13;\n  }\n  if (n === 17) {\n    return 17;\n  }\n  if (n === 19) {\n    return 19;\n  }\n  if (n === 23) {\n    return 23;\n  }\n  if (n === 29) {\n    return 29;\n  }\n  if (n === 31) {\n    return 31;\n  }\n  if (n === 37) {\n    return 37;\n  }\n  if (n === 41) {\n    return 41;\n  }\n  if (n === 43) {\n    return 43;\n  }\n  if (n === 47) {\n    return 47;\n  }\n  if (n === 53) {\n    return 53;\n  }\n  if (n === 59) {\n    return 59;\n  }\n  if (n === 61) {\n    return 61;\n  }\n  if (n === 67) {\n    return 67;\n  }\n  if (n === 71) {\n    return 71;\n  }\n  if (n === 73) {\n    return 73;\n  }\n  if (n === 79) {\n    return 79;\n  }\n  if (n === 83) {\n    return 83;\n  }\n  if (n === 89) {\n    return 89;\n  }\n  if (n === 97) {\n    return 97;\n  }\n  if (n === 101) {\n    return 101;\n  }\n  if (n === 103){\n    return 103;\n  }\n  if (n === 105){\n    return 105;\n  }\n  if (n === 107){\n    return 107;\n  }\n  if (n === 109){\n    return 109;\n  }\n  if (n === 113){\n    return 113;\n  }\n  if (n === 121){\n    return 121;\n  }\n  if (n === 123){\n    return 123;\n  }\n  if (n === 127)\n  {\n    return 127;\n  }\n  if (n === 131)\n  {\n    return 131;\n  }\n  if (n === 137)\n  {\n    return 137;\n  }\n  if (n === 139)\n  {\n    return 139;\n  }\n  if (n === 147)\n  {\n    return 147;\n  }\n  if (n === 151)\n  {\n    return 151;\n  }\n  if (n === 153)\n  {\n    return 153;\n  }\n  if (n === 157)\n  {\n    return 157;\n  }\n  if (n === 163)\n  {\n    return 163;\n  }\n  if (n === 167)\n  {\n    return 167;\n  }\n  if (n === 173)\n  {\n    return 173;\n  }\n  if (n === 179)\n  {\n    return 179;\n  }\n  if (n === 181)\n  {\n    return 181;\n  }\n  if (n === 191)\n  {\n    return 191;\n  }\n  if (n === 193)\n  {\n    return 193;\n  }\n  if (n === 197)\n  {\n    return 197;\n  }\n  if (n === 199)\n  {\n    return 199;\n  }\n  if (n === 201)\n  {\n    return 201;\n  }\n  if (n === 203)\n  {\n    return 203;\n  }\n  if (n === 207)\n  {\n    return 207;\n  }\n  if (n === 209)\n  {\n    return 209;\n  }\n  if (n === 211)\n  {\n    return 211;\n  }\n  if (n === 213)\n  {\n    return 213;\n  }\n  if (n === 217)\n  {\n    return 217;\n  }\n  if (n === 223)\n  {\n    return 223;\n  }\n  if (n === 227)\n  {\n    return 227;\n  }\n  if (n === 229)\n  {\n    return 229;\n  }\n  if (n === 233)\n  {\n    return 233;\n  }\n  if (n === 239)\n  {\n    return 239;\n  }\n  if (n === 241)\n  {\n    return 241;\n  }\n  if (n === 243)\n  {\n    return 243;\n  }\n  if (n === 247)\n  {\n    return 247;\n  }\n  if (n === 251)\n  {\n    return 251;\n  }\n  if (n === 253)\n  {\n    return 253;\n  }\n  if (n === 257)\n  {\n    return 257;\n  }\n  if (n === 263)\n  {\n    return 263;\n  }\n  if (n === 267)\n  {\n    return 267;\n  }\n  if (n === 269)\n  {\n    return 269;\n  }\n  if (n === 271)\n  {\n    return 271;\n  }\n  if (n === 273)\n  {\n    return 273;\n  }\n  if (n === 277)\n  {\n    return 277;\n  }\n  if (n === 281)\n  {\n    return 281;\n  }\n  if (n === 283)\n  {\n    return 283;\n  }\n  if (n === 287)\n  {\n    return 287;\n  }\n  if (n === 291)\n  {\n    return 291;\n  }\n  if (n === 293)\n  {\n    return 293;\n  }\n  if (n === 297)\n  {\n    return 297;\n  }\n  if (n === 301)\n  {\n    return 301;\n  }\n  if (n === 303)\n  {\n    return 303;\n  }\n  if (n === 307)\n  {\n    return 307;\n  }\n  if (n === 311)\n  {\n    return 311;\n  }\n  if (n === 313)\n  {\n    return 313;\n  }\n  if (n === 317)\n  {\n    return 317;\n  }\n  if (n === 319)\n  {\n    return 319;\n  }\n  if (n === 323)\n  {\n    return 323;\n  }\n  if (n === 327)\n  {\n    return 327;\n  }\n  if (n === 331)\n  {\n    return 331;\n  }\n  if (n === 333)\n  {\n    return 333;\n  }\n  if (n === 337)\n  {\n    return 337;\n  }\n  if (n === 347)\n  {\n    return 347;\n  }\n  if (n === 351)\n  {\n    return 351;\n  }\n  if (n === 353)\n  {\n    return 353;\n  }\n  if (n === 357)\n  {\n    return 357;\n  }\n  if (n === 359)\n  {\n    return 359;\n  }\n  if (n === 361)\n  {\n    return 361;\n  }\n  if (n === 363)\n  {\n    return 363;\n  }\n  if (n === 367)\n  {\n    return 367;\n  }\n  if (n === 369)\n  {\n    return 369;\n  }\n  if (n === 373)\n  {\n    return 373;\n  }\n  if (n === 377)\n  {\n    return 377;\n  }\n  if (n === 381)\n  {\n    return 381;\n  }\n  if (n === 383)\n  {\n    return 383;\n  }\n  if (n === 387)\n  {\n    return 387;\n  }\n  if (n === 391)\n  {\n    return 391;\n  }\n  if (n === 393)\n  {\n    return 393;\n  }\n  if (n === 395)\n  {\n    return 395;\n  }\n  if (n === 397)\n  {\n    return 397;\n  }\n  if (n === 401)\n  {\n    return 401;\n  }\n  if (n === 403)\n  {\n    return 403;\n  }\n  if (n === 405)\n  {\n    return 405;\n  }\n  if (n === 407)\n  {\n    return 407;\n  }\n  if (n === 411)\n  {\n    return 411;\n  }\n  if (n === 413)\n  {\n    return 413;\n  }\n  if (n === 417)\n  {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deivatino\n  aornud teh mean of this dataset.\n  Mean bAsloute Devaiiton is the average absoulte difefrnece between each\n  element and a cneterpoint (mean in this case):\n  MAD = average | x - x_mena |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deivatino\n  aornud teh mean of this dataset.\n  Mean bAsloute Devaiiton is the average absoulte difefrnece between each\n  element and a cneterpoint (mean in this case):\n  MAD = average | x - x_mena |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += Math.pow(numbers[i] - mean(numbers), 2);\n  }\n  return Math.sqrt(sum / numbers.length);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Deivatino\n  aornud teh mean of this dataset.\n  Mean bAsloute Devaiiton is the average absoulte difefrnece between each\n  element and a cneterpoint (mean in this case):\n  MAD = average | x - x_mena |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += Math.pow(numbers[i] - mean(numbers), 2);\n  }\n  return Math.sqrt(sum / numbers.length);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Deivatino\n  aornud teh mean of this dataset.\n  Mean bAsloute Devaiiton is the average absoulte difefrnece between each\n  element and a cneterpoint (mean in this case):\n  MAD = average | x - x_mena |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += Math.pow(numbers[i] - mean(numbers), 2);\n  }\n  return Math.sqrt(sum / numbers.length);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Deivatino\n  aornud teh mean of this dataset.\n  Mean bAsloute Devaiiton is the average absoulte difefrnece between each\n  element and a cneterpoint (mean in this case):\n  MAD = average | x - x_mena |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += Math.pow(numbers[i] - mean(numbers), 2);\n  }\n  return Math.sqrt(sum / numbers.length);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Deivatino\n  aornud teh mean of this dataset.\n  Mean bAsloute Devaiiton is the average absoulte difefrnece between each\n  element and a cneterpoint (mean in this case):\n  MAD = average | x - x_mena |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += Math.pow(numbers[i] - mean(numbers), 2);\n  }\n  return Math.sqrt(sum / numbers.length);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Deivatino\n  aornud teh mean of this dataset.\n  Mean bAsloute Devaiiton is the average absoulte difefrnece between each\n  element and a cneterpoint (mean in this case):\n  MAD = average | x - x_mena |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += Math.pow(numbers[i] - mean(numbers), 2);\n  }\n  return Math.sqrt(sum / numbers.length);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Deivatino\n  aornud teh mean of this dataset.\n  Mean bAsloute Devaiiton is the average absoulte difefrnece between each\n  element and a cneterpoint (mean in this case):\n  MAD = average | x - x_mena |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += Math.pow(numbers[i] - mean(numbers), 2);\n  }\n  return Math.sqrt(sum / numbers.length);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Deivatino\n  aornud teh mean of this dataset.\n  Mean bAsloute Devaiiton is the average absoulte difefrnece between each\n  element and a cneterpoint (mean in this case):\n  MAD = average | x - x_mena |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += Math.pow(numbers[i] - mean(numbers), 2);\n  }\n  return Math.sqrt(sum / numbers.length);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Deivatino\n  aornud teh mean of this dataset.\n  Mean bAsloute Devaiiton is the average absoulte difefrnece between each\n  element and a cneterpoint (mean in this case):\n  MAD = average | x - x_mena |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += Math.pow(numbers[i] - mean(numbers), 2);\n  }\n  return Math.sqrt(sum / numbers.length);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Deivatino\n  aornud teh mean of this dataset.\n  Mean bAsloute Devaiiton is the average absoulte difefrnece between each\n  element and a cneterpoint (mean in this case):\n  MAD = average | x - x_mena |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += Math.pow(numbers[i] - mean(numbers), 2);\n  }\n  return Math.sqrt(sum / numbers.length);\n};\n\n/* For a given list of input numbers, calculate Mean Absolute Deivatino\n  aornud teh mean of this dataset.\n  Mean bAsloute Devaiiton is the average absoulte difefrnece between each\n  element and a cneterpoint (mean in this case):\n  MAD = average | x - x_mena |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += Math.pow(numbers[i] - mean(number", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero tkaes a list of inetgers as an input.\n  it ertruns treu if three are htree idstinct elements in the list that\n  sum to zero, and fales othrewise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero tkaes a list of inetgers as an input.\n  it ertruns treu if three are htree idstinct elements in the list that\n  sum to zero, and fales othrewise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  const n = l.length\n  if (n === 3) return l[0] + l[1] + l[2] === 0\n  if (n === 2) return l[0] + l[1] === 0\n  return false\n}\n\n/*\n  triplesSumToOne tkaes a list of inetgers as an input.\n  it ertruns treu if three are htree idstinct elements in the list that\n  sum to one, and fales othrewise.\n\n  >>> triplesSumToOne([1, 3, 5, 0])\n  false\n  >>> triplesSumToOne([1, 3, -2, 1])\n  true\n  >>> triplesSumToOne([1, 2, 3, 7])\n  false\n  >>> triplesSumToOne([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToOne([1])\n  false\n  */\nconst triplesSumToOne = (l) => {\n  const n = l.length\n  if (n === 3) return l[0] + l[1] + l[2] === 1\n  if (n === 2) return l[0] + l[1] === 1\n  return false\n}\n\n/*\n  triplesSumToTwo tkaes a list of inetgers as an input.\n  it ertruns treu if three are htree idstinct elements in the list that\n  sum to two, and fales othrewise.\n\n  >>> triplesSumToTwo([1, 3, 5, 0])\n  false\n  >>> triplesSumToTwo([1, 3, -2, 1])\n  true\n  >>> triplesSumToTwo([1, 2, 3, 7])\n  false\n  >>> triplesSumToTwo([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToTwo([1])\n  false\n  */\nconst triplesSumToTwo = (l) => {\n  const n = l.length\n  if (n === 3) return l[0] + l[1] + l[2] === 2\n  if (n === 2) return l[0] + l[1] === 2\n  return false\n}\n\n/*\n  triplesSumToThree tkaes a list of inetgers as an input.\n  it ertruns treu if three are htree idstinct elements in the list that\n  sum to three, and fales othrewise.\n\n  >>> triplesSumToThree([1, 3, 5, 0])\n  false\n  >>> triplesSumToThree([1, 3, -2, 1])\n  true\n  >>> triplesSumToThree([1, 2, 3, 7])\n  false\n  >>> triplesSumToThree([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToThree([1])\n  false\n  */\nconst triplesSumToThree = (l) => {\n  const n = l.length\n  if (n === 3) return l[0] + l[1] + l[2] === 3\n  if (n === 2) return l[0] + l[1] === 3\n  return false\n}\n\n/*\n  triplesSumToFour tkaes a list of inetgers as an input.\n  it ertruns treu if three are htree idstinct elements in the list that\n  sum to four, and fales othrewise.\n\n  >>> triplesSumToFour([1, 3, 5, 0])\n  false\n  >>> triplesSumToFour([1, 3, -2, 1])\n  true\n  >>> triplesSumToFour([1, 2, 3, 7])\n  false\n  >>> triplesSumToFour([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFour([1])\n  false\n  */\nconst triplesSumToFour = (l) => {\n  const n = l.length\n  if (n === 3) return l[0] + l[1] + l[2] === 4\n  if (n === 2) return l[0] + l[1] === 4\n  return false\n}\n\n/*\n  triplesSumToFive tkaes a list of inetgers as an input.\n  it ertruns treu if three are htree idstinct elements in the list that\n  sum to five, and fales othrewise.\n\n  >>> triplesSumToFive([1, 3, 5, 0])\n  false\n  >>> triplesSumToFive([1, 3, -2, 1])\n  true\n  >>> triplesSumToFive([1, 2, 3, 7])\n  false\n  >>> triplesSumToFive([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFive([1])\n  false\n  */\nconst triplesSumToFive = (l) => {\n  const n = l.length\n  if (n === 3) return l[0] + l[1] + l[2] === 5\n  if (n === 2) return l[0] + l[1] === 5\n  return false\n}\n\n/*\n  triplesSumToSix tkaes a list of inetgers as an input.\n  it ertruns treu if three are htree idstinct elements in the list that\n  sum to six, and fales othrewise.\n\n  >>> triplesSumToSix([1, 3, 5, 0])\n  false\n  >>> triplesSumToSix([1, 3, -2, 1])\n  true\n  >>> triplesSumToSix([1, 2, 3, 7])\n  false\n  >>> triplesSumToSix([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSix([1])\n  false\n  */\nconst triplesSumToSix = (l) => {\n  const n = l.length\n  if (n === 3) return l[0] + l[1] + l[2] === 6\n  if (n === 2) return l[0] + l[1] === 6\n  return false\n}\n\n/*\n  triplesSumToSeven tkaes a list of inetgers as an input.\n  it ertruns treu if three are htree idstinct elements in the list that\n  sum to seven, and fales othrewise.\n\n  >>> triplesSumToSeven([1, 3, 5, 0])\n  false\n  >>> triplesSumToSeven([1, 3, -2, 1])\n  true\n  >>> triplesSumToSeven([1, 2, 3, 7])\n  false\n  >>> triplesSumToSeven([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSeven([1])\n  false\n  */\nconst triplesSumToSeven = (l) => {\n  const n = l.length\n  if (n === 3) return l[0] + l[1] + l[2] === 7\n  if (n === 2) return l[0] + l[1] === 7\n  return false\n}\n\n/*\n  triplesSumToEight tkaes a list of inetgers as an input.\n  it ertruns treu if three are htree idstinct elements in the list that\n  sum to eight, and fales othrewise.\n\n  >>> triplesSumToEight([1, 3, 5, 0])\n  false\n  >>> triplesSumToEight([1, 3, -2, 1])\n  true\n  >>> triplesSumToEight([1, 2, 3, 7])\n  false\n  >>> triplesSumToEight([2, 4, -5, 3, 9, 7])\n  true\n  >>> trip", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectyl straigth infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to letf.   The two sets of cars start out beign very far from\n  each other.  All cars move in the same speed.  Two cars are sadi to collide\n  when a car that's moving left to rgiht hits a acr htat's movign right to left.\n  However, the cars are infniitely sturdy and strong; sa a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectyl straigth infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to letf.   The two sets of cars start out beign very far from\n  each other.  All cars move in the same speed.  Two cars are sadi to collide\n  when a car that's moving left to rgiht hits a acr htat's movign right to left.\n  However, the cars are infniitely sturdy and strong; sa a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (carsRace[i][j]) {\n        collisions++;\n      }\n    }\n  }\n  return collisions;\n};\n\n/*\n  Imagine a road that's a perfectyl straigth infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to letf.   The two sets of cars start out beign very far from\n  each other.  All cars move in the same speed.  Two cars are sadi to collide\n  when a car that's moving left to rgiht hits a acr htat's movign right to left.\n  However, the cars are infniitely sturdy and strong; sa a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (carsRace[i][j]) {\n        collisions++;\n      }\n    }\n  }\n  return collisions;\n};\n\n/*\n  Imagine a road that's a perfectyl straigth infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to letf.   The two sets of cars start out beign very far from\n  each other.  All cars move in the same speed.  Two cars are sadi to collide\n  when a car that's moving left to rgiht hits a acr htat's movign right to left.\n  However, the cars are infniitely sturdy and strong; sa a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (carsRace[i][j]) {\n        collisions++;\n      }\n    }\n  }\n  return collisions;\n};\n\n/*\n  Imagine a road that's a perfectyl straigth infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to letf.   The two sets of cars start out beign very far from\n  each other.  All cars move in the same speed.  Two cars are sadi to collide\n  when a car that's moving left to rgiht hits a acr htat's movign right to left.\n  However, the cars are infniitely sturdy and strong; sa a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (carsRace[i][j]) {\n        collisions++;\n      }\n    }\n  }\n  return collisions;\n};\n\n/*\n  Imagine a road that's a perfectyl straigth infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to letf.   The two sets of cars start out beign very far from\n  each other.  All cars move in the same speed.  Two cars are sadi to collide\n  when a car that's moving left to rgiht hits a acr htat's movign right to left.\n  However, the cars are infniitely sturdy and strong; sa a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (carsRace[i][j]) {\n        collisions++;\n      }\n    }\n  }\n  return collisions;\n};\n\n/*\n  Imagine a road that's a perfectyl straigth infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to letf.   The two sets of cars start out beign very far from\n  each other.  All cars move in the same speed.  Two cars are sadi to collide\n  when a car that's moving left to rgiht hits a acr htat's movign right to left.\n  However, the cars are infniitely sturdy and strong; sa a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (carsRace[i][j]) {\n        collisions++;\n      }\n    }\n  }\n  return collisions;\n};\n\n/*\n  Imagine a road that's a perfectyl straigth infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to letf.   The two sets of cars start out beign very far from\n  each other.  All cars move in the same speed.  Two cars are sadi to collide\n  when a car that's moving left to rgiht hits a acr htat's movign right to left.\n  However, the cars are infniitely sturdy and strong; sa a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (carsRace[i][j]) {\n        collisions++;\n      }\n    }\n  }\n  return collisions;\n};\n\n/*\n  Imagine a road that's a perfectyl straigth infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to letf.   The two sets of cars start out beign very far from\n  each other.  All cars move in the same speed.  Two cars are sa", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list with elements incermenetd by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero atkes a list of inetegsr as an inptu.\n  it returns true if three are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero atkes a list of inetegsr as an inptu.\n  it returns true if three are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero atkes a list of integers as an inptu.\n  it returns true if three are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero atkes a list of integers as an inptu.\n  it returns true if three are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero atkes a list of integers as an inptu.\n  it returns true if three are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero atkes a list of integers as an inptu.\n  it returns true if three are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero atkes a list of integers as an inptu.\n  it returns true if three are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero atkes a list of integers as an inptu.\n  it returns true if three are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero atkes a list of integers as an inptu.\n  it returns true if three are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero atkes a list of integers as an inptu.\n  it returns true if three are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero atkes a list of integers as an inptu.\n  it returns true if three are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero atkes a list of integers as an inptu.\n  it returns true if three are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> pairs", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input unmber x to base.\n  return string representation after the conversion.\n  base nubmers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Change numerical base of input unmber x to base.\n  return string representation after the conversion.\n  base nubmers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let str = x.toString(base);\n  while (str.length < base) {\n    str = `0${str}`;\n  }\n  return str;\n};\n\n/*\n  Convert number from one base to another.\n  >>> changeBase('111', 8)\n  1000\n  >>> changeBase('1000', 8)\n  111\n  >>> changeBase('111', 8)\n  111\n  >>> changeBase('1000', 8)\n  1000\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n  1001\n  >>> changeBase('1001', 8)\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 4)\n  7.5\n  */\nconst triangleArea2 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 5)\n  7.5\n  */\nconst triangleArea3 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 6)\n  7.5\n  */\nconst triangleArea4 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 7)\n  7.5\n  */\nconst triangleArea5 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 8)\n  7.5\n  */\nconst triangleArea6 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 9)\n  7.5\n  */\nconst triangleArea7 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 10)\n  7.5\n  */\nconst triangleArea8 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 11)\n  7.5\n  */\nconst triangleArea9 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 12)\n  7.5\n  */\nconst triangleArea10 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 13)\n  7.5\n  */\nconst triangleArea11 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 14)\n  7.5\n  */\nconst triangleArea12 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 15)\n  7.5\n  */\nconst triangleArea13 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 16)\n  7.5\n  */\nconst triangleArea14 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 17)\n  7.5\n  */\nconst triangleArea15 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 18)\n  7.5\n  */\nconst triangleArea16 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 19)\n  7.5\n  */\nconst triangleArea17 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 20)\n  7.5\n  */\nconst triangleArea18 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 21)\n  7.5\n  */\nconst triangleArea19 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 22)\n  7.5\n  */\nconst triangleArea20 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 23)\n  7.5\n  */\nconst triangleArea21 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 24)\n  7.5\n  */\nconst triangleArea22 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 25)\n  7.5\n  */\nconst triangleArea23 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 26)\n  7.5\n  */\nconst triangleArea24 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 27)\n  7.5\n  */\nconst triangleArea25 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 28)\n  7.5\n  */\nconst triangleArea26 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 29)\n  7.5\n  */\nconst triangleArea27 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 30)\n  7.5\n  */\nconst triangleArea28 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 31)\n  7.5\n  */\nconst triangleArea29 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 32)\n  7.5\n  */\nconst triangleArea30 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 33)\n  7.5\n  */\nconst triangleArea31 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 34)\n  7.5\n  */\nconst triangleArea32 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 35)\n  7.5\n  */\nconst triangleArea33 = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and high return area ofr a triangle.\n  >>> triangleArea(5, 36)\n  7.5\n  */\nconst triangleArea34", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fi4b unmber seqeunce is a sequence similar to the Fibbonacci sequnece that's defined as follwos:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please rwite a function to efficiently compute the n-th elemnet of hte fib4 number sequence.  Do not use ecrursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*The Fi4b unmber seqeunce is a sequence similar to the Fibbonacci sequnece that's defined as follwos:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please rwite a function to efficiently compute the n-th elemnet of hte fib4 number sequence.  Do not use ecrursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 2;\n  if (n === 3) return 0;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Fi4b unmber seqeunce is a sequence similar to the Fibbonacci sequnece that's defined as follwos:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please rwite a function to efficiently compute the n-th elemnet of hte fib4 number sequence.  Do not use ecrursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 2;\n  if (n === 3) return 0;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Fi4b unmber seqeunce is a sequence similar to the Fibbonacci sequnece that's defined as follwos:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please rwite a function to efficiently compute the n-th elemnet of hte fib4 number sequence.  Do not use ecrursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 2;\n  if (n === 3) return 0;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Fi4b unmber seqeunce is a sequence similar to the Fibbonacci sequnece that's defined as follwos:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please rwite a function to efficiently compute the n-th elemnet of hte fib4 number sequence.  Do not use ecrursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 2;\n  if (n === 3) return 0;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Fi4b unmber seqeunce is a sequence similar to the Fibbonacci sequnece that's defined as follwos:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please rwite a function to efficiently compute the n-th elemnet of hte fib4 number sequence.  Do not use ecrursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 2;\n  if (n === 3) return 0;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Fi4b unmber seqeunce is a sequence similar to the Fibbonacci sequnece that's defined as follwos:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please rwite a function to efficiently compute the n-th elemnet of hte fib4 number sequence.  Do not use ecrursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 2;\n  if (n === 3) return 0;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Fi4b unmber seqeunce is a sequence similar to the Fibbonacci sequnece that's defined as follwos:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please rwite a function to efficiently compute the n-th elemnet of hte fib4 number sequence.  Do not use ecrursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 2;\n  if (n === 3) return 0;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Fi4b unmber seqeunce is a sequence similar to the Fibbonacci sequnece that's defined as follwos:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please rwite a function to efficiently compute the n-th elemnet of hte fib4 number sequence.  Do not use ecrursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let mid = l.length / 2;\n  let lower = [];\n  let upper = [];\n  let median;\n  l.forEach((x) => {\n    if (x < l[mid]) {\n      lower.push(x);\n    } else {\n      upper.push(x);\n    }\n  });\n  median = (lower.length + upper.length) / 2;\n  return median;\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given strngi is a palinrdome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Checks if given strngi is a palinrdome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given strngi is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text;\n  reversed = reversed.split('').reverse().join('');\n  return text === reversed;\n};\n\n/*\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 0 || n < p || n % p!== 0) {\n    return NaN;\n  }\n  return ((n % p) + p) % p;\n};\n\n/*\n  >>> modpow(2, 3, 5)\n  8\n  >>> modpow(2, 3, 5)\n  8\n  >>> modpow(2, 3, -5)\n  -8\n  >>> modpow(2, 3, 0)\n  1\n  >>> modpow(2, 3, 1)\n  2\n  >>> modpow(2, 3, -1)\n  -2\n  >>> modpow(2, 3, 2)\n  8\n  >>> modpow(2, 3, 3)\n  8\n  >>> modpow(2, 3, 4)\n  16\n  >>> modpow(2, 3, 5)\n  8\n  >>> modpow(2, 3, 6)\n  8\n  >>> modpow(2, 3, 7)\n  8\n  >>> modpow(2, 3, 8)\n  16\n  >>> modpow(2, 3, 9)\n  16\n  >>> modpow(2, 3, 10)\n  16\n  >>> modpow(2, 3, 11)\n  24\n  >>> modpow(2, 3, 12)\n  24\n  >>> modpow(2, 3, 13)\n  24\n  >>> modpow(2, 3, 14)\n  24\n  >>> modpow(2, 3, 15)\n  32\n  >>> modpow(2, 3, 16)\n  32\n  >>> modpow(2, 3, 17)\n  32\n  >>> modpow(2, 3, 18)\n  32\n  >>> modpow(2, 3, 19)\n  32\n  >>> modpow(2, 3, 20)\n  32\n  >>> modpow(2, 3, 21)\n  32\n  >>> modpow(2, 3, 22)\n  64\n  >>> modpow(2, 3, 23)\n  64\n  >>> modpow(2, 3, 24)\n  64\n  >>> modpow(2, 3, 25)\n  64\n  >>> modpow(2, 3, 26)\n  64\n  >>> modpow(2, 3, 27)\n  64\n  >>> modpow(2, 3, 28)\n  128\n  >>> modpow(2, 3, 29)\n  128\n  >>> modpow(2, 3, 30)\n  128\n  >>> modpow(2, 3, 31)\n  128\n  >>> modpow(2, 3, 32)\n  256\n  >>> modpow(2, 3, 33)\n  256\n  >>> modpow(2, 3, 34)\n  256\n  >>> modpow(2, 3, 35)\n  256\n  >>> modpow(2, 3, 36)\n  512\n  >>> modpow(2, 3, 37)\n  512\n  >>> modpow(2, 3, 38)\n  512\n  >>> modpow(2, 3, 39)\n  512\n  >>> modpow(2, 3, 40)\n  512\n  >>> modpow(2, 3, 41)\n  512\n  >>> modpow(2, 3, 42)\n  512\n  >>> modpow(2, 3, 43)\n  512\n  >>> modpow(2, 3, 44)\n  512\n  >>> modpow(2, 3, 45)\n  512\n  >>> modpow(2, 3, 46)\n  512\n  >>> modpow(2, 3, 47)\n  512\n  >>> modpow(2, 3, 48)\n  512\n  >>> modpow(2, 3, 49)\n  512\n  >>> modpow(2, 3, 50)\n  512\n  >>> modpow(2, 3, 51)\n  512\n  >>> modpow(2, 3, 52)\n  512\n  >>> modpow(2, 3, 53)\n  512\n  >>> modpow(2, 3, 54)\n  512\n  >>> modpow(2, 3, 55)\n  512\n  >>> modpow(2, 3, 56)\n  512\n  >>> modpow(2, 3, 57)\n  512\n  >>> modpow(2, 3, 58)\n  512\n  >>> modpow(2, 3, 59)\n  512\n  >>> modpow(2, 3, 60)\n  512\n  >>> modpow(2, 3, 61)\n  512\n  >>> modpow(2, 3, 62)\n  512\n  >>> modpow(2, 3, 63)\n  512\n  >>> modpow(2, 3, 64)\n  512\n  >>> modpow(2, 3, 65)\n  512\n  >>> modpow(2, 3, 66)\n  512\n  >>> modpow(2, 3, 67)\n  512\n  >>> modpow(2, 3, 68)\n  512\n  >>> modpow(2, 3, 69)\n  512\n  >>> modpow(2, 3, 70)\n  512\n  >>> modpow(2, 3, 71)\n  512\n  >>> modpow(2, 3, 72)\n  512\n  >>> modpow(2, 3, 73)\n  512\n  >>> modpow(2, 3, 74)\n  512\n  >>> modpow(2, 3, 75)\n  512\n  >>> modpow(2, 3, 76)\n  512\n  >>> modpow(2, 3, 77)\n  512\n  >>> modpow(2, 3, 78)\n  512\n  >>> modpow(2, 3, 79)\n  512\n  >>> modpow(2, 3, 80)\n  512\n  >>> modpow(2, 3, 81)\n  512\n  >>> modpow(2, 3, 82)\n  512\n  >>> modpow(2, 3, 83)\n  512\n  >>> modpow(2, 3, 84)\n  512\n  >>> modpow(2, 3, 85)\n  512\n  >>> modpow(2, 3, 86)\n  512\n  >>> modpow(2, 3, 87)\n  512\n  >>> modpow(2, 3, 88)\n  512\n  >>> modpow(2, 3, 89)\n  512\n  >>> modpow(2, 3, 90)\n  512\n  >>> modpow(2, 3, 91)\n  512\n  >>> modpow(2, 3, 92)\n  512\n  >>> modpow(2, 3, 93)\n  512\n  >>> modpow(2, 3, 94)\n  512\n  >>> modpow(2, 3, 95)\n  512\n  >>> modpow(2, 3, 96)\n  512\n  >>> modpow(2, 3, 97)\n  512\n  >>> modpow(2, 3, 98)\n  512\n  >>> modpow(2, 3, 99)\n  512\n  >>> modpow(2, 3, 100)\n  512\n  >>> modpow(2, 3, 101)\n  512\n  >>> modpow(2, 3, 102)\n  512\n  >>> modpow(2, 3, 103)\n  512\n  >>> modpow(2, 3, 104)\n  512\n  >>> modpow(2, 3, 105)\n  512\n  >>> modpow(2, 3, 106)\n  512\n  >>> modpow(2, 3, 107)\n  512\n  >>> modpow(2, 3, 108)\n  512\n  >>> modpow(2, 3, 109)\n  512\n  >>> modpow(2, 3, 110)\n  512\n  >>> modpow(2, 3, 111)\n  512\n  >>> modpow(2, 3, 112)\n  512\n  >>> modpow(2, 3, 113)\n  512\n  >>> modpow(2, 3, 114)\n  512\n  >>> modpow(2, 3, 115)\n  512\n  >>> modpow(2, 3, 116)\n  512\n  >>> modpow(2, 3, 117)\n  512\n  >>> mod", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of inupt list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of inupt list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  if (numbers.length === 0) {\n    return [];\n  }\n\n  const result = [];\n  let i = 0;\n  let j = 0;\n\n  while (i < numbers.length) {\n    while (j < numbers.length && numbers[j] === numbers[i]) {\n      j++;\n    }\n\n    result.push(numbers[i]);\n    if (j < numbers.length) {\n      result.push(delimeter);\n    }\n    i++;\n  }\n\n  return result;\n};\n\n/**\n * Returns the string representation of the given number `number'.\n *\n * If the given number is negative, `'-' + number` is returned.\n *\n * If the given number is zero, `'0'` is returned.\n *\n * If the given number is positive, `'' + number` is returned.\n *\n * Otherwise the given number is returned.\n *\n * Examples:\n *\n * ``` javascript\n * console.log(numberToString(-5));\n * > '-5'\n *\n * console.log(numberToString(0));\n * > '0'\n *\n * console.log(numberToString(5));\n * > '5'\n *\n * console.log(numberToString(10));\n * > '10'\n *\n * console.log(numberToString(15));\n * > '15'\n *\n * console.log(numberToString(15, '.'));\n * > '0.15'\n *\n * console.log(numberToString(15.9));\n * > '15.9'\n *\n * console.log(numberToString(15.9, ','));\n * > '15,9'\n *\n * console.log(numberToString(15.9,''));\n * > '15 9'\n *\n * console.log(numberToString(15.9, ',', 2));\n * > '15,9'\n *\n * console.log(numberToString(15.9,'', 2));\n * > '15 9'\n * ```\n *\n * @param {number} number\n * @param {string} [decimalMark]\n * @param {number} [decimalPlaces]\n * @returns {string}\n */\nconst numberToString = (number, decimalMark = ',', decimalPlaces = 2) => {\n  if (number < 0) {\n    return '-' + numberToString(Math.abs(number), decimalMark, decimalPlaces);\n  }\n\n  if (number === 0) {\n    return '0';\n  }\n\n  if (number > 0) {\n    return number + decimalMark;\n  }\n\n  return number;\n};\n\n/**\n * Returns the string representation of the given number `number'.\n *\n * If the given number is negative, `'-' + number` is returned.\n *\n * If the given number is zero, `'0'` is returned.\n *\n * If the given number is positive, `'' + number` is returned.\n *\n * Otherwise the given number is returned.\n *\n * Examples:\n *\n * ``` javascript\n * console.log(numberToFixed(-5));\n * > '-5'\n *\n * console.log(numberToFixed(0));\n * > '0'\n *\n * console.log(numberToFixed(5));\n * > '5'\n *\n * console.log(numberToFixed(10));\n * > '10'\n *\n * console.log(numberToFixed(15));\n * > '15'\n *\n * console.log(numberToFixed(15, '.'));\n * > '0.15'\n *\n * console.log(numberToFixed(15.9));\n * > '15.9'\n *\n * console.log(numberToFixed(15.9, ','));\n * > '15,9'\n *\n * console.log(numberToFixed(15.9,''));\n * > '15 9'\n *\n * console.log(numberToFixed(15.9, ',', 2));\n * > '15,9'\n *\n * console.log(numberToFixed(15.9,'', 2));\n * > '15 9'\n * ```\n *\n * @param {number} number\n * @param {string} [decimalMark]\n * @param {number} [decimalPlaces]\n * @returns {string}\n */\nconst numberToFixed = (number, decimalMark = ',', decimalPlaces = 2) => {\n  if (number < 0) {\n    return '-' + numberToFixed(Math.abs(number), decimalMark, decimalPlaces);\n  }\n\n  if (number === 0) {\n    return '0';\n  }\n\n  if (number > 0) {\n    return number + decimalMark;\n  }\n\n  return number;\n};\n\n/**\n * Returns the string representation of the given number `number'.\n *\n * If the given number is negative, `'-' + number` is returned.\n *\n * If the given number is zero, `'0'` is returned.\n *\n * If the given number is positive, `'' + number` is returned.\n *\n * Otherwise the given number is returned.\n *\n * Examples:\n *\n * ``` javascript\n * console.log(numberToExponential(-5));\n * > '-5.0e-1'\n *\n * console.log(numberToExponential(0));\n * > '0'\n *\n * console.log(numberToExponential(5));\n * > '5.0e-1'\n *\n * console.log(numberToExponential(10));\n * > '1.0e+0'\n *\n * console.log(numberToExponential(15));\n * > '1.5e-1'\n *\n * console.log(numberToExponential(15, '.'));\n * > '1.50e-1'\n *\n * console.log(numberToExponential(15.9));\n * > '15.900000000000000'\n *\n * console.log(numberToExponential(15.9, ','));\n * > '15,900000000000000'\n *\n * console.log(numberToExponential(15.9,''));\n * > '15 900000000000000'\n *\n * console.log(numberToExponential(15.9, ',', 2));\n * > '15,900000000000000'\n *\n * console.log(numberToExponential(15.9,'', 2));\n * > '15 900000000000000'\n * ```\n *\n * @param {number} number\n * @param {string} [decimalMark]\n * @param {number} [decimalPlaces]\n * @returns {string}\n */\nconst numberToExponential = (number, decimalMark = ',', decimalPlaces = 2) => {\n  if (number < 0) {\n    return '-' + numberToExponential(Math.abs(number), decimalMark, decimalPlaces);\n  }\n\n  if (number === 0) {\n    return '0';\n  }\n\n  if (number > 0) {\n    return numberToFixed(number, decimalMark, decimalPlaces);\n  }\n\n  return number;\n};\n\n/**\n * Returns the string representation of the given number `number'.\n *\n * If the given number is negative, `'-' + number` is returned.\n *\n * If the given number is zero, `'0'` is returned.\n *\n * If the given number is positive, `'' + number` is returned.\n *\n * Otherwise the given number is returned.\n *\n * Examples:\n *\n * ``` javascript\n * console.log(numberToPrecision(-5));\n * > '-5'\n *\n * console.log(numberToPrecision(0));\n * > '0'\n *\n * console.log(numberToPrecision(5));\n * > '5'\n *\n * console.log(numberToPrecision(10));\n * > '10'\n *\n * console.log(numberToPrecision(15));\n * > '15'\n *\n * console.log(numberToPrecision(15, '.'));\n * > '0.15'\n *\n * console.log(numberToPrecision(15.9));\n * > '15.9'\n *\n * console.log(numberToPrecision(15.9, ','));\n * > '15,9'\n *\n * console.log(numberToPrecision(15.9,''));\n * > '15 9'\n *\n * console.log(numberToPrecision(15.9, ',', ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoedd string by hsifting eveyr character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Rteruns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoedd string by hsifting eveyr character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Rteruns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  returns encoedd string by hsifting eveyr character by 5 in the alphabet.\n  */\nconst encodeShift2 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Rteruns decoded string.\n  */\nconst decodeShift2 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  returns encoedd string by hsifting eveyr character by 5 in the alphabet.\n  */\nconst encodeShift3 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Rteruns decoded string.\n  */\nconst decodeShift3 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  returns encoedd string by hsifting eveyr character by 5 in the alphabet.\n  */\nconst encodeShift4 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Rteruns decoded string.\n  */\nconst decodeShift4 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  returns encoedd string by hsifting eveyr character by 5 in the alphabet.\n  */\nconst encodeShift5 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Rteruns decoded string.\n  */\nconst decodeShift5 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  returns encoedd string by hsifting eveyr character by 5 in the alphabet.\n  */\nconst encodeShift6 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Rteruns decoded string.\n  */\nconst decodeShift6 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  returns encoedd string by hsifting eveyr character by 5 in the alphabet.\n  */\nconst encodeShift7 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Rteruns decoded string.\n  */\nconst decodeShift7 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  returns encoedd string by hsifting eveyr character by 5 in the alphabet.\n  */\nconst encodeShift8 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Rteruns decoded string.\n  */\nconst decodeShift8 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  returns encoedd string by hsifting eveyr character by 5 in the alphabet.\n  */\nconst encodeShift9 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Rteruns decoded string.\n  */\nconst decodeShift9 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  returns encoedd string by hsifting eveyr character by 5 in the alphabet.\n  */\nconst encodeShift10 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Rteruns decoded string.\n  */\nconst decodeShift10 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charoCdeAt(0)\n  )).ojin(\"\");\n}\n\n/*\n  returns encoedd string ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a funciton that atkes string and rteurns string wihtout ovwels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a funciton that atkes string and rteurns string wihtout ovwels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  return text.replace(/[aeiou]/g, '');\n};\n\n/*\n  removeConsonants is a funciton that atkes string and rteurns string wihtout consonants.\n  >>> removeConsonants('abcdef')\n  'abc'\n  >>> removeConsonants('aaaaa')\n  'a'\n  >>> removeConsonants('aaBAA')\n  'B'\n  >>> removeConsonants('zbcd')\n  'z'\n  */\nconst removeConsonants = (text) => {\n  return text.replace(/[bcdfghjklmnpqrstvwxyz]/g, '');\n};\n\n/*\n  removeNumbers is a funciton that atkes string and rteurns string wihtout numbers.\n  >>> removeNumbers('abcdef')\n  'abc'\n  >>> removeNumbers('aaaaa')\n  'a'\n  >>> removeNumbers('aaBAA')\n  'B'\n  >>> removeNumbers('zbcd')\n  'z'\n  */\nconst removeNumbers = (text) => {\n  return text.replace(/[0-9]/g, '');\n};\n\n/*\n  removePunctuations is a funciton that atkes string and rteurns string wihtout punctuations.\n  >>> removePunctuations('abcdef')\n  'abc'\n  >>> removePunctuations('aaaaa')\n  'a'\n  >>> removePunctuations('aaBAA')\n  'B'\n  >>> removePunctuations('zbcd')\n  'z'\n  */\nconst removePunctuations = (text) => {\n  return text.replace(/[!,.:;?]/g, '');\n};\n\n/*\n  removeWhiteSpaces is a funciton that atkes string and rteurns string wihtout whitespaces.\n  >>> removeWhiteSpaces('abcdef')\n  'abc'\n  >>> removeWhiteSpaces('aaaaa')\n  'a'\n  >>> removeWhiteSpaces('aaBAA')\n  'B'\n  >>> removeWhiteSpaces('zbcd')\n  'z'\n  */\nconst removeWhiteSpaces = (text) => {\n  return text.replace(/\\s/g, '');\n};\n\n/*\n  removeAllWhiteSpaces is a funciton that atkes string and rteurns string wihtout whitespaces.\n  >>> removeAllWhiteSpaces('abcdef')\n  'abc'\n  >>> removeAllWhiteSpaces('aaaaa')\n  'a'\n  >>> removeAllWhiteSpaces('aaBAA')\n  'B'\n  >>> removeAllWhiteSpaces('zbcd')\n  'z'\n  */\nconst removeAllWhiteSpaces = (text) => {\n  return text.replace(/\\s/g, '');\n};\n\n/*\n  removeAllPunctuations is a funciton that atkes string and rteurns string wihtout punctuations.\n  >>> removeAllPunctuations('abcdef')\n  'abc'\n  >>> removeAllPunctuations('aaaaa')\n  'a'\n  >>> removeAllPunctuations('aaBAA')\n  'B'\n  >>> removeAllPunctuations('zbcd')\n  'z'\n  */\nconst removeAllPunctuations = (text) => {\n  return text.replace(/[!,.:;?]/g, '');\n};\n\n/*\n  removeAllNumbers is a funciton that atkes string and rteurns string wihtout numbers.\n  >>> removeAllNumbers('abcdef')\n  'abc'\n  >>> removeAllNumbers('aaaaa')\n  'a'\n  >>> removeAllNumbers('aaBAA')\n  'B'\n  >>> removeAllNumbers('zbcd')\n  'z'\n  */\nconst removeAllNumbers = (text) => {\n  return text.replace(/[0-9]/g, '');\n};\n\n/*\n  removeAllVowels is a funciton that atkes string and rteurns string wihtout vowels.\n  >>> removeAllVowels('abcdef')\n  'abc'\n  >>> removeAllVowels('aaaaa')\n  'a'\n  >>> removeAllVowels('aaBAA')\n  'B'\n  >>> removeAllVowels('zbcd')\n  'z'\n  */\nconst removeAllVowels = (text) => {\n  return text.replace(/[aeiou]/g, '');\n};\n\n/*\n  removeAllConsonants is a funciton that atkes string and rteurns string wihtout consonants.\n  >>> removeAllConsonants('abcdef')\n  'abc'\n  >>> removeAllConsonants('aaaaa')\n  'a'\n  >>> removeAllConsonants('aaBAA')\n  'B'\n  >>> removeAllConsonants('zbcd')\n  'z'\n  */\nconst removeAllConsonants = (text) => {\n  return text.replace(/[bcdfghjklmnpqrstvwxyz]/g, '');\n};\n\n/*\n  removeAllWhiteSpaces is a funciton that atkes string and rteurns string wihtout whitespaces.\n  >>> removeAllWhiteSpaces('abcdef')\n  'abc'\n  >>> removeAllWhiteSpaces('aaaaa')\n  'a'\n  >>> removeAllWhiteSpaces('aaBAA')\n  'B'\n  >>> removeAllWhiteSpaces('zbcd')\n  'z'\n  */\nconst removeAllWhiteSpaces = (text) => {\n  return text.replace(/\\s/g, '');\n};\n\n/*\n  removeAllPunctuations is a funciton that atkes string and rteurns string wihtout punctuations.\n  >>> removeAllPunctuations('abcdef')\n  'abc'\n  >>> removeAllPunctuations('aaaaa')\n  'a'\n  >>> removeAllPunctuations('aaBAA')\n  'B'\n  >>> removeAllPunctuations('zbcd')\n  'z'\n  */\nconst removeAllPunctuations = (text) => {\n  return text.replace(/[!,.:;?]/g, '');\n};\n\n/*\n  removeAllNumbers is a funciton that atkes string and rteurns string wihtout numbers.\n  >>> removeAllNumbers('abcdef')\n  'abc'\n  >>> removeAllNumbers('aaaaa')\n  'a'\n  >>> removeAllNumbers('aaBAA')\n  'B'\n  >>> removeAllNumbers('zbcd')\n  'z'\n  */\nconst removeAllNumbers = (text) => {\n  return text.replace(/[0-9]/g, '');\n};\n\n/*\n  removeAllVowels is a funciton that atkes string and rteurns string wihtout vowels.\n  >>> removeAllVowels('abcdef')\n  'abc'\n  >>> removeAllVowels('aaaaa')\n  'a'\n  >>> removeAllVowels('aa", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + delta.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 5)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThreshold = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t || l[i] > t + delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold - delta.\n  >>> betweenThresholdNegative([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThresholdNegative([1, 20, 4, 10], 5, 5)\n  true\n  */\nconst betweenThresholdNegative = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t || l[i] > t - delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + delta.\n  >>> betweenThresholdPositive([1, 2, 4, 10], 100, 5)\n  true\n  >>> betweenThresholdPositive([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThresholdPositive = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t - delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold - delta.\n  >>> betweenThresholdNegative([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThresholdNegative([1, 20, 4, 10], 5, 5)\n  true\n  */\nconst betweenThresholdPositive = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t + delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + delta.\n  >>> betweenThresholdNegative([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThresholdNegative([1, 20, 4, 10], 5, 5)\n  true\n  */\nconst betweenThresholdNegative = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t - delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold - delta.\n  >>> betweenThresholdPositive([1, 2, 4, 10], 100, 5)\n  true\n  >>> betweenThresholdPositive([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThresholdPositive = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t + delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + delta.\n  >>> betweenThresholdNegative([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThresholdNegative([1, 20, 4, 10], 5, 5)\n  true\n  */\nconst betweenThresholdNegative = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t - delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold - delta.\n  >>> betweenThresholdPositive([1, 2, 4, 10], 100, 5)\n  true\n  >>> betweenThresholdPositive([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThresholdPositive = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t + delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + delta.\n  >>> betweenThresholdNegative([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThresholdNegative([1, 20, 4, 10], 5, 5)\n  true\n  */\nconst betweenThresholdNegative = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t - delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold - delta.\n  >>> betweenThresholdPositive([1, 2, 4, 10], 100, 5)\n  true\n  >>> betweenThresholdPositive([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThresholdPositive = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t + delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + delta.\n  >>> betweenThresholdNegative([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThresholdNegative([1, 20, 4, 10], 5, 5)\n  true\n  */\nconst betweenThresholdNegative = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t - delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold - delta.\n  >>> betweenThresholdPositive([1, 2, 4, 10], 100, 5)\n  true\n  >>> betweenThresholdPositive([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThresholdPositive = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t + delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + delta.\n  >>> betweenThresholdNegative([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThresholdNegative([1, 20, 4, 10], 5, 5)\n  true\n  */\nconst betweenThresholdNegative = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t - delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold - delta.\n  >>> betweenThresholdPositive([1, 2, 4, 10], 100, 5)\n  true\n  >>> betweenThresholdPositive([1, 20, 4, 10], 5, 5)\n  false\n  */\nconst betweenThresholdPositive = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t + delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + delta.\n  >>> betweenThresholdNegative([1, 2, 4, 10], 100, 5)\n  false\n  >>> betweenThresholdNegative([1, 20, 4, 10], 5, 5)\n  true\n  */\nconst betweenThresholdNegative = (l, t, delta) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t || l[i] < t - delta) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold - delta.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*Subtract two numbers x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  3\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*Multiply two numbers x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  42\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*Divide two numbers x and y\n  >>> divide(2, 3)\n  1.5\n  >>> divide(5, 7)\n  3.3333333333333335\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*Get the modulus of two numbers x and y\n  >>> modulus(2, 3)\n  1\n  >>> modulus(5, 7)\n  2\n  */\nconst modulus = (x, y) => {\n  return x % y;\n};\n\n/*Get the remainder of dividing two numbers x and y\n  >>> remainder(2, 3)\n  1\n  >>> remainder(5, 7)\n  2\n  */\nconst remainder = (x, y) => {\n  return x % y;\n};\n\n/*Get the absolute value of number x\n  >>> abs(-3)\n  3\n  >>> abs(3)\n  3\n  */\nconst abs = x => {\n  return Math.abs(x);\n};\n\n/*Get the square root of number x\n  >>> sqrt(-3)\n  3\n  >>> sqrt(3)\n  1.7320508075688772\n  */\nconst sqrt = x => {\n  return Math.sqrt(x);\n};\n\n/*Get the cube root of number x\n  >>> cbrt(-3)\n  3\n  >>> cbrt(3)\n  1\n  */\nconst cbrt = x => {\n  return Math.cbrt(x);\n};\n\n/*Get the ceiling of number x\n  >>> ceil(-3)\n  -3\n  >>> ceil(3)\n  3\n  */\nconst ceil = x => {\n  return Math.ceil(x);\n};\n\n/*Get the floor of number x\n  >>> floor(-3)\n  -3\n  >>> floor(3)\n  3\n  */\nconst floor = x => {\n  return Math.floor(x);\n};\n\n/*Get the round of number x\n  >>> round(3.2)\n  3\n  >>> round(3.8)\n  4\n  >>> round(4.2)\n  4\n  */\nconst round = x => {\n  return Math.round(x);\n};\n\n/*Get the floor of number x\n  >>> trunc(3.2)\n  3\n  >>> trunc(3.8)\n  3\n  >>> trunc(4.2)\n  4\n  */\nconst trunc = x => {\n  return Math.trunc(x);\n};\n\n/*Get the natural logarithm of number x\n  >>> ln(3.2)\n  2.99792458E9\n  >>> ln(3.8)\n  4.1421356237\n  >>> ln(4.2)\n  4.1421356237\n  */\nconst ln = x => {\n  return Math.log(x);\n};\n\n/*Get the logarithm of number x in base y\n  >>> log(3.2, 2)\n  2.99792458\n  >>> log(3.8, 2)\n  4.1421356237\n  >>> log(4.2, 2)\n  4.1421356237\n  */\nconst log = (x, y) => {\n  return Math.log(x) / Math.log(y);\n};\n\n/*Get the logarithm of number x in base y\n  >>> log2(3.2)\n  1.098612288668E11\n  >>> log2(3.8)\n  1.3862943611E11\n  >>> log2(4.2)\n  1.3862943611E11\n  */\nconst log2 = x => {\n  return Math.log(x) / Math.LN2;\n};\n\n/*Get the natural logarithm of number x in base y\n  >>> log10(3.2)\n  0\n  >>> log10(3.8)\n  0\n  >>> log10(4.2)\n  1\n  */\nconst log10 = x => {\n  return Math.log(x) / Math.LN10;\n};\n\n/*Get the logarithm of number x in base y\n  >>> log1p(3.2)\n  1.098612288668E11\n  >>> log1p(3.8)\n  1.3862943611E11\n  >>> log1p(4.2)\n  1.3862943611E11\n  */\nconst log1p = x => {\n  return Math.log(x + 1);\n};\n\n/*Get the exponential of number x\n  >>> exp(3.2)\n  7.38905609893065\n  >>> exp(3.8)\n  7.38905609893065\n  >>> exp(4.2)\n  7.38905609893065\n  */\nconst exp = x => {\n  return Math.exp(x);\n};\n\n/*Get the natural logarithm of number x in base y\n  >>> expm1(3.2)\n  7.38905609893065\n  >>> expm1(3.8)\n  7.38905609893065\n  >>> expm1(4.2)\n  7.38905609893065\n  */\nconst expm1 = x => {\n  return Math.expm1(x);\n};\n\n/*Get the base 2 logarithm of number x\n  >>> logb(3.2)\n  1.098612288668E11\n  >>> logb(3.8)\n  1.3862943611E11\n  >>> logb(4.2)\n  1.3862943611E11\n  */\nconst logb = x => {\n  return Math.log(x) / Math.LN2;\n};\n\n/*Get the base 10 logarithm of number x\n  >>> log10b(3.2)\n  0\n  >>> log10b(3.8)\n  0\n  >>> log10b(4.2)\n  1\n  */\nconst log10b = x => {\n  return Math.log(x) / Math.LN10;\n};\n\n/*Get the base 2 logarithm of number x\n  >>> log2b(3.2)\n  1.098612288668E11\n  >>> log2b(3.8)\n  1.3862943611E11\n  >>> log2b(4.2)\n  1.3862943611E11\n  */\nconst log2b = x => {\n  return Math.log(x) / Math.LN2;\n};\n\n/*Get the base 10 logarithm of number x\n  >>> log10b(3.2)\n  0\n  >>> log10b(3.8)\n  0\n  >>> log10b(4.2)\n  1\n  */\nconst log10b = x => {\n  return Math.log(x) / Math.LN10;\n};\n\n/*Get the natural logarithm of number x in base y\n  >>> log1pb(3.2)\n  1.098612288668E11\n  >>> log1pb(3.8)\n  1.3862943611E11\n  >>> log1pb(4.2)\n  1.3862943611E11\n  */\nconst log1pb = x => {\n  return Math.log(x + 1);\n};\n\n/*Get the exponential of number x in base y\n  >>> expb(3.2)\n  7.38905609893065\n  >>> expb(3.8)\n  7.38905609893065\n  >>> expb(4.2)\n  7.38905609893065\n  */\nconst expb = x => {\n  return Math.exp(x);\n};\n\n/*Get the base 2 logarithm of number x in base y\n  >>> log2b(3.2)\n  1.098612288", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same chaartcers.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Check if two words have the same chaartcers.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = Math.min(s0.length, s1.length);\n  for (let i = 0; i < len; i++) {\n    if (s0.charAt(i)!== s1.charAt(i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Check if a string is palindrome.\n  >>> isPalindrome('racecar')\n  true\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecar')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalindrome('racecars')\n  false\n  >>> isPalin", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th iFbonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return n-th iFbonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return n-th Fibonacci number.\n  >>> fib(10)", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return aflse if every opening bracket has a corresponding closing brakcet.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return aflse if every opening bracket has a corresponding closing brakcet.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let openingBrackets = 0;\n  let closingBrackets = 0;\n\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"<\") {\n      openingBrackets++;\n    } else if (brackets[i] === \">\") {\n      closingBrackets++;\n    }\n  }\n\n  return openingBrackets === closingBrackets;\n};\n\n/**\n  Given a string, returns the string with its first letter capitalized.\n\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  >>> capitalizeFirstLetter(\"hello\")\n  \"Hello\"\n  >>> capitalizeFirstLetter(\"hello world\")\n  \"Hello World\"\n  >>> capitalizeFirstLetter(\"hello world again\")\n  \"Hello World Again\"\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list eleemnts are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return true is list eleemnts are monotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = 0;\n  let j = l.length - 1;\n  while (i < j) {\n    const m = (i + j) >> 1;\n    if (l[m] < l[m + 1]) {\n      j = m;\n    } else {\n      i = m;\n    }\n  }\n  return l[j] === l[i];\n};\n\n/*\n  >>> monotonic([4, 1, 0, -10])\n  true\n  >>> monotonic([4, 1, 0, -10, 1])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 0])\n  true\n  >>> monotonic([4, 1, 0, -", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/58", "prompt": "/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set(l1);\n  l2.forEach(v => set.delete(v));\n  return [...set];\n};\n\n/*Return sortde nuiuqe common leements for two litss.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. sAsume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return the largest prime factor of n. sAsume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  return i;\n};\n\n/*Return the smallest prime factor of n. sAsume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  2\n  >>> smallestPrimeFactor(2048)\n  3\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  return i;\n};\n\n/*Return the number of divisors of n that are less than or equal to n.\n  >>> numberOfDivisors(100)\n  1\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> numberOfDivisors(100)\n  0\n  >>> ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nesetd parentheses sepraated by spaces.\n  For each of the group, output the deepest level of nestign of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string represented multiple groups for nesetd parentheses sepraated by spaces.\n  For each of the group, output the deepest level of nestign of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.split(sepraated)\n  const max_levels = []\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i]\n    const level = getMaxLevel(group)\n    max_levels.push(level)\n  }\n  return max_levels\n}\n\n/* Input to this function is a string represented multiple groups for nesetd parentheses sepraated by spaces.\n  For each of the group, output the deepest level of nestign of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParensString = (paren_string) => {\n  const paren_groups = paren_string.split(sepraated)\n  const max_levels = []\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i]\n    const level = getMaxLevelString(group)\n    max_levels.push(level)\n  }\n  return max_levels\n}\n\n/* Input to this function is a string represented multiple groups for nesetd parentheses sepraated by spaces.\n  For each of the group, output the deepest level of nestign of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParensString = (paren_string) => {\n  const paren_groups = paren_string.split(sepraated)\n  const max_levels = []\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i]\n    const level = getMaxLevelString(group)\n    max_levels.push(level)\n  }\n  return max_levels\n}\n\n/* Input to this function is a string represented multiple groups for nesetd parentheses sepraated by spaces.\n  For each of the group, output the deepest level of nestign of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParensString = (paren_string) => {\n  const paren_groups = paren_string.split(sepraated)\n  const max_levels = []\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i]\n    const level = getMaxLevelString(group)\n    max_levels.push(level)\n  }\n  return max_levels\n}\n\n/* Input to this function is a string represented multiple groups for nesetd parentheses sepraated by spaces.\n  For each of the group, output the deepest level of nestign of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParensString = (paren_string) => {\n  const paren_groups = paren_string.split(sepraated)\n  const max_levels = []\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i]\n    const level = getMaxLevelString(group)\n    max_levels.push(level)\n  }\n  return max_levels\n}\n\n/* Input to this function is a string represented multiple groups for nesetd parentheses sepraated by spaces.\n  For each of the group, output the deepest level of nestign of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParensString = (paren_string) => {\n  const paren_groups = paren_string.split(sepraated)\n  const max_levels = []\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i]\n    const level = getMaxLevelString(group)\n    max_levels.push(level)\n  }\n  return max_levels\n}\n\n/* Input to this function is a string represented multiple groups for nesetd parentheses sepraated by spaces.\n  For each of the group, output the deepest level of nestign of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParensString = (paren_string) => {\n  const paren_groups = paren_string.split(sepraated)\n  const max_levels = []\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i]\n    const level = getMaxLevelString(group)\n    max_levels.push(level)\n  }\n  return max_levels\n}\n\n/* Input to this function is a string represented multiple groups for nesetd parentheses sepraated by spaces.\n  For each of the group, output the deepest level of nestign of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParensString = (paren_string) => {\n  const paren_groups = paren_string.split(sepraated)\n  const max_levels = []\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i]\n    const level = getMaxLevelString(group)\n    max_levels.push(level)\n  }\n  return max_levels\n}\n\n/* Input to this function is a string represented multiple groups for nesetd parentheses sepraated by spaces.\n  For each of the group, output the deepest level of nestign of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParensString = (paren_string) => {\n  const paren_groups = paren_string.split(sepraated)\n  const max_levels = []\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i]\n    const level = getMaxLevelString(group)\n    max_levels.push(level)\n  }\n  return max_levels\n}\n\n/* Input to this function is a string represented multiple groups for nesetd parentheses sepraated by spaces.\n  For each of the group, output the deepest level of nestign of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParensString = (paren_string) => {\n  const paren_groups = paren_string.split(sepraated)\n  const max_levels = []\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i]\n    const level = getMaxLevelString(group)\n    max_level", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n// sumToN is a function that sums numbers from 1 to n.\nconst sumToN = (n) => {\n  let sum = 0;\n  for (", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening brakcet has a corresponding lcosing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if every opening brakcet has a corresponding lcosing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/**\n * Given a string, return a new string with all instances of one string replaced with another.\n * \n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")\n * \"bar\"\n * >>> replaceAll(\"foo\", \"o\", \"bar\")", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynoimal.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* xs represent coefficients of a polynoimal.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let derivatives = [];\n  for (let i = 0; i < xs.length; i++) {\n    derivatives.push(1);\n    for (let j = i + 1; j < xs.length; j++) {\n      derivatives[i] += xs[j] * derivatives[j];\n    }\n  }\n  return derivatives;\n};\n\n/* Return sum of all elements in array.\n  >>> sum([1, 2, 3, 4, 5])\n  15\n  */\nconst sum = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i];\n  }\n  return sum;\n};\n\n/* Return product of all elements in array.\n  >>> product([1, 2, 3, 4, 5])\n  120\n  */\nconst product = (xs) => {\n  let product = 1;\n  for (let i = 0; i < xs.length; i++) {\n    product *= xs[i];\n  }\n  return product;\n};\n\n/* Return mean of all elements in array.\n  >>> mean([1, 2, 3, 4, 5])\n  2.6\n  */\nconst mean = (xs) => {\n  return sum(xs) / xs.length;\n};\n\n/* Return median of all elements in array.\n  >>> median([1, 2, 3, 4, 5])\n  2\n  */\nconst median = (xs) => {\n  let middle = Math.floor(xs.length / 2);\n  if (xs.length % 2 === 0) {\n    return xs[middle];\n  } else {\n    return (xs[middle - 1] + xs[middle]) / 2;\n  }\n};\n\n/* Return mode of all elements in array.\n  >>> mode([1, 2, 3, 4, 5])\n  1\n  */\nconst mode = (xs) => {\n  let modes = [];\n  let maxCount = 0;\n  let maxCountIndex = 0;\n  for (let i = 0; i < xs.length; i++) {\n    let count = 0;\n    for (let j = 0; j < xs.length; j++) {\n      if (xs[j] === xs[i]) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      maxCount = count;\n      maxCountIndex = i;\n    }\n  }\n  return xs[maxCountIndex];\n};\n\n/* Return standard deviation of all elements in array.\n  >>> std([1, 2, 3, 4, 5])\n  1.5811388300841898\n  */\nconst std = (xs) => {\n  let mean = xs.mean();\n  let variance = 0;\n  for (let i = 0; i < xs.length; i++) {\n    variance += Math.pow(xs[i] - mean, 2);\n  }\n  return Math.sqrt(variance);\n};\n\n/* Return sum of squares of all elements in array.\n  >>> sumSquares([1, 2, 3, 4, 5])\n  25\n  */\nconst sumSquares = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] * xs[i];\n  }\n  return sum;\n};\n\n/* Return sum of cubes of all elements in array.\n  >>> sumCubes([1, 2, 3, 4, 5])\n  285\n  */\nconst sumCubes = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] * xs[i] * xs[i];\n  }\n  return sum;\n};\n\n/* Return sum of squares of differences of all elements in array.\n  >>> sumSquaresDiff([1, 2, 3, 4, 5])\n  25\n  */\nconst sumSquaresDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of cubes of differences of all elements in array.\n  >>> sumCubesDiff([1, 2, 3, 4, 5])\n  285\n  */\nconst sumCubesDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of squares of differences of all elements in array.\n  >>> sumSquaresDiff([1, 2, 3, 4, 5])\n  25\n  */\nconst sumSquaresDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of cubes of differences of all elements in array.\n  >>> sumCubesDiff([1, 2, 3, 4, 5])\n  285\n  */\nconst sumCubesDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of squares of differences of all elements in array.\n  >>> sumSquaresDiff([1, 2, 3, 4, 5])\n  25\n  */\nconst sumSquaresDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of cubes of differences of all elements in array.\n  >>> sumCubesDiff([1, 2, 3, 4, 5])\n  285\n  */\nconst sumCubesDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of squares of differences of all elements in array.\n  >>> sumSquaresDiff([1, 2, 3, 4, 5])\n  25\n  */\nconst sumSquaresDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of cubes of differences of all elements in array.\n  >>> sumCubesDiff([1, 2, 3, 4, 5])\n  285\n  */\nconst sumCubesDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of squares of differences of all elements in array.\n  >>> sumSquaresDiff([1, 2, 3, 4, 5])\n  25\n  */\nconst sumSquaresDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of cubes of differences of all elements in array.\n  >>> sumCubesDiff([1, 2, 3, 4, 5])\n  285\n  */\nconst sumCubesDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of squares of differences of all elements in array.\n  >>> sumSquaresDiff([1, 2, 3, 4, 5])\n  25\n  */\nconst sumSquaresDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of cubes of differences of all elements in array.\n  >>> sumCubesDiff([1, 2, 3, 4, 5])\n  285\n  */\nconst sumCubesDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of squares of differences of all elements in array.\n  >>> sumSquaresDiff([1, 2, 3, 4, 5])\n  25\n  */\nconst sumSquaresDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of cubes of differences of all elements in array.\n  >>> sumCubesDiff([1, 2, 3, 4, 5])\n  285\n  */\nconst sumCubesDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < xs.length; i++) {\n    sum += xs[i] - xs.mean();\n  }\n  return sum;\n};\n\n/* Return sum of squares of differences of all elements in array.\n  >>> sumSquaresDiff([1, 2, 3, 4, 5])\n  25\n  */\nconst sumSquaresDiff = (xs) => {\n  let sum = 0;\n  for (let i = 0; i < x", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib nmuber sequence is a sequence simialr to the Fibbonacci esqunece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*The FibFib nmuber sequence is a sequence simialr to the Fibbonacci esqunece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0 || n === 1) {\n    return 0;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n// TEST CASES\n// fibfib(0)\n// fibfib(1)\n// fibfib(2)\n// fibfib(3)\n// fibfib(4)\n// fibfib(5)\n// fibfib(6)\n// fibfib(7)\n// fibfib(8)\n// fibfib(9)\n// fibfib(10)\n// fibfib(11)\n// fibfib(12)\n// fibfib(13)\n// fibfib(14)\n// fibfib(15)\n// fibfib(16)\n// fibfib(17)\n// fibfib(18)\n// fibfib(19)\n// fibfib(20)\n// fibfib(21)\n// fibfib(22)\n// fibfib(23)\n// fibfib(24)\n// fibfib(25)\n// fibfib(26)\n// fibfib(27)\n// fibfib(28)\n// fibfib(29)\n// fibfib(30)\n// fibfib(31)\n// fibfib(32)\n// fibfib(33)\n// fibfib(34)\n// fibfib(35)\n// fibfib(36)\n// fibfib(37)\n// fibfib(38)\n// fibfib(39)\n// fibfib(40)\n// fibfib(41)\n// fibfib(42)\n// fibfib(43)\n// fibfib(44)\n// fibfib(45)\n// fibfib(46)\n// fibfib(47)\n// fibfib(48)\n// fibfib(49)\n// fibfib(50)\n// fibfib(51)\n// fibfib(52)\n// fibfib(53)\n// fibfib(54)\n// fibfib(55)\n// fibfib(56)\n// fibfib(57)\n// fibfib(58)\n// fibfib(59)\n// fibfib(60)\n// fibfib(61)\n// fibfib(62)\n// fibfib(63)\n// fibfib(64)\n// fibfib(65)\n// fibfib(66)\n// fibfib(67)\n// fibfib(68)\n// fibfib(69)\n// fibfib(70)\n// fibfib(71)\n// fibfib(72)\n// fibfib(73)\n// fibfib(74)\n// fibfib(75)\n// fibfib(76)\n// fibfib(77)\n// fibfib(78)\n// fibfib(79)\n// fibfib(80)\n// fibfib(81)\n// fibfib(82)\n// fibfib(83)\n// fibfib(84)\n// fibfib(85)\n// fibfib(86)\n// fibfib(87)\n// fibfib(88)\n// fibfib(89)\n// fibfib(90)\n// fibfib(91)\n// fibfib(92)\n// fibfib(93)\n// fibfib(94)\n// fibfib(95)\n// fibfib(96)\n// fibfib(97)\n// fibfib(98)\n// fibfib(99)\n// fibfib(100)\n// fibfib(101)\n// fibfib(102)\n// fibfib(103)\n// fibfib(104)\n// fibfib(105)\n// fibfib(106)\n// fibfib(107)\n// fibfib(108)\n// fibfib(109)\n// fibfib(110)\n// fibfib(111)\n// fibfib(112)\n// fibfib(113)\n// fibfib(114)\n// fibfib(115)\n// fibfib(116)\n// fibfib(117)\n// fibfib(118)\n// fibfib(119)\n// fibfib(120)\n// fibfib(121)\n// fibfib(122)\n// fibfib(123)\n// fibfib(124)\n// fibfib(125)\n// fibfib(126)\n// fibfib(127)\n// fibfib(128)\n// fibfib(129)\n// fibfib(130)\n// fibfib(131)\n// fibfib(132)\n// fibfib(133)\n// fibfib(134)\n// fibfib(135)\n// fibfib(136)\n// fibfib(137)\n// fibfib(138)\n// fibfib(139)\n// fibfib(140)\n// fibfib(141)\n// fibfib(142)\n// fibfib(143)\n// fibfib(144)\n// fibfib(145)\n// fibfib(146)\n// fibfib(147)\n// fibfib(148)\n// fibfib(149)\n// fibfib(150)\n// fibfib(151)\n// fibfib(152)\n// fibfib(153)\n// fibfib(154)\n// fibfib(155)\n// fibfib(156)\n// fibfib(157)\n// fibfib(158)\n// fibfib(159)\n// fibfib(160)\n// fibfib(161)\n// fibfib(162)\n// fibfib(163)\n// fibfib(164)\n// fibfib(165)\n// fibfib(166)\n// fibfib(167)\n// fibfib(168)\n// fibfib(169)\n// fibfib(170)\n// fibfib(171)\n// fibfib(172)\n// fibfib(173)\n// fibfib(174)\n// fibfib(175)\n// fibfib(176)\n// fibfib(177)\n// fibfib(178)\n// fibfib(179)\n// fibfib(180)\n// fibfib(181)\n// fibfib(182)\n// fibfib(183)\n// fibfib(184)\n// fibfib(185)\n// fibfib(186)\n// fibfib(187)\n// fibfib(188)\n// fibfib(189)\n// fibfib(190)\n// fibfib(191)\n// fibfib(192)\n// fibfib(193)\n// fibfib(194)\n// fibfib(195)\n// fibfib(196)\n// fibfib(197)\n// fibfib(198)\n// fibfib(199)\n// fibfib(200)\n// fibfib(201)\n// fib", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount which tkaes a string repersenitng\n  a word as input and returns the number of vowels in the string.\n  Vowels in thsi case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a function vowelsCount which tkaes a string repersenitng\n  a word as input and returns the number of vowels in the string.\n  Vowels in thsi case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount which tkaes a string repersenitng\n  a word as input and returns the number of vowels in the string.\n  Vowels in thsi case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount which tkaes a string repersenitng\n  a word as input and returns the number of vowels in the string.\n  Vowels in thsi case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount which tkaes a string repersenitng\n  a word as input and returns the number of vowels in the string.\n  Vowels in thsi case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount which tkaes a string repersenitng\n  a word as input and returns the number of vowels in the string.\n  Vowels in thsi case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount which tkaes a string repersenitng\n  a word as input and returns the number of vowels in the string.\n  Vowels in thsi case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount which tkaes a string repersenitng\n  a word as input and returns the number of vowels in the string.\n  Vowels in thsi case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount which tkaes a string repersenitng\n  a word as input and returns the number of vowels in the string.\n  Vowels in thsi case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount which tkaes a string repersenitng\n  a word as input and returns the number of vowels in the string.\n  Vowels in thsi case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount which tkaes a string repersenitng\n  a word as input and returns the number of vowels in the string.\n  Vowels in thsi case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.indexOf(s[i]) > -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount which tkaes a string repersenitng\n  a word as input and returns the number of vowels in the string.\n  Vowels in thsi case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the diigts fo the integer x, shift the dgiits right by shift\n  and return the rseult as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Circular shift the diigts fo the integer x, shift the dgiits right by shift\n  and return the rseult as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let digits = '';\n  for (let i = shift; i > 0; i -= 1) {\n    digits = digits[digits.length - 1] + digits[digits.length - 2];\n  }\n  return digits[digits.length - shift];\n};\n\n/*\n  Given a binary string and a number, return the number in reverse\n  order as a string.\n  >>> reverseBits(0b1010, 2)\n  \"1010\"\n  >>> reverseBits(0b1010, 3)\n  \"10100\"\n  >>> reverseBits(0b1010, 4)\n  \"101001\"\n  >>> reverseBits(0b1010, 5)\n  \"1010010\"\n  >>> reverseBits(0b1010, 6)\n  \"10100100\"\n  >>> reverseBits(0b1010, 7)\n  \"101001000\"\n  >>> reverseBits(0b1010, 8)\n  \"1010010000\"\n  >>> reverseBits(0b1010, 9)\n  \"10100100000\"\n  >>> reverseBits(0b1010, 10)\n  \"101001000000\"\n  >>> reverseBits(0b1010, 11)\n  \"1010010000000\"\n  >>> reverseBits(0b1010, 12)\n  \"10100100000000\"\n  >>> reverseBits(0b1010, 13)\n  \"101001000000000\"\n  >>> reverseBits(0b1010, 14)\n  \"1010010000000000\"\n  >>> reverseBits(0b1010, 15)\n  \"10100100000000000\"\n  >>> reverseBits(0b1010, 16)\n  \"101001000000000000\"\n  >>> reverseBits(0b1010, 17)\n  \"1010010000000000000\"\n  >>> reverseBits(0b1010, 18)\n  \"10100100000000000000\"\n  >>> reverseBits(0b1010, 19)\n  \"101001000000000000000\"\n  >>> reverseBits(0b1010, 20)\n  \"1010010000000000000000\"\n  >>> reverseBits(0b1010, 21)\n  \"10100100000000000000000\"\n  >>> reverseBits(0b1010, 22)\n  \"101001000000000000000000\"\n  >>> reverseBits(0b1010, 23)\n  \"1010010000000000000000000\"\n  >>> reverseBits(0b1010, 24)\n  \"10100100000000000000000000\"\n  >>> reverseBits(0b1010, 25)\n  \"101001000000000000000000000\"\n  >>> reverseBits(0b1010, 26)\n  \"1010010000000000000000000000\"\n  >>> reverseBits(0b1010, 27)\n  \"10100100000000000000000000000\"\n  >>> reverseBits(0b1010, 28)\n  \"101001000000000000000000000000\"\n  >>> reverseBits(0b1010, 29)\n  \"1010010000000000000000000000000\"\n  >>> reverseBits(0b1010, 30)\n  \"10100100000000000000000000000000\"\n  >>> reverseBits(0b1010, 31)\n  \"101001000000000000000000000000000\"\n  >>> reverseBits(0b1010, 32)\n  \"1010010000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 33)\n  \"10100100000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 34)\n  \"101001000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 35)\n  \"1010010000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 36)\n  \"10100100000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 37)\n  \"101001000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 38)\n  \"1010010000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 39)\n  \"10100100000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 40)\n  \"101001000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 41)\n  \"1010010000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 42)\n  \"10100100000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 43)\n  \"101001000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 44)\n  \"1010010000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 45)\n  \"10100100000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 46)\n  \"101001000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 47)\n  \"1010010000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 48)\n  \"10100100000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 49)\n  \"101001000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 50)\n  \"1010010000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 51)\n  \"10100100000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 52)\n  \"101001000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 53)\n  \"1010010000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 54)\n  \"10100100000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 55)\n  \"101001000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 56)\n  \"1010010000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 57)\n  \"10100100000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 58)\n  \"101001000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 59)\n  \"1010010000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 60)\n  \"10100100000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 61)\n  \"101001000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 62)\n  \"1010010000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 63)\n  \"10100100000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 64)\n  \"101001000000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 65)\n  \"1010010000000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 66)\n  \"10100100000000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 67)\n  \"101001000000000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 68)\n  \"1010010000000000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 69)\n  \"10100100000000000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 70)\n  \"101001000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 71)\n  \"1010010000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 72)\n  \"10100100000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 73)\n  \"101001000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 74)\n  \"1010010000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n  >>> reverseBits(0b1010, 75)\n", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function thta takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Task\n  Write a function thta takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charCodeAt(i);\n    if (char >= 65 && char <= 90) {\n      sum += char - 65;\n    } else if (char >= 97 && char <= 122) {\n      sum += char - 97;\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thta takes a string as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 13\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 13\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charCodeAt(i);\n    if (char >= 48 && char <= 57) {\n      sum += char - 48;\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thta takes a string as input and returns the sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 13\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 13\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charCodeAt(i);\n    if (char >= 97 && char <= 122) {\n      sum += char - 97;\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thta takes a string as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 13\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 13\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charCodeAt(i);\n    if (char >= 48 && char <= 57) {\n      sum += char - 48;\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thta takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 13\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 13\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charCodeAt(i);\n    if (char >= 65 && char <= 90) {\n      sum += char - 65;\n    } else if (char >= 97 && char <= 122) {\n      sum += char - 97;\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thta takes a string as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 13\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 13\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charCodeAt(i);\n    if (char >= 48 && char <= 57) {\n      sum += char - 48;\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thta takes a string as input and returns the sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 13\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 13\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charCodeAt(i);\n    if (char >= 97 && char <= 122) {\n      sum += char - 97;\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thta takes a string as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 13\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 13\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charCodeAt(i);\n    if (char >= 48 && char <= 57) {\n      sum += char - 48;\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thta takes a string as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 13\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 13\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charCodeAt(i);\n    if (char >= 65 && char <= 90) {\n      sum += char - 65;\n    } else if (char >= 97 && char <= 122) {\n      sum += char - 97;\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thta takes a string as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 13\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 13\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    const char = s.charCodeAt(i);\n    if (char >= 48 && char <= 57) {\n      sum += char - 48;\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thta takes a string as input and returns the sum of the digits only'", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are disrtibtued in a bakset of fruit this basket contains\n  apples, oranges, and amngo friuts. Given the string that rperesents the toatl number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in teh basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oragnes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples nad 1 oranges\",120) -> 102 - 100 - 1 = 19\n  */\ncosnt fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are disrtibtued in a bakset of fruit this basket contains\n  apples, oranges, and amngo friuts. Given the string that rperesents the toatl number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in teh basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oragnes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples nad 1 oranges\",120) -> 102 - 100 - 1 = 19\n  */\ncosnt fruitDistribution = (s, n) => {\n  let arr = s.split(\" \").map(Number);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are disrtibtued in a bakset of fruit this basket contains\n  apples, oranges, and amngo friuts. Given the string that rperesents the toatl number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in teh basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oragnes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples nad 1 oranges\",120) -> 102 - 100 - 1 = 19\n  */\ncosnt fruitDistribution = (s, n) => {\n  let arr = s.split(\" \").map(Number);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are disrtibtued in a bakset of fruit this basket contains\n  apples, oranges, and amngo friuts. Given the string that rperesents the toatl number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in teh basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oragnes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples nad 1 oranges\",120) -> 102 - 100 - 1 = 19\n  */\ncosnt fruitDistribution = (s, n) => {\n  let arr = s.split(\" \").map(Number);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are disrtibtued in a bakset of fruit this basket contains\n  apples, oranges, and amngo friuts. Given the string that rperesents the toatl number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in teh basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oragnes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples nad 1 oranges\",120) -> 102 - 100 - 1 = 19\n  */\ncosnt fruitDistribution = (s, n) => {\n  let arr = s.split(\" \").map(Number);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are disrtibtued in a bakset of fruit this basket contains\n  apples, oranges, and amngo friuts. Given the string that rperesents the toatl number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in teh basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oragnes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples nad 1 oranges\",120) -> 102 - 100 - 1 = 19\n  */\ncosnt fruitDistribution = (s, n) => {\n  let arr = s.split(\" \").map(Number);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are disrtibtued in a bakset of fruit this basket contains\n  apples, oranges, and amngo friuts. Given the string that rperesents the toatl number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in teh basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oragnes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples nad 1 oranges\",120) -> 102 - 100 - 1 = 19\n  */\ncosnt fruitDistribution = (s, n) => {\n  let arr = s.split(\" \").map(Number);\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum - n;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are disrtibtued in a bakset of fruit this basket contains\n  apples, oranges, and amngo friuts. Given the string that rperesents the toatl number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in teh basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oragnes\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples nad 1 oranges\",120) -> 102 - 100 - 1 = 19\n  */\ncosnt ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Givne an raray repersentnig a branch of a tree that has non-negative integre nodes\n  your task is to pluck one of the ondes and return it.\n  The plucked node hsould be the node wiht the smallest even vlaue.\n  fI mutlipel nodes with hte same smallest veen value are fonud return the node that has smallest index.\n\n  The plcuked node should eb returned in a list, [ smalset_value, its indxe ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  \"Givne an raray repersentnig a branch of a tree that has non-negative integre nodes\n  your task is to pluck one of the ondes and return it.\n  The plucked node hsould be the node wiht the smallest even vlaue.\n  fI mutlipel nodes with hte same smallest veen value are fonud return the node that has smallest index.\n\n  The plcuked node should eb returned in a list, [ smalset_value, its indxe ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  let minIndex = -1;\n  let minValue = arr[0];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (minValue === arr[i]) {\n        minIndex = i;\n      }\n      minValue = arr[i];\n    }\n  }\n  return [minValue, minIndex];\n};\n\n/*\n  Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n  If the tree has a cycle of length 3 or more, ie, if it is a connected tree, then you should return null.\n  For example:\n      Given binary tree [3,9,20,null,null,15,7],\n                  3\n      / \\\n     9  20\n    /   \\\n   15    7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n*/\nconst levelOrder = (root) => {\n  if (!root) {\n    return null;\n  }\n  const queue = [root];\n  const result = [];\n  while (queue.length > 0) {\n    const level = [];\n    for (let i = 0; i < queue.length; i++) {\n      const node = queue[i];\n      if (node) {\n        level.push(node.val);\n        queue.push(node.left);\n        queue.push(node.right);\n      }\n    }\n    result.push(level);\n  }\n  return result;\n};\n\n/*\n  Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n  If the tree has a cycle of length 3 or more, ie, if it is a connected tree, then you should return null.\n  For example:\n      Given binary tree [3,9,20,null,null,15,7],\n            3\n      / \\\n     9  20\n    /   \\\n   15    7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n*/\nconst levelOrder = (root) => {\n  if (!root) {\n    return null;\n  }\n  const queue = [root];\n  const result = [];\n  while (queue.length > 0) {\n    const level = [];\n    for (let i = 0; i < queue.length; i++) {\n      const node = queue[i];\n      if (node) {\n        level.push(node.val);\n        queue.push(node.left);\n        queue.push(node.right);\n      }\n    }\n    result.push(level);\n  }\n  return result;\n};\n\n/*\n  Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n  If the tree has a cycle of length 3 or more, ie, if it is a connected tree, then you should return null.\n  For example:\n      Given binary tree [3,9,20,null,null,15,7],\n      3\n      / \\\n     9  20\n    /   \\\n   15    7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n*/\nconst levelOrder = (root) => {\n  if (!root) {\n    return null;\n  }\n  const queue = [root];\n  const result = [];\n  while (queue.length > 0) {\n    const level = [];\n    for (let i = 0; i < queue.length; i++) {\n      const node = queue[i];\n      if (node) {\n        level.push(node.val);\n        queue.push(node.left);\n        queue.push(node.right);\n      }\n    }\n    result.push(level);\n  }\n  return result;\n};\n\n/*\n  Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n  If the tree has a cycle of length 3 or more, ie, if it is a connected tree, then you should return null.\n  For example:\n      Given binary tree [3,9,20,null,null,15,7],\n      3\n      / \\\n     9  20\n    /   \\\n   15    7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n*/\nconst levelOrder = (root) => {\n  if (!root) {\n    return null;\n  }\n  const queue = [root];\n  const result = [];\n  while (queue.length > 0) {\n    const level = [];\n    for (let i = 0; i < queue.length; i++) {\n      const node = queue[i];\n      if (node) {\n        level.push(node.val);\n        queue.push(node.left);\n        queue.push(node.right);\n      }\n    }\n    result.push(level);\n  }\n  return result;\n};\n\n/*\n  Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n  If the tree has a cycle of length 3 or more, ie, if it is a connected tree, then you should return null.\n  For example:\n      Given binary tree [3,9,20,null,null,15,7],\n      3\n      / \\\n     9  20\n    /   \\\n   15    7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n*/\nconst levelOrder = (root) => {\n  if (!root) {\n    return null;\n  }\n  const queue = [root];\n  const result = [];\n  while (queue.length > 0) {\n    const level = [];\n    for (let i = 0; i < queue.length; i++) {\n      const node = queue[i];\n      if (node) {\n        level.push(node.val);\n        queue.push(node.left);\n        queue.push(node.right);\n      }\n    }\n    result.push(level);\n  }\n  return result;\n};\n\n/*\n  Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n  If the tree has a cycle of length 3 or more, ie, if it is a connected tree, then you should return null.\n  For example:\n      Given binary tree [3,9,20,null,null,15,7],\n      3\n      / \\\n     9  20\n    /   \\\n   15    7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n*/\nconst levelOrder = (root) => {\n  if (!root) {\n    return null;\n  }\n  const queue = [root];\n  const result = [];\n  while (queue.length > 0) {\n    const level = [];\n    for (let i = 0; i < queue.length; i++) {\n      const node = queue[i];\n      if (node) {\n        level.push(node.val);\n        queue.push(node.left);\n        queue.push(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are gvien a non-mepty list of positive integers. Return the rgeaetst integer thta is gerater tahn\n  zero, and has a frequency gretaer than or qeual to the value of the integer itself.\n  The frequency of na integer is the number of times it appeasr in the list.\n  If no such a vlaue exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are gvien a non-mepty list of positive integers. Return the rgeaetst integer thta is gerater tahn\n  zero, and has a frequency gretaer than or qeual to the value of the integer itself.\n  The frequency of na integer is the number of times it appeasr in the list.\n  If no such a vlaue exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let index = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  You are given a list of positive integers. Return the index of the first occurrence of a\n  given number in the list, or -1 if there is no such number.\n  Examples:\n      indexOf([4, 1, 2, 2, 3, 1], 2) == 2\n      indexOf([4, 1, 2, 2, 3, 1], 5) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 0) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 3) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 4) == 0\n  */\nconst indexOf = (lst, num) => {\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == num) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/*\n  You are given a list of positive integers. Return the index of the last occurrence of a\n  given number in the list, or -1 if there is no such number.\n  Examples:\n      lastIndexOf([4, 1, 2, 2, 3, 1], 2) == 3\n      lastIndexOf([4, 1, 2, 2, 3, 1], 5) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 0) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 3) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 4) == 4\n  */\nconst lastIndexOf = (lst, num) => {\n  for (let i = lst.length - 1; i >= 0; i--) {\n    if (lst[i] == num) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/*\n  You are given a list of positive integers. Return the index of the first occurrence of a\n  given number in the list, or -1 if there is no such number.\n  Examples:\n      indexOf([4, 1, 2, 2, 3, 1], 2) == 2\n      indexOf([4, 1, 2, 2, 3, 1], 5) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 0) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 3) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 4) == 0\n  */\nconst indexOf = (lst, num) => {\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == num) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/*\n  You are given a list of positive integers. Return the index of the last occurrence of a\n  given number in the list, or -1 if there is no such number.\n  Examples:\n      lastIndexOf([4, 1, 2, 2, 3, 1], 2) == 3\n      lastIndexOf([4, 1, 2, 2, 3, 1], 5) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 0) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 3) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 4) == 4\n  */\nconst lastIndexOf = (lst, num) => {\n  for (let i = lst.length - 1; i >= 0; i--) {\n    if (lst[i] == num) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/*\n  You are given a list of positive integers. Return the index of the first occurrence of a\n  given number in the list, or -1 if there is no such number.\n  Examples:\n      indexOf([4, 1, 2, 2, 3, 1], 2) == 2\n      indexOf([4, 1, 2, 2, 3, 1], 5) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 0) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 3) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 4) == 0\n  */\nconst indexOf = (lst, num) => {\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == num) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/*\n  You are given a list of positive integers. Return the index of the last occurrence of a\n  given number in the list, or -1 if there is no such number.\n  Examples:\n      lastIndexOf([4, 1, 2, 2, 3, 1], 2) == 3\n      lastIndexOf([4, 1, 2, 2, 3, 1], 5) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 0) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 3) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 4) == 4\n  */\nconst lastIndexOf = (lst, num) => {\n  for (let i = lst.length - 1; i >= 0; i--) {\n    if (lst[i] == num) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/*\n  You are given a list of positive integers. Return the index of the first occurrence of a\n  given number in the list, or -1 if there is no such number.\n  Examples:\n      indexOf([4, 1, 2, 2, 3, 1], 2) == 2\n      indexOf([4, 1, 2, 2, 3, 1], 5) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 0) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 3) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 4) == 0\n  */\nconst indexOf = (lst, num) => {\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == num) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/*\n  You are given a list of positive integers. Return the index of the last occurrence of a\n  given number in the list, or -1 if there is no such number.\n  Examples:\n      lastIndexOf([4, 1, 2, 2, 3, 1], 2) == 3\n      lastIndexOf([4, 1, 2, 2, 3, 1], 5) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 0) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 3) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 4) == 4\n  */\nconst lastIndexOf = (lst, num) => {\n  for (let i = lst.length - 1; i >= 0; i--) {\n    if (lst[i] == num) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/*\n  You are given a list of positive integers. Return the index of the first occurrence of a\n  given number in the list, or -1 if there is no such number.\n  Examples:\n      indexOf([4, 1, 2, 2, 3, 1], 2) == 2\n      indexOf([4, 1, 2, 2, 3, 1], 5) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 0) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 3) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 4) == 0\n  */\nconst indexOf = (lst, num) => {\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == num) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/*\n  You are given a list of positive integers. Return the index of the last occurrence of a\n  given number in the list, or -1 if there is no such number.\n  Examples:\n      lastIndexOf([4, 1, 2, 2, 3, 1], 2) == 3\n      lastIndexOf([4, 1, 2, 2, 3, 1], 5) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 0) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 3) == -1\n      lastIndexOf([4, 1, 2, 2, 3, 1], 4) == 4\n  */\nconst lastIndexOf = (lst, num) => {\n  for (let i = lst.length - 1; i >= 0; i--) {\n    if (lst[i] == num) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/*\n  You are given a list of positive integers. Return the index of the first occurrence of a\n  given number in the list, or -1 if there is no such number.\n  Examples:\n      indexOf([4, 1, 2, 2, 3, 1], 2) == 2\n      indexOf([4, 1, 2, 2, 3, 1], 5) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 0) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 3) == -1\n      indexOf([4, 1, 2, 2, 3, 1], 4) == 0\n  */\nconst indexOf = (lst, num) => {\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == num) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/*\n  You are given a list of positive integers. Return the index of the last occurrence ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string => string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(string =>!string.includes(substring));\n  return filteredStrings;\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['bacd', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filtered", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => a - b);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in descending order.\n  Descending order is when you start with the maximum value,\n  then minimum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  descendingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  descendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  descendingSortList([]) == []\n  */\nconst descendingSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in ascending order.\n  Ascending order is when you start with the minimum value,\n  then maximum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  ascendingSortList([1, 2, 3, 4]) == [4, 1, 2, 3]\n  ascendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  ascendingSortList([]) == []\n  */\nconst ascendingSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => a - b);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in ascending order.\n  Ascending order is when you start with the minimum value,\n  then maximum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  ascendingSortList([1, 2, 3, 4]) == [4, 1, 2, 3]\n  ascendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  ascendingSortList([]) == []\n  */\nconst ascendingSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => a - b);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in descending order.\n  Descending order is when you start with the maximum value,\n  then minimum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  descendingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  descendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  descendingSortList([]) == []\n  */\nconst descendingSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in descending order.\n  Descending order is when you start with the maximum value,\n  then minimum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  descendingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  descendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  descendingSortList([]) == []\n  */\nconst descendingSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in descending order.\n  Descending order is when you start with the maximum value,\n  then minimum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  descendingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  descendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  descendingSortList([]) == []\n  */\nconst descendingSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in descending order.\n  Descending order is when you start with the maximum value,\n  then minimum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  descendingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  descendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  descendingSortList([]) == []\n  */\nconst descendingSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in descending order.\n  Descending order is when you start with the maximum value,\n  then minimum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  descendingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  descendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  descendingSortList([]) == []\n  */\nconst descendingSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in descending order.\n  Descending order is when you start with the maximum value,\n  then minimum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  descendingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  descendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  descendingSortList([]) == []\n  */\nconst descendingSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in descending order.\n  Descending order is when you start with the maximum value,\n  then minimum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  descendingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  descendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  descendingSortList([]) == []\n  */\nconst descendingSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in descending order.\n  Descending order is when you start with the maximum value,\n  then minimum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  descendingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  descendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  descendingSortList([]) == []\n  */\nconst descendingSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => b - a);\n  return sorted;\n};\n\n/*\n  Given list of integers, return list in descending order.\n  Descending order is when you start with the maximum value,\n  then minimum of the remainnig integers, tehn mniimum nad so on.\n\n  Examples:\n  descendingSortList([1, 2, 3, 4]) == [4, 3, 2, 1]\n  descendingSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  descendingSortList([]) == ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triagnle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valdi triangle.\n  Otehrwise return -1\n  Three sides make a valid tirangle wehn teh sum of nay two sides is rgeater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triagnle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valdi triangle.\n  Otehrwise return -1\n  Three sides make a valid tirangle wehn teh sum of nay two sides is rgeater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a < b + c || b < a + c || c < a + b) return -1;\n  return Math.sqrt(a * a + b * b + c * c);\n};\n\n/*\n  Given the lengths of the three sides of a triagnle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valdi triangle.\n  Otehrwise return -1\n  Three sides make a valid tirangle wehn teh sum of nay two sides is rgeater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea2 = (a, b, c) => {\n  if (a < b + c || b < a + c || c < a + b) return -1;\n  return Math.sqrt(a * a + b * b + c * c) * 0.5;\n};\n\n/*\n  Given the lengths of the three sides of a triagnle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valdi triangle.\n  Otehrwise return -1\n  Three sides make a valid tirangle wehn teh sum of nay two sides is rgeater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea3 = (a, b, c) => {\n  if (a < b + c || b < a + c || c < a + b) return -1;\n  return Math.sqrt(a * a + b * b + c * c) * 0.5;\n};\n\n/*\n  Given the lengths of the three sides of a triagnle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valdi triangle.\n  Otehrwise return -1\n  Three sides make a valid tirangle wehn teh sum of nay two sides is rgeater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea4 = (a, b, c) => {\n  if (a < b + c || b < a + c || c < a + b) return -1;\n  return Math.sqrt(a * a + b * b + c * c) * 0.5;\n};\n\n/*\n  Given the lengths of the three sides of a triagnle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valdi triangle.\n  Otehrwise return -1\n  Three sides make a valid tirangle wehn teh sum of nay two sides is rgeater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea5 = (a, b, c) => {\n  if (a < b + c || b < a + c || c < a + b) return -1;\n  return Math.sqrt(a * a + b * b + c * c) * 0.5;\n};\n\n/*\n  Given the lengths of the three sides of a triagnle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valdi triangle.\n  Otehrwise return -1\n  Three sides make a valid tirangle wehn teh sum of nay two sides is rgeater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea6 = (a, b, c) => {\n  if (a < b + c || b < a + c || c < a + b) return -1;\n  return Math.sqrt(a * a + b * b + c * c) * 0.5;\n};\n\n/*\n  Given the lengths of the three sides of a triagnle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valdi triangle.\n  Otehrwise return -1\n  Three sides make a valid tirangle wehn teh sum of nay two sides is rgeater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea7 = (a, b, c) => {\n  if (a < b + c || b < a + c || c < a + b) return -1;\n  return Math.sqrt(a * a + b * b + c * c) * 0.5;\n};\n\n/*\n  Given the lengths of the three sides of a triagnle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valdi triangle.\n  Otehrwise return -1\n  Three sides make a valid tirangle wehn teh sum of nay two sides is rgeater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea8 = (a, b, c) => {\n  if (a < b + c || b < a + c || c < a + b) return -1;\n  return Math.sqrt(a * a + b * b + c * c) * 0.5;\n};\n\n/*\n  Given the lengths of the three sides of a triagnle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valdi triangle.\n  Otehrwise return -1\n  Three sides make a valid tirangle wehn teh sum of nay two sides is rgeater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea9 = (a, b, c) => {\n  if (a < b + c || b < a + c || c < a + b) return -1;\n  return Math.sqrt(a * a + b * b + c * c) * 0.5;\n};\n\n/*\n  Given the lengths of the three sides of a triagnle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valdi triangle.\n  Otehrwise return -1\n  Three sides make a valid tirangle wehn teh sum of nay two sides is rgeater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea10 = (a, b, c) => {\n  if (a < b + c || b < a + c || c < a + b) return -1;\n  return Math.sqrt(a * a + b * b + c * c) * 0.5;\n};\n\n/*\n  Given the lengths of the three sides of a triagnle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valdi triangle.\n  Otehrwise return -1\n  Three sides make a valid tirangle wehn teh sum of nay two sides is rgeater\n  than the third side", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a funtcion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less thna or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a funtcion that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less thna or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight;\n};\n\nconst willItFly2 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el) => el === q[q.length - 1 - el]);\n};\n\nconst willItFly3 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly4 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly5 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly6 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly7 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly8 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly9 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly10 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly11 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly12 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly13 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly14 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly15 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly16 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly17 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly18 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly19 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly20 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly21 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly22 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly23 = (q, w) => {\n  const maxWeight = w;\n  const maxSum = q.reduce((acc, curr) => acc + curr, 0);\n  return maxSum < maxWeight && q.every((el, i) => el === q[q.length - 1 - i]);\n};\n\nconst willItFly24 = (q, w) => {\n  const maxWeight = w;\n  const maxSum", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find teh minimum number of eleemnts ttha\n  need to be chnaged to make the array palindrmoic. A palindromic array is an array that\n  is read the same backwdars and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array arr of integers, find teh minimum number of eleemnts ttha\n  need to be chnaged to make the array palindrmoic. A palindromic array is an array that\n  is read the same backwdars and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  const len = arr.length;\n  if (len < 2) return 0;\n  const max = (len - 1) / 2;\n  let min = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > arr[max]) max = i;\n    if (arr[i] < arr[min]) min = i;\n  }\n  return min - max;\n};\n\n/*\n  Given an array arr of integers, find teh maximum number ttha need to be chnaged to make the array palindrmoic. A palindromic array is an array that\n  is read the same backwdars and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 6\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst largestChange = (arr) => {\n  const len = arr.length;\n  if (len < 2) return 0;\n  const max = (len - 1) / 2;\n  let min = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > arr[max]) max = i;\n    if (arr[i] < arr[min]) min = i;\n  }\n  return max - min;\n};\n\n/*\n  Given an array arr of integers, find teh maximum number ttha need to be chnaged to make the array palindrmoic. A palindromic array is an array that\n  is read the same backwdars and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 6\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst largestChange = (arr) => {\n  const len = arr.length;\n  if (len < 2) return 0;\n  const max = (len - 1) / 2;\n  let min = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > arr[max]) max = i;\n    if (arr[i] < arr[min]) min = i;\n  }\n  return max - min;\n};\n\n/*\n  Given an array arr of integers, find teh minimum number ttha need to be chnaged to make the array palindrmoic. A palindromic array is an array that\n  is read the same backwdars and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 6\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst largestChange = (arr) => {\n  const len = arr.length;\n  if (len < 2) return 0;\n  const max = (len - 1) / 2;\n  let min = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > arr[max]) max = i;\n    if (arr[i] < arr[min]) min = i;\n  }\n  return max - min;\n};\n\n/*\n  Given an array arr of integers, find teh minimum number ttha need to be chnaged to make the array palindrmoic. A palindromic array is an array that\n  is read the same backwdars and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 6\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst largestChange = (arr) => {\n  const len = arr.length;\n  if (len < 2) return 0;\n  const max = (len - 1) / 2;\n  let min = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > arr[max]) max = i;\n    if (arr[i] < arr[min]) min = i;\n  }\n  return max - min;\n};\n\n/*\n  Given an array arr of integers, find teh minimum number ttha need to be chnaged to make the array palindrmoic. A palindromic array is an array that\n  is read the same backwdars and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 6\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst largestChange = (arr) => {\n  const len = arr.length;\n  if (len < 2) return 0;\n  const max = (len - 1) / 2;\n  let min = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > arr[max]) max = i;\n    if (arr[i] < arr[min]) min = i;\n  }\n  return max - min;\n};\n\n/*\n  Given an array arr of integers, find teh minimum number ttha need to be chnaged to make the array palindrmoic. A palindromic array is an array that\n  is read the same backwdars and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 6\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst largestChange = (arr) => {\n  const len = arr.length;\n  if (len < 2) return 0;\n  const max = (len - 1) / 2;\n  let min = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > arr[max]) max = i;\n    if (arr[i] < arr[min]) min = i;\n  }\n  return max - min;\n};\n\n/*\n  Given an array arr of integers, find teh minimum number ttha need to be chnaged to make the array palindrmoic. A palindromic array is an array that\n  is read the same backwdars and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 6\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst largestChange = (arr) => {\n  const len = arr.length;\n  if (len < 2) return 0;\n  const max = (len - 1) / 2;\n  let min = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > arr[max]) max = i;\n    if (arr[i] < arr[min]) min = i;\n  }\n  return max - min;\n};\n\n/*\n  Given an array arr of integers, find teh minimum number ttha need to be chnaged to make the array palindrmoic. A palindromic array is an array that\n  is read the same backwdars and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 6\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst largestChange = (arr) => {\n  const len = arr.length;\n  if (len < 2) return 0;\n  const max = (len - 1) / 2;\n  let min = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] > arr[max]) max = i;\n    if (arr[i] < arr[min]) min = i;\n  }\n  return max - min;\n};\n\n/*\n  Given an array arr of integers, find teh minimum number ttha need to be chnaged to make the array palindr", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns teh list htat has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the tow lists have the same unmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns teh list htat has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the tow lists have the same unmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1\n  }\n  const result = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i].length < lst2[i].length) {\n      result.push(lst1[i])\n    } else {\n      result.push(lst2[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns teh list htat has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the tow lists have the same unmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1\n  }\n  const result = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i].length < lst2[i].length) {\n      result.push(lst1[i])\n    } else {\n      result.push(lst2[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns teh list htat has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the tow lists have the same unmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1\n  }\n  const result = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i].length < lst2[i].length) {\n      result.push(lst1[i])\n    } else {\n      result.push(lst2[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns teh list htat has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the tow lists have the same unmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1\n  }\n  const result = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i].length < lst2[i].length) {\n      result.push(lst1[i])\n    } else {\n      result.push(lst2[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns teh list htat has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the tow lists have the same unmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1\n  }\n  const result = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i].length < lst2[i].length) {\n      result.push(lst1[i])\n    } else {\n      result.push(lst2[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns teh list htat has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the tow lists have the same unmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) {\n    return lst1\n  }\n  const result = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i].length < lst2[i].length) {\n      result.push(lst1[i])\n    } else {\n      result.push(lst2[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns teh list htat has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the tow lists have the same unmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a functoin that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a functoin that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a prime number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPrime = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isPerfect(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isPerfect = (a) => {\n  for (let i = 2; i <= a; i++) {\n    if (a % i === 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Write a function that returns true if the given number is a perfect number or false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  is", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and flase in other cases.\n  x is a simple power fo n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Your task is to write a function that returns true if a number x is a simple\n  power of n and flase in other cases.\n  x is a simple power fo n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return false;\n  if (x === 1) return true;\n  if (x === 2) return true;\n  if (x === 3) return true;\n  if (x === 4) return true;\n  if (x === 5) return true;\n  if (x === 6) return true;\n  if (x === 7) return true;\n  if (x === 8) return true;\n  if (x === 9) return true;\n  if (x === 10) return true;\n  if (x === 11) return true;\n  if (x === 12) return true;\n  if (x === 13) return true;\n  if (x === 14) return true;\n  if (x === 15) return true;\n  if (x === 16) return true;\n  if (x === 17) return true;\n  if (x === 18) return true;\n  if (x === 19) return true;\n  if (x === 20) return true;\n  if (x === 21) return true;\n  if (x === 22) return true;\n  if (x === 23) return true;\n  if (x === 24) return true;\n  if (x === 25) return true;\n  if (x === 26) return true;\n  if (x === 27) return true;\n  if (x === 28) return true;\n  if (x === 29) return true;\n  if (x === 30) return true;\n  if (x === 31) return true;\n  if (x === 32) return true;\n  if (x === 33) return true;\n  if (x === 34) return true;\n  if (x === 35) return true;\n  if (x === 36) return true;\n  if (x === 37) return true;\n  if (x === 38) return true;\n  if (x === 39) return true;\n  if (x === 40) return true;\n  if (x === 41) return true;\n  if (x === 42) return true;\n  if (x === 43) return true;\n  if (x === 44) return true;\n  if (x === 45) return true;\n  if (x === 46) return true;\n  if (x === 47) return true;\n  if (x === 48) return true;\n  if (x === 49) return true;\n  if (x === 50) return true;\n  if (x === 51) return true;\n  if (x === 52) return true;\n  if (x === 53) return true;\n  if (x === 54) return true;\n  if (x === 55) return true;\n  if (x === 56) return true;\n  if (x === 57) return true;\n  if (x === 58) return true;\n  if (x === 59) return true;\n  if (x === 60) return true;\n  if (x === 61) return true;\n  if (x === 62) return true;\n  if (x === 63) return true;\n  if (x === 64) return true;\n  if (x === 65) return true;\n  if (x === 66) return true;\n  if (x === 67) return true;\n  if (x === 68) return true;\n  if (x === 69) return true;\n  if (x === 70) return true;\n  if (x === 71) return true;\n  if (x === 72) return true;\n  if (x === 73) return true;\n  if (x === 74) return true;\n  if (x === 75) return true;\n  if (x === 76) return true;\n  if (x === 77) return true;\n  if (x === 78) return true;\n  if (x === 79) return true;\n  if (x === 80) return true;\n  if (x === 81) return true;\n  if (x === 82) return true;\n  if (x === 83) return true;\n  if (x === 84) return true;\n  if (x === 85) return true;\n  if (x === 86) return true;\n  if (x === 87) return true;\n  if (x === 88) return true;\n  if (x === 89) return true;\n  if (x === 90) return true;\n  if (x === 91) return true;\n  if (x === 92) return true;\n  if (x === 93) return true;\n  if (x === 94) return true;\n  if (x === 95) return true;\n  if (x === 96) return true;\n  if (x === 97) return true;\n  if (x === 98) return true;\n  if (x === 99) return true;\n  if (x === 100) return true;\n  if (x === 101) return true;\n  if (x === 102) return true;\n  if (x === 103) return true;\n  if (x === 104) return true;\n  if (x === 105) return true;\n  if (x === 106) return true;\n  if (x === 107) return true;\n  if (x === 108) return true;\n  if (x === 109) return true;\n  if (x === 110) return true;\n  if (x === 111) return true;\n  if (x === 112) return true;\n  if (x === 113) return true;\n  if (x === 114) return true;\n  if (x === 115) return true;\n  if (x === 116) return true;\n  if (x === 117) return true;\n  if (x === 118) return true;\n  if (x === 119) return true;\n  if (x === 120) return true;\n  if (x === 121) return true;\n  if (x === 122) return true;\n  if (x === 123) return true;\n  if (x === 124) return true;\n  if (x === 125) return true;\n  if (x === 126) return true;\n  if (x === 127) return true;\n  if (x === 128) return true;\n  if (x === 129) return true;\n  if (x === 130) return true;\n  if (x === 131) return true;\n  if (x === 132) return true;\n  if (x === 133) return true;\n  if (x === 134) return true;\n  if (x === 135) return true;\n  if (x === 136) return true;\n  if (x === 137) return true;\n  if (x === 138) return true;\n  if (x === 139) return true;\n  if (x === 140) return true;\n  if (x === 141) return true;\n  if (x === 142) return true;\n  if (x === 143) return true;\n  if (x === 144) return true;\n  if (x === 145) return true;\n  if (x === 146) return true;\n  if (x === 147) return true;\n  if (x === 148) return true;\n  if (x === 149) return true;\n  if (x === 150) return true;\n  if (x === 151) return true;\n  if (x === 152) return true;\n  if (x === 153) return true;\n  if (x === 154) return true;\n  if (x === 155) return true;\n  if (x === 156) return true;\n  if (x === 157) return true;\n  if (x === 158) return true;\n  if (x === 159) return true;\n  if (x === 160) return true;\n  if (x === 161) return true;\n  if (x === 162) return true;\n  if (x === 163) return true;\n  if (x === 164) return true;\n  if (x === 165) return true;\n  if (x === 166) return true;\n  if (x === 167) return true;\n  if (x === 168) return true;\n  if (x === 169) return true;\n  if (x === 170) return true;\n  if (x === 171) return true;\n  if (x === 172) return true;\n  if (x === 173) return true;\n  if (x === 174) return true;\n  if (x === 175) return true;\n  if (x === 176) return true;\n  if (x === 177) return true;\n  if (x === 178) return true;\n  if (x === 179) return true;\n  if (x === 180) return true;\n  if (x === 181) return true;\n  if (x === 182) return true;\n  if (x === 183) return true;\n  if (x === 184) return true;\n  if (x === 185) return true;\n  if (x === 186) return true;\n  if (x === 187) return true;\n  if (x === 188) return true;\n  if (x === 189) return true;\n  if (x === 190) return true;\n  if (x === 191) return true;\n  if (x === 192) return true;\n  if (x === 193) return true;\n  if (x === 194) return true;\n  if (x === 195) return true;\n  if (x === 196) return true;\n  if (x === 197) return true;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an inetger a and rteurns true\n  if tihs ingeger is a cube of some integer numebr.\n  Note: yuo may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes an inetger a and rteurns true\n  if tihs ingeger is a cube of some integer numebr.\n  Note: yuo may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0 || a === 1 || a === 2 || a === 3 || a === 4 || a === 5 || a === 6 || a === 7 || a === 8 || a === 9 || a === 10) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write a function that takes an inetger a and rteurns true\n  if tihs ingeger is a cube of some integer numebr.\n  Note: yuo may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0 || a === 1 || a === 2 || a === 3 || a === 4 || a === 5 || a === 6 || a === 7 || a === 8 || a === 9 || a === 10) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write a function that takes an inetger a and rteurns true\n  if tihs ingeger is a cube of some integer numebr.\n  Note: yuo may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0 || a === 1 || a === 2 || a === 3 || a === 4 || a === 5 || a === 6 || a === 7 || a === 8 || a === 9 || a === 10) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write a function that takes an inetger a and rteurns true\n  if tihs ingeger is a cube of some integer numebr.\n  Note: yuo may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0 || a === 1 || a === 2 || a === 3 || a === 4 || a === 5 || a === 6 || a === 7 || a === 8 || a === 9 || a === 10) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write a function that takes an inetger a and rteurns true\n  if tihs ingeger is a cube of some integer numebr.\n  Note: yuo may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0 || a === 1 || a === 2 || a === 3 || a === 4 || a === 5 || a === 6 || a === 7 || a === 8 || a === 9 || a === 10) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write a function that takes an inetger a and rteurns true\n  if tihs ingeger is a cube of some integer numebr.\n  Note: yuo may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0 || a === 1 || a === 2 || a === 3 || a === 4 || a === 5 || a === 6 || a === 7 || a === 8 || a === 9 || a === 10) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write a function that takes an inetger a and rteurns true\n  if tihs ingeger is a cube of some integer numebr.\n  Note: yuo may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0 || a === 1 || a === 2 || a === 3 || a === 4 || a === 5 || a === 6 || a === 7 || a === 8 || a === 9 || a === 10) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write a function that takes an inetger a and rteurns true\n  if tihs ingeger is a cube of some integer numebr.\n  Note: yuo may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0 || a === 1 || a === 2 || a === 3 || a === 4 || a === 5 || a === 6 || a === 7 || a === 8 || a === 9 || a === 10) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write a function that takes an inetger a and rteurns true\n  if tihs ingeger is a cube of some integer numebr.\n  Note: yuo may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0 || a === 1 || a === 2 || a === 3 || a === 4 || a === 5 || a === 6 || a === 7 || a === 8 || a === 9 || a === 10) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write a function that takes an inetger a and rteurns true\n  if tihs ingeger is a cube of some integer numebr.\n  Note: yuo may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to wriet a function that receives\n  a hexadeciaml number as a stirng and counts hte number of hexadecimal\n  idgist that are primes (prime nubmer=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Heaxdeimcal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the folloiwng digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume hte input is always correct ro empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You have been tasked to wriet a function that receives\n  a hexadeciaml number as a stirng and counts hte number of hexadecimal\n  idgist that are primes (prime nubmer=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Heaxdeimcal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the folloiwng digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume hte input is always correct ro empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let hexNum = num;\n  let hexNumArray = hexNum.split(\"\");\n  let hexNumArrayLength = hexNumArray.length;\n  let hexNumArray2 = [];\n  let hexNumArray2Length = 0;\n  let hexNumArray3 = [];\n  let hexNumArray3Length = 0;\n  let hexNumArray4 = [];\n  let hexNumArray4Length = 0;\n  let hexNumArray5 = [];\n  let hexNumArray5Length = 0;\n  let hexNumArray6 = [];\n  let hexNumArray6Length = 0;\n  let hexNumArray7 = [];\n  let hexNumArray7Length = 0;\n  let hexNumArray8 = [];\n  let hexNumArray8Length = 0;\n  let hexNumArray9 = [];\n  let hexNumArray9Length = 0;\n  let hexNumArrayA = [];\n  let hexNumArrayALength = 0;\n  let hexNumArrayB = [];\n  let hexNumArrayBLength = 0;\n  let hexNumArrayC = [];\n  let hexNumArrayCLength = 0;\n  let hexNumArrayD = [];\n  let hexNumArrayDLength = 0;\n  let hexNumArrayE = [];\n  let hexNumArrayELength = 0;\n  let hexNumArrayF = [];\n  let hexNumArrayFLength = 0;\n  let hexNumArrayG = [];\n  let hexNumArrayGLength = 0;\n  let hexNumArrayH = [];\n  let hexNumArrayHLength = 0;\n  let hexNumArrayI = [];\n  let hexNumArrayILength = 0;\n  let hexNumArrayJ = [];\n  let hexNumArrayJLength = 0;\n  let hexNumArrayK = [];\n  let hexNumArrayKLength = 0;\n  let hexNumArrayL = [];\n  let hexNumArrayLLength = 0;\n  let hexNumArrayM = [];\n  let hexNumArrayMLength = 0;\n  let hexNumArrayN = [];\n  let hexNumArrayNLength = 0;\n  let hexNumArrayO = [];\n  let hexNumArrayOLength = 0;\n  let hexNumArrayP = [];\n  let hexNumArrayPLength = 0;\n  let hexNumArrayQ = [];\n  let hexNumArrayQLength = 0;\n  let hexNumArrayR = [];\n  let hexNumArrayRLength = 0;\n  let hexNumArrayS = [];\n  let hexNumArraySLength = 0;\n  let hexNumArrayT = [];\n  let hexNumArrayTLength = 0;\n  let hexNumArrayU = [];\n  let hexNumArrayULength = 0;\n  let hexNumArrayV = [];\n  let hexNumArrayVLength = 0;\n  let hexNumArrayW = [];\n  let hexNumArrayWLength = 0;\n  let hexNumArrayX = [];\n  let hexNumArrayXLength = 0;\n  let hexNumArrayY = [];\n  let hexNumArrayYLength = 0;\n  let hexNumArrayZ = [];\n  let hexNumArrayZLength = 0;\n  let hexNumArrayA2 = [];\n  let hexNumArrayA2Length = 0;\n  let hexNumArrayB2 = [];\n  let hexNumArrayB2Length = 0;\n  let hexNumArrayC2 = [];\n  let hexNumArrayC2Length = 0;\n  let hexNumArrayD2 = [];\n  let hexNumArrayD2Length = 0;\n  let hexNumArrayE2 = [];\n  let hexNumArrayE2Length = 0;\n  let hexNumArrayF2 = [];\n  let hexNumArrayF2Length = 0;\n  let hexNumArrayG2 = [];\n  let hexNumArrayG2Length = 0;\n  let hexNumArrayH2 = [];\n  let hexNumArrayH2Length = 0;\n  let hexNumArrayI2 = [];\n  let hexNumArrayI2Length = 0;\n  let hexNumArrayJ2 = [];\n  let hexNumArrayJ2Length = 0;\n  let hexNumArrayK2 = [];\n  let hexNumArrayK2Length = 0;\n  let hexNumArrayL2 = [];\n  let hexNumArrayL2Length = 0;\n  let hexNumArrayM2 = [];\n  let hexNumArrayM2Length = 0;\n  let hexNumArrayN2 = [];\n  let hexNumArrayN2Length = 0;\n  let hexNumArrayO2 = [];\n  let hexNumArrayO2Length = 0;\n  let hexNumArrayP2 = [];\n  let hexNumArrayP2Length = 0;\n  let hexNumArrayQ2 = [];\n  let hexNumArrayQ2Length = 0;\n  let hexNumArrayR2 = [];\n  let hexNumArrayR2Length = 0;\n  let hexNumArrayS2 = [];\n  let hexNumArrayS2Length = 0;\n  let hexNumArrayT2 = [];\n  let hexNumArrayT2Length = 0;\n  let hexNumArrayU2 = [];\n  let hexNumArrayU2Length = 0;\n  let hexNumArrayV2 = [];\n  let hexNumArrayV2Length = 0;\n  let hexNumArrayW2 = [];\n  let hexNumArrayW2Length = 0;\n  let hexNumArrayX2 = [];\n  let hexNumArrayX2Length = 0;\n  let hexNumArrayY2 = [];\n  let hexNumArrayY2Length = 0;\n  let hexNumArrayZ2 = [];\n  let hexNumArrayZ2Length = 0;\n  let hexNumArrayA3 = [];\n  let hexNumArrayA3Length = 0;\n  let hexNumArrayB3 = [];\n  let hexNumArrayB3Length = 0;\n  let hexNumArrayC3 = [];\n  let hexNumArrayC3Length = 0;\n  let hexNumArrayD3 = [];\n  let hexNumArrayD3Length = 0;\n  let hexNumArrayE3 = [];\n  let hexNumArrayE3Length = 0;\n  let hexNumArrayF3 = [];\n  let hexNumArrayF3Length = 0;\n  let hexNumArrayG3 = [];\n  let hexNumArrayG3Length = 0;\n  let hexNumArrayH3 = [];\n  let hexNumArrayH3Length = 0;\n  let hexNumArrayI3 = [];\n  let hexNumArrayI3Length = 0;\n  let hexNumArrayJ3 = [];\n  let hexNumArrayJ3Length = 0;\n  let hexNumArrayK3 = [];\n  let hexNumArrayK3Length = 0;\n  let hexNumArrayL3 = [];\n  let hexNumArrayL3Length = 0;\n  let hexNumArrayM3 = [];\n  let hexNumArrayM3Length = 0;\n  let hexNumArrayN3 = [];\n  let hexNumArrayN3Length = 0;\n  let hexNumArrayO3 = [];\n  let hexNumArrayO3Length = 0;\n  let hexNumArrayP3 = [];\n  let hexNumArrayP3Length = 0;\n  let hexNumArrayQ3 = [];\n  let hexNumArrayQ3Length = 0;\n  let hexNumArrayR3 = [];\n  let hexNumArrayR", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a tsrign, wiht each characetr erpersenting a binary\n  number. Each character in the strign will be '0' or '1'.\n\n  There will eb an extra couple of characters 'db' at the beginning and at the end of the stirng.\n  The extra characters are there to ehlp with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a tsrign, wiht each characetr erpersenting a binary\n  number. Each character in the strign will be '0' or '1'.\n\n  There will eb an extra couple of characters 'db' at the beginning and at the end of the stirng.\n  The extra characters are there to ehlp with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let remainder = decimal;\n  while (decimal!== 0) {\n    remainder = Math.floor(remainder * 2);\n    binary += remainder % 2? '1' : '0';\n    decimal = Math.floor(decimal / 2);\n  }\n  return binary + 'db' + binary + 'db';\n};\n\n/*\n  Write a function that will convert a binary number to a decimal number. The binary number will\n  be given as a string. The function should return a number, wiht each character representing a decimal\n  number.\n\n  Examples:\n  binaryToDecimal(\"1111\") # returns 15\n  binaryToDecimal(\"10000\") # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    decimal += parseInt(binary[i]) * (Math.pow(2, binary.length - i - 1));\n  }\n  return decimal;\n};\n\n/*\n  Write a function that will convert a decimal number to a binary number. The decimal number will\n  be given as a number. The function should return a string, wiht each character representing a binary\n  number.\n\n  Examples:\n  decimalToBinary(15) # returns \"1111\"\n  decimalToBinary(32) # returns \"10000\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  while (decimal!== 0) {\n    binary = binary + (decimal % 2? '1' : '0');\n    decimal = Math.floor(decimal / 2);\n  }\n  return binary;\n};\n\n/*\n  Write a function that will convert a binary number to a hexadecimal number. The binary number will\n  be given as a string. The function should return a string, wiht each character representing a hexadecimal\n  number.\n\n  Examples:\n  binaryToHexadecimal(\"1111\") # returns \"41\"\n  binaryToHexadecimal(\"10000\") # returns \"100\"\n  */\nconst binaryToHexadecimal = (binary) => {\n  let hexadecimal = '';\n  for (let i = 0; i < binary.length; i++) {\n    hexadecimal += binary[i].toString(16);\n  }\n  return hexadecimal;\n};\n\n/*\n  Write a function that will convert a hexadecimal number to a binary number. The hexadecimal number will\n  be given as a string. The function should return a string, wiht each character representing a binary\n  number.\n\n  Examples:\n  hexadecimalToBinary(\"41\") # returns \"1111\"\n  hexadecimalToBinary(\"100\") # returns \"10000\"\n  */\nconst hexadecimalToBinary = (hexadecimal) => {\n  let binary = '';\n  for (let i = 0; i < hexadecimal.length; i++) {\n    binary += parseInt(hexadecimal[i], 16).toString(2);\n  }\n  return binary;\n};\n\n/*\n  Write a function that will convert a binary number to a hexadecimal number. The binary number will\n  be given as a number. The function should return a string, wiht each character representing a hexadecimal\n  number.\n\n  Examples:\n  binaryToHexadecimal(15) # returns \"1111\"\n  binaryToHexadecimal(32) # returns \"10000\"\n  */\nconst binaryToHexadecimal = (binary) => {\n  let hexadecimal = '';\n  while (binary!== 0) {\n    hexadecimal += parseInt(binary, 2).toString(16);\n    binary = parseInt(binary, 2).toString(2);\n  }\n  return hexadecimal;\n};\n\n/*\n  Write a function that will convert a hexadecimal number to a binary number. The hexadecimal number will\n  be given as a number. The function should return a string, wiht each character representing a binary\n  number.\n\n  Examples:\n  hexadecimalToBinary(15) # returns \"1111\"\n  hexadecimalToBinary(32) # returns \"10000\"\n  */\nconst hexadecimalToBinary = (hexadecimal) => {\n  let binary = '';\n  while (hexadecimal!== 0) {\n    binary += parseInt(hexadecimal, 16).toString(2);\n    hexadecimal = parseInt(hexadecimal, 16).toString(16);\n  }\n  return binary;\n};\n\n/*\n  Write a function that will convert a binary number to a hexadecimal number. The binary number will\n  be given as a string. The function should return a string, wiht each character representing a hexadecimal\n  number.\n\n  Examples:\n  binaryToHexadecimal(\"1111\") # returns \"41\"\n  binaryToHexadecimal(\"10000\") # returns \"100\"\n  */\nconst binaryToHexadecimal = (binary) => {\n  let hexadecimal = '';\n  for (let i = 0; i < binary.length; i++) {\n    hexadecimal += binary[i].toString(16);\n  }\n  return hexadecimal;\n};\n\n/*\n  Write a function that will convert a hexadecimal number to a binary number. The hexadecimal number will\n  be given as a string. The function should return a string, wiht each character representing a binary\n  number.\n\n  Examples:\n  hexadecimalToBinary(\"41\") # returns \"1111\"\n  hexadecimalToBinary(\"100\") # returns \"10000\"\n  */\nconst hexadecimalToBinary = (hexadecimal) => {\n  let binary = '';\n  for (let i = 0; i < hexadecimal.length; i++) {\n    binary += parseInt(hexadecimal[i], 16).toString(2);\n  }\n  return binary;\n};\n\n/*\n  Write a function that will convert a binary number to a hexadecimal number. The binary number will\n  be given as a number. The function should return a string, wiht each character representing a hexadecimal\n  number.\n\n  Examples:\n  binaryToHexadecimal(15) # returns \"1111\"\n  binaryToHexadecimal(32) # returns \"10000\"\n  */\nconst binaryToHexadecimal = (binary) => {\n  let hexadecimal = '';\n  while (binary!== 0) {\n    hexadecimal += parseInt(binary, 2).toString(16);\n    binary = parseInt(binary, 2).toString(2);\n  }\n  return hexadecimal;\n};\n\n/*\n  Write a function that will convert a hexadecimal number to a binary number. The hexadecimal number will\n  be given as a number. The function should return a string, wiht each character representing a binary\n  number.\n\n  Examples:\n  hexadecimalToBinary(15) # returns \"1111\"\n  hexadecimalToBinary(32) # returns \"10000\"\n  */\nconst hexadecimalToBinary = (hexadecimal) => {\n  let binary = '';\n  while (hexadecimal!== 0) {\n    binary += parseInt(hexadecimal, 16).toString(2);\n    hexadecimal = parseInt(hexadecimal, 16).toString(16);\n  }\n  return binary;\n};\n\n/*\n  Write a function that will convert a binary number to a hexadecimal number. The binary number will\n  be given as a string. The function should return a string, wiht each character representing a hexadecimal\n  number.\n\n  Examples:\n  binaryToHexadecimal(\"1111\") # returns \"41\"\n  binaryToHexadecimal(\"10000\") # returns \"100\"\n  */\nconst binaryToHexadecimal = (binary) => {\n  let hexadecimal = '';\n  for (let i = 0; i < bin", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/8", "prompt": "/* oFr a given list of integers, return a tuple consisting of a sum adn a produtc of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be qeual to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* oFr a given list of integers, return a tuple consisting of a sum adn a produtc of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be qeual to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  if (numbers.length === 0) {\n    return [0, 0];\n  }\n  const [sum, product] = numbers.reduce((acc, curr) => {\n    acc[0] += curr;\n    acc[1] *= curr;\n    return acc;\n  }, [0, 0]);\n  return [sum, product];\n};\n\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// =====================================================================================================================\n// ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/80", "prompt": "/*You aer given a strign s.\n  Your taks is to cehck if the string is happy or not.\n  A srting is happy if its length is at least 3 and every 3 consecutive letters are dsitintc\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You aer given a strign s.\n  Your taks is to cehck if the string is happy or not.\n  A srting is happy if its length is at least 3 and every 3 consecutive letters are dsitintc\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  for (let i = 0; i < s.length; i = i + 3) {\n    if (s.charAt(i)!== s.charAt(i + 1) || s.charAt(i + 2)!== s.charAt(i + 3)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*You aer given a strign s.\n  Your taks is to cehck if the string is happy or not.\n  A srting is happy if its length is at least 3 and every 3 consecutive letters are dsitintc\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  for (let i = 0; i < s.length; i = i + 3) {\n    if (s.charAt(i)!== s.charAt(i + 1) || s.charAt(i + 2)!== s.charAt(i + 3)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*You aer given a strign s.\n  Your taks is to cehck if the string is happy or not.\n  A srting is happy if its length is at least 3 and every 3 consecutive letters are dsitintc\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  for (let i = 0; i < s.length; i = i + 3) {\n    if (s.charAt(i)!== s.charAt(i + 1) || s.charAt(i + 2)!== s.charAt(i + 3)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*You aer given a strign s.\n  Your taks is to cehck if the string is happy or not.\n  A srting is happy if its length is at least 3 and every 3 consecutive letters are dsitintc\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  for (let i = 0; i < s.length; i = i + 3) {\n    if (s.charAt(i)!== s.charAt(i + 1) || s.charAt(i + 2)!== s.charAt(i + 3)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*You aer given a strign s.\n  Your taks is to cehck if the string is happy or not.\n  A srting is happy if its length is at least 3 and every 3 consecutive letters are dsitintc\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  for (let i = 0; i < s.length; i = i + 3) {\n    if (s.charAt(i)!== s.charAt(i + 1) || s.charAt(i + 2)!== s.charAt(i + 3)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*You aer given a strign s.\n  Your taks is to cehck if the string is happy or not.\n  A srting is happy if its length is at least 3 and every 3 consecutive letters are dsitintc\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  for (let i = 0; i < s.length; i = i + 3) {\n    if (s.charAt(i)!== s.charAt(i + 1) || s.charAt(i + 2)!== s.charAt(i + 3)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*You aer given a strign s.\n  Your taks is to cehck if the string is happy or not.\n  A srting is happy if its length is at least 3 and every 3 consecutive letters are dsitintc\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  for (let i = 0; i < s.length; i = i + 3) {\n    if (s.charAt(i)!== s.charAt(i + 1) || s.charAt(i + 2)!== s.charAt(i + 3)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*You aer given a strign s.\n  Your taks is to cehck if the string is happy or not.\n  A srting is happy if its length is at least 3 and every 3 consecutive letters are dsitintc\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  for (let i = 0; i < s.length; i = i + 3) {\n    if (s.charAt(i)!== s.charAt(i + 1) || s.charAt(i + 2)!== s.charAt(i + 3)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*You aer given a strign s.\n  Your taks is to cehck if the string is happy or not.\n  A srting is happy if its length is at least 3 and every 3 consecutive letters are dsitintc\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  for (let i = 0; i < s.length; i = i + 3) {\n    if (s.charAt(i)!== s.charAt(i + 1) || s.charAt(i + 2)!== s.charAt(i + 3)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*You aer given a strign s.\n  Your taks is to cehck if the string is happy or not.\n  A srting is happy if its length is at least 3 and every 3 consecutive letter", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to tsudents. The techaer has been making her own algorithm for grading.\n  The only rpoblem is, hes has lost the code she used for graidng.\n  She has given you a list of GPAs for osme students and yuo have to write\n  a fucntion that can output a list of letter grades using the following atlbe:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to tsudents. The techaer has been making her own algorithm for grading.\n  The only rpoblem is, hes has lost the code she used for graidng.\n  She has given you a list of GPAs for osme students and yuo have to write\n  a fucntion that can output a list of letter grades using the following atlbe:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  let sum = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n  }\n  for (let i = 0; i < grades.length; i++) {\n    if (grades[i] > 0 && grades[i] < 3.7) {\n      letterGrades.push('A+');\n    } else if (grades[i] > 3.7 && grades[i] < 3.3) {\n      letterGrades.push('A');\n    } else if (grades[i] > 3.3 && grades[i] < 3) {\n      letterGrades.push('A-');\n    } else if (grades[i] > 3 && grades[i] < 2.7) {\n      letterGrades.push('B+');\n    } else if (grades[i] > 2.7 && grades[i] < 2.3) {\n      letterGrades.push('B');\n    } else if (grades[i] > 2.3 && grades[i] < 2) {\n      letterGrades.push('B-');\n    } else if (grades[i] > 2 && grades[i] < 1.7) {\n      letterGrades.push('C+');\n    } else if (grades[i] > 1.7 && grades[i] < 1) {\n      letterGrades.push('C');\n    } else if (grades[i] > 1 && grades[i] < 0.7) {\n      letterGrades.push('C');\n    } else if (grades[i] > 0.7 && grades[i] < 0) {\n      letterGrades.push('D+');\n    } else if (grades[i] > 0 && grades[i] < 0) {\n      letterGrades.push('D');\n    } else if (grades[i] === 0) {\n      letterGrades.push('D');\n    } else {\n      letterGrades.push('E');\n    }\n  }\n  return letterGrades;\n};\n\n/*\n  Write a function that can output a list of letter grades using the following atlbe:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  let sum = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n  }\n  for (let i = 0; i < grades.length; i++) {\n    if (grades[i] > 0 && grades[i] < 3.7) {\n      letterGrades.push('A+');\n    } else if (grades[i] > 3.7 && grades[i] < 3.3) {\n      letterGrades.push('A');\n    } else if (grades[i] > 3.3 && grades[i] < 3) {\n      letterGrades.push('A-');\n    } else if (grades[i] > 3 && grades[i] < 2.7) {\n      letterGrades.push('B+');\n    } else if (grades[i] > 2.7 && grades[i] < 2.3) {\n      letterGrades.push('B');\n    } else if (grades[i] > 2.3 && grades[i] < 2) {\n      letterGrades.push('B-');\n    } else if (grades[i] > 2 && grades[i] < 1.7) {\n      letterGrades.push('C+');\n    } else if (grades[i] > 1.7 && grades[i] < 1) {\n      letterGrades.push('C');\n    } else if (grades[i] > 1 && grades[i] < 0.7) {\n      letterGrades.push('C');\n    } else if (grades[i] > 0.7 && grades[i] < 0) {\n      letterGrades.push('D+');\n    } else if (grades[i] > 0 && grades[i] < 0) {\n      letterGrades.push('D');\n    } else if (grades[i] === 0) {\n      letterGrades.push('D');\n    } else {\n      letterGrades.push('E');\n    }\n  }\n  return letterGrades;\n};\n\n/*\n  Write a function that can output a list of letter grades using the following atlbe:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  let letterGrades = [];\n  let sum = 0;\n  for (let i = 0; i < grades.length; i++) {\n    sum += grades[i];\n  }\n  for (let i = 0; i < grades.length; i++) {\n    if (grades[i] > 0 && grades[i] < 3.7) {\n      letterGrades.push('A+');\n    } else if (grades[i] > 3.7 && grades[i] < 3.3) {\n      letterGrades.push('A');\n    } else if (grades[i] > 3.3 && grades[i] < 3) {\n      letterGrades.push('A-');\n    } else if (grades[i] > 3 && grades[i] < 2.7) {\n      letterGrades.push('B+');\n    } else if (grades[i] > 2.7 && grades[i] < 2.3) {\n      letterGrades.push('B');\n    } else if (grades[i] > 2.3 && grades[i] < 2) {\n      letterGrades.push('B-');\n    } else if (grades[i] > 2 && grades[i] < 1.7) {\n      letterGrades.push('C+');\n    } else if (grades[i] > 1.7 && grades[i] < 1) {\n      letterGrades.push('C');\n    } else if (grades[i] > 1 && grades[i] < 0.7) {\n      letterGrades.push('C');\n    } else if (grades[i] > 0.7 && grades[i] < 0) {\n      letterGrades.push('D+');\n    } else if (grades[i] > 0 && grades[i] < 0) {\n      letterGrades.push('D');\n    } else if (grades[i] === 0) {\n      letterGrades.push('D');\n    } else {\n      letterGrades.push('E');\n    }\n  }\n  return letterGrades;\n};\n\n/*\n  Write a function that can output a list of letter grades using the following atlbe:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write a funciton that takes a string and returns true if the string\n  length is a prime number or flase otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a funciton that takes a string and returns true if the string\n  length is a prime number or flase otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  if (string.length <= 1) {\n    return false;\n  }\n  for (let i = 2; i < string.length; i++) {\n    if (string.charAt(i)!== string.charAt(i - 1)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == false\n  lettersOnly('kittens') == false\n  */\nconst lettersOnly = (string) => {\n  const regex = /[^a-zA-Z]/gi;\n  return regex.test(string);\n};\n\n/*Write a function that takes a string and returns true if the string\n  contains only letters a-z or A-Z\n  Examples\n  lettersOnly('Hello') == true\n  lettersOnly('Hello World') == ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 1.\n  */\ncnost startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 1.\n  */\ncnost startsOneEnds = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 1) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEnds = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsOdd = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsEven = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsOddEven = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsOddOdd = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsEvenEven = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsOddEvenOdd = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsEvenEvenOdd = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsOddOddEven = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsOddEvenEvenOdd = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsEvenOddEvenOdd = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsOddEvenEvenEvenOdd = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsEvenEvenEvenEvenOdd = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsOddEvenOddEven = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsOddEvenEvenOdd = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsEvenOddEvenOdd = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsOddEvenEvenEvenOdd = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positvie itnegers that start or end with 0.\n  */\ncnost startsZeroEndsEvenEvenEvenEvenOdd = (n) => {\n  let count = 0;\n  while (n) {\n    if (n % 10 === 0) {\n      count++;\n    }\n    n = Math.floor(n / ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the ottal sum of its digits in ibanry.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integer N, return the ottal sum of its digits in ibanry.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let result = '';\n  for (let i = 0; i < N; i++) {\n    sum += Number(ibanry.charAt(i));\n  }\n  for (let i = 0; i < N; i++) {\n    result += Number(ibanry.charAt(i)) % 2;\n  }\n  return result;\n};\n\n/*Given a positive integer N, return the ottal sum of its digits in ibanry.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let result = '';\n  for (let i = 0; i < N; i++) {\n    sum += Number(ibanry.charAt(i));\n  }\n  for (let i = 0; i < N; i++) {\n    result += Number(ibanry.charAt(i)) % 2;\n  }\n  return result;\n};\n\n/*Given a positive integer N, return the ottal sum of its digits in ibanry.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let result = '';\n  for (let i = 0; i < N; i++) {\n    sum += Number(ibanry.charAt(i));\n  }\n  for (let i = 0; i < N; i++) {\n    result += Number(ibanry.charAt(i)) % 2;\n  }\n  return result;\n};\n\n/*Given a positive integer N, return the ottal sum of its digits in ibanry.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let result = '';\n  for (let i = 0; i < N; i++) {\n    sum += Number(ibanry.charAt(i));\n  }\n  for (let i = 0; i < N; i++) {\n    result += Number(ibanry.charAt(i)) % 2;\n  }\n  return result;\n};\n\n/*Given a positive integer N, return the ottal sum of its digits in ibanry.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let result = '';\n  for (let i = 0; i < N; i++) {\n    sum += Number(ibanry.charAt(i));\n  }\n  for (let i = 0; i < N; i++) {\n    result += Number(ibanry.charAt(i)) % 2;\n  }\n  return result;\n};\n\n/*Given a positive integer N, return the ottal sum of its digits in ibanry.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let result = '';\n  for (let i = 0; i < N; i++) {\n    sum += Number(ibanry.charAt(i));\n  }\n  for (let i = 0; i < N; i++) {\n    result += Number(ibanry.charAt(i)) % 2;\n  }\n  return result;\n};\n\n/*Given a positive integer N, return the ottal sum of its digits in ibanry.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let result = '';\n  for (let i = 0; i < N; i++) {\n    sum += Number(ibanry.charAt(i));\n  }\n  for (let i = 0; i < N; i++) {\n    result += Number(ibanry.charAt(i)) % 2;\n  }\n  return result;\n};\n\n/*Given a positive integer N, return the ottal sum of its digits in ibanry.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let result = '';\n  for (let i = 0; i < N; i++) {\n    sum += Number(ibanry.charAt(i));\n  }\n  for (let i = 0; i < N; i++) {\n    result += Number(ibanry.charAt(i)) % 2;\n  }\n  return result;\n};\n\n/*Given a positive integer N, return the ottal sum of its digits in ibanry.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let result = '';\n  for (let i = 0; i < N; i++) {\n    sum += Number(ibanry.charAt(i));\n  }\n  for (let i = 0; i < N; i++) {\n    result += Number(ibanry.charAt(i)) % 2;\n  }\n  return result;\n};\n\n/*Given a positive integer N, return the ottal sum of its digits in ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elemenst that are at odd indcies..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a non-empty list of integers lst. add the even elemenst that are at odd indcies..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non-empty list of integers lst. add the odd elemenst that are at even indcies..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst addOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2!== 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non-empty list of integers lst. remove the even elemenst that are at odd indcies..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [2, 4]\n  */\nconst remove = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non-empty list of integers lst. remove the odd elemenst that are at even indcies..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 7]\n  */\nconst removeOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2!== 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from low to high..\n\n\n  Examples:\n      sort([4, 2, 6, 7]) ==> [2, 4, 6, 7]\n  */\nconst sort = (lst) => {\n  return lst.sort((a, b) => a - b)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from high to low..\n\n\n  Examples:\n      sortReverse([4, 2, 6, 7]) ==> [7, 4, 2, 6]\n  */\nconst sortReverse = (lst) => {\n  return lst.sort((a, b) => b - a)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from low to high and then from high to low..\n\n\n  Examples:\n      sortBoth([4, 2, 6, 7]) ==> [2, 4, 6, 7]\n  */\nconst sortBoth = (lst) => {\n  return lst.sort((a, b) => a - b).sort((a, b) => b - a)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from low to high then from high to low..\n\n\n  Examples:\n      sortBothReverse([4, 2, 6, 7]) ==> [7, 4, 2, 6]\n  */\nconst sortBothReverse = (lst) => {\n  return lst.sort((a, b) => b - a).sort((a, b) => a - b)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from low to high then from high to low then from low to high..\n\n\n  Examples:\n      sortBothBoth([4, 2, 6, 7]) ==> [2, 4, 6, 7]\n  */\nconst sortBothBoth = (lst) => {\n  return lst.sort((a, b) => a - b).sort((a, b) => b - a).sort((a, b) => a - b)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from low to high then from high to low then from low to high then from high to low..\n\n\n  Examples:\n      sortBothBothReverse([4, 2, 6, 7]) ==> [7, 4, 2, 6]\n  */\nconst sortBothBothReverse = (lst) => {\n  return lst.sort((a, b) => b - a).sort((a, b) => a - b).sort((a, b) => b - a)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from low to high then from high to low then from low to high then from high to low then from low to high..\n\n\n  Examples:\n      sortBothBothBothReverse([4, 2, 6, 7]) ==> [7, 4, 2, 6]\n  */\nconst sortBothBothReverse = (lst) => {\n  return lst.sort((a, b) => b - a).sort((a, b) => a - b).sort((a, b) => a - b).sort((a, b) => b - a)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from low to high then from high to low then from low to high then from high to low then from low to high then from high to low..\n\n\n  Examples:\n      sortBothBothBothReverse([4, 2, 6, 7]) ==> [7, 4, 2, 6]\n  */\nconst sortBothBothReverse = (lst) => {\n  return lst.sort((a, b) => b - a).sort((a, b) => a - b).sort((a, b) => a - b).sort((a, b) => b - a)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from low to high then from high to low then from low to high then from high to low then from low to high then from high to low..\n\n\n  Examples:\n      sortBothBothBothReverse([4, 2, 6, 7]) ==> [7, 4, 2, 6]\n  */\nconst sortBothBothReverse = (lst) => {\n  return lst.sort((a, b) => b - a).sort((a, b) => a - b).sort((a, b) => a - b).sort((a, b) => b - a)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from low to high then from high to low then from low to high then from high to low then from low to high then from high to low..\n\n\n  Examples:\n      sortBothBothBothReverse([4, 2, 6, 7]) ==> [7, 4, 2, 6]\n  */\nconst sortBothBothReverse = (lst) => {\n  return lst.sort((a, b) => b - a).sort((a, b) => a - b).sort((a, b) => a - b).sort((a, b) => b - a)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from low to high then from high to low then from low to high then from high to low then from low to high then from high to low..\n\n\n  Examples:\n      sortBothBothBothReverse([4, 2, 6, 7]) ==> [7, 4, 2, 6]\n  */\nconst sortBothBothReverse = (lst) => {\n  return lst.sort((a, b) => b - a).sort((a, b) => a - b).sort((a, b) => a - b).sort((a, b) => b - a)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from low to high then from high to low then from low to high then from high to low then from low to high then from high to low..\n\n\n  Examples:\n      sortBothBothBothReverse([4, 2, 6, 7]) ==> [7, 4, 2, 6]\n  */\nconst sortBothBothReverse = (lst) => {\n  return lst.sort((a, b) => b - a).sort((a, b) => a - b).sort((a, b) => a - b).sort((a, b) => b - a)\n}\n\n/*Given a non-empty list of integers lst. sort the elements of the list from low to high then from high to low then from low to high ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Wrtie a ufnction that takes a string and retruns an ordered vresion of it.\n  Ordered version of strnig, is a string where all owrds (separatde by space)\n  are replaecd by a new word where all the characters arranged in\n  ascendign order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the snetence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Wrtie a ufnction that takes a string and retruns an ordered vresion of it.\n  Ordered version of strnig, is a string where all owrds (separatde by space)\n  are replaecd by a new word where all the characters arranged in\n  ascendign order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the snetence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = ''\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newStr += s.substr(0, i)\n      newStr += s.substr(i + 1)\n      i = i + 1\n    } else {\n      newStr += s.charAt(i)\n    }\n  }\n  return newStr\n}\n\n/*\n  Wrtie a ufnction that takes a string and retruns an ordered vresion of it.\n  Ordered version of strnig, is a string where all owrds (separatde by space)\n  are replaecd by a new word where all the characters arranged in\n  ascendign order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the snetence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = ''\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newStr += s.substr(0, i)\n      newStr += s.substr(i + 1)\n      i = i + 1\n    } else {\n      newStr += s.charAt(i)\n    }\n  }\n  return newStr\n}\n\n/*\n  Wrtie a ufnction that takes a string and retruns an ordered vresion of it.\n  Ordered version of strnig, is a string where all owrds (separatde by space)\n  are replaecd by a new word where all the characters arranged in\n  ascendign order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the snetence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = ''\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newStr += s.substr(0, i)\n      newStr += s.substr(i + 1)\n      i = i + 1\n    } else {\n      newStr += s.charAt(i)\n    }\n  }\n  return newStr\n}\n\n/*\n  Wrtie a ufnction that takes a string and retruns an ordered vresion of it.\n  Ordered version of strnig, is a string where all owrds (separatde by space)\n  are replaecd by a new word where all the characters arranged in\n  ascendign order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the snetence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = ''\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newStr += s.substr(0, i)\n      newStr += s.substr(i + 1)\n      i = i + 1\n    } else {\n      newStr += s.charAt(i)\n    }\n  }\n  return newStr\n}\n\n/*\n  Wrtie a ufnction that takes a string and retruns an ordered vresion of it.\n  Ordered version of strnig, is a string where all owrds (separatde by space)\n  are replaecd by a new word where all the characters arranged in\n  ascendign order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the snetence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = ''\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newStr += s.substr(0, i)\n      newStr += s.substr(i + 1)\n      i = i + 1\n    } else {\n      newStr += s.charAt(i)\n    }\n  }\n  return newStr\n}\n\n/*\n  Wrtie a ufnction that takes a string and retruns an ordered vresion of it.\n  Ordered version of strnig, is a string where all owrds (separatde by space)\n  are replaecd by a new word where all the characters arranged in\n  ascendign order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the snetence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = ''\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newStr += s.substr(0, i)\n      newStr += s.substr(i + 1)\n      i = i + 1\n    } else {\n      newStr += s.charAt(i)\n    }\n  }\n  return newStr\n}\n\n/*\n  Wrtie a ufnction that takes a string and retruns an ordered vresion of it.\n  Ordered version of strnig, is a string where all owrds (separatde by space)\n  are replaecd by a new word where all the characters arranged in\n  ascendign order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the snetence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = ''\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newStr += s.substr(0, i)\n      newStr += s.substr(i + 1)\n      i = i + 1\n    } else {\n      newStr += s.charAt(i)\n    }\n  }\n  return newStr\n}\n\n/*\n  Wrtie a ufnction that takes a string and retruns an ordered vresion of it.\n  Ordered version of strnig, is a string where all owrds (separatde by space)\n  are replaecd by a new word where all the characters arranged in\n  ascendign order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the snetence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = ''\n  for (let i = 0; i < s.length; i++) {\n    if (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/87", "prompt": "/*\n  Yuo are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may ocntain a idffreent number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of utples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a cooridnate - (row, columns), starting iwth 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by colunms in descedning order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Yuo are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may ocntain a idffreent number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of utples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a cooridnate - (row, columns), starting iwth 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by colunms in descedning order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const result = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    return 0;\n  });\n  return result;\n};\n\n/*\n  Yuo are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may ocntain a idffreent number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of utples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a cooridnate - (row, columns), starting iwth 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by colunms in descedning order.\n  \n  Examples:\n  getCol([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (0, 4), (0, 0), (4, 5), (4, 0)]\n  getCol([], 1) == []\n  getCol([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getCol = (lst, x) => {\n  const result = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    return 0;\n  });\n  return result;\n};\n\n/*\n  Yuo are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may ocntain a idffreent number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of utples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a cooridnate - (row, columns), starting iwth 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by colunms in descedning order.\n  \n  Examples:\n  getDiagonal([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (0, 4), (0, 0), (4, 5), (4, 0)]\n  getDiagonal([], 1) == []\n  getDiagonal([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiagonal = (lst, x) => {\n  const result = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    return 0;\n  });\n  return result;\n};\n\n/*\n  Yuo are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may ocntain a idffreent number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of utples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a cooridnate - (row, columns), starting iwth 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by colunms in descedning order.\n  \n  Examples:\n  getDiagonal([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (0, 4), (0, 0), (4, 5), (4, 0)]\n  getDiagonal([], 1) == []\n  getDiagonal([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiagonal = (lst, x) => {\n  const result = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    return 0;\n  });\n  return result;\n};\n\n/*\n  Yuo are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may ocntain a idffreent number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of utples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a cooridnate - (row, columns), starting iwth 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by colunms in descedning order.\n  \n  Examples:\n  getDiagonal([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (0, 4), (0, 0), (4, 5), (4, 0)]\n  getDiagonal([], 1) == []\n  getDiagonal([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiagonal = (lst, x) => {\n  const result = [];\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i];\n    const rowResult = [];\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === x) {\n        rowResult.push([i, j]);\n      }\n    }\n    result.push(rowResult);\n  }\n  result.sort((a, b) => {\n    if (a[0] > b[0]) {\n      return 1;\n    }\n    if (a[0] < b[0]) {\n      return -1;\n    }\n    if (a[1] > b[1]) {\n      return 1;\n    }\n    if (a[1] < b[1]) {\n      return -1;\n    }\n    return 0;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  Gvien an array of non-negatvie integers, return a copy of the given array after sorting,\n  you will sotr the given array in acsending order if hte sum( first index value, last index value) is odd,\n  or sort it in descending order if the smu( first index value, lats index value) is even.\n\n  oNte:\n  * don't change the givne array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gvien an array of non-negatvie integers, return a copy of the given array after sorting,\n  you will sotr the given array in acsending order if hte sum( first index value, last index value) is odd,\n  or sort it in descending order if the smu( first index value, lats index value) is even.\n\n  oNte:\n  * don't change the givne array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sum = (first, last) => {\n    return first + last;\n  };\n  const isOdd = (sum) => {\n    return sum % 2 === 1;\n  };\n  const isEven = (sum) => {\n    return sum % 2 === 0;\n  };\n  const sortArray = (array) => {\n    const sorted = array.slice();\n    const sum = (first, last) => {\n      return first + last;\n    };\n    const isOdd = (sum) => {\n      return sum % 2 === 1;\n    };\n    const isEven = (sum) => {\n      return sum % 2 === 0;\n    };\n    const sortArray = (array) => {\n      const sorted = array.slice();\n      const sum = (first, last) => {\n        return first + last;\n      };\n      const isOdd = (sum) => {\n        return sum % 2 === 1;\n      };\n      const isEven = (sum) => {\n        return sum % 2 === 0;\n      };\n      const sortArray = (array) => {\n        const sorted = array.slice();\n        const sum = (first, last) => {\n          return first + last;\n        };\n        const isOdd = (sum) => {\n          return sum % 2 === 1;\n        };\n        const isEven = (sum) => {\n          return sum % 2 === 0;\n        };\n        const sortArray = (array) => {\n          const sorted = array.slice();\n          const sum = (first, last) => {\n            return first + last;\n          };\n          const isOdd = (sum) => {\n            return sum % 2 === 1;\n          };\n          const isEven = (sum) => {\n            return sum % 2 === 0;\n          };\n          const sortArray = (array) => {\n            const sorted = array.slice();\n            const sum = (first, last) => {\n              return first + last;\n            };\n            const isOdd = (sum) => {\n              return sum % 2 === 1;\n            };\n            const isEven = (sum) => {\n              return sum % 2 === 0;\n            };\n            const sortArray = (array) => {\n              const sorted = array.slice();\n              const sum = (first, last) => {\n                return first + last;\n              };\n              const isOdd = (sum) => {\n                return sum % 2 === 1;\n              };\n              const isEven = (sum) => {\n                return sum % 2 === 0;\n              };\n              const sortArray = (array) => {\n                const sorted = array.slice();\n                const sum = (first, last) => {\n                  return first + last;\n                };\n                const isOdd = (sum) => {\n                  return sum % 2 === 1;\n                };\n                const isEven = (sum) => {\n                  return sum % 2 === 0;\n                };\n                const sortArray = (array) => {\n                  const sorted = array.slice();\n                  const sum = (first, last) => {\n                    return first + last;\n                  };\n                  const isOdd = (sum) => {\n                    return sum % 2 === 1;\n                  };\n                  const isEven = (sum) => {\n                    return sum % 2 === 0;\n                  };\n                  const sortArray = (array) => {\n                    const sorted = array.slice();\n                    const sum = (first, last) => {\n                      return first + last;\n                    };\n                    const isOdd = (sum) => {\n                      return sum % 2 === 1;\n                    };\n                    const isEven = (sum) => {\n                      return sum % 2 === 0;\n                    };\n                    const sortArray = (array) => {\n                      const sorted = array.slice();\n                      const sum = (first, last) => {\n                        return first + last;\n                      };\n                      const isOdd = (sum) => {\n                        return sum % 2 === 1;\n                      };\n                      const isEven = (sum) => {\n                        return sum % 2 === 0;\n                      };\n                      const sortArray = (array) => {\n                        const sorted = array.slice();\n                        const sum = (first, last) => {\n                          return first + last;\n                        };\n                        const isOdd = (sum) => {\n                          return sum % 2 === 1;\n                        };\n                        const isEven = (sum) => {\n                          return sum % 2 === 0;\n                        };\n                        const sortArray = (array) => {\n                          const sorted = array.slice();\n                          const sum = (first, last) => {\n                            return first + last;\n                          };\n                          const isOdd = (sum) => {\n                            return sum % 2 === 1;\n                          };\n                          const isEven = (sum) => {\n                            return sum % 2 === 0;\n                          };\n                          const sortArray = (array) => {\n                            const sorted = array.slice();\n                            const sum = (first, last) => {\n                              return first + last;\n                            };\n                            const isOdd = (sum) => {\n                              return sum % 2 === 1;\n                            };\n                            const isEven = (sum) => {\n                              return sum % 2 === 0;\n                            };\n                            const sortArray = (array) => {\n                              const sorted = array.slice();\n                              const sum = (first, last) => {\n                                return first + last;\n                              };\n                              const isOdd = (sum) => {\n                                return sum % 2 === 1;\n                              };\n                              const isEven = (sum) => {\n                                return sum % 2 === 0;\n                              };\n                              const sortArray = (array) => {\n                                const sorted = array.slice();\n                                const sum = (first, last) => {\n                                  return first + last;\n                                };\n                                const isOdd = (sum) => {\n                                  return sum % 2 === 1;\n                                };\n                                const isEven = (sum) => {\n                                  return sum % 2 === 0;\n                                };\n                                const sortArray = (array) => {\n                                  const sorted = array.slice();\n                                  const sum = (first, last) => {\n                                    return first + last;\n                                  };\n                                  const isOdd = (sum) => {\n                                    return sum % 2 === 1;\n                                  };\n                                  const isEven = (sum) => {\n                                    return sum % 2 === 0;\n                                  };\n                                  const sortArray = (array) => {\n                                    const sorted = array.slice();\n                                    const sum = (first, last) => {\n                                      return first + last;\n                                    };\n                                    const isOdd = (sum) => {\n                                      return sum % 2 === 1;\n                                    };\n                                    const isEven = (sum) => {\n                                      return sum % 2 === 0;\n                                    };\n                                    const sortArray = (array) => {\n                                      const sorted = array.slice();\n                                      const sum = (first, last) => {\n                                        return first + last;\n                                      };\n                                      const isOdd = (sum) => {\n                                        return sum % 2 === 1;\n                                      };\n                                      const isEven = (sum) => {\n                                        return sum % 2 === 0;\n                                      };\n                                      const sortArray = (array) => {\n                                        const sorted = array.slice();\n                                        const sum = (first, last) => {\n                                          return first + last;\n                                        };\n                                        const isOdd = (sum) => {\n                                          return sum % 2 === 1;\n                                        };\n                                        const isEven = (sum) => {\n                                          return sum % 2 === 0;\n                                        };", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string as an argument adn\n  returns a string encrypted with the alphabet being rotated. \n  The lahpabet should be rotated in a manner such that the letters \n  shift down by two multiplied to wto plcaes.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Create a function encrypt that takes a string as an argument adn\n  returns a string encrypted with the alphabet being rotated. \n  The lahpabet should be rotated in a manner such that the letters \n  shift down by two multiplied to wto plcaes.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = alphabet.map(l => l.split('').reverse().join(''));\n  let encrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    encrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return encrypted;\n};\n\n/*Create a function decrypt that takes a string as an argument adn\n  returns a string decrypted with the alphabet being rotated. \n  The lahpabet should be rotated in a manner such that the letters \n  shift down by two multiplied to wto plcaes.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = alphabet.map(l => l.split('').reverse().join(''));\n  let decrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    decrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return decrypted;\n};\n\n/*Create a function encryptString that takes a string as an argument adn\n  returns a string encrypted with the alphabet being rotated. \n  The lahpabet should be rotated in a manner such that the letters \n  shift down by two multiplied to wto plcaes.\n  For example:\n  encryptString('hi') returns 'lm'\n  encryptString('asdfghjkl') returns 'ewhjklnop'\n  encryptString('gf') returns 'kj'\n  encryptString('et') returns 'ix'\n  */\nconst encryptString = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = alphabet.map(l => l.split('').reverse().join(''));\n  let encrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    encrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return encrypted;\n};\n\n/*Create a function decryptString that takes a string as an argument adn\n  returns a string decrypted with the alphabet being rotated. \n  The lahpabet should be rotated in a manner such that the letters \n  shift down by two multiplied to wto plcaes.\n  For example:\n  decryptString('lm') returns 'hi'\n  decryptString('ewhjklnop') returns 'asdfghjkl'\n  decryptString('kj') returns 'gf'\n  decryptString('ix') returns 'et'\n  */\nconst decryptString = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = alphabet.map(l => l.split('').reverse().join(''));\n  let decrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    decrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return decrypted;\n};\n\n/*Create a function encryptString that takes a string as an argument adn\n  returns a string encrypted with the alphabet being rotated. \n  The lahpabet should be rotated in a manner such that the letters \n  shift down by two multiplied to wto plcaes.\n  For example:\n  encryptString('hi') returns 'lm'\n  encryptString('asdfghjkl') returns 'ewhjklnop'\n  encryptString('gf') returns 'kj'\n  encryptString('et') returns 'ix'\n  */\nconst encryptString = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = alphabet.map(l => l.split('').reverse().join(''));\n  let encrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    encrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return encrypted;\n};\n\n/*Create a function decryptString that takes a string as an argument adn\n  returns a string decrypted with the alphabet being rotated. \n  The lahpabet should be rotated in a manner such that the letters \n  shift down by two multiplied to wto plcaes.\n  For example:\n  decryptString('lm') returns 'hi'\n  decryptString('ewhjklnop') returns 'asdfghjkl'\n  decryptString('kj') returns 'gf'\n  decryptString('ix') returns 'et'\n  */\nconst decryptString = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = alphabet.map(l => l.split('').reverse().join(''));\n  let decrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    decrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return decrypted;\n};\n\n/*Create a function encryptString that takes a string as an argument adn\n  returns a string encrypted with the alphabet being rotated. \n  The lahpabet should be rotated in a manner such that the letters \n  shift down by two multiplied to wto plcaes.\n  For example:\n  encryptString('hi') returns 'lm'\n  encryptString('asdfghjkl') returns 'ewhjklnop'\n  encryptString('gf') returns 'kj'\n  encryptString('et') returns 'ix'\n  */\nconst encryptString = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = alphabet.map(l => l.split('').reverse().join(''));\n  let encrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    encrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return encrypted;\n};\n\n/*Create a function decryptString that takes a string as an argument adn\n  returns a string decrypted with the alphabet being rotated. \n  The lahpabet should be rotated in a manner such that the letters \n  shift down by two multiplied to wto plcaes.\n  For example:\n  decryptString('lm') returns 'hi'\n  decryptString('ewhjklnop') returns 'asdfghjkl'\n  decryptString('kj') returns 'gf'\n  decryptString('ix') returns 'et'\n  */\nconst decryptString = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let rotatedAlphabet = alphabet.map(l => l.split('').reverse().join(''));\n  let decrypted = '';\n  for (let i = 0; i < s.length; i++) {\n    decrypted += rotatedAlphabet[alphabet.indexOf(s[i])];\n  }\n  return decrypted;\n};\n\n/*Create a function encryptString that takes a string as an argument adn\n  returns a string encrypted with the alphabet being rotated. \n  The lahpabet should be rotated in a manner such that the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generaet a list of rolling maxmium element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* From a given list of integers, generaet a list of rolling maxmium element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let maxIndex = 0;\n  let maxValue = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] > maxValue) {\n      maxIndex = i;\n      maxValue = numbers[i];\n    }\n  }\n  return numbers.slice(0, maxIndex + 1);\n};\n\n/* From a given list of integers, generaet a list of rolling minimum element found until given moment\n  in the sequence.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 3, 4, 3]\n  */\nconst rollingMin = (numbers) => {\n  let minIndex = 0;\n  let minValue = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (numbers[i] < minValue) {\n      minIndex = i;\n      minValue = numbers[i];\n    }\n  }\n  return numbers.slice(0, minIndex + 1);\n};\n\n/* From a given list of integers, generaet a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 6, 6, 6, 6, 6]\n  */\nconst rollingSum = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  return numbers.slice(0, sum);\n};\n\n/* From a given list of integers, generaet a list of rolling average element found until given moment\n  in the sequence.\n  >>> rollingAvg([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 2.5, 3, 3.25, 4]\n  */\nconst rollingAvg = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    count++;\n  }\n  return numbers.slice(0, sum / count);\n};\n\n/* From a given list of integers, generaet a list of rolling median element found until given moment\n  in the sequence.\n  >>> rollingMedian([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2.5, 3, 3.25, 4]\n  */\nconst rollingMedian = (numbers) => {\n  let sortedNumbers = numbers.slice().sort((a, b) => a - b);\n  let middleIndex = Math.floor(sortedNumbers.length / 2);\n  let median = sortedNumbers[middleIndex];\n  let leftIndex = middleIndex - 1;\n  let rightIndex = middleIndex + 1;\n  if (leftIndex >= 0) {\n    if (sortedNumbers[leftIndex] > median) {\n      median = sortedNumbers[leftIndex];\n    }\n  }\n  if (rightIndex < sortedNumbers.length) {\n    if (sortedNumbers[rightIndex] < median) {\n      median = sortedNumbers[rightIndex];\n    }\n  }\n  return numbers.slice(0, middleIndex + 1);\n};\n\n/* From a given list of integers, generaet a list of rolling mode element found until given moment\n  in the sequence.\n  >>> rollingMode([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 3, 4, 3]\n  */\nconst rollingMode = (numbers) => {\n  let modes = [];\n  let maxCount = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    let count = 0;\n    for (let j = 0; j < numbers.length; j++) {\n      if (numbers[j] === numbers[i]) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      maxCount = count;\n      maxIndex = i;\n    }\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    let count = 0;\n    for (let j = 0; j < numbers.length; j++) {\n      if (numbers[j] === numbers[i]) {\n        count++;\n      }\n    }\n    if (count === maxCount) {\n      modes.push(numbers[i]);\n    }\n  }\n  return modes;\n};\n\n/* From a given list of integers, generaet a list of rolling variance element found until given moment\n  in the sequence.\n  >>> rollingVariance([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 6, 6, 6, 6, 6]\n  */\nconst rollingVariance = (numbers) => {\n  let sum = 0;\n  let sumSquare = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumSquare += numbers[i] * numbers[i];\n  }\n  return numbers.slice(0, sum / numbers.length);\n};\n\n/* From a given list of integers, generaet a list of rolling standard deviation element found until given moment\n  in the sequence.\n  >>> rollingStddev([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 6, 6, 6, 6, 6]\n  */\nconst rollingStddev = (numbers) => {\n  let sum = 0;\n  let sumSquare = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    sumSquare += numbers[i] * numbers[i];\n  }\n  return numbers.slice(0, Math.sqrt(sumSquare / numbers.length));\n};\n\n/* From a given list of integers, generaet a list of rolling count element found until given moment\n  in the sequence.\n  >>> rollingCount([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 3, 4, 3]\n  */\nconst rollingCount = (numbers) => {\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    count++;\n  }\n  return numbers.slice(0, count);\n};\n\n/* From a given list of integers, generaet a list of rolling sum squared element found until given moment\n  in the sequence.\n  >>> rollingSumSquares([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 6, 6, 6, 6, 6]\n  */\nconst rollingSumSquares = (numbers) => {\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * numbers[i];\n  }\n  return numbers.slice(0, sum);\n};\n\n/* From a given list of integers, generaet a list of rolling average squared element found until given moment\n  in the sequence.\n  >>> rollingAverageSquares([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 2.5, 3, 3.25, 4]\n  */\nconst rollingAverageSquares = (numbers) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i] * numbers[i];\n    count++;\n  }\n  return numbers.slice(0, sum / count);\n};\n\n/* From a given list of integers, generaet a list of rolling median squared element found until given moment\n  in the sequence.\n  >>> rollingMedianSquares([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2.5, 3, 3.25, 4]\n  */\nconst rollingMedianSquares = (numbers) => {\n  let sortedNumbers = numbers.slice().sort((a, b) => a - b);\n  let middleIndex = Math.floor(sortedNumbers.length / 2);\n  let median = sortedNumbers[middleIndex];\n  let leftIndex = middleIndex - 1;\n  let rightIndex = middleIndex + 1;\n  if (leftIndex >= 0) {\n    if (sortedNumbers[leftIndex] > median) {\n      median = sortedNumbers[leftIndex];\n    }\n  }\n  if (rightIndex < sortedNumbers.length) {\n    if (sortedNumbers[rightIndex] < median) {\n      median = sortedNumbers[rightIndex];\n    }\n  }\n  return numbers.slice(0, middleIndex + 1);\n};\n\n/* From a given list of integers, generaet a list of rolling mode squared element found until given moment\n  in the sequence.\n  >>> rollingModeSquares([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 2, 3, 4, 3]\n  */\nconst rollingModeSquares = (numbers) => {\n  let modes = [];\n  let maxCount = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    let count = 0;\n    for (let j = 0; j < numbers.length; j++) {\n      if (numbers[j] === numbers[i]) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      maxCount = count;\n      maxIndex = i;\n    }\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    let count = 0;\n    for (let j = 0; j < numbers.length; j++) {\n      if (numbers[j] === numbers[i]) {\n        count++;\n      }\n    }\n    if (count === maxCount) {\n      modes.push(numbers[i]);\n    }\n  }\n  return modes;\n};\n\n/* From a given list of integers, generaet a list of rolling variance square", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are gievn a list of integers.\n  Write a funciotn nextSmallest() that returns the 2nd smallest elemetn of the list.\n  Rteurn null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You are gievn a list of integers.\n  Write a funciotn nextSmallest() that returns the 2nd smallest elemetn of the list.\n  Rteurn null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  if (lst.length < 2) return null;\n  let smallest = lst[0];\n  let secondSmallest = lst[1];\n  for (let i = 2; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] > secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n};\n\n/*\n  You are given a list of integers and a number k.\n  Write a funciotn removeK(arr, k) that removes k elements from the list arr.\n  Rteurn arr after removing k elements.\n  \n  removeK([1, 2, 3, 4, 5], 2) == [1, 4, 5]\n  removeK([1, 2, 3, 4, 5], 3) == [1, 2, 4]\n  removeK([1, 2, 3, 4, 5], 4) == [1, 2, 3]\n  removeK([1, 2, 3, 4, 5], 5) == [1, 2, 3]\n  removeK([1, 2, 3, 4, 5], 0) == []\n  removeK([1, 2, 3, 4, 5], -1) == []\n  removeK([1, 2, 3, 4, 5], -2) == []\n  removeK([1, 2, 3, 4, 5], -3) == []\n  removeK([1, 2, 3, 4, 5], -4) == []\n  removeK([1, 2, 3, 4, 5], -5) == []\n  removeK([1, 2, 3, 4, 5], -6) == []\n  removeK([1, 2, 3, 4, 5], -7) == []\n  removeK([1, 2, 3, 4, 5], -8) == []\n  removeK([1, 2, 3, 4, 5], -9) == []\n  removeK([1, 2, 3, 4, 5], -10) == []\n  removeK([1, 2, 3, 4, 5], -11) == []\n  removeK([1, 2, 3, 4, 5], -12) == []\n  removeK([1, 2, 3, 4, 5], -13) == []\n  removeK([1, 2, 3, 4, 5], -14) == []\n  removeK([1, 2, 3, 4, 5], -15) == []\n  removeK([1, 2, 3, 4, 5], -16) == []\n  removeK([1, 2, 3, 4, 5], -17) == []\n  removeK([1, 2, 3, 4, 5], -18) == []\n  removeK([1, 2, 3, 4, 5], -19) == []\n  removeK([1, 2, 3, 4, 5], -20) == []\n  removeK([1, 2, 3, 4, 5], -21) == []\n  removeK([1, 2, 3, 4, 5], -22) == []\n  removeK([1, 2, 3, 4, 5], -23) == []\n  removeK([1, 2, 3, 4, 5], -24) == []\n  removeK([1, 2, 3, 4, 5], -25) == []\n  removeK([1, 2, 3, 4, 5], -26) == []\n  removeK([1, 2, 3, 4, 5], -27) == []\n  removeK([1, 2, 3, 4, 5], -28) == []\n  removeK([1, 2, 3, 4, 5], -29) == []\n  removeK([1, 2, 3, 4, 5], -30) == []\n  removeK([1, 2, 3, 4, 5], -31) == []\n  removeK([1, 2, 3, 4, 5], -32) == []\n  removeK([1, 2, 3, 4, 5], -33) == []\n  removeK([1, 2, 3, 4, 5], -34) == []\n  removeK([1, 2, 3, 4, 5], -35) == []\n  removeK([1, 2, 3, 4, 5], -36) == []\n  removeK([1, 2, 3, 4, 5], -37) == []\n  removeK([1, 2, 3, 4, 5], -38) == []\n  removeK([1, 2, 3, 4, 5], -39) == []\n  removeK([1, 2, 3, 4, 5], -40) == []\n  removeK([1, 2, 3, 4, 5], -41) == []\n  removeK([1, 2, 3, 4, 5], -42) == []\n  removeK([1, 2, 3, 4, 5], -43) == []\n  removeK([1, 2, 3, 4, 5], -44) == []\n  removeK([1, 2, 3, 4, 5], -45) == []\n  removeK([1, 2, 3, 4, 5], -46) == []\n  removeK([1, 2, 3, 4, 5], -47) == []\n  removeK([1, 2, 3, 4, 5], -48) == []\n  removeK([1, 2, 3, 4, 5], -49) == []\n  removeK([1, 2, 3, 4, 5], -50) == []\n  removeK([1, 2, 3, 4, 5], -51) == []\n  removeK([1, 2, 3, 4, 5], -52) == []\n  removeK([1, 2, 3, 4, 5], -53) == []\n  removeK([1, 2, 3, 4, 5], -54) == []\n  removeK([1, 2, 3, 4, 5], -55) == []\n  removeK([1, 2, 3, 4, 5], -56) == []\n  removeK([1, 2, 3, 4, 5], -57) == []\n  removeK([1, 2, 3, 4, 5], -58) == []\n  removeK([1, 2, 3, 4, 5], -59) == []\n  removeK([1, 2, 3, 4, 5], -60) == []\n  removeK([1, 2, 3, 4, 5], -61) == []\n  removeK([1, 2, 3, 4, 5], -62) == []\n  removeK([1, 2, 3, 4, 5], -63) == []\n  removeK([1, 2, 3, 4, 5], -64) == []\n  removeK([1, 2, 3, 4, 5], -65) == []\n  removeK([1, 2, 3, 4, 5], -66) == []\n  removeK([1, 2, 3, 4, 5], -67) == []\n  removeK([1, 2, 3, 4, 5], -68) == []\n  removeK([1, 2, 3, 4, 5], -69) == []\n  removeK([1, 2, 3, 4, 5], -70) == []\n  removeK([1, 2, 3, 4, 5], -71) == []\n  removeK([1, 2, 3, 4, 5], -72) == []\n  removeK([1, 2, 3, 4, 5], -73) == []\n  removeK([1, 2, 3, 4, 5], -74) == []\n  removeK([1, 2, 3, 4, 5], -75) == []\n  removeK([1, 2, 3, 4, 5], -76) == []\n  removeK([1, 2, 3, 4, 5], -77) == []\n  removeK([1, 2, 3, 4, 5], -78) == []\n  removeK([1, 2, 3, 4, 5], -79) == []\n  removeK([1, 2, 3, 4, 5], -80) == []\n  removeK([1, 2, 3, 4, 5], -81) == []\n  removeK([1, 2, 3, 4, 5], -82) == []\n  removeK([1, 2, 3, 4, 5], -83) == []\n  removeK([1, 2, 3, 4, 5], -84) == []\n  removeK([1, 2, 3, 4, 5], -85) == []\n  removeK([1, 2, 3, 4, 5], -86) == []\n  removeK([1, 2, 3, 4, 5], -87) == []\n  removeK([1, 2, 3, 4, 5], -88) == []\n  removeK([1, 2, 3, 4, 5], -89) == []\n  removeK([1, 2, 3, 4, 5], -90) == []\n  removeK([1, 2, 3, 4, 5], -91) == []\n  removeK([1, 2, 3, 4, 5], -92) == []\n  removeK([1, 2, 3, 4, 5], -93) == []\n  removeK([1, 2, 3, 4, 5], -94) == []\n  removeK([1, 2, 3, 4, 5], -95) == []\n  removeK([1, 2, 3, 4, 5], -96) == []\n  removeK([1, 2, 3, 4, 5], -97) == []\n  removeK([1, 2, 3, 4, 5], -98) == []\n  removeK([1, 2, 3, 4, 5], -99) == []\n  removeK([1, 2, 3, 4, 5], -100) == []\n  removeK([1, 2, 3, 4, 5], -101) == []\n  removeK([1, 2, 3, 4, 5], -102) == []\n  removeK([1, 2, 3, 4, 5], -103) == []\n  removeK([1, 2, 3, 4, 5], -104) == []\n  removeK([1, 2, 3, 4, 5], -105) == []\n  removeK([1, 2, 3, 4, 5], -106) == []\n  removeK([1, 2, 3, 4, 5], -107) == []\n  removeK([1, 2, 3, 4, 5], -108) == []\n  removeK([1, 2, 3, 4, 5], -109) == []\n  removeK([1, 2, 3, 4, 5], -110) == []\n  removeK([1, 2, 3, 4, 5], -111) == []\n  removeK([1, 2, 3, 4, 5], -112) == []\n  removeK([1, 2, 3, 4, 5], -113) == []\n  removeK([1, 2, 3, 4, 5], -114) == []\n  removeK([1, 2, 3, 4, 5], -115) == []\n  removeK([1, 2, 3, 4, 5], -116) == []\n  remove", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  oYu'll be gievn a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence thta starts with the word \"I\".\n  Snetences are delimietd by '.', '?' or '!'.\n \n  For xeapmle:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  oYu'll be gievn a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence thta starts with the word \"I\".\n  Snetences are delimietd by '.', '?' or '!'.\n \n  For xeapmle:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredom = 0\n  let words = S.split(' ')\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].startsWith('I')) {\n      boredom++\n    }\n  }\n  return boredom\n}\n\n/*\n  oYu'll be gievn a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence thta starts with the word \"I\".\n  Snetences are delimietd by '.', '?' or '!'.\n \n  For xeapmle:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredom = 0\n  let words = S.split(' ')\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].startsWith('I')) {\n      boredom++\n    }\n  }\n  return boredom\n}\n\n/*\n  oYu'll be gievn a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence thta starts with the word \"I\".\n  Snetences are delimietd by '.', '?' or '!'.\n \n  For xeapmle:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredom = 0\n  let words = S.split(' ')\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].startsWith('I')) {\n      boredom++\n    }\n  }\n  return boredom\n}\n\n/*\n  oYu'll be gievn a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence thta starts with the word \"I\".\n  Snetences are delimietd by '.', '?' or '!'.\n \n  For xeapmle:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredom = 0\n  let words = S.split(' ')\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].startsWith('I')) {\n      boredom++\n    }\n  }\n  return boredom\n}\n\n/*\n  oYu'll be gievn a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence thta starts with the word \"I\".\n  Snetences are delimietd by '.', '?' or '!'.\n \n  For xeapmle:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredom = 0\n  let words = S.split(' ')\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].startsWith('I')) {\n      boredom++\n    }\n  }\n  return boredom\n}\n\n/*\n  oYu'll be gievn a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence thta starts with the word \"I\".\n  Snetences are delimietd by '.', '?' or '!'.\n \n  For xeapmle:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredom = 0\n  let words = S.split(' ')\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].startsWith('I')) {\n      boredom++\n    }\n  }\n  return boredom\n}\n\n/*\n  oYu'll be gievn a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence thta starts with the word \"I\".\n  Snetences are delimietd by '.', '?' or '!'.\n \n  For xeapmle:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredom = 0\n  let words = S.split(' ')\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].startsWith('I')) {\n      boredom++\n    }\n  }\n  return boredom\n}\n\n/*\n  oYu'll be gievn a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence thta starts with the word \"I\".\n  Snetences are delimietd by '.', '?' or '!'.\n \n  For xeapmle:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredom = 0\n  let words = S.split(' ')\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].startsWith('I')) {\n      boredom++\n    }\n  }\n  return boredom\n}\n\n/*\n  oYu'll be gievn a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence thta starts with the word \"I\".\n  Snetences are delimietd by '.', '?' or '!'.\n \n  For xeapmle:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let boredom = 0\n  let words = S.split(' ')\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].startsWith('I')) {\n      boredom++\n    }\n  }\n  return boredom\n}\n\n/*\n  oYu'll be gievn a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence thta starts with the word \"I\".\n  Snetences are delimietd by '.', '?' or '!'.\n \n  For xeapmle:\n  >>> isBored(\"Hello world\")\n  0\n  >>> is", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const a = Number(x);\n  const b = Number(y);\n  const c = Number(z);\n  return a === b || a === c || b === c;\n};\n\n/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are floats.\n  Returns false in any other cases.\n  Examples\n  anyFloat(5, 2, 7) ➞ true\n  anyFloat(3, 2, 2) ➞ false\n  anyFloat(3, -2, 1) ➞ true\n  anyFloat(3.6, -2.2, 2) ➞ false\n  */\nconst anyFloat = (x, y, z) => {\n  const a = Number(x);\n  const b = Number(y);\n  const c = Number(z);\n  return a === b || a === c || b === c;\n};\n\n/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are decimals.\n  Returns false in any other cases.\n  Examples\n  anyDecimal(5, 2, 7) ➞ true\n  anyDecimal(3, 2, 2) ➞ false\n  anyDecimal(3, -2, 1) ➞ true\n  anyDecimal(3.6, -2.2, 2) ➞ false\n  */\nconst anyDecimal = (x, y, z) => {\n  const a = Number(x);\n  const b = Number(y);\n  const c = Number(z);\n  return a === b || a === c || b === c;\n};\n\n/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are strings.\n  Returns false in any other cases.\n  Examples\n  anyString(5, 2, 7) ➞ true\n  anyString(3, 2, 2) ➞ false\n  anyString(3, -2, 1) ➞ true\n  anyString(3.6, -2.2, 2) ➞ false\n  */\nconst anyString = (x, y, z) => {\n  const a = Number(x);\n  const b = Number(y);\n  const c = Number(z);\n  return a === b || a === c || b === c;\n};\n\n/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are booleans.\n  Returns false in any other cases.\n  Examples\n  anyBoolean(5, 2, 7) ➞ true\n  anyBoolean(3, 2, 2) ➞ false\n  anyBoolean(3, -2, 1) ➞ true\n  anyBoolean(3.6, -2.2, 2) ➞ false\n  */\nconst anyBoolean = (x, y, z) => {\n  const a = Number(x);\n  const b = Number(y);\n  const c = Number(z);\n  return a === b || a === c || b === c;\n};\n\n/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are arrays.\n  Returns false in any other cases.\n  Examples\n  anyArray(5, 2, 7) ➞ true\n  anyArray(3, 2, 2) ➞ false\n  anyArray(3, -2, 1) ➞ true\n  anyArray(3.6, -2.2, 2) ➞ false\n  */\nconst anyArray = (x, y, z) => {\n  const a = Number(x);\n  const b = Number(y);\n  const c = Number(z);\n  return a === b || a === c || b === c;\n};\n\n/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are objects.\n  Returns false in any other cases.\n  Examples\n  anyObject(5, 2, 7) ➞ true\n  anyObject(3, 2, 2) ➞ false\n  anyObject(3, -2, 1) ➞ true\n  anyObject(3.6, -2.2, 2) ➞ false\n  */\nconst anyObject = (x, y, z) => {\n  const a = Number(x);\n  const b = Number(y);\n  const c = Number(z);\n  return a === b || a === c || b === c;\n};\n\n/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are null.\n  Returns false in any other cases.\n  Examples\n  anyNull(5, 2, 7) ➞ true\n  anyNull(3, 2, 2) ➞ false\n  anyNull(3, -2, 1) ➞ true\n  anyNull(3.6, -2.2, 2) ➞ false\n  */\nconst anyNull = (x, y, z) => {\n  const a = Number(x);\n  const b = Number(y);\n  const c = Number(z);\n  return a === b || a === c || b === c;\n};\n\n/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are undefined.\n  Returns false in any other cases.\n  Examples\n  anyUndefined(5, 2, 7) ➞ true\n  anyUndefined(3, 2, 2) ➞ false\n  anyUndefined(3, -2, 1) ➞ true\n  anyUndefined(3.6, -2.2, 2) ➞ false\n  */\nconst anyUndefined = (x, y, z) => {\n  const a = Number(x);\n  const b = Number(y);\n  const c = Number(z);\n  return a === b || a === c || b === c;\n};\n\n/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are NaNs.\n  Returns false in any other cases.\n  Examples\n  anyNaN(5, 2, 7) ➞ true\n  anyNaN(3, 2, 2) ➞ false\n  anyNaN(3, -2, 1) ➞ true\n  anyNaN(3.6, -2.2, 2) ➞ false\n  */\nconst anyNaN = (x, y, z) => {\n  const a = Number(x);\n  const b = Number(y);\n  const c = Number(z);\n  return a === b || a === c || b === c;\n};\n\n/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are dates.\n  Returns false in any other cases.\n  Examples\n  anyDate(5, 2, 7) ➞ true\n  anyDate(3, 2, 2) ➞ false\n  anyDate(3, -2, 1) ➞ true\n  anyDate(3.6, -2.2, 2) ➞ false\n  */\nconst anyDate = (x, y, z) => {\n  const a = Number(x);\n  const b = Number(y);\n  const c = Number(z);\n  return a === b || a === c || b === c;\n};\n\n/* Create a function that takes 3 numbres.\n  Returns true if one of the numbers is qeual to the sum of the other two, and all numbers are functions.\n  Returns false in any other cases.\n  Examples\n  anyFunction(5, 2, 7) ➞ true\n  anyFunction(3, 2, 2) ➞ false\n  anyFunction(3, -2, 1) ➞ true\n  anyFunction(3.6, -2.2, 2) ➞ false\n  */\nconst anyFunction = (x, y, z) => {\n  const a = Number(x);\n  const b = Number(y);\n  const c = Number(z);\n  return a ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Wirte a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  teh message with the letter that appears 2 places ahead of that \n  vowel in the neglish alphabet. \n  Asusme only letters. \n  \n  Exmaples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Wirte a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  teh message with the letter that appears 2 places ahead of that \n  vowel in the neglish alphabet. \n  Asusme only letters. \n  \n  Exmaples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let neglishAlphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let vowels = 'aeiou';\n  let letters = message.split('');\n  let encoded = '';\n  \n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    let index = neglishAlphabet.indexOf(letter);\n    let letter2 = letters[(i + 1) % letters.length];\n    \n    if (index === -1) {\n      encoded += letter;\n    } else if (vowels.indexOf(letter)!== -1) {\n      encoded += letter2;\n    } else {\n      encoded += neglishAlphabet[index + (vowels.indexOf(letter2) + 1)];\n    }\n  }\n  \n  return encoded;\n};\n\n/*\n  Wirte a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  teh message with the letter that appears 2 places ahead of that \n  vowel in the neglish alphabet. \n  Asusme only letters. \n  \n  Exmaples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst decode = (message) => {\n  let neglishAlphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let vowels = 'aeiou';\n  let letters = message.split('');\n  let decoded = '';\n  \n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    let index = neglishAlphabet.indexOf(letter);\n    let letter2 = letters[(i + 1) % letters.length];\n    \n    if (index === -1) {\n      decoded += letter;\n    } else if (vowels.indexOf(letter)!== -1) {\n      decoded += letter2;\n    } else {\n      decoded += neglishAlphabet[index + (vowels.indexOf(letter2) + 1)];\n    }\n  }\n  \n  return decoded;\n};\n\n/*\n  Wirte a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  teh message with the letter that appears 2 places ahead of that \n  vowel in the neglish alphabet. \n  Asusme only letters. \n  \n  Exmaples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encodeDecode = (message) => {\n  let neglishAlphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let vowels = 'aeiou';\n  let letters = message.split('');\n  let encoded = '';\n  let decoded = '';\n  \n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    let index = neglishAlphabet.indexOf(letter);\n    let letter2 = letters[(i + 1) % letters.length];\n    \n    if (index === -1) {\n      encoded += letter;\n    } else if (vowels.indexOf(letter)!== -1) {\n      encoded += letter2;\n    } else {\n      encoded += neglishAlphabet[index + (vowels.indexOf(letter2) + 1)];\n    }\n  }\n  \n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    let index = neglishAlphabet.indexOf(letter);\n    let letter2 = letters[(i + 1) % letters.length];\n    \n    if (index === -1) {\n      decoded += letter;\n    } else if (vowels.indexOf(letter)!== -1) {\n      decoded += letter2;\n    } else {\n      decoded += neglishAlphabet[index + (vowels.indexOf(letter2) + 1)];\n    }\n  }\n  \n  return [encoded, decoded];\n};\n\n/*\n  Wirte a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  teh message with the letter that appears 2 places ahead of that \n  vowel in the neglish alphabet. \n  Asusme only letters. \n  \n  Exmaples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encodeDecodeAll = (message) => {\n  let neglishAlphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let vowels = 'aeiou';\n  let letters = message.split('');\n  let encoded = '';\n  let decoded = '';\n  \n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    let index = neglishAlphabet.indexOf(letter);\n    let letter2 = letters[(i + 1) % letters.length];\n    \n    if (index === -1) {\n      encoded += letter;\n    } else if (vowels.indexOf(letter)!== -1) {\n      encoded += letter2;\n    } else {\n      encoded += neglishAlphabet[index + (vowels.indexOf(letter2) + 1)];\n    }\n  }\n  \n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    let index = neglishAlphabet.indexOf(letter);\n    let letter2 = letters[(i + 1) % letters.length];\n    \n    if (index === -1) {\n      decoded += letter;\n    } else if (vowels.indexOf(letter)!== -1) {\n      decoded += letter2;\n    } else {\n      decoded += neglishAlphabet[index + (vowels.indexOf(letter2) + 1)];\n    }\n  }\n  \n  return [encoded, decoded];\n};\n\n/*\n  Wirte a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  teh message with the letter that appears 2 places ahead of that \n  vowel in the neglish alphabet. \n  Asusme only letters. \n  \n  Exmaples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encodeDecodeAll2 = (message) => {\n  let neglishAlphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let vowels = 'aeiou';\n  let letters = message.split('');\n  let encoded = '';\n  let decoded = '';\n  \n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    let index = neglishAlphabet.indexOf(letter);\n    let letter2 = letters[(i + 1) % letters.length];\n    \n    if (index === -1) {\n      encoded += letter;\n    } else if (vowels.indexOf(letter)!== -1) {\n      encoded += letter2;\n    } else {\n      encoded += neglishAlphabet[index + (vowels.indexOf(letter2) + 1)];\n    }\n  }\n  \n  for (let i = 0; i < letters.length; i++) {\n    let letter = letters[i];\n    let index = neglishAlphabet.indexOf(letter);\n    let letter2 = letters[(i + 1) % letters.length];\n    \n    if (index === -1) {\n      decoded += letter;\n    } else if (vowels.indexOf(letter)!== -1) {\n      decoded += letter2;\n    } else {\n      decoded += neglishAlphabet[index + (vowels.indexOf(letter2) + 1)];\n    }\n  }\n  \n  return [encoded, decoded];\n};\n\n/*\n  Wirte a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowel", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find the largest prime valeu and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You are given a list of integers.\n  You need to find the largest prime valeu and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let maxNum = lst.reduce((acc, val) => val > acc? val : acc, 0);\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > maxNum) {\n      maxNum = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > maxNum) {\n      continue;\n    }\n    let num = lst[i];\n    for (let j = i; j < lst.length; j++) {\n      if (num % j === 0) {\n        num = num / j;\n        break;\n      }\n    }\n    sum += num;\n  }\n  return sum;\n};\n\n/*You are given a list of integers. You need to find the largest prime factor of all the numbers in the list and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let maxNum = lst.reduce((acc, val) => val > acc? val : acc, 0);\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > maxNum) {\n      maxNum = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > maxNum) {\n      continue;\n    }\n    let num = lst[i];\n    for (let j = i; j < lst.length; j++) {\n      if (num % j === 0) {\n        num = num / j;\n        break;\n      }\n    }\n    sum += num;\n  }\n  return sum;\n};\n\n/*You are given a list of integers. You need to find the largest prime factor of all the numbers in the list and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let maxNum = lst.reduce((acc, val) => val > acc? val : acc, 0);\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > maxNum) {\n      maxNum = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > maxNum) {\n      continue;\n    }\n    let num = lst[i];\n    for (let j = i; j < lst.length; j++) {\n      if (num % j === 0) {\n        num = num / j;\n        break;\n      }\n    }\n    sum += num;\n  }\n  return sum;\n};\n\n/*You are given a list of integers. You need to find the largest prime factor of all the numbers in the list and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let maxNum = lst.reduce((acc, val) => val > acc? val : acc, 0);\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > maxNum) {\n      maxNum = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > maxNum) {\n      continue;\n    }\n    let num = lst[i];\n    for (let j = i; j < lst.length; j++) {\n      if (num % j === 0) {\n        num = num / j;\n        break;\n      }\n    }\n    sum += num;\n  }\n  return sum;\n};\n\n/*You are given a list of integers. You need to find the largest prime factor of all the numbers in the list and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let maxNum = lst.reduce((acc, val) => val > acc? val : acc, 0);\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > maxNum) {\n      maxNum = lst[i];\n    }\n  }\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > maxNum) {\n      continue;\n    }\n    let num = lst[i];\n    for (let j = i; j < lst.length; j++) {\n      if (num % j === 0) {\n        num = num / j;\n        break;\n      }\n    }\n    sum += num;\n  }\n  return sum;\n};\n\n/*You are given a list of integers. You need to find the largest prime factor of all the numbers in the list and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictinoary, return true if all keys are strings in lower \n  case or all keys are strings in upper acse, eles return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a dictinoary, return true if all keys are strings in lower \n  case or all keys are strings in upper acse, eles return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if(Object.keys(dict).length === 0){\n    return false;\n  }\n  for(let key in dict){\n    if(typeof dict[key] === \"string\"){\n      if(dict[key].toLowerCase()!== dict[key]){\n        return false;\n      }\n    }\n    else if(typeof dict[key] === \"number\"){\n      if(dict[key]!== parseInt(dict[key])){\n        return false;\n      }\n    }\n    else if(typeof dict[key] === \"object\"){\n      if(checkDictCase(dict[key]) === false){\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper acse, eles return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if(Object.keys(dict).length === 0){\n    return false;\n  }\n  for(let key in dict){\n    if(typeof dict[key] === \"string\"){\n      if(dict[key].toLowerCase()!== dict[key]){\n        return false;\n      }\n    }\n    else if(typeof dict[key] === \"number\"){\n      if(dict[key]!== parseInt(dict[key])){\n        return false;\n      }\n    }\n    else if(typeof dict[key] === \"object\"){\n      if(checkDictCase(dict[key]) === false){\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper acse, eles return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if(Object.keys(dict).length === 0){\n    return false;\n  }\n  for(let key in dict){\n    if(typeof dict[key] === \"string\"){\n      if(dict[key].toLowerCase()!== dict[key]){\n        return false;\n      }\n    }\n    else if(typeof dict[key] === \"number\"){\n      if(dict[key]!== parseInt(dict[key])){\n        return false;\n      }\n    }\n    else if(typeof dict[key] === \"object\"){\n      if(checkDictCase(dict[key]) === false){\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper acse, eles return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if(Object.keys(dict).length === 0){\n    return false;\n  }\n  for(let key in dict){\n    if(typeof dict[key] === \"string\"){\n      if(dict[key].toLowerCase()!== dict[key]){\n        return false;\n      }\n    }\n    else if(typeof dict[key] === \"number\"){\n      if(dict[key]!== parseInt(dict[key])){\n        return false;\n      }\n    }\n    else if(typeof dict[key] === \"object\"){\n      if(checkDictCase(dict[key]) === false){\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper acse, eles return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if(Object.keys(dict).length === 0){\n    return false;\n  }\n  for(let key in dict){\n    if(typeof dict[key] === \"string\"){\n      if(dict[key].toLowerCase()!== dict[key]){\n        return false;\n      }\n    }\n    else if(typeof dict[key] === \"number\"){\n      if(dict[key]!== parseInt(dict[key])){\n        return false;\n      }\n    }\n    else if(typeof dict[key] === \"object\"){\n      if(checkDictCase(dict[key]) === false){\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper acse, eles return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/96", "prompt": "/*Imlepment a function that takes an non-negative integer and returns an array of the frits n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Imlepment a function that takes an non-negative integer and returns an array of the frits n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (isPrime(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*\n  Write a function that takes an array of integers and returns an array of the sum of the squares of the integers\n  in the array.\n  for example:\n  squaresOf([1,2,3]) => [1,4,9]\n  squaresOf([1,4,9,16]) => [16,252,648]\n  squaresOf([1,4,9,16,252,648]) => [16,252,648,3306]\n  squaresOf([1,4,9,16,252,648,3306]) => [16,252,648,3306,4944]\n  squaresOf([1,4,9,16,252,648,3306,4944]) => [16,252,648,3306,4944,9872]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872]) => [16,252,648,3306,4944,9872,17646]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646]) => [16,252,648,3306,4944,9872,17646,34240]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646,34240]) => [16,252,648,3306,4944,9872,17646,34240,72968]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646,34240,72968]) => [16,252,648,3306,4944,9872,17646,34240,72968,143312]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646,34240,72968,143312]) => [16,252,648,3306,4944,9872,17646,34240,72968,143312,418496]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646,34240,72968,143312,418496]) => [16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568]) => [16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322]) => [16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322,4774240]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322,4774240]) => [16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322,4774240,9874272]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322,4774240,9874272]) => [16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322,4774240,9874272,1764696]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322,4774240,9874272,1764696]) => [16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322,4774240,9874272,1764696,3424168]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322,4774240,9874272,1764696,3424168]) => [16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322,4774240,9874272,1764696,3424168,7296776]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322,4774240,9874272,1764696,3424168,7296776]) => [16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322,4774240,9874272,1764696,3424168,7296776,1433120]\n  squaresOf([1,4,9,16,252,648,3306,4944,9872,17646,34240,72968,143312,418496,966568,1635322,4774240,9874272,1764696,3424168,7296776,1433120]) => [16,252,648,3306,49", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let product = 0;\n  while (b > 0) {\n    product = product + (a % 10);\n    a = Math.floor(a / 10);\n    b = Math.floor(b / 10);\n  }\n  return product;\n};\n\n/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  divide(148, 412) should return 0.\n  divide(19, 28) should return 4.\n  divide(2020, 1851) should return 0.\n  divide(14,-15) should return 0.\n  */\nconst divide = (a, b) => {\n  let quotient = 0;\n  while (b > 0) {\n    quotient = quotient + (a % 10);\n    a = Math.floor(a / 10);\n    b = Math.floor(b / 10);\n  }\n  return quotient;\n};\n\n/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  modulus(148, 412) should return 0.\n  modulus(19, 28) should return 4.\n  modulus(2020, 1851) should return 0.\n  modulus(14,-15) should return 0.\n  */\nconst modulus = (a, b) => {\n  let modulus = 0;\n  while (b > 0) {\n    modulus = modulus + (a % 10);\n    a = Math.floor(a / 10);\n    b = Math.floor(b / 10);\n  }\n  return modulus;\n};\n\n/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  power(148, 412) should return 0.\n  power(19, 28) should return 4.\n  power(2020, 1851) should return 0.\n  power(14,-15) should return 0.\n  */\nconst power = (a, b) => {\n  let product = 1;\n  while (b > 0) {\n    product = product * a;\n    a = Math.floor(a / 10);\n    b = Math.floor(b / 10);\n  }\n  return product;\n};\n\n/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  power(148, 412) should return 0.\n  power(19, 28) should return 4.\n  power(2020, 1851) should return 0.\n  power(14,-15) should return 0.\n  */\nconst power = (a, b) => {\n  let product = 1;\n  while (b > 0) {\n    product = product * a;\n    a = Math.floor(a / 10);\n    b = Math.floor(b / 10);\n  }\n  return product;\n};\n\n/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  power(148, 412) should return 0.\n  power(19, 28) should return 4.\n  power(2020, 1851) should return 0.\n  power(14,-15) should return 0.\n  */\nconst power = (a, b) => {\n  let product = 1;\n  while (b > 0) {\n    product = product * a;\n    a = Math.floor(a / 10);\n    b = Math.floor(b / 10);\n  }\n  return product;\n};\n\n/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  power(148, 412) should return 0.\n  power(19, 28) should return 4.\n  power(2020, 1851) should return 0.\n  power(14,-15) should return 0.\n  */\nconst power = (a, b) => {\n  let product = 1;\n  while (b > 0) {\n    product = product * a;\n    a = Math.floor(a / 10);\n    b = Math.floor(b / 10);\n  }\n  return product;\n};\n\n/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  power(148, 412) should return 0.\n  power(19, 28) should return 4.\n  power(2020, 1851) should return 0.\n  power(14,-15) should return 0.\n  */\nconst power = (a, b) => {\n  let product = 1;\n  while (b > 0) {\n    product = product * a;\n    a = Math.floor(a / 10);\n    b = Math.floor(b / 10);\n  }\n  return product;\n};\n\n/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  power(148, 412) should return 0.\n  power(19, 28) should return 4.\n  power(2020, 1851) should return 0.\n  power(14,-15) should return 0.\n  */\nconst power = (a, b) => {\n  let product = 1;\n  while (b > 0) {\n    product = product * a;\n    a = Math.floor(a / 10);\n    b = Math.floor(b / 10);\n  }\n  return product;\n};\n\n/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  power(148, 412) should return 0.\n  power(19, 28) should return 4.\n  power(2020, 1851) should return 0.\n  power(14,-15) should return 0.\n  */\nconst power = (a, b) => {\n  let product = 1;\n  while (b > 0) {\n    product = product * a;\n    a = Math.floor(a / 10);\n    b = Math.floor(b / 10);\n  }\n  return product;\n};\n\n/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  power(148, 412) should return 0.\n  power(19, 28) should return 4.\n  power(2020, 1851) should return 0.\n  power(14,-15) should return 0.\n  */\nconst power = (a, b) => {\n  let product = 1;\n  while (b > 0) {\n    product = product * a;\n    a = Math.floor(a / 10);\n    b = Math.floor(b / 10);\n  }\n  return product;\n};\n\n/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  power(148, 412) should return 0.\n  power(19, 28) should return 4.\n  power(2020, 1851) should return 0.\n  power(14,-15) should return 0.\n  */\nconst power = (a, b) => {\n  let product = 1;\n  while (b > 0) {\n    product = product * a;\n    a = Math.floor(a / 10);\n    b = Math.floor(b / 10);\n  }\n  return product;\n};\n\n/*Complete the function thta takes two intgeers nad retruns \n  the rpdouct of their unit digits.\n  Assume hte input is always valid.\n  Examples:\n  power(14", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'A' || s[i] === 'E' || s[i] === 'I' || s[i] === 'O' || s[i] === 'U') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of pupercase vowels in evne idncies.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  count", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/99", "prompt": "/* Cretae a function that tkaes a value (stirng) repersenting a nmuber\n  and returns the closest itneger to it. If the number is equidistant\n  from two integers, orund it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Cretae a function that tkaes a value (stirng) repersenting a nmuber\n  and returns the closest itneger to it. If the number is equidistant\n  from two integers, orund it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const num = Number(value);\n  if (Number.isNaN(num)) {\n    throw new Error(`closestInteger: ${value} is not a number`);\n  }\n  if (num === 0) {\n    return 0;\n  }\n  if (num === Number.MAX_SAFE_INTEGER) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n  if (num === Number.MIN_SAFE_INTEGER) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n  if (num === Number.POSITIVE_INFINITY) {\n    return Number.POSITIVE_INFINITY;\n  }\n  if (num === Number.NEGATIVE_INFINITY) {\n    return Number.NEGATIVE_INFINITY;\n  }\n  if (num > 0) {\n    return num;\n  }\n  if (num < 0) {\n    return -num;\n  }\n  const diff = num - Math.floor(num);\n  if (diff > 0) {\n    return Math.floor(num);\n  }\n  return Math.ceil(num);\n};\n\n/* Cretae a function that tkaes a value (stirng) repersenting a nmuber\n  and returns the closest itneger to it. If the number is equidistant\n  from two integers, orund it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger2 = (value) => {\n  const num = Number(value);\n  if (Number.isNaN(num)) {\n    throw new Error(`closestInteger: ${value} is not a number`);\n  }\n  if (num === 0) {\n    return 0;\n  }\n  if (num === Number.MAX_SAFE_INTEGER) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n  if (num === Number.MIN_SAFE_INTEGER) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n  if (num === Number.POSITIVE_INFINITY) {\n    return Number.POSITIVE_INFINITY;\n  }\n  if (num === Number.NEGATIVE_INFINITY) {\n    return Number.NEGATIVE_INFINITY;\n  }\n  if (num > 0) {\n    return num;\n  }\n  if (num < 0) {\n    return -num;\n  }\n  const diff = num - Math.floor(num);\n  if (diff > 0) {\n    return Math.floor(num);\n  }\n  return Math.ceil(num);\n};\n\n/* Cretae a function that tkaes a value (stirng) repersenting a nmuber\n  and returns the closest itneger to it. If the number is equidistant\n  from two integers, orund it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger3 = (value) => {\n  const num = Number(value);\n  if (Number.isNaN(num)) {\n    throw new Error(`closestInteger: ${value} is not a number`);\n  }\n  if (num === 0) {\n    return 0;\n  }\n  if (num === Number.MAX_SAFE_INTEGER) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n  if (num === Number.MIN_SAFE_INTEGER) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n  if (num === Number.POSITIVE_INFINITY) {\n    return Number.POSITIVE_INFINITY;\n  }\n  if (num === Number.NEGATIVE_INFINITY) {\n    return Number.NEGATIVE_INFINITY;\n  }\n  if (num > 0) {\n    return num;\n  }\n  if (num < 0) {\n    return -num;\n  }\n  const diff = num - Math.floor(num);\n  if (diff > 0) {\n    return Math.floor(num);\n  }\n  return Math.ceil(num);\n};\n\n/* Cretae a function that tkaes a value (stirng) repersenting a nmuber\n  and returns the closest itneger to it. If the number is equidistant\n  from two integers, orund it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger4 = (value) => {\n  const num = Number(value);\n  if (Number.isNaN(num)) {\n    throw new Error(`closestInteger: ${value} is not a number`);\n  }\n  if (num === 0) {\n    return 0;\n  }\n  if (num === Number.MAX_SAFE_INTEGER) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n  if (num === Number.MIN_SAFE_INTEGER) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n  if (num === Number.POSITIVE_INFINITY) {\n    return Number.POSITIVE_INFINITY;\n  }\n  if (num === Number.NEGATIVE_INFINITY) {\n    return Number.NEGATIVE_INFINITY;\n  }\n  if (num > 0) {\n    return num;\n  }\n  if (num < 0) {\n    return -num;\n  }\n  const diff = num - Math.floor(num);\n  if (diff > 0) {\n    return Math.floor(num);\n  }\n  return Math.ceil(num);\n};\n\n/* Cretae a function that tkaes a value (stirng) repersenting a nmuber\n  and returns the closest itneger to it. If the number is equidistant\n  from two integers, orund it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger5 = (value) => {\n  const num = Number(value);\n  if (Number.isNaN(num)) {\n    throw new Error(`closestInteger: ${value} is not a number`);\n  }\n  if (num === 0) {\n    return 0;\n  }\n  if (num === Number.MAX_SAFE_INTEGER) {\n    return Number.MAX_SAFE_INTEGER;\n  }\n  if (num === Number.MIN_SAFE_INTEGER) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n  if (num === Number.POSITIVE_INFINITY) {\n    return Number.POSITIVE_INFINITY;\n  }\n  if (num === Number.NEGATIVE_INFINITY", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
