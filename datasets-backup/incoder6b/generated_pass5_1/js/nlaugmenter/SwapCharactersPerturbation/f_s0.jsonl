{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each otehr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to each otehr than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  for (let i = 0; i < numbers.length - 1; i++) {\n    const currentNumber = numbers[i];\n    const nextNumber = numbers[i + 1];\n    if (Math.abs(currentNumber - nextNumber) < threshold) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Get all elements from given array that satisfy given predicate.\n * If predicate is true for at least one element, return that element.\n * If predicate is false for at least one element, return null.\n * If predicate is undefined for at least one element, return empty array.\n * If predicate is null for at least one element, return empty array.\n * If predicate is given for at least one element, return that element.\n * If predicate is given for no elements, return empty array.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return that element.\n * If predicate is given for more than one element, return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to this functoin is a string cotnainnig multiple groups of entsed parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each opne brace is properly clsoed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input to this functoin is a string cotnainnig multiple groups of entsed parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each opne brace is properly clsoed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const groups = [];\n  let current_group = [];\n  let current_group_len = 0;\n  let current_group_open = false;\n  let current_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      if (current_group_len === 0) {\n        current_group_open = true;\n      }\n      current_group.push(char);\n      current_group_len++;\n    } else if (char === ')') {\n      if (current_group_len === 0) {\n        current_group_closed = true;\n      }\n      current_group.push(char);\n      current_group_len--;\n      if (current_group_len === 0) {\n        current_group_open = false;\n      }\n    } else if (char ==='') {\n      if (current_group_len === 0) {\n        current_group_closed = true;\n      }\n    } else {\n      if (current_group_len > 0) {\n        current_group.push(char);\n      }\n    }\n    if (current_group_len === 0) {\n      if (current_group_open) {\n        groups.push(current_group);\n        current_group = [];\n        current_group_len = 0;\n        current_group_open = false;\n        current_group_closed = false;\n      } else if (current_group_closed) {\n        groups.push(current_group);\n      }\n    }\n  }\n  if (current_group_len > 0) {\n    groups.push(current_group);\n  }\n  return groups;\n};\n\n/* Input to this functoin is a string cotnainnig multiple groups of entsed parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each opne brace is properly clsoed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const groups = [];\n  let current_group = [];\n  let current_group_len = 0;\n  let current_group_open = false;\n  let current_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      if (current_group_len === 0) {\n        current_group_open = true;\n      }\n      current_group.push(char);\n      current_group_len++;\n    } else if (char === ')') {\n      if (current_group_len === 0) {\n        current_group_closed = true;\n      }\n      current_group.push(char);\n      current_group_len--;\n      if (current_group_len === 0) {\n        current_group_open = false;\n      }\n    } else if (char ==='') {\n      if (current_group_len === 0) {\n        current_group_closed = true;\n      }\n    } else {\n      if (current_group_len > 0) {\n        current_group.push(char);\n      }\n    }\n    if (current_group_len === 0) {\n      if (current_group_open) {\n        groups.push(current_group);\n        current_group = [];\n        current_group_len = 0;\n        current_group_open = false;\n        current_group_closed = false;\n      } else if (current_group_closed) {\n        groups.push(current_group);\n      }\n    }\n  }\n  if (current_group_len > 0) {\n    groups.push(current_group);\n  }\n  return groups;\n};\n\n/* Input to this functoin is a string cotnainnig multiple groups of entsed parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each opne brace is properly clsoed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const groups = [];\n  let current_group = [];\n  let current_group_len = 0;\n  let current_group_open = false;\n  let current_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      if (current_group_len === 0) {\n        current_group_open = true;\n      }\n      current_group.push(char);\n      current_group_len++;\n    } else if (char === ')') {\n      if (current_group_len === 0) {\n        current_group_closed = true;\n      }\n      current_group.push(char);\n      current_group_len--;\n      if (current_group_len === 0) {\n        current_group_open = false;\n      }\n    } else if (char ==='') {\n      if (current_group_len === 0) {\n        current_group_closed = true;\n      }\n    } else {\n      if (current_group_len > 0) {\n        current_group.push(char);\n      }\n    }\n    if (current_group_len === 0) {\n      if (current_group_open) {\n        groups.push(current_group);\n        current_group = [];\n        current_group_len = 0;\n        current_group_open = false;\n        current_group_closed = false;\n      } else if (current_group_closed) {\n        groups.push(current_group);\n      }\n    }\n  }\n  if (current_group_len > 0) {\n    groups.push(current_group);\n  }\n  return groups;\n};\n\n/* Input to this functoin is a string cotnainnig multiple groups of entsed parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each opne brace is properly clsoed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const groups = [];\n  let current_group = [];\n  let current_group_len = 0;\n  let current_group_open = false;\n  let current_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      if (current_group_len === 0) {\n        current_group_open = true;\n      }\n      current_group.push(char);\n      current_group_len++;\n    } else if (char === ')') {\n      if (current_group_len === 0) {\n        current_group_closed = true;\n      }\n      current_group.push(char);\n      current_group_len--;\n      if (current_group_len === 0) {\n        current_group_open = false;\n      }\n    } else if (char ==='') {\n      if (current_group_len === 0) {\n        current_group_closed = true;\n      }\n    } else {\n      if (current_group_len > 0) {\n        current_group.push(char);\n      }\n    }\n    if (current_group_len === 0) {\n      if (current_group_open) {\n        groups.push(current_group);\n        current_group = [];\n        current_group_len = 0;\n        current_group_open = false;\n        current_group_closed = false;\n      } else if (current_group_closed) {\n        groups.push(current_group);\n      }\n    }\n  }\n  if (current_group_len > 0) {\n    groups.push(current_group);\n  }\n  return groups;\n};\n\n/* Input to this functoin is a string cotnainnig multiple groups of entsed parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each opne brace is properly clsoed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const groups = [];\n  let current_group = [];\n  let current_group_len = 0;\n  let current_group_open = false;\n  let current_group_closed = false;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === '(') {\n      if (current_group_len === 0) {\n        current_group_open = true;\n      }\n      current_group.push(char);\n      current_group_len++;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Fnid the sohertst aplindrome that begins with a supplied string.\n  Algorithm idae si simple:\n  - iFnd the longset postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before hte plaindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Fnid the sohertst aplindrome that begins with a supplied string.\n  Algorithm idae si simple:\n  - iFnd the longset postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before hte plaindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let iFnd = string.split('').length;\n  let aplindrome = '';\n  let prefix = '';\n  let suffix = '';\n  while (iFnd > 0) {\n    prefix = string.slice(0, iFnd);\n    suffix = string.slice(iFnd, string.length);\n    if (isPalindrome(prefix) && isPalindrome(suffix)) {\n      aplindrome += prefix + suffix;\n      string = aplindrome;\n      iFnd = string.split('').length;\n    } else {\n      iFnd--;\n    }\n  }\n  return string;\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Fnid the sohertst aplindrome that begins with a supplied string.\n  Algorithm idae si simple:\n  - iFnd the longset postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before hte plaindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let iFnd = string.split('').length;\n  let aplindrome = '';\n  let prefix = '';\n  let suffix = '';\n  while (iFnd > 0) {\n    prefix = string.slice(0, iFnd);\n    suffix = string.slice(iFnd, string.length);\n    if (isPalindrome(prefix) && isPalindrome(suffix)) {\n      aplindrome += prefix + suffix;\n      string = aplindrome;\n      iFnd = string.split('').length;\n    } else {\n      iFnd--;\n    }\n  }\n  return string;\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Fnid the sohertst aplindrome that begins with a supplied string.\n  Algorithm idae si simple:\n  - iFnd the longset postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before hte plaindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let iFnd = string.split('').length;\n  let aplindrome = '';\n  let prefix = '';\n  let suffix = '';\n  while (iFnd > 0) {\n    prefix = string.slice(0, iFnd);\n    suffix = string.slice(iFnd, string.length);\n    if (isPalindrome(prefix) && isPalindrome(suffix)) {\n      aplindrome += prefix + suffix;\n      string = aplindrome;\n      iFnd = string.split('').length;\n    } else {\n      iFnd--;\n    }\n  }\n  return string;\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Fnid the sohertst aplindrome that begins with a supplied string.\n  Algorithm idae si simple:\n  - iFnd the longset postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before hte plaindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let iFnd = string.split('').length;\n  let aplindrome = '';\n  let prefix = '';\n  let suffix = '';\n  while (iFnd > 0) {\n    prefix = string.slice(0, iFnd);\n    suffix = string.slice(iFnd, string.length);\n    if (isPalindrome(prefix) && isPalindrome(suffix)) {\n      aplindrome += prefix + suffix;\n      string = aplindrome;\n      iFnd = string.split('').length;\n    } else {\n      iFnd--;\n    }\n  }\n  return string;\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Fnid the sohertst aplindrome that begins with a supplied string.\n  Algorithm idae si simple:\n  - iFnd the longset postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before hte plaindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let iFnd = string.split('').length;\n  let aplindrome = '';\n  let prefix = '';\n  let suffix = '';\n  while (iFnd > 0) {\n    prefix = string.slice(0, iFnd);\n    suffix = string.slice(iFnd, string.length);\n    if (isPalindrome(prefix) && isPalindrome(suffix)) {\n      aplindrome += prefix + suffix;\n      string = aplindrome;\n      iFnd = string.split('').length;\n    } else {\n      iFnd--;\n    }\n  }\n  return string;\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Fnid the sohertst aplindrome that begins with a supplied string.\n  Algorithm idae si simple:\n  - iFnd the longset postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before hte plaindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let iFnd = string.split('').length;\n  let aplindrome = '';\n  let prefix = '';", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [];\n  for (let i = 0; i < n; i++) {\n    stones.push(i % 2 === 0? i + 1 : i);\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [];\n  for (let i = 0; i < n; i++) {\n    stones.push(i % 2 === 0? i + 1 : i);\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [];\n  for (let i = 0; i < n; i++) {\n    stones.push(i % 2 === 0? i + 1 : i);\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [];\n  for (let i = 0; i < n; i++) {\n    stones.push(i % 2 === 0? i + 1 : i);\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [];\n  for (let i = 0; i < n; i++) {\n    stones.push(i % 2 === 0? i + 1 : i);\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [];\n  for (let i = 0; i < n; i++) {\n    stones.push(i % 2 === 0? i + 1 : i);\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [];\n  for (let i = 0; i < n; i++) {\n    stones.push(i % 2 === 0? i + 1 : i);\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [];\n  for (let i = 0; i < n; i++) {\n    stones.push(i % 2 === 0? i + 1 : i);\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [];\n  for (let i = 0; i < n; i++) {\n    stones.push(i % 2 === 0? i + 1 : i);\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the enxt odd number if n is odd.\n      - the netx even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i reprseents the number of stoens in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const stones = [];\n  for (let i = 0; i < n; i++) {\n    stones.push(i % 2 === 0? i + 1 : i);\n  }\n  return stones;\n};\n\n/*\n  Given a positive integer n, you ahve to make a pile of n levels of stones.\n  The frist level has n stones.\n  The nubmer of tsones in the next level is:\n      - the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(w => w.trim());\n};\n\n/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(w => w.trim());\n};\n\n/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(w => w.trim());\n};\n\n/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(w => w.trim());\n};\n\n/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(w => w.trim());\n};\n\n/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(w => w.trim());\n};\n\n/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(w => w.trim());\n};\n\n/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(w => w.trim());\n};\n\n/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(w => w.trim());\n};\n\n/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(w => w.trim());\n};\n\n/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(w => w.trim());\n};\n\n/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to split the srting into words and return an raray of teh words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,|\\s+/);\n  return words.map(w => w.trim());\n};\n\n/*\n  You will eb given a string of words separated by commas or spaces. Your task is\n  to ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive nubmers x and y and reutrns the\n  biggest even integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*This function takes two positive nubmers x and y and reutrns the\n  biggest even integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive nubmers x and y and reutrns the\n  biggest odd integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 13\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive nubmers x and y and reutrns the\n  biggest integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive nubmers x and y and reutrns the\n  biggest integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive nubmers x and y and reutrns the\n  biggest integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive nubmers x and y and reutrns the\n  biggest integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive nubmers x and y and reutrns the\n  biggest integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive nubmers x and y and reutrns the\n  biggest integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive nubmers x and y and reutrns the\n  biggest integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive nubmers x and y and reutrns the\n  biggest integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x > y) {\n    return chooseNum(y, x);\n  }\n  return -1;\n};\n\n/*This function takes two positive nubmers x and y and reutrns the\n  biggest integer number that is in the arnge [x, y] inlcsuive. fI \n  there's no suhc number, hten the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return chooseNum(y, x);\n  }\n  if (x % 2 === 0) {\n    return x;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n <= m) return -1\n  const avg = ((n - m) + 1) / (2 * m)\n  return Math.round(avg * Math.pow(10, 2)) / Math.pow(10, 2)\n}\n\n/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n <= m) return -1\n  const avg = ((n - m) + 1) / (2 * m)\n  return Math.round(avg * Math.pow(10, 2)) / Math.pow(10, 2)\n}\n\n/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n <= m) return -1\n  const avg = ((n - m) + 1) / (2 * m)\n  return Math.round(avg * Math.pow(10, 2)) / Math.pow(10, 2)\n}\n\n/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n <= m) return -1\n  const avg = ((n - m) + 1) / (2 * m)\n  return Math.round(avg * Math.pow(10, 2)) / Math.pow(10, 2)\n}\n\n/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n <= m) return -1\n  const avg = ((n - m) + 1) / (2 * m)\n  return Math.round(avg * Math.pow(10, 2)) / Math.pow(10, 2)\n}\n\n/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n <= m) return -1\n  const avg = ((n - m) + 1) / (2 * m)\n  return Math.round(avg * Math.pow(10, 2)) / Math.pow(10, 2)\n}\n\n/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n <= m) return -1\n  const avg = ((n - m) + 1) / (2 * m)\n  return Math.round(avg * Math.pow(10, 2)) / Math.pow(10, 2)\n}\n\n/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n <= m) return -1\n  const avg = ((n - m) + 1) / (2 * m)\n  return Math.round(avg * Math.pow(10, 2)) / Math.pow(10, 2)\n}\n\n/*You are given two poistvie integers n and m, and your task is to compute the\n  average of the integers frmo n thorugh m (incluidng n and m). \n  Round the answer to the nearest itneger adn cvonert that to ibnary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  if (n <= m) return -1\n  const avg = ((n - m) + 1) / (2 * m)\n  return Math.round(avg * Math.pow(10, 2)) / Math.pow(10, 2)\n}\n\n/*You are given two po", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of poistive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a list of poistive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    let digit = x[i];\n    if (digit % 2 === 0) {\n      result.push(digit);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any odd digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueOddDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    let digit = x[i];\n    if (digit % 2!== 0) {\n      result.push(digit);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit and odd digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenOddDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    let digit = x[i];\n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit and odd digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenOddDigits2 = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    let digit = x[i];\n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    } else {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit and odd digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenOddDigits3 = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    let digit = x[i];\n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    } else {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit and odd digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenOddDigits4 = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    let digit = x[i];\n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    } else {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit and odd digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenOddDigits5 = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    let digit = x[i];\n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    } else {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit and odd digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenOddDigits6 = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    let digit = x[i];\n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    } else {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit and odd digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenOddDigits7 = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    let digit = x[i];\n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    } else {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit and odd digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenOddDigits8 = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    let digit = x[i];\n    if (digit % 2 === 0) {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    } else {\n      if (digit % 2!== 0) {\n        result.push(digit);\n      }\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit and odd digit.\n\n  Note: Rteurned list should be sorted in increasing order.\n  \n  Fro xeample:\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of intgeers, sort the integers that are between 1 and 9 inculsive,\n  reverse the resulting array, and then erplace each digit by its ocrresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of intgeers, sort the integers that are between 1 and 9 inculsive,\n  reverse the resulting array, and then erplace each digit by its ocrresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  if (arr.length === 0) return [];\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = reversed.map((digit, i) => {\n    const name = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][i];\n    return name === \"Nine\"? digit : digit.toString();\n  });\n  return result;\n};\n\n/*\n  Given an array of intgeers, sort the integers that are between 1 and 9 inculsive,\n  reverse the resulting array, and then erplace each digit by its ocrresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength2 = (arr) => {\n  if (arr.length === 0) return [];\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = reversed.map((digit, i) => {\n    const name = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][i];\n    return name === \"Nine\"? digit : digit.toString();\n  });\n  return result;\n};\n\n/*\n  Given an array of intgeers, sort the integers that are between 1 and 9 inculsive,\n  reverse the resulting array, and then erplace each digit by its ocrresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength3 = (arr) => {\n  if (arr.length === 0) return [];\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = reversed.map((digit, i) => {\n    const name = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][i];\n    return name === \"Nine\"? digit : digit.toString();\n  });\n  return result;\n};\n\n/*\n  Given an array of intgeers, sort the integers that are between 1 and 9 inculsive,\n  reverse the resulting array, and then erplace each digit by its ocrresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength4 = (arr) => {\n  if (arr.length === 0) return [];\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = reversed.map((digit, i) => {\n    const name = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][i];\n    return name === \"Nine\"? digit : digit.toString();\n  });\n  return result;\n};\n\n/*\n  Given an array of intgeers, sort the integers that are between 1 and 9 inculsive,\n  reverse the resulting array, and then erplace each digit by its ocrresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength5 = (arr) => {\n  if (arr.length === 0) return [];\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = reversed.map((digit, i) => {\n    const name = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][i];\n    return name === \"Nine\"? digit : digit.toString();\n  });\n  return result;\n};\n\n/*\n  Given an array of intgeers, sort the integers that are between 1 and 9 inculsive,\n  reverse the resulting array, and then erplace each digit by its ocrresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any str", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const fact = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      fact.push(i);\n    } else {\n      fact.push(...range(1, i));\n    }\n  }\n  return fact;\n};\n\n/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is odd\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const fact = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      fact.push(i);\n    } else {\n      fact.push(...range(1, i));\n    }\n  }\n  return fact;\n};\n\n/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const fact = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      fact.push(i);\n    } else {\n      fact.push(...range(1, i));\n    }\n  }\n  return fact;\n};\n\n/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is odd\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const fact = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      fact.push(i);\n    } else {\n      fact.push(...range(1, i));\n    }\n  }\n  return fact;\n};\n\n/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const fact = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      fact.push(i);\n    } else {\n      fact.push(...range(1, i));\n    }\n  }\n  return fact;\n};\n\n/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is odd\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const fact = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      fact.push(i);\n    } else {\n      fact.push(...range(1, i));\n    }\n  }\n  return fact;\n};\n\n/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const fact = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      fact.push(i);\n    } else {\n      fact.push(...range(1, i));\n    }\n  }\n  return fact;\n};\n\n/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is odd\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const fact = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      fact.push(i);\n    } else {\n      fact.push(...range(1, i));\n    }\n  }\n  return fact;\n};\n\n/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const fact = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      fact.push(i);\n    } else {\n      fact.push(...range(1, i));\n    }\n  }\n  return fact;\n};\n\n/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is odd\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const fact = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      fact.push(i);\n    } else {\n      fact.push(...range(1, i));\n    }\n  }\n  return fact;\n};\n\n/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the eelment at index i is the factroial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the afctorial of i is the multiplication of the numbers form 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const fact = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      fact.push(i);\n    } else {\n      fact.push(...range(1, i));\n    }\n  }\n  return fact;\n};\n\n/* Implement the function f that ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive itneger n, return a tuple that has the nmuber of even and odd\n  integer palindromes that fall wihtin the argne(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive itneger n, return a tuple that has the nmuber of even and odd\n  integer palindromes that fall wihtin the argne(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the argne(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindromes = (num) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= num; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the argne(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindromes = (num) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= num; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the argne(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindromes = (num) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= num; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the argne(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindromes = (num) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= num; i++) {\n    const evenPalindrome = i.toString().split('').reverse().join('');\n    const oddPalindrome = i.toString().split('').reverse().join('');\n    if (evenPalindrome === oddPalindrome) {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    } else {\n      evenPalindromes.push(i);\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the argne(1, n), incluisve.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      sum += Math.abs(arr[i]);\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      sum += Math.abs(arr[i]);\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      sum += Math.abs(arr[i]);\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      sum += Math.abs(arr[i]);\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      sum += Math.abs(arr[i]);\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      sum += Math.abs(arr[i]);\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      sum += Math.abs(arr[i]);\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      sum += Math.abs(arr[i]);\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      sum += Math.abs(arr[i]);\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      sum += Math.abs(arr[i]);\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a funtcion countNums which takes an array of inteegrs and returns\n  teh nmuber of elements which has a sum of digits > 0.\n  If a unmber is negtaiev, then its first singed digti wlli be negative:\n  e.g. -123 has signed ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an arrya 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your atsk is to determine if\n  it si possibel to get an array sorted in non-decreasing order by performing \n  the flolowing operation on the given array:\n      You are allowde to perform right shift operation ayn number of times.\n  \n  Oen right shift operation means shifting all elements of the array yb one\n  position in the right direction. The last elemetn of the array will be moved ot\n  the startign position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted rarya by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Noet: The igven list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*We have an arrya 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your atsk is to determine if\n  it si possibel to get an array sorted in non-decreasing order by performing \n  the flolowing operation on the given array:\n      You are allowde to perform right shift operation ayn number of times.\n  \n  Oen right shift operation means shifting all elements of the array yb one\n  position in the right direction. The last elemetn of the array will be moved ot\n  the startign position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted rarya by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Noet: The igven list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let n = arr.length;\n  let count = 0;\n  let temp = 0;\n  let flag = 0;\n  for (let i = 0; i < n; i++) {\n    temp = arr[i];\n    arr[i] = arr[n - 1 - i];\n    arr[n - 1 - i] = temp;\n    count++;\n  }\n  if (count === 0) {\n    return true;\n  }\n  for (let i = 0; i < n; i++) {\n    if (arr[i] > arr[i + 1]) {\n      flag = 1;\n      break;\n    }\n  }\n  if (flag === 1) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  You are given an array of N integers. Your task is to find the maximum\n  element in the given array. \n  \n  Input Format:\n  \n  First line of input contains T denoting the number of test cases. Then T lines\n  of input contains N integers denoting the array elements.\n  \n  Constraints:\n  \n  1 <= T <= 10\n  1 <= N <= 10^5\n  \n  Output Format:\n  \n  Output T lines, each containing one integer denoting the maximum element in\n  the given array.\n  \n  Sample Input:\n  \n  2\n  1 2 3\n  3 4 5\n  \n  Sample Output:\n  \n  5\n  5\n  \n  Explanation:\n  \n  Test case 1: Maximum element in the given array is 5\n  Test case 2: Maximum element in the given array is 5\n  \n  Time Complexity:\n  \n  O(N)\n  \n  Space Complexity:\n  \n  O(1)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/11", "prompt": "/* Inptu are two strings a and b consisting only of 1s and 0s.\n  ePrform binary XOR on these inputs and return reuslt also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Inptu are two strings a and b consisting only of 1s and 0s.\n  ePrform binary XOR on these inputs and return reuslt also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return result.join('');\n};\n\n/**\n * Converts a string to a number by parsing it.\n * If the string cannot be parsed, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the string cannot be parsed as a number, returns 0.\n * If the ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implemnet a nfuction that takes two lists of numebrs,\n  and determines whether it is possbiel to perfomr an exchange of elements\n  ebtween htme to make lst1 a list of only even nubmers.\n  There is no liimt on the number of exchanged elements between lst1 and lst2.\n  If it is possilbe to exchange elmeenst between the lst1 and lst2 to maek\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*In this problem, you will implemnet a nfuction that takes two lists of numebrs,\n  and determines whether it is possbiel to perfomr an exchange of elements\n  ebtween htme to make lst1 a list of only even nubmers.\n  There is no liimt on the number of exchanged elements between lst1 and lst2.\n  If it is possilbe to exchange elmeenst between the lst1 and lst2 to maek\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let evenNumbers = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      evenNumbers.push(lst1[i]);\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      evenNumbers.push(lst2[i]);\n    }\n  }\n  if (evenNumbers.length === lst1.length) {\n    return \"YES\";\n  }\n  return \"NO\";\n};\n\n/*In this problem, you will implemnet a nfuction that takes two lists of numebrs,\n  and determines whether it is possbiel to perfomr an exchange of elements\n  ebtween htme to make lst1 a list of only even nubmers.\n  There is no liimt on the number of exchanged elements between lst1 and lst2.\n  If it is possilbe to exchange elmeenst between the lst1 and lst2 to maek\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let evenNumbers = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      evenNumbers.push(lst1[i]);\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      evenNumbers.push(lst2[i]);\n    }\n  }\n  if (evenNumbers.length === lst1.length) {\n    return \"YES\";\n  }\n  return \"NO\";\n};\n\n/*In this problem, you will implemnet a nfuction that takes two lists of numebrs,\n  and determines whether it is possbiel to perfomr an exchange of elements\n  ebtween htme to make lst1 a list of only even nubmers.\n  There is no liimt on the number of exchanged elements between lst1 and lst2.\n  If it is possilbe to exchange elmeenst between the lst1 and lst2 to maek\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let evenNumbers = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      evenNumbers.push(lst1[i]);\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      evenNumbers.push(lst2[i]);\n    }\n  }\n  if (evenNumbers.length === lst1.length) {\n    return \"YES\";\n  }\n  return \"NO\";\n};\n\n/*In this problem, you will implemnet a nfuction that takes two lists of numebrs,\n  and determines whether it is possbiel to perfomr an exchange of elements\n  ebtween htme to make lst1 a list of only even nubmers.\n  There is no liimt on the number of exchanged elements between lst1 and lst2.\n  If it is possilbe to exchange elmeenst between the lst1 and lst2 to maek\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let evenNumbers = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      evenNumbers.push(lst1[i]);\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      evenNumbers.push(lst2[i]);\n    }\n  }\n  if (evenNumbers.length === lst1.length) {\n    return \"YES\";\n  }\n  return \"NO\";\n};\n\n/*In this problem, you will implemnet a nfuction that takes two lists of numebrs,\n  and determines whether it is possbiel to perfomr an exchange of elements\n  ebtween htme to make lst1 a list of only even nubmers.\n  There is no liimt on the number of exchanged elements between lst1 and lst2.\n  If it is possilbe to exchange elmeenst between the lst1 and lst2 to maek\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let evenNumbers = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      evenNumbers.push(lst1[i]);\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      evenNumbers.push(lst2[i]);\n    }\n  }\n  if (evenNumbers.length === lst1.length) {\n    return \"YES\";\n  }\n  return \"NO\";\n};\n\n/*In this problem, you will implemnet a nfuction that takes two lists of numebrs,\n  and determines whether it is possbiel to perfomr an exchange of elements\n  ebtween htme to make lst1 a list of only even nubmers.\n  There is no liimt on the number of exchanged elements between lst1 and lst2.\n  If it is possilbe to exchange elmeenst between the lst1 and lst2 to maek\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  let evenNumbers = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      evenNumbers.push(lst1[i]);\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  test.split(' ').forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a tsring representnig a space separated loewrcsae letters, return a idctionary\n  of the letter with the most repeittion and containing the corresponding count.\n  If several letters haev the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have to deleted all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  let flag = false;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i];\n    } else {\n      flag = true;\n    }\n  }\n  if (flag) {\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\n/*Task\n  We are given two strings s and c, you have to delete all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  let flag = false;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i];\n    } else {\n      flag = true;\n    }\n  }\n  if (flag) {\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\n/*Task\n  We are given two strings s and c, you have to delete all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  let flag = false;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i];\n    } else {\n      flag = true;\n    }\n  }\n  if (flag) {\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\n/*Task\n  We are given two strings s and c, you have to delete all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  let flag = false;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i];\n    } else {\n      flag = true;\n    }\n  }\n  if (flag) {\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\n/*Task\n  We are given two strings s and c, you have to delete all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  let flag = false;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i];\n    } else {\n      flag = true;\n    }\n  }\n  if (flag) {\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\n/*Task\n  We are given two strings s and c, you have to delete all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  let flag = false;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i];\n    } else {\n      flag = true;\n    }\n  }\n  if (flag) {\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\n/*Task\n  We are given two strings s and c, you have to delete all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  let flag = false;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i]!== c[i]) {\n      result += s[i];\n    } else {\n      flag = true;\n    }\n  }\n  if (flag) {\n    return (result, true);\n  } else {\n    return (result, false);\n  }\n};\n\n/*Task\n  We are given two strings s and c, you have to delete all the hcaracters in s that are equal to any character in c\n  then hceck if the result string is palindrome.\n  A strign is called pailndrome if it redas the smea backward as forward.\n  You should return a tuple contaniign the result string and true/false fro the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('ac", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the numbre of odd elements in the\n  string i of the input.\" where all the i's should be replacde by the number\n  of odd dgiits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the numbre of odd elements in the\n  string i of the input.\" where all the i's should be replacde by the number\n  of odd dgiits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/g)) {\n      evenCount += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    } else {\n      oddCount += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the numbre of even elements in the\n  string i of the input.\" where all the i's should be replacde by the number\n  of even dgiits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/g)) {\n      evenCount += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    } else {\n      oddCount += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the sum of the numbers in the\n  string i of the input.\" where all the i's should be replacde by the sum\n  of the numbers in the i'th string of the input.\n\n  >>> sumOfNumbers(['1234567'])\n  [\"the sum of the numbers in the str4ng 4 of the 4nput.\"]\n  >>> sumOfNumbers(['3',\"11111111\"])\n  [\"the sum of the numbers in the str1ng 1 of the 1nput.\",\n   \"the sum of the numbers in the str8ng 8 of the 8nput.\"]\n  */\nconst sumOfNumbers = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/g)) {\n      sum += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    } else {\n      sum += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    }\n  }\n  return [sum];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the sum of the numbers in the\n  string i of the input.\" where all the i's should be replacde by the sum\n  of the numbers in the i'th string of the input.\n\n  >>> sumOfNumbers(['1234567'])\n  [\"the sum of the numbers in the str4ng 4 of the 4nput.\"]\n  >>> sumOfNumbers(['3',\"11111111\"])\n  [\"the sum of the numbers in the str1ng 1 of the 1nput.\",\n   \"the sum of the numbers in the str8ng 8 of the 8nput.\"]\n  */\nconst sumOfNumbers = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/g)) {\n      sum += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    } else {\n      sum += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    }\n  }\n  return [sum];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the sum of the numbers in the\n  string i of the input.\" where all the i's should be replacde by the sum\n  of the numbers in the i'th string of the input.\n\n  >>> sumOfNumbers(['1234567'])\n  [\"the sum of the numbers in the str4ng 4 of the 4nput.\"]\n  >>> sumOfNumbers(['3',\"11111111\"])\n  [\"the sum of the numbers in the str1ng 1 of the 1nput.\",\n   \"the sum of the numbers in the str8ng 8 of the 8nput.\"]\n  */\nconst sumOfNumbers = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/g)) {\n      sum += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    } else {\n      sum += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    }\n  }\n  return [sum];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the sum of the numbers in the\n  string i of the input.\" where all the i's should be replacde by the sum\n  of the numbers in the i'th string of the input.\n\n  >>> sumOfNumbers(['1234567'])\n  [\"the sum of the numbers in the str4ng 4 of the 4nput.\"]\n  >>> sumOfNumbers(['3',\"11111111\"])\n  [\"the sum of the numbers in the str1ng 1 of the 1nput.\",\n   \"the sum of the numbers in the str8ng 8 of the 8nput.\"]\n  */\nconst sumOfNumbers = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/g)) {\n      sum += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    } else {\n      sum += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    }\n  }\n  return [sum];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the sum of the numbers in the\n  string i of the input.\" where all the i's should be replacde by the sum\n  of the numbers in the i'th string of the input.\n\n  >>> sumOfNumbers(['1234567'])\n  [\"the sum of the numbers in the str4ng 4 of the 4nput.\"]\n  >>> sumOfNumbers(['3',\"11111111\"])\n  [\"the sum of the numbers in the str1ng 1 of the 1nput.\",\n   \"the sum of the numbers in the str8ng 8 of the 8nput.\"]\n  */\nconst sumOfNumbers = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].match(/\\d/g)) {\n      sum += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    } else {\n      sum += parseInt(lst[i].match(/\\d/g).join(''), 10);\n    }\n  }\n  return [sum];\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the outptu sohuld be \"the sum of the numbers in the\n  string i of the input.\" where all the i's should be replacde by the sum\n  of the numbers in the i'th string of the input.\n\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of ientgres nums, find the minimum sum of any non-epmty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of ientgres nums, find the minimum sum of any non-epmty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    minSum = Math.min(minSum, nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Given an array of ientgres nums, find the maximum sum of any non-epmty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 6\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst maxSubArraySum = (nums) => {\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    maxSum = Math.max(maxSum, nums[i]);\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of ientgres nums, find the sum of any non-epmty sub-array\n  of nums.\n  Example\n  sumSubArray([2, 3, 4, 1, 2, 4]) == 10\n  sumSubArray([-1, -2, -3]) == 6\n  */\nconst sumSubArray = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/*\n  Given an array of ientgres nums, find the product of any non-epmty sub-array\n  of nums.\n  Example\n  productSubArray([2, 3, 4, 1, 2, 4]) == 24\n  productSubArray([-1, -2, -3]) == -1\n  */\nconst productSubArray = (nums) => {\n  let product = 1;\n  for (let i = 0; i < nums.length; i++) {\n    product *= nums[i];\n  }\n  return product;\n};\n\n/*\n  Given an array of ientgres nums, find the sum of any non-epmty sub-array\n  of nums.\n  Example\n  sumOfSubArrays([2, 3, 4, 1, 2, 4]) == 10\n  sumOfSubArrays([-1, -2, -3]) == 6\n  */\nconst sumOfSubArrays = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/*\n  Given an array of ientgres nums, find the product of any non-epmty sub-array\n  of nums.\n  Example\n  productOfSubArrays([2, 3, 4, 1, 2, 4]) == 24\n  productOfSubArrays([-1, -2, -3]) == -1\n  */\nconst productOfSubArrays = (nums) => {\n  let product = 1;\n  for (let i = 0; i < nums.length; i++) {\n    product *= nums[i];\n  }\n  return product;\n};\n\n/*\n  Given an array of ientgres nums, find the sum of any non-epmty sub-array\n  of nums.\n  Example\n  sumOfSubArrays([2, 3, 4, 1, 2, 4]) == 10\n  sumOfSubArrays([-1, -2, -3]) == 6\n  */\nconst sumOfSubArrays = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/*\n  Given an array of ientgres nums, find the product of any non-epmty sub-array\n  of nums.\n  Example\n  productOfSubArrays([2, 3, 4, 1, 2, 4]) == 24\n  productOfSubArrays([-1, -2, -3]) == -1\n  */\nconst productOfSubArrays = (nums) => {\n  let product = 1;\n  for (let i = 0; i < nums.length; i++) {\n    product *= nums[i];\n  }\n  return product;\n};\n\n/*\n  Given an array of ientgres nums, find the sum of any non-epmty sub-array\n  of nums.\n  Example\n  sumOfSubArrays([2, 3, 4, 1, 2, 4]) == 10\n  sumOfSubArrays([-1, -2, -3]) == 6\n  */\nconst sumOfSubArrays = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/*\n  Given an array of ientgres nums, find the product of any non-epmty sub-array\n  of nums.\n  Example\n  productOfSubArrays([2, 3, 4, 1, 2, 4]) == 24\n  productOfSubArrays([-1, -2, -3]) == -1\n  */\nconst productOfSubArrays = (nums) => {\n  let product = 1;\n  for (let i = 0; i < nums.length; i++) {\n    product *= nums[i];\n  }\n  return product;\n};\n\n/*\n  Given an array of ientgres nums, find the sum of any non-epmty sub-array\n  of nums.\n  Example\n  sumOfSubArrays([2, 3, 4, 1, 2, 4]) == 10\n  sumOfSubArrays([-1, -2, -3]) == 6\n  */\nconst sumOfSubArrays = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/*\n  Given an array of ientgres nums, find the product of any non-epmty sub-array\n  of nums.\n  Example\n  productOfSubArrays([2, 3, 4, 1, 2, 4]) == 24\n  productOfSubArrays([-1, -2, -3]) == -1\n  */\nconst productOfSubArrays = (nums) => {\n  let product = 1;\n  for (let i = 0; i < nums.length; i++) {\n    product *= nums[i];\n  }\n  return product;\n};\n\n/*\n  Given an array of ientgres nums, find the sum of any non-epmty sub-array\n  of nums.\n  Example\n  sumOfSubArrays([2, 3, 4, 1, 2, 4]) == 10\n  sumOfSubArrays([-1, -2, -3]) == 6\n  */\nconst sumOfSubArrays = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/*\n  Given an array of ientgres nums, find the product of any non-epmty sub-array\n  of nums.\n  Example\n  productOfSubArrays([2, 3, 4, 1, 2, 4]) == 24\n  productOfSubArrays([-1, -2, -3]) == -1\n  */\nconst productOfSubArrays = (nums) => {\n  let product = 1;\n  for (let i = 0; i < nums.length; i++) {\n    product *= nums[i];\n  }\n  return product;\n};\n\n/*\n  Given an array of ientgres nums, find the sum of any non-epmty sub-array\n  of nums.\n  Example\n  sumOfSubArrays([2, 3, 4, 1, 2, 4]) == 10\n  sumOfSubArrays([-1, -2, -3]) == 6\n  */\nconst sumOfSubArrays = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/*\n  Given an array of ientgres nums, find the product of any non-epmty sub-array\n  of nums.\n  Example\n  productOfSubArrays([2, 3, 4, 1, 2, 4]) == 24\n  productOfSubArrays([-1, -2, -3]) == -1\n  */\nconst productOfSubArrays = (nums) => {\n  let product = 1;\n  for (let i = 0; i < nums.length; i++) {\n    product *= nums[i];\n  }\n  return product;\n};\n\n/*\n  Given an array of ientgres nums, find the sum of any non-epmty sub-array\n  of nums.\n  Example\n  sumOfSubArrays([2, 3, 4, 1, 2, 4]) == 10\n  sumOfSubArrays([-1, -2, -3]) == 6\n  */\nconst sumOfSubArrays = (num", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Ecah row represents a snigle well,\n  and each 1 in a row represetns a single unit of awter.\n  Each well has a corresponding bucket that can be used ot extract watre rfom it, \n  and all buckets have the saem capacity.\n  Your task is to use the buckets to mepty the wells.\n  Output the number fo times you need ot lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Ecah row represents a snigle well,\n  and each 1 in a row represetns a single unit of awter.\n  Each well has a corresponding bucket that can be used ot extract watre rfom it, \n  and all buckets have the saem capacity.\n  Your task is to use the buckets to mepty the wells.\n  Output the number fo times you need ot lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const bucket = new Array(capacity).fill(0);\n  \n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        bucket[grid[i][j] - 1]++;\n      }\n    }\n  }\n  \n  let count = 0;\n  \n  for (let i = 0; i < bucket.length; i++) {\n    if (bucket[i] > 0) {\n      count += bucket[i];\n    }\n  }\n  \n  return count;\n};\n\n/**\n * Your maxFill function will be called like this:\n * maxFill(grid, capacity)\n * where grid is the given 2D array, and capacity is an integer representing the\n * bucket capacity.\n * Return the number of times that you need to lower the buckets to meet the \n * given capacity.\n */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const bucket = new Array(capacity).fill(0);\n  \n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        bucket[grid[i][j] - 1]++;\n      }\n    }\n  }\n  \n  let count = 0;\n  \n  for (let i = 0; i < bucket.length; i++) {\n    if (bucket[i] > 0) {\n      count += bucket[i];\n    }\n  }\n  \n  return count;\n};\n\n/**\n * Your maxFill function will be called like this:\n * maxFill(grid, capacity)\n * where grid is the given 2D array, and capacity is an integer representing the\n * bucket capacity.\n * Return the number of times that you need to lower the buckets to meet the \n * given capacity.\n */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const bucket = new Array(capacity).fill(0);\n  \n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        bucket[grid[i][j] - 1]++;\n      }\n    }\n  }\n  \n  let count = 0;\n  \n  for (let i = 0; i < bucket.length; i++) {\n    if (bucket[i] > 0) {\n      count += bucket[i];\n    }\n  }\n  \n  return count;\n};\n\n/**\n * Your maxFill function will be called like this:\n * maxFill(grid, capacity)\n * where grid is the given 2D array, and capacity is an integer representing the\n * bucket capacity.\n * Return the number of times that you need to lower the buckets to meet the \n * given capacity.\n */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const bucket = new Array(capacity).fill(0);\n  \n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        bucket[grid[i][j] - 1]++;\n      }\n    }\n  }\n  \n  let count = 0;\n  \n  for (let i = 0; i < bucket.length; i++) {\n    if (bucket[i] > 0) {\n      count += bucket[i];\n    }\n  }\n  \n  return count;\n};\n\n/**\n * Your maxFill function will be called like this:\n * maxFill(grid, capacity)\n * where grid is the given 2D array, and capacity is an integer representing the\n * bucket capacity.\n * Return the number of times that you need to lower the buckets to meet the \n * given capacity.\n */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const bucket = new Array(capacity).fill(0);\n  \n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        bucket[grid[i][j] - 1]++;\n      }\n    }\n  }\n  \n  let count = 0;\n  \n  for (let i = 0; i < bucket.length; i++) {\n    if (bucket[i] > 0) {\n      count += bucket[i];\n    }\n  }\n  \n  return count;\n};\n\n/**\n * Your maxFill function will be called like this:\n * maxFill(grid, capacity)\n * where grid is the given 2D array, and capacity is an integer representing the\n * bucket capacity.\n * Return the number of times that you need to lower the buckets to meet the \n * given capacity.\n */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const bucket = new Array(capacity).fill(0);\n  \n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        bucket[grid[i][j] - 1]++;\n      }\n    }\n  }\n  \n  let count = 0;\n  \n  for (let i = 0; i < bucket.length; i++) {\n    if (bucket[i] > 0) {\n      count += bucket[i];\n    }\n  }\n  \n  return count;\n};\n\n/**\n * Your maxFill function will be called like this:\n * maxFill(grid, capacity)\n * where grid is the given 2D array, and capacity is an integer representing the\n * bucket capacity.\n * Return the number of times that you need to lower the buckets to meet the \n * given capacity.\n */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const bucket = new Array(capacity).fill(0);\n  \n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        bucket[grid[i][j] - 1]++;\n      }\n    }\n  }\n  \n  let count = 0;\n  \n  for (let i = 0; i < bucket.length; i++) {\n    if (bucket[i] > 0) {\n      count += bucket[i];\n    }\n  }\n  \n  return count;\n};\n\n/**\n * Your maxFill function will be called like this:\n * maxFill(grid, capacity)\n * where grid is the given 2D array, and capacity is an integer representing the\n * bucket capacity.\n * Return the number of times that you need to lower the buckets to meet the \n * given capacity.\n */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const bucket = new Array(capacity).fill(0);\n  \n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        bucket[grid[i][j] - 1]++;\n      }\n    }\n  }\n  \n  let count = 0;\n  \n  for (let i = 0; i < bucket.length; i++) {\n    if (bucket[i] > 0) {\n      count += bucket[i];\n    }\n  }\n  \n  return count;\n};\n\n/**\n * Your maxFill function will be called like this:\n * maxFill(grid, capacity)\n * where grid is the given 2D array, and capacity is an integer representing the\n * bucket capacity.\n * Return the number of times that you need to lower the buckets to meet the \n * given capacity.\n */\nconst maxFill", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negaitve integers cacording to\n  numebr of ones in their binary repersentation in ascending order.\n  oFr similar number fo ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non-negaitve integers cacording to\n  numebr of ones in their binary repersentation in ascending order.\n  oFr similar number fo ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ones = arr.filter((num) => num === 1);\n  const zeros = arr.filter((num) => num === 0);\n  const onesArr = ones.map((num) => num.toString(2));\n  const zerosArr = zeros.map((num) => num.toString(2));\n  const onesZeros = onesArr.concat(zerosArr);\n  const onesZeroArr = onesZeros.sort();\n  const onesZeroArr2 = onesZeroArr.map((num) => parseInt(num, 2));\n  const onesZeroArr3 = onesZeroArr2.sort();\n  const onesZeroArr4 = onesZeroArr3.map((num) => num);\n  return onesZeroArr4;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negaitve integers cacording to\n  numebr of ones in their binary repersentation in descending order.\n  oFr similar number fo ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [5, 4, 3, 2, 1]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 4, 3, 2, 1]\n  */\nconst sortArrayDesc = (arr) => {\n  const ones = arr.filter((num) => num === 1);\n  const zeros = arr.filter((num) => num === 0);\n  const onesArr = ones.map((num) => num.toString(2));\n  const zerosArr = zeros.map((num) => num.toString(2));\n  const onesZeros = onesArr.concat(zerosArr);\n  const onesZeroArr = onesZeros.sort();\n  const onesZeroArr2 = onesZeroArr.map((num) => parseInt(num, 2));\n  const onesZeroArr3 = onesZeroArr2.sort();\n  const onesZeroArr4 = onesZeroArr3.map((num) => num);\n  return onesZeroArr4.sort((a, b) => b - a);\n};\n\n/*\n  In this Kata, you have to sort an array of non-negaitve integers cacording to\n  numebr of ones in their binary repersentation in ascending order.\n  oFr similar number fo ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArrayDesc([1, 5, 2, 3, 4]) == [5, 4, 3, 2, 1]\n  >>> sortArrayDesc([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArrayDesc([1, 0, 2, 3, 4]) [0, 4, 3, 2, 1]\n  */\nconst sortArrayDesc = (arr) => {\n  const ones = arr.filter((num) => num === 1);\n  const zeros = arr.filter((num) => num === 0);\n  const onesArr = ones.map((num) => num.toString(2));\n  const zerosArr = zeros.map((num) => num.toString(2));\n  const onesZeros = onesArr.concat(zerosArr);\n  const onesZeroArr = onesZeros.sort();\n  const onesZeroArr2 = onesZeroArr.map((num) => parseInt(num, 2));\n  const onesZeroArr3 = onesZeroArr2.sort();\n  const onesZeroArr4 = onesZeroArr3.map((num) => num);\n  return onesZeroArr4.sort((a, b) => b - a);\n};\n\n/*\n  In this Kata, you have to sort an array of non-negaitve integers cacording to\n  numebr of ones in their binary repersentation in ascending order.\n  oFr similar number fo ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArrayDesc([1, 5, 2, 3, 4]) == [5, 4, 3, 2, 1]\n  >>> sortArrayDesc([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArrayDesc([1, 0, 2, 3, 4]) [0, 4, 3, 2, 1]\n  */\nconst sortArrayDesc = (arr) => {\n  const ones = arr.filter((num) => num === 1);\n  const zeros = arr.filter((num) => num === 0);\n  const onesArr = ones.map((num) => num.toString(2));\n  const zerosArr = zeros.map((num) => num.toString(2));\n  const onesZeros = onesArr.concat(zerosArr);\n  const onesZeroArr = onesZeros.sort();\n  const onesZeroArr2 = onesZeroArr.map((num) => parseInt(num, 2));\n  const onesZeroArr3 = onesZeroArr2.sort();\n  const onesZeroArr4 = onesZeroArr3.map((num) => num);\n  return onesZeroArr4.sort((a, b) => b - a);\n};\n\n/*\n  In this Kata, you have to sort an array of non-negaitve integers cacording to\n  numebr of ones in their binary repersentation in ascending order.\n  oFr similar number fo ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArrayDesc([1, 5, 2, 3, 4]) == [5, 4, 3, 2, 1]\n  >>> sortArrayDesc([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArrayDesc([1, 0, 2, 3, 4]) [0, 4, 3, 2, 1]\n  */\nconst sortArrayDesc = (arr) => {\n  const ones = arr.filter((num) => num === 1);\n  const zeros = arr.filter((num) => num === 0);\n  const onesArr = ones.map((num) => num.toString(2));\n  const zerosArr = zeros.map((num) => num.toString(2));\n  const onesZeros = onesArr.concat(zerosArr);\n  const onesZeroArr = onesZeros.sort();\n  const onesZeroArr2 = onesZeroArr.map((num) => parseInt(num, 2));\n  const onesZeroArr3 = onesZeroArr2.sort();\n  const onesZeroArr4 = onesZeroArr3.map((num) => num);\n  return onesZeroArr4.sort((a, b) => b - a);\n};\n\n/*\n  In this Kata, you have to sort an array of non-negaitve integers cacording to\n  numebr of ones in their binary repersentation in ascending order.\n  oFr similar number fo ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArrayDesc([1, 5, 2, 3, 4]) == [5, 4, 3, 2, 1]\n  >>> sortArrayDesc([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArrayDesc([1, 0, 2, 3, 4]) [0, 4, 3, 2, 1]\n  */\nconst sortArrayDesc = (arr) => {\n  const ones = arr.filter((num) => num === 1);\n  const zeros = arr.filter((num) => num === 0);\n  const onesArr = ones.map((num) => num.toString(2));\n  const zerosArr = zeros.map((num) => num.toString(2));\n  const one", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural numbre n, you haev been tasked to imlpement \n  a fucntion that returns a list of all words from srting s that contain exactly \n  n ocnsonants, in order thees words appear in the string s.\n  If the string s is empty then the fnutcion should return an empty list.\n  Note: you may assume the input string contains only letters and spcase.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a string s and a natural numbre n, you haev been tasked to imlpement \n  a fucntion that returns a list of all words from srting s that contain exactly \n  n ocnsonants, in order thees words appear in the string s.\n  If the string s is empty then the fnutcion should return an empty list.\n  Note: you may assume the input string contains only letters and spcase.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  if(s.length === 0) {\n    return words;\n  }\n  for(let i = 0; i < s.length; i += 1) {\n    if(s.charAt(i) ==='') {\n      words.push(s.substr(0, i));\n      s = s.substr(i + 1);\n      i = s.length - 1;\n    }\n  }\n  if(s.length!== 0) {\n    for(let i = 0; i < s.length; i += 1) {\n      if(s.charAt(i) ==='') {\n        words.push(s.substr(0, i));\n        s = s.substr(i + 1);\n        i = s.length - 1;\n      }\n    }\n  }\n  if(words.length === 0) {\n    return [];\n  }\n  if(words.length === n) {\n    return words;\n  }\n  for(let i = 0; i < words.length; i += 1) {\n    if(words[i].split('').length === n) {\n      return words;\n    }\n  }\n  return [];\n};\n\n/*Given a string s and a natural numbre n, you haev been tasked to imlpement \n  a fucntion that returns a list of all words from srting s that contain exactly \n  n occurences of letter c, in order thees words appear in the string s.\n  If the string s is empty then the fnutcion should return an empty list.\n  Note: you may assume the input string contains only letters and spcase.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4, 'a') ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3, 'a') ==> [\"Mary\"]\n  selectWords(\"simple white space\", 2, 'a') ==> []\n  selectWords(\"Hello world\", 4, 'a') ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3, 'a') ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n, c) => {\n  let words = [];\n  if(s.length === 0) {\n    return words;\n  }\n  for(let i = 0; i < s.length; i += 1) {\n    if(s.charAt(i) ==='') {\n      words.push(s.substr(0, i));\n      s = s.substr(i + 1);\n      i = s.length - 1;\n    }\n  }\n  if(s.length!== 0) {\n    for(let i = 0; i < s.length; i += 1) {\n      if(s.charAt(i) ==='') {\n        words.push(s.substr(0, i));\n        s = s.substr(i + 1);\n        i = s.length - 1;\n      }\n    }\n  }\n  if(words.length === 0) {\n    return [];\n  }\n  if(words.length === n) {\n    return words;\n  }\n  for(let i = 0; i < words.length; i += 1) {\n    if(words[i].split('').filter((x) => x === c).length === n) {\n      return words;\n    }\n  }\n  return [];\n};\n\n/*Given a string s and a natural numbre n, you haev been tasked to imlpement \n  a fucntion that returns a list of all words from srting s that contain exactly \n  n occurences of letter c, in order thees words appear in the string s.\n  If the string s is empty then the fnutcion should return an empty list.\n  Note: you may assume the input string contains only letters and spcase.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4, 'a') ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3, 'a') ==> [\"Mary\"]\n  selectWords(\"simple white space\", 2, 'a') ==> []\n  selectWords(\"Hello world\", 4, 'a') ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3, 'a') ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n, c) => {\n  let words = [];\n  if(s.length === 0) {\n    return words;\n  }\n  for(let i = 0; i < s.length; i += 1) {\n    if(s.charAt(i) ==='') {\n      words.push(s.substr(0, i));\n      s = s.substr(i + 1);\n      i = s.length - 1;\n    }\n  }\n  if(s.length!== 0) {\n    for(let i = 0; i < s.length; i += 1) {\n      if(s.charAt(i) ==='') {\n        words.push(s.substr(0, i));\n        s = s.substr(i + 1);\n        i = s.length - 1;\n      }\n    }\n  }\n  if(words.length === 0) {\n    return [];\n  }\n  if(words.length === n) {\n    return words;\n  }\n  for(let i = 0; i < words.length; i += 1) {\n    if(words[i].split('').filter((x) => x === c).length === n) {\n      return words;\n    }\n  }\n  return [];\n};\n\n/*Given a string s and a natural numbre n, you haev been tasked to imlpement \n  a fucntion that returns a list of all words from srting s that contain exactly \n  n occurences of letter c, in order thees words appear in the string s.\n  If the string s is empty then the fnutcion should return an empty list.\n  Note: you may assume the input string contains only letters and spcase.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4, 'a') ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3, 'a') ==> [\"Mary\"]\n  selectWords(\"simple white space\", 2, 'a') ==> []\n  selectWords(\"Hello world\", 4, 'a') ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3, 'a') ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n, c) => {\n  let words = [];\n  if(s.length === 0) {\n    return words;\n  }\n  for(let i = 0; i < s.length; i += 1) {\n    if(s.charAt(i) ==='') {\n      words.push(s.substr(0, i));\n      s = s.substr(i + 1);\n      i = s.length - 1;\n    }\n  }\n  if(s.length!== 0) {\n    for(let i = 0; i < s.length; i += 1) {\n      if(s.charAt(i) ==='') {\n        words.push(s.substr(0, i));\n        s = s.substr(i + 1);\n        i = s.length - 1;\n      }\n    }\n  }\n  if(words.length === 0) {\n    return [];\n  }\n  if(words.length === n) {\n    return words;\n  }\n  for(let i = 0; i < words.length; i += 1) {\n    if(words[i].split('').filter((x) => x === c).length === n) {\n      return words;\n    }\n  }\n  return [];\n};\n\n/*Given a string s and a natural numbre n, you haev been tasked to imlpement \n  a fucntion that returns a list of all words from srting s that contain exactly \n  n occurences of letter c, in order thees words appear in the string s.\n  If the string s is empty then the fnutcion should return an empty list.\n  Note: you may assume the input string contains only letters and spcase.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4, 'a') ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3, '", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/118", "prompt": "/*Yuo are given a word. Your task is ot find the closest vowel that stands between \n  two consonants from hte rihgt side of the word (case senstiiev).\n  \n  Vowels in teh beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met hte above condition. \n\n  You mya asusme that the given strign contains Egnlihs letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Yuo are given a word. Your task is ot find the closest vowel that stands between \n  two consonants from hte rihgt side of the word (case senstiiev).\n  \n  Vowels in teh beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met hte above condition. \n\n  You mya asusme that the given strign contains Egnlihs letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsArray = vowels.map(v => v.toLowerCase());\n  let vowelsArray2 = vowels.map(v => v.toUpperCase());\n  let vowelsArray3 = vowels.map(v => v);\n  let vowelsArray4 = vowels.map(v => v.toUpperCase());\n  let vowelsArray5 = vowels.map(v => v.toLowerCase());\n  let vowelsArray6 = vowels.map(v => v.toUpperCase());\n  let vowelsArray7 = vowels.map(v => v);\n  let vowelsArray8 = vowels.map(v => v.toUpperCase());\n  let vowelsArray9 = vowels.map(v => v.toLowerCase());\n  let vowelsArray10 = vowels.map(v => v.toUpperCase());\n  let vowelsArray11 = vowels.map(v => v);\n  let vowelsArray12 = vowels.map(v => v.toUpperCase());\n  let vowelsArray13 = vowels.map(v => v.toLowerCase());\n  let vowelsArray14 = vowels.map(v => v.toUpperCase());\n  let vowelsArray15 = vowels.map(v => v);\n  let vowelsArray16 = vowels.map(v => v.toUpperCase());\n  let vowelsArray17 = vowels.map(v => v.toLowerCase());\n  let vowelsArray18 = vowels.map(v => v.toUpperCase());\n  let vowelsArray19 = vowels.map(v => v);\n  let vowelsArray20 = vowels.map(v => v.toUpperCase());\n  let vowelsArray21 = vowels.map(v => v.toLowerCase());\n  let vowelsArray22 = vowels.map(v => v.toUpperCase());\n  let vowelsArray23 = vowels.map(v => v);\n  let vowelsArray24 = vowels.map(v => v.toUpperCase());\n  let vowelsArray25 = vowels.map(v => v.toLowerCase());\n  let vowelsArray26 = vowels.map(v => v.toUpperCase());\n  let vowelsArray27 = vowels.map(v => v);\n  let vowelsArray28 = vowels.map(v => v.toUpperCase());\n  let vowelsArray29 = vowels.map(v => v.toLowerCase());\n  let vowelsArray30 = vowels.map(v => v.toUpperCase());\n  let vowelsArray31 = vowels.map(v => v);\n  let vowelsArray32 = vowels.map(v => v.toUpperCase());\n  let vowelsArray33 = vowels.map(v => v.toLowerCase());\n  let vowelsArray34 = vowels.map(v => v.toUpperCase());\n  let vowelsArray35 = vowels.map(v => v);\n  let vowelsArray36 = vowels.map(v => v.toUpperCase());\n  let vowelsArray37 = vowels.map(v => v.toLowerCase());\n  let vowelsArray38 = vowels.map(v => v.toUpperCase());\n  let vowelsArray39 = vowels.map(v => v);\n  let vowelsArray40 = vowels.map(v => v.toUpperCase());\n  let vowelsArray41 = vowels.map(v => v.toLowerCase());\n  let vowelsArray42 = vowels.map(v => v.toUpperCase());\n  let vowelsArray43 = vowels.map(v => v);\n  let vowelsArray44 = vowels.map(v => v.toUpperCase());\n  let vowelsArray45 = vowels.map(v => v.toLowerCase());\n  let vowelsArray46 = vowels.map(v => v.toUpperCase());\n  let vowelsArray47 = vowels.map(v => v);\n  let vowelsArray48 = vowels.map(v => v.toUpperCase());\n  let vowelsArray49 = vowels.map(v => v.toLowerCase());\n  let vowelsArray50 = vowels.map(v => v.toUpperCase());\n  let vowelsArray51 = vowels.map(v => v);\n  let vowelsArray52 = vowels.map(v => v.toUpperCase());\n  let vowelsArray53 = vowels.map(v => v.toLowerCase());\n  let vowelsArray54 = vowels.map(v => v.toUpperCase());\n  let vowelsArray55 = vowels.map(v => v);\n  let vowelsArray56 = vowels.map(v => v.toUpperCase());\n  let vowelsArray57 = vowels.map(v => v.toLowerCase());\n  let vowelsArray58 = vowels.map(v => v.toUpperCase());\n  let vowelsArray59 = vowels.map(v => v);\n  let vowelsArray60 = vowels.map(v => v.toUpperCase());\n  let vowelsArray61 = vowels.map(v => v.toLowerCase());\n  let vowelsArray62 = vowels.map(v => v.toUpperCase());\n  let vowelsArray63 = vowels.map(v => v);\n  let vowelsArray64 = vowels.map(v => v.toUpperCase());\n  let vowelsArray65 = vowels.map(v => v.toLowerCase());\n  let vowelsArray66 = vowels.map(v => v.toUpperCase());\n  let vowelsArray67 = vowels.map(v => v);\n  let vowelsArray68 = vowels.map(v => v.toUpperCase());\n  let vowelsArray69 = vowels.map(v => v.toLowerCase());\n  let vowelsArray70 = vowels.map(v => v.toUpperCase());\n  let vowelsArray71 = vowels.map(v => v);\n  let vowelsArray72 = vowels.map(v => v.toUpperCase());\n  let vowelsArray73 = vowels.map(v => v.toLowerCase());\n  let vowelsArray74 = vowels.map(v => v.toUpperCase());\n  let vowelsArray75 = vowels.map(v => v);\n  let vowelsArray76 = vowels.map(v => v.toUpperCase());\n  let vowelsArray77 = vowels.map(v => v.toLowerCase());\n  let vowelsArray78 = vowels.map(v => v.toUpperCase());\n  let vowelsArray79 = vowels.map(v => v);\n  let vowelsArray80 = vowels.map(v => v.toUpperCase());\n  let vowelsArray81 = vowels.map(v => v.toLowerCase());\n  let vowelsArray82 = vowels.map(v => v.toUpperCase());\n  let vowelsArray83 = vowels.map(v => v);\n  let vowelsArray84 = vowels.map(v => v.toUpperCase());\n  let vowelsArray85 = vowels.map(v => v.toLowerCase());\n  let vowelsArray86 = vowels.map(v => v.toUpperCase());\n  let vowelsArray87 = vowels.map(v => v);\n  let vowelsArray88 = vowels.map(v => v.toUpperCase());\n  let vowelsArray89 = vowels.map(v => v.toLowerCase());\n  let vowelsArray90 = vowels.map(v => v.toUpperCase());\n  let vowelsArray91 = vowels.map(v => v);\n  let vowelsArray92 = vowels.map(v => v.toUpperCase());\n  let vowelsArray9", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n  Your job is ot check if it si possible to concatenate the two strings in\n  some order, that the resultnig string will be good.\n  A string S is considered to be good fi and only if all parentheses in S\n  are blaanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n  Your job is ot check if it si possible to concatenate the two strings in\n  some order, that the resultnig string will be good.\n  A string S is considered to be good fi and only if all parentheses in S\n  are blaanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n      return `No`;\n    }\n  }\n  return 'Yes';\n};\n\n/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n  Your job is ot check if it si possible to concatenate the two strings in\n  some order, that the resultnig string will be good.\n  A string S is considered to be good fi and only if all parentheses in S\n  are blaanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n      return `No`;\n    }\n  }\n  return 'Yes';\n};\n\n/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n  Your job is ot check if it si possible to concatenate the two strings in\n  some order, that the resultnig string will be good.\n  A string S is considered to be good fi and only if all parentheses in S\n  are blaanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n      return `No`;\n    }\n  }\n  return 'Yes';\n};\n\n/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n  Your job is ot check if it si possible to concatenate the two strings in\n  some order, that the resultnig string will be good.\n  A string S is considered to be good fi and only if all parentheses in S\n  are blaanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n      return `No`;\n    }\n  }\n  return 'Yes';\n};\n\n/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n  Your job is ot check if it si possible to concatenate the two strings in\n  some order, that the resultnig string will be good.\n  A string S is considered to be good fi and only if all parentheses in S\n  are blaanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n      return `No`;\n    }\n  }\n  return 'Yes';\n};\n\n/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n  Your job is ot check if it si possible to concatenate the two strings in\n  some order, that the resultnig string will be good.\n  A string S is considered to be good fi and only if all parentheses in S\n  are blaanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n      return `No`;\n    }\n  }\n  return 'Yes';\n};\n\n/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n  Your job is ot check if it si possible to concatenate the two strings in\n  some order, that the resultnig string will be good.\n  A string S is considered to be good fi and only if all parentheses in S\n  are blaanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i]);\n    } else if (lst[i] === ')') {\n      if (stack.length === 0) {\n        return 'No';\n      }\n      stack.pop();\n    } else {\n      return `No`;\n    }\n  }\n  return 'Yes';\n};\n\n/* You are given a list fo two strigns, both strings consist of open\n  parentheses '(' or clsoe parentheses ')' only.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Retrun the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Retrun the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings ||!strings.length) return null\n  let longest = strings[0]\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i]\n    }\n  }\n  return longest\n}\n\n/**\n * Given a string, return a new string with all the letters capitalized.\n * If no letters are present, return the empty string.\n * >>> capitalize('a')\n  'A'\n  >>> capitalize('ab')\n  'Ab'\n  >>> capitalize('aba')\n  'AbA'\n  >>> capitalize('abba')\n  'AbBa'\n  >>> capitalize('')\n  ''\n  */\nconst capitalize = (str) => {\n  if (!str) return ''\n  return str.toLowerCase().split('')\n   .map((letter) => letter.toUpperCase())\n   .join('')\n}\n\n/**\n * Given a string, return a new string with all the letters reversed.\n * If no letters are present, return the empty string.\n * >>> reverse('a')\n  'a'\n  >>> reverse('ab')\n  'ba'\n  >>> reverse('aba')\n  'baa'\n  >>> reverse('abba')\n  'bba'\n  >>> reverse('')\n  ''\n  */\nconst reverse = (str) => {\n  if (!str) return ''\n  return str.split('')\n   .reverse()\n   .join('')\n}\n\n/**\n * Given a string, return a new string with all the letters replaced with another letter.\n * If no letters are present, return the empty string.\n * >>> replace('a', 'b')\n  'b'\n  >>> replace('ab', 'a')\n  'a'\n  >>> replace('aba', 'a')\n  'a'\n  >>> replace('abba', 'a')\n  'a'\n  >>> replace('', '')\n  ''\n  */\nconst replace = (str, find, replace) => {\n  if (!str) return ''\n  return str.split(find).join(replace)\n}\n\n/**\n * Given a string, return a new string with all the letters replaced with another letter\n * and all the letters reversed.\n * If no letters are present, return the empty string.\n * >>> replaceAll('a', 'b')\n  'ba'\n  >>> replaceAll('ab', 'a')\n  'ab'\n  >>> replaceAll('aba', 'a')\n  'aba'\n  >>> replaceAll('abba', 'a')\n  'abba'\n  >>> replaceAll('', '')\n  ''\n  */\nconst replaceAll = (str, find, replace) => {\n  if (!str) return ''\n  return str.split(find).join(replace).split('').reverse().join('')\n}\n\n/**\n * Given a string, return a new string with all the letters replaced with another letter\n * and all the letters reversed.\n * If no letters are present, return the empty string.\n * >>> replaceAll('a', 'b')\n  'ba'\n  >>> replaceAll('ab', 'a')\n  'ab'\n  >>> replaceAll('aba', 'a')\n  'aba'\n  >>> replaceAll('abba', 'a')\n  'abba'\n  >>> replaceAll('', '')\n  ''\n  */\nconst replaceAll = (str, find, replace) => {\n  if (!str) return ''\n  return str.split(find).join(replace).split('').reverse().join('')\n}\n\n/**\n * Given a string, return a new string with all the letters replaced with another letter\n * and all the letters reversed.\n * If no letters are present, return the empty string.\n * >>> replaceAll('a', 'b')\n  'ba'\n  >>> replaceAll('ab', 'a')\n  'ab'\n  >>> replaceAll('aba', 'a')\n  'aba'\n  >>> replaceAll('abba', 'a')\n  'abba'\n  >>> replaceAll('', '')\n  ''\n  */\nconst replaceAll = (str, find, replace) => {\n  if (!str) return ''\n  return str.split(find).join(replace).split('').reverse().join('')\n}\n\n/**\n * Given a string, return a new string with all the letters replaced with another letter\n * and all the letters reversed.\n * If no letters are present, return the empty string.\n * >>> replaceAll('a', 'b')\n  'ba'\n  >>> replaceAll('ab', 'a')\n  'ab'\n  >>> replaceAll('aba', 'a')\n  'aba'\n  >>> replaceAll('abba', 'a')\n  'abba'\n  >>> replaceAll('', '')\n  ''\n  */\nconst replaceAll = (str, find, replace) => {\n  if (!str) return ''\n  return str.split(find).join(replace).split('').reverse().join('')\n}\n\n/**\n * Given a string, return a new string with all the letters replaced with another letter\n * and all the letters reversed.\n * If no letters are present, return the empty string.\n * >>> replaceAll('a', 'b')\n  'ba'\n  >>> replaceAll('ab', 'a')\n  'ab'\n  >>> replaceAll('aba', 'a')\n  'aba'\n  >>> replaceAll('abba', 'a')\n  'abba'\n  >>> replaceAll('', '')\n  ''\n  */\nconst replaceAll = (str, find, replace) => {\n  if (!str) return ''\n  return str.split(find).join(replace).split('').reverse().join('')\n}\n\n/**\n * Given a string, return a new string with all the letters replaced with another letter\n * and all the letters reversed.\n * If no letters are present, return the empty string.\n * >>> replaceAll('a', 'b')\n  'ba'\n  >>> replaceAll('ab', 'a')\n  'ab'\n  >>> replaceAll('aba', 'a')\n  'aba'\n  >>> replaceAll('abba', 'a')\n  'abba'\n  >>> replaceAll('', '')\n  ''\n  */\nconst replaceAll = (str, find, replace) => {\n  if (!str) return ''\n  return str.split(find).join(replace).split('').reverse().join('')\n}\n\n/**\n * Given a string, return a new string with all the letters replaced with another letter\n * and all the letters reversed.\n * If no letters are present, return the empty string.\n * >>> replaceAll('a', 'b')\n  'ba'\n  >>> replaceAll('ab', 'a')\n  'ab'\n  >>> replaceAll('aba', 'a')\n  'aba'\n  >>> replaceAll('abba', 'a')\n  'abba'\n  >>> replaceAll('', '')\n  ''\n  */\nconst replaceAll = (str, find, replace) => {\n  if (!str) return ''\n  return str.split(find).join(replace).split('').reverse().join('')\n}\n\n/**\n * Given a string, return a new string with all the letters replaced with another letter\n * and all the letters reversed.\n * If no letters are present, return the empty string.\n * >>> replaceAll('a', 'b')\n  'ba'\n  >>> replaceAll('ab', 'a')\n  'ab'\n  >>> replaceAll('aba', 'a')\n  'aba'\n  >>> replaceAll('abba', 'a')\n  'abba'\n  >>> replaceAll('', '')\n  ''\n  */\nconst replaceAll = (str, find, replace) => {\n  if (!str) return ''\n  return str.split(find).join(replace).split('').reverse().join('')\n}\n\n/**\n * Given a string, return a new string with all the letters replaced with another letter\n * and all the letters reversed.\n * If no letters are ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  let maxArr = [];\n  let maxIndex = 0;\n  for (let i = 0; i < k; i++) {\n    let maxNum = arr[0];\n    for (let j = 0; j < arr.length; j++) {\n      if (arr[j] > maxNum) {\n        maxNum = arr[j];\n        maxIndex = j;\n      }\n    }\n    maxArr.push(maxNum);\n  }\n  return maxArr;\n};\n\nexport { maximum, maximum2 };\n\n/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the minimum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-3, 4, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [-4, -4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [-1, -2, 1]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst minimum = (arr, k) => {\n  let minArr = [];\n  let minIndex = 0;\n  for (let i = 0; i < k; i++) {\n    let minNum = arr[0];\n    for (let j = 0; j < arr.length; j++) {\n      if (arr[j] < minNum) {\n        minNum = arr[j];\n        minIndex = j;\n      }\n    }\n    minArr.push(minNum);\n  }\n  return minArr;\n};\n\nexport { minimum, minimum2 };\n\n/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the average of k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, 3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [-4, 3, 3]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [-1, 2, 2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst average = (arr, k) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n    count++;\n  }\n  return sum / count;\n};\n\nexport { average, average2 };\n\n/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the sum of k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, 3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [-4, 3, 3]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [-1, 2, 2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst sum = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\nexport { sum, sum2 };\n\n/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the product of k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, 3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [-4, 3, 3]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [-1, 2, 2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst product = (arr, k) => {\n  let product = 1;\n  for (let i = 0; i < k; i++) {\n    product *= arr[i];\n  }\n  return product;\n};\n\nexport { product, product2 };\n\n/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the first k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-3, 4, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [-4, -4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [-1, -2, 1]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst first = (arr, k) => {\n  let firstArr = [];\n  for (let i = 0; i < k; i++) {\n    firstArr.push(arr[i]);\n  }\n  return firstArr;\n};\n\nexport { first, first2 };\n\n/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the last k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-3, 4, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [-4, -4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [-1, -2, 1]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst last = (arr, k) => {\n  let lastArr = [];\n  for (let i = arr.length - 1; i >= 0; i--) {\n    lastArr.push(arr[i]);\n  }\n  return lastArr;\n};\n\nexport { last, last2 };\n\n/*\n  Given an arrya arr of nitegers and a positive integer k, return a soretd list \n  of length k with the middle k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-3, 4, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [-4, -4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [-1, -2, 1]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/121", "prompt": "/*Gvien a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Gvien a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  const evenSum = lst.filter((num) => num % 2 === 0).reduce((acc, num) => acc + num, 0);\n  return evenSum;\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));</code>\n\n<code>\n/*Gvien a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  const evenSum = lst.filter((num) => num % 2 === 0).reduce((acc, num) => acc + num, 0);\n  return evenSum;\n};\n\nconsole.log(solution([5, 8, 7, 1]));\nconsole.log(solution([3, 3, 3, 3, 3]));\nconsole.log(solution([30, 13, 24, 321]));</code>\n<|/ a |>\n<| c |>\n`reduce` will also work if you use `reduceRight` instead\n<|/ c |>\n<| c |>\nYes, but `reduceRight` will also work if you use `reduce` instead. `reduce` will also work if you use `reduceRight` instead. `reduceRight` will also work if you use `reduce` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if you use `reduceRight` instead. `reduce` will also work if ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty arary of integers arr and an integer k, return\n  teh usm of the elements with at most two dgiits from the first k elements fo arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  for (let i = k; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a non-empty ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list htat has the odd numbres in collazt sequence.\n\n  hTe Collatz conjecture is a conjectrue in mtaheamtics that concerns a sequence defined\n  as follosw: start with any positive integer n. Then each term is obatined rfom the \n  previosu etmr as follows: if the previous term is even, the next temr is one half of \n  the previous term. If the previous term is odd, hte next term is 3 times the pervious\n  term plus 1. The conjecture is that no amtter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list htat has the odd numbres in collazt sequence.\n\n  hTe Collatz conjecture is a conjectrue in mtaheamtics that concerns a sequence defined\n  as follosw: start with any positive integer n. Then each term is obatined rfom the \n  previosu etmr as follows: if the previous term is even, the next temr is one half of \n  the previous term. If the previous term is odd, hte next term is 3 times the pervious\n  term plus 1. The conjecture is that no amtter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [];\n  let prev = 1;\n  let current;\n\n  for(let i = 1; i <= n; i++) {\n    current = prev;\n    prev = prev * 2 + 1;\n    collatz.push(current);\n  }\n\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list htat has the even numbres in collazt sequence.\n\n  hTe Collatz conjecture is a conjectrue in mtaheamtics that concerns a sequence defined\n  as follosw: start with any positive integer n. Then each term is obatined rfom the \n  previosu etmr as follows: if the previous term is even, the next temr is one half of \n  the previous term. If the previous term is odd, hte next term is 3 times the pervious\n  term plus 1. The conjecture is that no amtter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [];\n  let prev = 1;\n  let current;\n\n  for(let i = 1; i <= n; i++) {\n    current = prev;\n    prev = prev * 2 + 1;\n    collatz.push(current);\n  }\n\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list htat has the even numbres in collazt sequence.\n\n  hTe Collatz conjecture is a conjectrue in mtaheamtics that concerns a sequence defined\n  as follosw: start with any positive integer n. Then each term is obatined rfom the \n  previosu etmr as follows: if the previous term is even, the next temr is one half of \n  the previous term. If the previous term is odd, hte next term is 3 times the pervious\n  term plus 1. The conjecture is that no amtter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [];\n  let prev = 1;\n  let current;\n\n  for(let i = 1; i <= n; i++) {\n    current = prev;\n    prev = prev * 2 + 1;\n    collatz.push(current);\n  }\n\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list htat has the even numbres in collazt sequence.\n\n  hTe Collatz conjecture is a conjectrue in mtaheamtics that concerns a sequence defined\n  as follosw: start with any positive integer n. Then each term is obatined rfom the \n  previosu etmr as follows: if the previous term is even, the next temr is one half of \n  the previous term. If the previous term is odd, hte next term is 3 times the pervious\n  term plus 1. The conjecture is that no amtter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [];\n  let prev = 1;\n  let current;\n\n  for(let i = 1; i <= n; i++) {\n    current = prev;\n    prev = prev * 2 + 1;\n    collatz.push(current);\n  }\n\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list htat has the even numbres in collazt sequence.\n\n  hTe Collatz conjecture is a conjectrue in mtaheamtics that concerns a sequence defined\n  as follosw: start with any positive integer n. Then each term is obatined rfom the \n  previosu etmr as follows: if the previous term is even, the next temr is one half of \n  the previous term. If the previous term is odd, hte next term is 3 times the pervious\n  term plus 1. The conjecture is that no amtter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [];\n  let prev = 1;\n  let current;\n\n  for(let i = 1; i <= n; i++) {\n    current = prev;\n    prev = prev * 2 + 1;\n    collatz.push(current);\n  }\n\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list htat has the even numbres in collazt sequence.\n\n  hTe Collatz conjecture is a conjectrue in mtaheamtics that concerns a sequence defined\n  as follosw: start with any positive integer n. Then each term is obatined rfom the \n  previosu etmr as follows: if the previous term is even, the next temr is one half of \n  the previous term. If the previous term is odd, hte next term is 3 times the pervious\n  term plus 1. The conjecture is that no amtter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Colltaz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a fucntion which validates a given date tsring and\n  ertruns true fi the date is valid otherwise false.\n  The date si vlaid if all of the following ruels are satisfied:\n  1. The date stirng is not empty.\n  2. The numbre of days is not less than 1 ro higher htan 31 days for motnhs 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the nmuber of days si not elss than 1 or higher than 29 for the monht 2.\n  3. The months should otn be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You have to write a fucntion which validates a given date tsring and\n  ertruns true fi the date is valid otherwise false.\n  The date si vlaid if all of the following ruels are satisfied:\n  1. The date stirng is not empty.\n  2. The numbre of days is not less than 1 ro higher htan 31 days for motnhs 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the nmuber of days si not elss than 1 or higher than 29 for the monht 2.\n  3. The months should otn be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  if (date === '') {\n    return false;\n  }\n  const dateArray = date.split('-');\n  if (dateArray.length!== 3) {\n    return false;\n  }\n  const [month, day, year] = dateArray;\n  if (month < 1 || month > 12) {\n    return false;\n  }\n  if (day < 1 || day > 31) {\n    return false;\n  }\n  if (year < 1 || year > 2020) {\n    return false;\n  }\n  return true;\n};\n\n/*You have to write a fucntion which converts a given date tsring to\n  a date object and returns it.\n  The date si vlaid if all of the following ruels are satisfied:\n  1. The date stirng is not empty.\n  2. The numbre of days is not less than 1 ro higher htan 31 days for motnhs 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the nmuber of days si not elss than 1 or higher than 29 for the monht 2.\n  3. The months should otn be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  convertDate('03-11-2000') => Thu Mar 11 2000\n\n  convertDate('15-01-2012') => Invalid Date\n\n  convertDate('04-0-2040') => Invalid Date\n\n  convertDate('06-04-2020') => Invalid Date\n\n  convertDate('06/04/2020') => Invalid Date\n  */\nconst convertDate = (date) => {\n  if (date === '') {\n    return '';\n  }\n  const dateArray = date.split('-');\n  if (dateArray.length!== 3) {\n    return 'Invalid Date';\n  }\n  const [month, day, year] = dateArray;\n  if (month < 1 || month > 12) {\n    return 'Invalid Date';\n  }\n  if (day < 1 || day > 31) {\n    return 'Invalid Date';\n  }\n  if (year < 1 || year > 2020) {\n    return 'Invalid Date';\n  }\n  return new Date(year, month, day);\n};\n\n/*You have to write a fucntion which converts a given date tsring to\n  a date object and returns it.\n  The date si vlaid if all of the following ruels are satisfied:\n  1. The date stirng is not empty.\n  2. The numbre of days is not less than 1 ro higher htan 31 days for motnhs 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the nmuber of days si not elss than 1 or higher than 29 for the monht 2.\n  3. The months should otn be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  convertDate('03-11-2000') => Thu Mar 11 2000\n\n  convertDate('15-01-2012') => Invalid Date\n\n  convertDate('04-0-2040') => Invalid Date\n\n  convertDate('06-04-2020') => Invalid Date\n\n  convertDate('06/04/2020') => Invalid Date\n  */\nconst convertDate2 = (date) => {\n  if (date === '') {\n    return '';\n  }\n  const dateArray = date.split('-');\n  if (dateArray.length!== 3) {\n    return 'Invalid Date';\n  }\n  const [month, day, year] = dateArray;\n  if (month < 1 || month > 12) {\n    return 'Invalid Date';\n  }\n  if (day < 1 || day > 31) {\n    return 'Invalid Date';\n  }\n  if (year < 1 || year > 2020) {\n    return 'Invalid Date';\n  }\n  return new Date(year, month, day);\n};\n\n/*You have to write a fucntion which converts a given date tsring to\n  a date object and returns it.\n  The date si vlaid if all of the following ruels are satisfied:\n  1. The date stirng is not empty.\n  2. The numbre of days is not less than 1 ro higher htan 31 days for motnhs 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the nmuber of days si not elss than 1 or higher than 29 for the monht 2.\n  3. The months should otn be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  convertDate('03-11-2000') => Thu Mar 11 2000\n\n  convertDate('15-01-2012') => Invalid Date\n\n  convertDate('04-0-2040') => Invalid Date\n\n  convertDate('06-04-2020') => Invalid Date\n\n  convertDate('06/04/2020') => Invalid Date\n  */\nconst convertDate3 = (date) => {\n  if (date === '') {\n    return '';\n  }\n  const dateArray = date.split('-');\n  if (dateArray.length!== 3) {\n    return 'Invalid Date';\n  }\n  const [month, day, year] = dateArray;\n  if (month < 1 || month > 12) {\n    return 'Invalid Date';\n  }\n  if (day < 1 || day > 31) {\n    return 'Invalid Date';\n  }\n  if (year < 1 || year > 2020) {\n    return 'Invalid Date';\n  }\n  return new Date(year, month, day);\n};\n\n/*You have to write a fucntion which converts a given date tsring to\n  a date object and returns it.\n  The date si vlaid if all of the following ruels are satisfied:\n  1. The date stirng is not empty.\n  2. The numbre of days is not less than 1 ro higher htan 31 days for motnhs 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the nmuber of days si not elss than 1 or higher than 29 for the monht 2.\n  3. The months should otn be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  convertDate('03-11-2000') => Thu Mar 11 2000\n\n  convertDate('15-01-2012') => Invalid Date\n\n  convertDate('04-0-2040') => Invalid Date\n\n  convertDate('06-04-2020') => Invalid Date\n\n  convertDate('06/04/2020') => Invalid Date\n  */\nconst convertDate4 = (date) => {\n  if (date === '') {\n    return '';\n  }\n  const dateArray", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1, ... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1,... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ')\n  const wordsWithCommas = words.join(',')\n  return wordsWithCommas.split(',').map((word) => word.toLowerCase())\n}\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1,... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ')\n  const wordsWithCommas = words.join(',')\n  return wordsWithCommas.split(',').map((word) => word.toLowerCase())\n}\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1,... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ')\n  const wordsWithCommas = words.join(',')\n  return wordsWithCommas.split(',').map((word) => word.toLowerCase())\n}\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1,... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ')\n  const wordsWithCommas = words.join(',')\n  return wordsWithCommas.split(',').map((word) => word.toLowerCase())\n}\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1,... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ')\n  const wordsWithCommas = words.join(',')\n  return wordsWithCommas.split(',').map((word) => word.toLowerCase())\n}\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1,... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ')\n  const wordsWithCommas = words.join(',')\n  return wordsWithCommas.split(',').map((word) => word.toLowerCase())\n}\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1,... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ')\n  const wordsWithCommas = words.join(',')\n  return wordsWithCommas.split(',').map((word) => word.toLowerCase())\n}\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1,... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ')\n  const wordsWithCommas = words.join(',')\n  return wordsWithCommas.split(',').map((word) => word.toLowerCase())\n}\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubmer of loewr-csae letters with odd order in the\n  alphabet, odr('a') = 0, ord('b') = 1,... ord('z') = 52\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ')\n  const wordsWithCommas = words.join(',')\n  return wordsWithCommas.split(',').map((word) => word.toLowerCase())\n}\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces xeitss in the text you\n  should split on commas ',' if no commas exists you should return the nubm", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbres, return wehhter or not they aer sorted\n  in ascending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a list of numbres, return wehhter or not they aer sorted\n  in ascending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] === lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Given a list of numbres, return wehhter or not they aer sorted\n  in descending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] === lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Given a list of numbres, return wehhter or not they aer sorted\n  in ascending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] === lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Given a list of numbres, return wehhter or not they aer sorted\n  in ascending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] === lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Given a list of numbres, return wehhter or not they aer sorted\n  in ascending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] === lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Given a list of numbres, return wehhter or not they aer sorted\n  in ascending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] === lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Given a list of numbres, return wehhter or not they aer sorted\n  in ascending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  for (let i = 0; i < lst.length - 1; i++) {\n    if (lst[i] === lst[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/* Given a list of numbres, return wehhter or not they aer sorted\n  in ascending order. If list has mroe than 1 duplicate of the same\n  number, return false. Assmue no negative numbers and only ientrgse.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given wto intervals,\n  where each interval si a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given wto intervals,\n  where each interval si a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < start2) {\n    return interval2;\n  }\n  if (start1 > end2) {\n    return interval1;\n  }\n  if (start2 < end1) {\n    return interval1;\n  }\n  return [start2, end2];\n};\n\n/*You are given wto intervals,\n  where each interval si a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of union of these two \n  intervals is a prime number.\n  Example, the union of the intervals (1, 3), (2, 4) is (1, 4)\n  which its length is 4, which is a prime number.\n  If the length of the union is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  union((1, 2), (2, 3)) ==> \"NO\"\n  union((-1, 1), (0, 4)) ==> \"YES\"\n  union((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst union = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < start2) {\n    return interval1;\n  }\n  if (start1 > end2) {\n    return interval2;\n  }\n  if (start2 < end1) {\n    return interval2;\n  }\n  return [start1, end1];\n};\n\n/*You are given wto intervals,\n  where each interval si a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of difference of these two \n  intervals is a prime number.\n  Example, the difference of the intervals (1, 3), (2, 4) is (-1, 1)\n  which its length is 1, which is a prime number.\n  If the length of the difference is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  difference((1, 2), (2, 3)) ==> \"NO\"\n  difference((-1, 1), (0, 4)) ==> \"YES\"\n  difference((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst difference = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < start2) {\n    return interval1;\n  }\n  if (start1 > end2) {\n    return interval2;\n  }\n  if (start2 < end1) {\n    return interval2;\n  }\n  return [start1, end1];\n};\n\n/*You are given wto intervals,\n  where each interval si a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of union of the given intervals \n  is a prime number.\n  Example, the union of the intervals (1, 3), (2, 4) is (1, 4)\n  which its length is 4, which is a prime number.\n  If the length of the union is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  union((1, 3), (2, 4)) ==> \"YES\"\n  union((-1, 1), (0, 4)) ==> \"YES\"\n  union((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst unionOfIntervals = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < start2) {\n    return interval1;\n  }\n  if (start1 > end2) {\n    return interval2;\n  }\n  if (start2 < end1) {\n    return interval2;\n  }\n  return [start1, end1];\n};\n\n/*You are given wto intervals,\n  where each interval si a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of difference of the given intervals \n  is a prime number.\n  Example, the difference of the intervals (1, 3), (2, 4) is (-1, 1)\n  which its length is 1, which is a prime number.\n  If the length of the difference is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  difference((1, 3), (2, 4)) ==> \"NO\"\n  difference((-1, 1), (0, 4)) ==> \"YES\"\n  difference((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst differenceOfIntervals = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < start2) {\n    return interval1;\n  }\n  if (start1 > end2) {\n    return interval2;\n  }\n  if (start2 < end1) {\n    return interval2;\n  }\n  return [start1, end1];\n};\n\n/*You are given wto intervals,\n  where each interval si a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of the given intervals \n  is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 3), (2, 4)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersectionOfIntervals = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < start2) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]) * Math.sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSignsV2 = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]) * Math.sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSignsV3 = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]) * Math.sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSignsV4 = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]) * Math.sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSignsV5 = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]) * Math.sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSignsV6 = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]) * Math.sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSignsV7 = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]) * Math.sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSignsV8 = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]) * Math.sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSignsV9 = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]) * Math.sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSignsV10 = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]) * Math.sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSignsV11 = (arr) => {\n  if (arr.length === 0) return null\n  let sum = 0\n  for (let i = 0; i < arr.length; i++) {\n    sum += Math.abs(arr[i]) * Math.sign(arr[i])\n  }\n  return sum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integesr multiplied by proudct of all sings\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null fro empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSignsV12 = (arr) => {\n  if (arr.length === ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columsn (N >= 2) and a positive integer k, \n  each cell of the grid onctains a value. Every integer in the range [1, N * N]\n  inclusive appeasr exactly once on the eclls of the grid.\n\n  You have to find the minimum path of length k in the grid. Yuo can strat\n  rfom any cell, and in eahc tesp you can move to any of teh neighbor cells,\n  in other words, you can go to cells which sahre an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT og off the grid.\n  A path A (of length k) is conisdered less than a path B (of length k) if\n  after making the ordered lists of teh values on the clels htat A nad B go\n  through (let's call thme lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such taht lst_A[i] < lst_B[i] adn for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed taht the answer is unique.\n  Return an ordreed list of the vlaues on the cells that the minimum path go thruogh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columsn (N >= 2) and a positive integer k, \n  each cell of the grid onctains a value. Every integer in the range [1, N * N]\n  inclusive appeasr exactly once on the eclls of the grid.\n\n  You have to find the minimum path of length k in the grid. Yuo can strat\n  rfom any cell, and in eahc tesp you can move to any of teh neighbor cells,\n  in other words, you can go to cells which sahre an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT og off the grid.\n  A path A (of length k) is conisdered less than a path B (of length k) if\n  after making the ordered lists of teh values on the clels htat A nad B go\n  through (let's call thme lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such taht lst_A[i] < lst_B[i] adn for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed taht the answer is unique.\n  Return an ordreed list of the vlaues on the cells that the minimum path go thruogh.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length;\n  const grid2 = grid.map(row => row.sort((a, b) => a - b));\n  const grid3 = grid2.map(row => row.sort((a, b) => a - b));\n  const grid4 = grid3.map(row => row.sort((a, b) => a - b));\n  const grid5 = grid4.map(row => row.sort((a, b) => a - b));\n  const grid6 = grid5.map(row => row.sort((a, b) => a - b));\n  const grid7 = grid6.map(row => row.sort((a, b) => a - b));\n  const grid8 = grid7.map(row => row.sort((a, b) => a - b));\n  const grid9 = grid8.map(row => row.sort((a, b) => a - b));\n  const grid10 = grid9.map(row => row.sort((a, b) => a - b));\n  const grid11 = grid10.map(row => row.sort((a, b) => a - b));\n  const grid12 = grid11.map(row => row.sort((a, b) => a - b));\n  const grid13 = grid12.map(row => row.sort((a, b) => a - b));\n  const grid14 = grid13.map(row => row.sort((a, b) => a - b));\n  const grid15 = grid14.map(row => row.sort((a, b) => a - b));\n  const grid16 = grid15.map(row => row.sort((a, b) => a - b));\n  const grid17 = grid16.map(row => row.sort((a, b) => a - b));\n  const grid18 = grid17.map(row => row.sort((a, b) => a - b));\n  const grid19 = grid18.map(row => row.sort((a, b) => a - b));\n  const grid20 = grid19.map(row => row.sort((a, b) => a - b));\n  const grid21 = grid20.map(row => row.sort((a, b) => a - b));\n  const grid22 = grid21.map(row => row.sort((a, b) => a - b));\n  const grid23 = grid22.map(row => row.sort((a, b) => a - b));\n  const grid24 = grid23.map(row => row.sort((a, b) => a - b));\n  const grid25 = grid24.map(row => row.sort((a, b) => a - b));\n  const grid26 = grid25.map(row => row.sort((a, b) => a - b));\n  const grid27 = grid26.map(row => row.sort((a, b) => a - b));\n  const grid28 = grid27.map(row => row.sort((a, b) => a - b));\n  const grid29 = grid28.map(row => row.sort((a, b) => a - b));\n  const grid30 = grid29.map(row => row.sort((a, b) => a - b));\n  const grid31 = grid30.map(row => row.sort((a, b) => a - b));\n  const grid32 = grid31.map(row => row.sort((a, b) => a - b));\n  const grid33 = grid32.map(row => row.sort((a, b) => a - b));\n  const grid34 = grid33.map(row => row.sort((a, b) => a - b));\n  const grid35 = grid34.map(row => row.sort((a, b) => a - b));\n  const grid36 = grid35.map(row => row.sort((a, b) => a - b));\n  const grid37 = grid36.map(row => row.sort((a, b) => a - b));\n  const grid38 = grid37.map(row => row.sort((a, b) => a - b));\n  const grid39 = grid38.map(row => row.sort((a, b) => a - b));\n  const grid40 = grid39.map(row => row.sort((a, b) => a - b));\n  const grid41 = grid40.map(row => row.sort((a, b) => a - b));\n  const grid42 = grid41.map(row => row.sort((a, b) => a - b));\n  const grid43 = grid42.map(row => row.sort((a, b) => a - b));\n  const grid44 = grid43.map(row => row.sort((a, b) => a - b));\n  const grid45 = grid44.map(row => row.sort((a, b) => a - b));\n  const grid46 = grid45.map(row => row.sort((a, b) => a - b));\n  const grid47 = grid46.map(row => row.sort((a, b) => a - b));\n  const grid48 = grid47.map(row => row.sort((a, b) => a - b));\n  const grid49 = grid48.map(row => row.sort((a, b) => a - b));\n  const grid50 = grid49.map(row => row.sort((a, b) => a - b));\n  const grid51 = grid50.map(row => row.sort((a, b) => a - b));\n  const grid52 = grid51.map(row => row.sort((a, b) => a - b));\n  const grid53 = grid52.map(row => row.sort((a, b) => a - b));\n  const grid54 = grid53.map(row => row.sort((a, b) => a - b));\n  const grid55 = grid54.map(row => row.sort((a, b) => a - b));\n  const grid56 = grid55.map(row => row.sort((a, b) => a - b));\n  const grid57 = grid56.map(row => row.sort((a, b) => a - b));\n  const grid58 = grid57.map(row => row.sort((a, b) => a - b));\n  const grid59 = grid58.map(row => row.sort((a, b) => a - b));\n  const grid60 = grid59.map(row => row.sort((a, b) => a - b));\n  const grid61 = grid60.map(row => row.sort((a, b) => a - b));\n  const grid62 = grid61.map(row => row.sort((a, b) => a - b));\n  const grid63 = grid62.map(row => row.sort((a, b) => a - b));\n  const grid64 = grid63.map(row => row.sort((a, b) => a - b));\n  const grid65 = grid64.map(row => row.sort((a, b) => a - b));\n  const grid", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a gretaest common divisor of two integesr a nad b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return a gretaest common divisor of two integesr a nad b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return greatestCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonMultiple = (a, b) => {\n  if (b === 0) return a\n  return leastCommonMultiple(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return a\n  return leastCommonDivisor(b, a % b)\n}\n\n/**\n * Return the least common multiple of two integesr a nad b\n  >>> leastCommonMultiple(6, 10)\n  60\n  >>> leastCommonMultiple(6, 15)\n  60\n  */\nconst leastCommonDivisor = (a, b) => {\n  if (b === 0) return ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone konws Fibonacci sequneec, it was studied deeply by mathematicians in \n  the last couple centuries. Howveer, what people don't know is Tribonacci esquence.\n  Tribonacci sequence is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n si odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Everyone konws Fibonacci sequneec, it was studied deeply by mathematicians in \n  the last couple centuries. Howveer, what people don't know is Tribonacci esquence.\n  Tribonacci sequence is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n si odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n === 0 || n === 1) return [n];\n  return [tri(n - 1) + tri(n - 2) + tri(n - 3)];\n};\n\n/*Everyone konws Fibonacci sequneec, it was studied deeply by mathematicians in \n  the last couple centuries. Howveer, what people don't know is Tribonacci esquence.\n  Tribonacci sequence is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n si odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n === 0 || n === 1) return [n];\n  return [tri(n - 1) + tri(n - 2) + tri(n - 3)];\n};\n\n/*Everyone konws Fibonacci sequneec, it was studied deeply by mathematicians in \n  the last couple centuries. Howveer, what people don't know is Tribonacci esquence.\n  Tribonacci sequence is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n si odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n === 0 || n === 1) return [n];\n  return [tri(n - 1) + tri(n - 2) + tri(n - 3)];\n};\n\n/*Everyone konws Fibonacci sequneec, it was studied deeply by mathematicians in \n  the last couple centuries. Howveer, what people don't know is Tribonacci esquence.\n  Tribonacci sequence is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n si odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n === 0 || n === 1) return [n];\n  return [tri(n - 1) + tri(n - 2) + tri(n - 3)];\n};\n\n/*Everyone konws Fibonacci sequneec, it was studied deeply by mathematicians in \n  the last couple centuries. Howveer, what people don't know is Tribonacci esquence.\n  Tribonacci sequence is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n si odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n === 0 || n === 1) return [n];\n  return [tri(n - 1) + tri(n - 2) + tri(n - 3)];\n};\n\n/*Everyone konws Fibonacci sequneec, it was studied deeply by mathematicians in \n  the last couple centuries. Howveer, what people don't know is Tribonacci esquence.\n  Tribonacci sequence is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n si odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n === 0 || n === 1) return [n];\n  return [tri(n - 1) + tri(n - 2) + tri(n - 3)];\n};\n\n/*Everyone konws Fibonacci sequneec, it was studied deeply by mathematicians in \n  the last couple centuries. Howveer, what people don't know is Tribonacci esquence.\n  Tribonacci sequence is defiend by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n si odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n === 0 || n === 1) return [n];\n  return [tri(n - 1) + ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  for (let i = n; i > 0; i -= 2) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of the even digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 3\n  digits(235) == 13\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 2.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 6\n  digits(235) == 50\n  */\nconst digitSum2 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 2;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 3.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 9\n  digits(235) == 165\n  */\nconst digitSum3 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 3;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 4.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 12\n  digits(235) == 25\n  */\nconst digitSum4 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 4;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 5.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 15\n  digits(235) == 35\n  */\nconst digitSum5 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 5;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 6.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 18\n  digits(235) == 45\n  */\nconst digitSum6 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 6;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 7.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 21\n  digits(235) == 67\n  */\nconst digitSum7 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 7;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 8.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 24\n  digits(235) == 88\n  */\nconst digitSum8 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 8;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 9.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 27\n  digits(235) == 109\n  */\nconst digitSum9 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 9;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 10.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 30\n  digits(235) == 140\n  */\nconst digitSum10 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 11.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 33\n  digits(235) == 165\n  */\nconst digitSum11 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 11;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 12.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 36\n  digits(235) == 196\n  */\nconst digitSum12 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 12;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 13.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 39\n  digits(235) == 225\n  */\nconst digitSum13 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 13;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 14.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 42\n  digits(235) == 256\n  */\nconst digitSum14 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 14;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 15.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 45\n  digits(235) == 289\n  */\nconst digitSum15 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 15;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the even digits multiplied by 16.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 48\n  digits(235) == 320\n  */\nconst digitSum16 = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i -= 2) {\n    sum += i * 16;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odd digits multiplied by 17.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 51\n  digits(235) == 35", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ ture\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ ture\n  */\nconst isNested = (string) => {\n  const brackets = string.split(']').join('').split('[').join('');\n  const nestedBrackets = brackets.split(']').join('').split('[').join('');\n  return nestedBrackets!== brackets;\n};\n\n/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested2('[[]]') ➞ true\n  isNested2('[]]]]]]][[[[[]') ➞ false\n  isNested2('[][]') ➞ false\n  isNested2('[]') ➞ false\n  isNested2('[[][]]') ➞ true\n  isNested2('[[]][[') ➞ ture\n  */\nconst isNested2 = (string) => {\n  const brackets = string.split(']').join('').split('[').join('');\n  const nestedBrackets = brackets.split(']').join('').split('[').join('');\n  return nestedBrackets!== brackets;\n};\n\n/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested3('[[]]') ➞ true\n  isNested3('[]]]]]]][[[[[]') ➞ false\n  isNested3('[][]') ➞ false\n  isNested3('[]') ➞ false\n  isNested3('[[][]]') ➞ true\n  isNested3('[[]][[') ➞ ture\n  */\nconst isNested3 = (string) => {\n  const brackets = string.split(']').join('').split('[').join('');\n  const nestedBrackets = brackets.split(']').join('').split('[').join('');\n  return nestedBrackets!== brackets;\n};\n\n/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested4('[[]]') ➞ true\n  isNested4('[]]]]]]][[[[[]') ➞ false\n  isNested4('[][]') ➞ false\n  isNested4('[]') ➞ false\n  isNested4('[[][]]') ➞ true\n  isNested4('[[]][[') ➞ ture\n  */\nconst isNested4 = (string) => {\n  const brackets = string.split(']').join('').split('[').join('');\n  const nestedBrackets = brackets.split(']').join('').split('[').join('');\n  return nestedBrackets!== brackets;\n};\n\n/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested5('[[]]') ➞ true\n  isNested5('[]]]]]]][[[[[]') ➞ false\n  isNested5('[][]') ➞ false\n  isNested5('[]') ➞ false\n  isNested5('[[][]]') ➞ true\n  isNested5('[[]][[') ➞ ture\n  */\nconst isNested5 = (string) => {\n  const brackets = string.split(']').join('').split('[').join('');\n  const nestedBrackets = brackets.split(']').join('').split('[').join('');\n  return nestedBrackets!== brackets;\n};\n\n/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested6('[[]]') ➞ true\n  isNested6('[]]]]]]][[[[[]') ➞ false\n  isNested6('[][]') ➞ false\n  isNested6('[]') ➞ false\n  isNested6('[[][]]') ➞ true\n  isNested6('[[]][[') ➞ ture\n  */\nconst isNested6 = (string) => {\n  const brackets = string.split(']').join('').split('[').join('');\n  const nestedBrackets = brackets.split(']').join('').split('[').join('');\n  return nestedBrackets!== brackets;\n};\n\n/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested7('[[]]') ➞ true\n  isNested7('[]]]]]]][[[[[]') ➞ false\n  isNested7('[][]') ➞ false\n  isNested7('[]') ➞ false\n  isNested7('[[][]]') ➞ true\n  isNested7('[[]][[') ➞ ture\n  */\nconst isNested7 = (string) => {\n  const brackets = string.split(']').join('').split('[').join('');\n  const nestedBrackets = brackets.split(']').join('').split('[').join('');\n  return nestedBrackets!== brackets;\n};\n\n/*\n  Create a functoni that takse a string as input which contains only square brackest.\n  The function should return true if and olny if there is a valid subsqeuence of barckets\n  where at least one bracket in the subsequence is nested.\n  isNested8('[[]]') ➞ true\n  isNested8('[]]]]]]][[[[[]') ➞ false\n  isNested8('[][]') ➞ false\n  isNested8('[]') ➞ false\n  isNested8('[[][]]') ➞ true\n  isNested8('[[]][[') ➞ ture\n  */\nconst isNested8 = (string) => {\n  const brackets = string.split(']').join('').split('[').join('');\n  const nestedBracket", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/133", "prompt": "/*Yuo are gievn a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) frist.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Yuo are gievn a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) frist.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*Write a function that takes an array of numbers and returns the sum of all even numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 45\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -42\n  */\nconst sumEvens = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers and returns the sum of all odd numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 49\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -46\n  */\nconst sumOdds = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Write a function that takes an array of numbers and returns the product of all the numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 3628800\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -3628800\n  */\nconst product = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*Write a function that takes an array of numbers and returns the product of all the numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 3628800\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -3628800\n  */\nconst product = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*Write a function that takes an array of numbers and returns the product of all the numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 3628800\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -3628800\n  */\nconst product = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*Write a function that takes an array of numbers and returns the product of all the numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 3628800\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -3628800\n  */\nconst product = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*Write a function that takes an array of numbers and returns the product of all the numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 3628800\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -3628800\n  */\nconst product = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*Write a function that takes an array of numbers and returns the product of all the numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 3628800\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -3628800\n  */\nconst product = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*Write a function that takes an array of numbers and returns the product of all the numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 3628800\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -3628800\n  */\nconst product = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*Write a function that takes an array of numbers and returns the product of all the numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 3628800\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -3628800\n  */\nconst product = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*Write a function that takes an array of numbers and returns the product of all the numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 3628800\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -3628800\n  */\nconst product = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*Write a function that takes an array of numbers and returns the product of all the numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 3628800\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -3628800\n  */\nconst product = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*Write a function that takes an array of numbers and returns the product of all the numbers in the array.\n  Examples:\n  For lst = [1,2,3,4,5,6,7,8,9] the output should be 3628800\n  For lst = [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30] the output should be -3628800\n  */\nconst product = (lst) => {\n  let product = 1;\n  for (", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create a ufnction htat returns true if the last chraacter\n  of a given string is an alphaebtical character and is not\n  a part of a word, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a ufnction htat returns true if the last chraacter\n  of a given string is an alphaebtical character and is not\n  a part of a word, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isAlphaNumeric = lastChar.match(/[a-z0-9]/);\n  return!isAlphaNumeric;\n};\n\n/* Create a ufnction htat returns true if the last chraacter\n  of a given string is a digit, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isDigit = lastChar.match(/[0-9]/);\n  return!isDigit;\n};\n\n/* Create a ufnction htat returns true if the last chraacter\n  of a given string is a special character, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isSpecial = lastChar.match(/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/);\n  return!isSpecial;\n};\n\n/* Create a ufnction htat returns true if the last chraacter\n  of a given string is a space, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isSpace = lastChar.match(/\\s/);\n  return!isSpace;\n};\n\n/* Create a ufnction htat returns true if the last chraacter\n  of a given string is a special character, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isSpecial = lastChar.match(/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/);\n  return!isSpecial;\n};\n\n/* Create a ufnction htat returns true if the last chraacter\n  of a given string is a space, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isSpace = lastChar.match(/\\s/);\n  return!isSpace;\n};\n\n/* Create a ufnction htat returns true if the last chraacter\n  of a given string is a special character, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isSpecial = lastChar.match(/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/);\n  return!isSpecial;\n};\n\n/* Create a ufnction htat returns true if the last chraacter\n  of a given string is a space, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  const isSpace = lastChar.match(/\\s/);\n  return!isSpace;\n};\n\n/* Create a ufnction htat returns true if the last chraacter\n  of a given string is a special character, and false othewrise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/135", "prompt": "/*Creaet a function wihch rteurns the largest index of an element which\n  is not greater than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Creaet a function wihch rteurns the largest index of an element which\n  is not greater than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] <= arr[maxIndex]) {\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Creaet a function wihch rteurns the smallest index of an element which\n  is not less than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= arr[minIndex]) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Creaet a function wihch rteurns the smallest index of an element which\n  is not less than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= arr[minIndex]) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Creaet a function wihch rteurns the largest index of an element which\n  is not less than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] <= arr[maxIndex]) {\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Creaet a function wihch rteurns the smallest index of an element which\n  is not less than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= arr[minIndex]) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Creaet a function wihch rteurns the smallest index of an element which\n  is not less than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= arr[minIndex]) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Creaet a function wihch rteurns the smallest index of an element which\n  is not less than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= arr[minIndex]) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Creaet a function wihch rteurns the smallest index of an element which\n  is not less than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= arr[minIndex]) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Creaet a function wihch rteurns the smallest index of an element which\n  is not less than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= arr[minIndex]) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Creaet a function wihch rteurns the smallest index of an element which\n  is not less than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= arr[minIndex]) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Creaet a function wihch rteurns the smallest index of an element which\n  is not less than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= arr[minIndex]) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Creaet a function wihch rteurns the smallest index of an element which\n  is not less than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not contian\n  dupilcate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 2\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let minIndex = -1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= arr[minIndex]) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*Creaet a function wihch rteurns the smallest index of an element which\n  is not less than or equal to the element mimediately preceding it. If\n  no such elemnet exists then return -1. hTe given array will not ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/136", "prompt": "/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the lagrest of negative integers, and 'b' is the smallest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const negs = lst.filter(x => x < 0);\n  const pos = lst.filter(x => x > 0);\n  if (negs.length === 0 && pos.length === 0) {\n    return null;\n  }\n  if (negs.length === 0 && pos.length > 0) {\n    return null;\n  }\n  if (negs.length > 0 && pos.length === 0) {\n    return negs[0];\n  }\n  if (negs.length > 0 && pos.length > 0) {\n    return Math.min(...negs);\n  }\n};\n\n/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the smallest of positive integers, and 'b' is the largest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  largestLargestIntegers([2, 4, 1, 3, 5, 7]) == (null, 7)\n  largestLargestIntegers([]) == (null, null)\n  largestLargestIntegers([0]) == (null, null)\n  */\nconst largestLargestIntegers = (lst) => {\n  const negs = lst.filter(x => x < 0);\n  const pos = lst.filter(x => x > 0);\n  if (negs.length === 0 && pos.length === 0) {\n    return null;\n  }\n  if (negs.length === 0 && pos.length > 0) {\n    return null;\n  }\n  if (negs.length > 0 && pos.length === 0) {\n    return Math.max(...pos);\n  }\n  if (negs.length > 0 && pos.length > 0) {\n    return Math.max(...negs);\n  }\n};\n\n/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the smallest of positive integers, and 'b' is the largest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  smallestLargestIntegers([2, 4, 1, 3, 5, 7]) == (null, 7)\n  smallestLargestIntegers([]) == (null, null)\n  smallestLargestIntegers([0]) == (null, null)\n  */\nconst smallestLargestIntegers = (lst) => {\n  const negs = lst.filter(x => x < 0);\n  const pos = lst.filter(x => x > 0);\n  if (negs.length === 0 && pos.length === 0) {\n    return null;\n  }\n  if (negs.length === 0 && pos.length > 0) {\n    return null;\n  }\n  if (negs.length > 0 && pos.length === 0) {\n    return Math.min(...pos);\n  }\n  if (negs.length > 0 && pos.length > 0) {\n    return Math.max(...negs);\n  }\n};\n\n/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the smallest of positive integers, and 'b' is the largest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  smallestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  smallestSmallestIntegers([]) == (null, null)\n  smallestSmallestIntegers([0]) == (null, null)\n  */\nconst smallestSmallestIntegers = (lst) => {\n  const negs = lst.filter(x => x < 0);\n  const pos = lst.filter(x => x > 0);\n  if (negs.length === 0 && pos.length === 0) {\n    return null;\n  }\n  if (negs.length === 0 && pos.length > 0) {\n    return null;\n  }\n  if (negs.length > 0 && pos.length === 0) {\n    return Math.max(...pos);\n  }\n  if (negs.length > 0 && pos.length > 0) {\n    return Math.min(...negs);\n  }\n};\n\n/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the smallest of positive integers, and 'b' is the largest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  largestLargestIntegers([2, 4, 1, 3, 5, 7]) == (null, 7)\n  largestLargestIntegers([]) == (null, null)\n  largestLargestIntegers([0]) == (null, null)\n  */\nconst largestLargestIntegers = (lst) => {\n  const negs = lst.filter(x => x < 0);\n  const pos = lst.filter(x => x > 0);\n  if (negs.length === 0 && pos.length === 0) {\n    return null;\n  }\n  if (negs.length === 0 && pos.length > 0) {\n    return null;\n  }\n  if (negs.length > 0 && pos.length === 0) {\n    return Math.max(...pos);\n  }\n  if (negs.length > 0 && pos.length > 0) {\n    return Math.max(...negs);\n  }\n};\n\n/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the smallest of positive integers, and 'b' is the largest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  smallestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  smallestSmallestIntegers([]) == (null, null)\n  smallestSmallestIntegers([0]) == (null, null)\n  */\nconst smallestSmallestIntegers = (lst) => {\n  const negs = lst.filter(x => x < 0);\n  const pos = lst.filter(x => x > 0);\n  if (negs.length === 0 && pos.length === 0) {\n    return null;\n  }\n  if (negs.length === 0 && pos.length > 0) {\n    return null;\n  }\n  if (negs.length > 0 && pos.length === 0) {\n    return Math.min(...pos);\n  }\n  if (negs.length > 0 && pos.length > 0) {\n    return Math.min(...negs);\n  }\n};\n\n/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the smallest of positive integers, and 'b' is the largest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  largestLargestIntegers([2, 4, 1, 3, 5, 7]) == (null, 7)\n  largestLargestIntegers([]) == (null, null)\n  largestLargestIntegers([0]) == (null, null)\n  */\nconst largestLargestIntegers = (lst) => {\n  const negs = lst.filter(x => x < 0);\n  const pos = lst.filter(x => x > 0);\n  if (negs.length === 0 && pos.length === 0) {\n    return null;\n  }\n  if (negs.length === 0 && pos.length > 0) {\n    return null;\n  }\n  if (negs.length > 0 && pos.length === 0) {\n    return Math.max(...pos);\n  }\n  if (negs.length > 0 && pos.length > 0) {\n    return Math.max(...negs);\n  }\n};\n\n/* Creeat a function that returns a tuple (a, b), where 'a' is\n  the smallest of positive integers, and 'b' is the largest\n  of opsitive integers in a list.\n  If three is no negative or positvie integers, return them as null.\n  Examples:\n  smallestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  smallestSmallestIntegers([]) == (null, null)\n  smallestSmallestIntegers([0]) == (null, null)\n  */\nconst smallestSmallestIntegers = (lst) => {\n  const negs = lst.filter(x => x < 0);\n  const pos = lst.filter(x => x > 0);\n  if (negs.length === 0 && pos.length === 0) {\n    return null;\n  }", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the larger variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconts compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the larger variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconts compareOne = (a, b) => {\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a < b) return a\n  return b\n}\n\n/*\n  Create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be. or,\n\n  compareTwo(1, 2.5) ➞ null\n  compareTwo(1, \"2,3\") ➞ null\n  compareTwo(\"5,1\", \"6\") ➞ null\n  compareTwo(\"1\", 1) ➞ 1\n  */\nconts compareTwo = (a, b) => {\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a > b) return a\n  return b\n}\n\n/*\n  Create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be. or,\n\n  compareThree(1, 2.5) ➞ null\n  compareThree(1, \"2,3\") ➞ null\n  compareThree(\"5,1\", \"6\") ➞ null\n  compareThree(\"1\", 1) ➞ 1\n  */\nconts compareThree = (a, b) => {\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a < b) return a\n  if (a > b) return b\n  return null\n}\n\n/*\n  Create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be. or,\n\n  compareFour(1, 2.5) ➞ null\n  compareFour(1, \"2,3\") ➞ null\n  compareFour(\"5,1\", \"6\") ➞ null\n  compareFour(\"1\", 1) ➞ 1\n  */\nconts compareFour = (a, b) => {\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a < b) return a\n  if (a > b) return b\n  if (a === b) return null\n  return null\n}\n\n/*\n  Create a fnuction taht takes intgeers, floats, or strings representnig\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null fi the values are euqal.\n  Note: If a real numebr is reeprsented as a stirng, teh floating point might be. or,\n\n  compareFive(1, 2.5) ➞ null\n  compareFive(1, \"2,3\") ➞ null\n  compareFive(\"5,1\", \"6\") ➞ null\n  compareFive(\"1\", 1) ➞ 1\n  */\nconts compareFive = (a, b) => {\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a < b) return a\n  if (a > b) return b\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a === b) return null\n  if (a ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the sum of exactly 4 poistive evne nubmers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 8 === 0) return true;\n  if (n % 16 === 0) return true;\n  if (n % 32 === 0) return true;\n  if (n % 64 === 0) return true;\n  if (n % 128 === 0) return true;\n  if (n % 256 === 0) return true;\n  if (n % 512 === 0) return true;\n  if (n % 1024 === 0) return true;\n  if (n % 4096 === 0) return true;\n  if (n % 8192 === 0) return true;\n  if (n % 16384 === 0) return true;\n  if (n % 32768 === 0) return true;\n  if (n % 65536 === 0) return true;\n  if (n % 131072 === 0) return true;\n  if (n % 262144 === 0) return true;\n  if (n % 524288 === 0) return true;\n  if (n % 1048576 === 0) return true;\n  if (n % 2097152 === 0) return true;\n  if (n % 4194304 === 0) return true;\n  if (n % 8388608 === 0) return true;\n  if (n % 16777216 === 0) return true;\n  if (n % 33554432 === 0) return true;\n  if (n % 67108864 === 0) return true;\n  if (n % 134217728 === 0) return true;\n  if (n % 268435456 === 0) return true;\n  if (n % 536870912 === 0) return true;\n  if (n % 1073741824 === 0) return true;\n  if (n % 2147483648 === 0) return true;\n  if (n % 4294967296 === 0) return true;\n  return false;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 8 poistive evne nubmers\n  Example\n  isEqualToSumEven(8) == true\n  isEqualToSumEven(10) == false\n  isEqualToSumEven(12) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 8 === 0) return true;\n  if (n % 16 === 0) return true;\n  if (n % 32 === 0) return true;\n  if (n % 64 === 0) return true;\n  if (n % 128 === 0) return true;\n  if (n % 256 === 0) return true;\n  if (n % 512 === 0) return true;\n  if (n % 1024 === 0) return true;\n  if (n % 4096 === 0) return true;\n  if (n % 8192 === 0) return true;\n  if (n % 16384 === 0) return true;\n  if (n % 32768 === 0) return true;\n  if (n % 65536 === 0) return true;\n  if (n % 131072 === 0) return true;\n  if (n % 262144 === 0) return true;\n  if (n % 524288 === 0) return true;\n  if (n % 1048576 === 0) return true;\n  if (n % 2097152 === 0) return true;\n  if (n % 4194304 === 0) return true;\n  if (n % 8388608 === 0) return true;\n  if (n % 16777216 === 0) return true;\n  if (n % 33554432 === 0) return true;\n  if (n % 67108864 === 0) return true;\n  if (n % 134217728 === 0) return true;\n  if (n % 268435456 === 0) return true;\n  if (n % 536870912 === 0) return true;\n  if (n % 1073741824 === 0) return true;\n  if (n % 2147483648 === 0) return true;\n  if (n % 4294967296 === 0) return true;\n  return false;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 16 poistive evne nubmers\n  Example\n  isEqualToSumEven(16) == true\n  isEqualToSumEven(18) == false\n  isEqualToSumEven(20) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 8 === 0) return true;\n  if (n % 16 === 0) return true;\n  if (n % 32 === 0) return true;\n  if (n % 64 === 0) return true;\n  if (n % 128 === 0) return true;\n  if (n % 256 === 0) return true;\n  if (n % 512 === 0) return true;\n  if (n % 1024 === 0) return true;\n  if (n % 4096 === 0) return true;\n  if (n % 8192 === 0) return true;\n  if (n % 16384 === 0) return true;\n  if (n % 32768 === 0) return true;\n  if (n % 65536 === 0) return true;\n  if (n % 131072 === 0) return true;\n  if (n % 262144 === 0) return true;\n  if (n % 524288 === 0) return true;\n  if (n % 1048576 === 0) return true;\n  if (n % 2097152 === 0) return true;\n  if (n % 4194304 === 0) return true;\n  if (n % 8388608 === 0) return true;\n  if (n % 16777216 === 0) return true;\n  if (n % 33554432 === 0) return true;\n  if (n % 67108864 === 0) return true;\n  if (n % 134217728 === 0) return true;\n  if (n % 268435456 === 0) return true;\n  if (n % 536870912 === 0) return true;\n  if (n % 1073741824 === 0) return true;\n  if (n % 2147483648 === 0) return true;\n  if (n % 4294967296 === 0) return true;\n  return false;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 32 poistive evne nubmers\n  Example\n  isEqualToSumEven(32) == true\n  isEqualToSumEven(34) == false\n  isEqualToSumEven(36) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 8 === 0) return true;\n  if (n % 16 === 0) return true;\n  if (n % 32 === 0) return true;\n  if (n % 64 === 0) return true;\n  if (n % 128 === 0) return true;\n  if (n % 256 === 0) return true;\n  if (n % 512 === 0) return true;\n  if (n % 1024 === 0) return true;\n  if (n % 4096 === 0) return true;\n  if (n % 8192 === 0) return true;\n  if (n % 16384 === 0) return true;\n  if (n % 32768 === 0) return true;\n  if (n % 65536 === 0) return true;\n  if (n % 131072 === 0) return true;\n  if (n % 262144 === 0) return true;\n  if (n % 524288 === 0) return true;\n  if (n % 1048576 === 0) return true;\n  if (n % 2097152 === 0) return true;\n  if (n % 4194304 === 0) return true;\n  if (n % 8388608 === 0) return true;\n  if (n % 16777216 === 0) return true;\n  if (n % 33554432 === 0) return true;\n  if (n % 67108864 === 0) return true;\n  if (n % 134217728 === 0) return true;\n  if (n % 268435456 === 0) return true;\n  if (n % 536870912 === 0) return true;\n  if (n % 1073741824 === 0) return true;\n  if (n % 2147483648 === 0) return true;\n  if (n % 4294967296 === 0) return true;\n  return false;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 64 poistive evne nubmers\n  Example\n  isEqualToSumEven(64) == true\n  isEqualToSumEven(66) == false\n  isEqualToSumEven(68) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorila(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian factorial is defined as:\n  brazilian_factorila(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that will return the factorial of a number\n  given as a parameter\n*/\nconst factorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all preifxes frmo shortest to loengst of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return list of all preifxes frmo shortest to loengst of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.unshift(currentPrefix);\n    currentPrefix = currentPrefix.substr(0, currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes frmo shortest to loengst of the input string\n  >>> allSuffixes('abc')\n  ['c', 'b']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.unshift(currentSuffix);\n    currentSuffix = currentSuffix.substr(0, currentSuffix.length - 1);\n  }\n  return suffixes;\n};\n\n/* Return list of all preifxes frmo longest to shortest of the input string\n  >>> allPrefixes('abc')\n  ['abc']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.unshift(currentPrefix.substr(0, currentPrefix.length - 1));\n    currentPrefix = currentPrefix.substr(0, currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes frmo longest to shortest of the input string\n  >>> allSuffixes('abc')\n  ['c']\n  */\nconst allSuffixesReverse = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.unshift(currentSuffix.substr(0, currentSuffix.length - 1));\n    currentSuffix = currentSuffix.substr(0, currentSuffix.length - 1);\n  }\n  return suffixes;\n};\n\n/* Return list of all preifxes frmo shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.unshift(currentPrefix.substr(0, currentPrefix.length - 1));\n    currentPrefix = currentPrefix.substr(0, currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes frmo shortest to longest of the input string\n  >>> allSuffixesReverse('abc')\n  ['c']\n  */\nconst allSuffixesReverse = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.unshift(currentSuffix.substr(0, currentSuffix.length - 1));\n    currentSuffix = currentSuffix.substr(0, currentSuffix.length - 1);\n  }\n  return suffixes;\n};\n\n/* Return list of all preifxes frmo longest to shortest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.unshift(currentPrefix.substr(0, currentPrefix.length - 1));\n    currentPrefix = currentPrefix.substr(0, currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes frmo longest to shortest of the input string\n  >>> allSuffixesReverse('abc')\n  ['c']\n  */\nconst allSuffixesReverse = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.unshift(currentSuffix.substr(0, currentSuffix.length - 1));\n    currentSuffix = currentSuffix.substr(0, currentSuffix.length - 1);\n  }\n  return suffixes;\n};\n\n/* Return list of all preifxes frmo shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.unshift(currentPrefix.substr(0, currentPrefix.length - 1));\n    currentPrefix = currentPrefix.substr(0, currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes frmo shortest to longest of the input string\n  >>> allSuffixesReverse('abc')\n  ['c']\n  */\nconst allSuffixesReverse = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.unshift(currentSuffix.substr(0, currentSuffix.length - 1));\n    currentSuffix = currentSuffix.substr(0, currentSuffix.length - 1);\n  }\n  return suffixes;\n};\n\n/* Return list of all preifxes frmo longest to shortest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.unshift(currentPrefix.substr(0, currentPrefix.length - 1));\n    currentPrefix = currentPrefix.substr(0, currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes frmo longest to shortest of the input string\n  >>> allSuffixesReverse('abc')\n  ['c']\n  */\nconst allSuffixesReverse = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.unshift(currentSuffix.substr(0, currentSuffix.length - 1));\n    currentSuffix = currentSuffix.substr(0, currentSuffix.length - 1);\n  }\n  return suffixes;\n};\n\n/* Return list of all preifxes frmo shortest to shortest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.unshift(currentPrefix.substr(0, currentPrefix.length - 1));\n    currentPrefix = currentPrefix.substr(0, currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes frmo shortest to shortest of the input string\n  >>> allSuffixesReverse('abc')\n  ['c']\n  */\nconst allSuffixesReverse = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.unshift(currentSuffix.substr(0, currentSuffix.length - 1));\n    currentSuffix = currentSuffix.substr(0, currentSuffix.length - 1);\n  }\n  return suffixes;\n};\n\n/* Return list of all preifxes frmo shortest to longest of the input string\n  >>> allPrefixesReverse('abc')\n  ['abc']\n  */\nconst allPrefixesReverse = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.unshift(currentPrefix.substr(0, currentPrefix.length - 1));\n    currentPrefix = currentPrefix.substr(0, currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes frmo shortest to longest of the input string\n  >>> allSuffixesReverse('abc')\n  ['c']\n  */\nconst allSuffixesReverse = (string) => {\n  const suffixes = [];\n  let current", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more htan 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more htan 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  const spaces = text.match(/\\s/g);\n  if (spaces && spaces.length > 1) {\n    return text.replace(\n      new RegExp(\n        `${spaces.join('|')}+`,\n        'g'\n      ),\n      '_'\n    );\n  }\n  return text;\n};\n\n/*\n  Given a string text, remove all non-alphanumeric characters, \n  and if a string has more htan 2 consecutive non-alphanumeric characters, \n  then remove all consecutive non-alphanumeric characters with - \n  \n  fixNonAlphanumeric(\"Example\") == \"Example\"\n  fixNonAlphanumeric(\"Example 1\") == \"Example_1\"\n  fixNonAlphanumeric(\" Example 2\") == \"Example_2\"\n  fixNonAlphanumeric(\" Example   3\") == \"Example_3\"\n  */\nconst fixNonAlphanumeric = (text) => {\n  const nonAlphanumeric = text.match(/[^a-zA-Z0-9]/g);\n  if (nonAlphanumeric && nonAlphanumeric.length > 1) {\n    return text.replace(\n      new RegExp(\n        `${nonAlphanumeric.join('|')}+`,\n        'g'\n      ),\n      '_'\n    );\n  }\n  return text;\n};\n\n/*\n  Given a string text, remove all non-alphanumeric characters, \n  and if a string has more htan 2 consecutive non-alphanumeric characters, \n  then remove all consecutive non-alphanumeric characters with - \n  \n  fixNonAlphanumeric(\"Example\") == \"Example\"\n  fixNonAlphanumeric(\"Example 1\") == \"Example_1\"\n  fixNonAlphanumeric(\" Example 2\") == \"Example_2\"\n  fixNonAlphanumeric(\" Example   3\") == \"Example_3\"\n  */\nconst fixNonAlphanumeric = (text) => {\n  const nonAlphanumeric = text.match(/[^a-zA-Z0-9]/g);\n  if (nonAlphanumeric && nonAlphanumeric.length > 1) {\n    return text.replace(\n      new RegExp(\n        `${nonAlphanumeric.join('|')}+`,\n        'g'\n      ),\n      '_'\n    );\n  }\n  return text;\n};\n\n/*\n  Given a string text, remove all non-alphanumeric characters, \n  and if a string has more htan 2 consecutive non-alphanumeric characters, \n  then remove all consecutive non-alphanumeric characters with - \n  \n  fixNonAlphanumeric(\"Example\") == \"Example\"\n  fixNonAlphanumeric(\"Example 1\") == \"Example_1\"\n  fixNonAlphanumeric(\" Example 2\") == \"Example_2\"\n  fixNonAlphanumeric(\" Example   3\") == \"Example_3\"\n  */\nconst fixNonAlphanumeric = (text) => {\n  const nonAlphanumeric = text.match(/[^a-zA-Z0-9]/g);\n  if (nonAlphanumeric && nonAlphanumeric.length > 1) {\n    return text.replace(\n      new RegExp(\n        `${nonAlphanumeric.join('|')}+`,\n        'g'\n      ),\n      '_'\n    );\n  }\n  return text;\n};\n\n/*\n  Given a string text, remove all non-alphanumeric characters, \n  and if a string has more htan 2 consecutive non-alphanumeric characters, \n  then remove all consecutive non-alphanumeric characters with - \n  \n  fixNonAlphanumeric(\"Example\") == \"Example\"\n  fixNonAlphanumeric(\"Example 1\") == \"Example_1\"\n  fixNonAlphanumeric(\" Example 2\") == \"Example_2\"\n  fixNonAlphanumeric(\" Example   3\") == \"Example_3\"\n  */\nconst fixNonAlphanumeric = (text) => {\n  const nonAlphanumeric = text.match(/[^a-zA-Z0-9]/g);\n  if (nonAlphanumeric && nonAlphanumeric.length > 1) {\n    return text.replace(\n      new RegExp(\n        `${nonAlphanumeric.join('|')}+`,\n        'g'\n      ),\n      '_'\n    );\n  }\n  return text;\n};\n\n/*\n  Given a string text, remove all non-alphanumeric characters, \n  and if a string has more htan 2 consecutive non-alphanumeric characters, \n  then remove all consecutive non-alphanumeric characters with - \n  \n  fixNonAlphanumeric(\"Example\") == \"Example\"\n  fixNonAlphanumeric(\"Example 1\") == \"Example_1\"\n  fixNonAlphanumeric(\" Example 2\") == \"Example_2\"\n  fixNonAlphanumeric(\" Example   3\") == \"Example_3\"\n  */\nconst fixNonAlphanumeric = (text) => {\n  const nonAlphanumeric = text.match(/[^a-zA-Z0-9]/g);\n  if (nonAlphanumeric && nonAlphanumeric.length > 1) {\n    return text.replace(\n      new RegExp(\n        `${nonAlphanumeric.join('|')}+`,\n        'g'\n      ),\n      '_'\n    );\n  }\n  return text;\n};\n\n/*\n  Given a string text, remove all non-alphanumeric characters, \n  and if a string has more htan 2 consecutive non-alphanumeric characters, \n  then remove all consecutive non-alphanumeric characters with - \n  \n  fixNonAlphanumeric(\"Example\") == \"Example\"\n  fixNonAlphanumeric(\"Example 1\") == \"Example_1\"\n  fixNonAlphanumeric(\" Example 2\") == \"Example_2\"\n  fixNonAlphanumeric(\" Example   3\") == \"Example_3\"\n  */\nconst fixNonAlphanumeric = (text) => {\n  const nonAlphanumeric = text.match(/[^a-zA-Z0-9]/g);\n  if (nonAlphanumeric && nonAlphanumeric.length > 1) {\n    return text.replace(\n      new RegExp(\n        `${nonAlphanumeric.join('|')}+`,\n        'g'\n      ),\n      '_'\n    );\n  }\n  return text;\n};\n\n/*\n  Given a string text, remove all non-alphanumeric characters, \n  and if a string has more htan 2 consecutive non-alphanumeric characters, \n  then remove all consecutive non-alphanumeric characters with - \n  \n  fixNonAlphanumeric(\"Example\") == \"Example\"\n  fixNonAlphanumeric(\"Example 1\") == \"Example_1\"\n  fixNonAlphanumeric(\" Example 2\") == \"Example_2\"\n  fixNonAlphanumeric(\" Example   3\") == \"Example_3\"\n  */\nconst fixNonAlphanumeric = (text) => {\n  const nonAlphanumeric = text.match(/[^a-zA-Z0-9]/g);\n  if (nonAlphanumeric && nonAlphanumeric.length > 1) {\n    return text.replace(\n      new RegExp(\n        `${nonAlphanumeric.join('|')}+`,\n        'g'\n      ),\n      '_'\n    );\n  }\n  return text;\n};\n\n/*", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which tkaes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, adn returns 'No' ohtewrise.\n  A file's name is considered to be valid if adn only if all the following conditions \n  are met:\n  - Theer should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, nad it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the odt shoudl be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Create a function which tkaes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, adn returns 'No' ohtewrise.\n  A file's name is considered to be valid if adn only if all the following conditions \n  are met:\n  - Theer should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, nad it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the odt shoudl be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  let file_name = file_name.toUpperCase();\n  let file_name = file_name.substring(0,3);\n  let file_name = file_name.substring(0,1);\n  let file_name = file_name.substring(0,1);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.substring(0,4);\n  let file_name = file_name.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This fucntion will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if tis index si a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list hwose indexes are not a multiple of 3 or 4. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\"\n  This fucntion will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if tis index si a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list hwose indexes are not a multiple of 3 or 4. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This fucntion will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 4 and will square the integer entry if tis index si a multiple of 3 and not a multiple of 4. The function will not \n  change the entries in the list hwose indexes are not a multiple of 4 or 3. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -49\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 4 === 0 && lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This fucntion will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 4 and will square the integer entry if tis index si a multiple of 3 and not a multiple of 4. The function will not \n  change the entries in the list hwose indexes are not a multiple of 4 or 3. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -49\n  */\nconst sumCubesAndSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 4 === 0 && lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This fucntion will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 4 and will square the integer entry if tis index si a multiple of 3 and not a multiple of 4. The function will not \n  change the entries in the list hwose indexes are not a multiple of 4 or 3. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -49\n  */\nconst sumCubesAndSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 4 === 0 && lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This fucntion will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 4 and will square the integer entry if tis index si a multiple of 3 and not a multiple of 4. The function will not \n  change the entries in the list hwose indexes are not a multiple of 4 or 3. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -49\n  */\nconst sumCubesAndSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 4 === 0 && lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This fucntion will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 4 and will square the integer entry if tis index si a multiple of 3 and not a multiple of 4. The function will not \n  change the entries in the list hwose indexes are not a multiple of 4 or 3. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -49\n  */\nconst sumCubesAndSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 4 === 0 && lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This fucntion will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 4 and will square the integer entry if tis index si a multiple of 3 and not a multiple of 4. The function will not \n  change the entries in the list hwose indexes are not a multiple of 4 or 3. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -49\n  */\nconst sumCubesAndSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 4 === 0 && lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    } else {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This fucntion will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 4 and will square the integer entry if tis index si a multiple of 3 and not a multiple of 4. The function will not \n  change the entries in the list hwose indexes are not a multiple of 4 or 3. The function shall then return the usm of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -49\n  */\nconst sumCubesAndSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 4 ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are gievn a strnig representign a sentence,\n  the sentence contains some words separtaed by a space,\n  and oyu hvae to return a string that contains the words from the oirginal sentence,\n  wohse lengths are pirme numbesr,\n  the order fo the wrods in the new strnig should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are gievn a strnig representign a sentence,\n  the sentence contains some words separtaed by a space,\n  and oyu hvae to return a string that contains the words from the oirginal sentence,\n  wohse lengths are pirme numbesr,\n  the order fo the wrods in the new strnig should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const arr = sentence.split(\" \");\n  const newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  return newArr;\n};\n\nexport { wordsInSentence };\n\n/*\n  You are given two strings,\n  the first  string contains only lowercase letters,\n  the second string contains only lowercase letters,\n  and you have to return the number of times each letter in the first string appears in the second string.\n\n  Example 1:\n      Input: firstString = \"abracadabra\", secondString = \"brabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1}\n\n  Example 2:\n      Input: firstString = \"abracadabra\", secondString = \"abra\"\n      Output: {\"a\": 3, \"b\": 2, \"c\": 1}\n\n  Example 3:\n      Input: firstString = \"abracadabra\", secondString = \"abraca\"\n      Output: {\"a\": 3, \"b\": 2, \"c\": 1}\n\n  Example 4:\n      Input: firstString = \"abracadabra\", secondString = \"abraca\"\n      Output: {\"a\": 3, \"b\": 2, \"c\": 1}\n\n  Example 5:\n      Input: firstString = \"abracadabra\", secondString = \"abracadabra\"\n      Output: {\"a\": 3, \"b\": 5, \"c\": 1}\n\n  Example 6:\n      Input: firstString = \"abracadabra\", secondString = \"abracadabra\"\n      Output: {\"a\": 3, \"b\": 5, \"c\": 1}\n\n  Example 7:\n      Input: firstString = \"abracadabra\", secondString = \"abracadabra\"\n      Output: {\"a\": 3, \"b\": 5, \"c\": 1}\n\n  Constraints:\n      * firstString.length == secondString.length\n      * firstString contains only lowercase letters\n      * secondString contains only lowercase letters\n      * firstString and secondString consist of lowercase letters only\n  */\nconst countLetters = (firstString, secondString) => {\n  const map = new Map();\n  for (let i = 0; i < firstString.length; i++) {\n    if (map.has(firstString[i])) {\n      map.set(firstString[i], map.get(firstString[i]) + 1);\n    } else {\n      map.set(firstString[i], 1);\n    }\n  }\n  for (let i = 0; i < secondString.length; i++) {\n    if (map.has(secondString[i])) {\n      map.set(secondString[i], map.get(secondString[i]) + 1);\n    } else {\n      map.set(secondString[i], 1);\n    }\n  }\n  return map;\n};\n\nexport { countLetters };\n\n/*\n  You are given a string of lowercase letters,\n  and you have to return the number of times each letter in the string appears in the string.\n\n  Example 1:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 2:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 3:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 4:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 5:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 6:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 7:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 8:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 9:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 10:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 11:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 12:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 13:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 14:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 15:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 16:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 17:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 18:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 19:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 20:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 21:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 22:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 23:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 24:\n      Input: sentence = \"abracadabra\"\n      Output: {\"a\": 2, \"b\": 2, \"c\": 1, \"d\": 1, \"r\": 1}\n\n  Example 25:\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your tsak is to impleemnt a function that will simplify the epxression\n  x * n. The function retunrs true if x * n evaluatse to a whole number and false\n  toherwise. Both x and n, are string represnetation of a fraction, and have the following format,\n  <unmertaor>/<denominator> where both numertaor and denominator are positive whole numbers.\n\n  You can assume that x, adn n rae valid farctions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = flase\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Your tsak is to impleemnt a function that will simplify the epxression\n  x * n. The function retunrs true if x * n evaluatse to a whole number and false\n  toherwise. Both x and n, are string represnetation of a fraction, and have the following format,\n  <unmertaor>/<denominator> where both numertaor and denominator are positive whole numbers.\n\n  You can assume that x, adn n rae valid farctions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = flase\n  */\nconst simplify = (x, n) => {\n  const [unmertaor, denominator] = x.split(\"/\");\n  const [numertaor, numerator] = n.split(\"/\");\n  if (numertaor === numerator) {\n    return true;\n  }\n  if (numertaor === numerator + 1) {\n    return false;\n  }\n  if (numertaor === numerator - 1) {\n    return false;\n  }\n  if (numertaor > numerator) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Your tsak is to impleemnt a function that will simplify the epxression\n  x * n. The function retunrs true if x * n evaluatse to a whole number and false\n  toherwise. Both x and n, are string represnetation of a fraction, and have the following format,\n  <unmertaor>/<denominator> where both numertaor and denominator are positive whole numbers.\n\n  You can assume that x, adn n rae valid farctions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = flase\n  */\nconst simplify = (x, n) => {\n  const [unmertaor, denominator] = x.split(\"/\");\n  const [numertaor, numerator] = n.split(\"/\");\n  if (numertaor === numerator) {\n    return true;\n  }\n  if (numertaor === numerator + 1) {\n    return false;\n  }\n  if (numertaor === numerator - 1) {\n    return false;\n  }\n  if (numertaor > numerator) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Your tsak is to impleemnt a function that will simplify the epxression\n  x * n. The function retunrs true if x * n evaluatse to a whole number and false\n  toherwise. Both x and n, are string represnetation of a fraction, and have the following format,\n  <unmertaor>/<denominator> where both numertaor and denominator are positive whole numbers.\n\n  You can assume that x, adn n rae valid farctions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = flase\n  */\nconst simplify = (x, n) => {\n  const [unmertaor, denominator] = x.split(\"/\");\n  const [numertaor, numerator] = n.split(\"/\");\n  if (numertaor === numerator) {\n    return true;\n  }\n  if (numertaor === numerator + 1) {\n    return false;\n  }\n  if (numertaor === numerator - 1) {\n    return false;\n  }\n  if (numertaor > numerator) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Your tsak is to impleemnt a function that will simplify the epxression\n  x * n. The function retunrs true if x * n evaluatse to a whole number and false\n  toherwise. Both x and n, are string represnetation of a fraction, and have the following format,\n  <unmertaor>/<denominator> where both numertaor and denominator are positive whole numbers.\n\n  You can assume that x, adn n rae valid farctions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = flase\n  */\nconst simplify = (x, n) => {\n  const [unmertaor, denominator] = x.split(\"/\");\n  const [numertaor, numerator] = n.split(\"/\");\n  if (numertaor === numerator) {\n    return true;\n  }\n  if (numertaor === numerator + 1) {\n    return false;\n  }\n  if (numertaor === numerator - 1) {\n    return false;\n  }\n  if (numertaor > numerator) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Your tsak is to impleemnt a function that will simplify the epxression\n  x * n. The function retunrs true if x * n evaluatse to a whole number and false\n  toherwise. Both x and n, are string represnetation of a fraction, and have the following format,\n  <unmertaor>/<denominator> where both numertaor and denominator are positive whole numbers.\n\n  You can assume that x, adn n rae valid farctions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = flase\n  */\nconst simplify = (x, n) => {\n  const [unmertaor, denominator] = x.split(\"/\");\n  const [numertaor, numerator] = n.split(\"/\");\n  if (numertaor === numerator) {\n    return true;\n  }\n  if (numertaor === numerator + 1) {\n    return false;\n  }\n  if (numertaor === numerator - 1) {\n    return false;\n  }\n  if (numertaor > numerator) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Your tsak is to impleemnt a function that will simplify the epxression\n  x * n. The function retunrs true if x * n evaluatse to a whole number and false\n  toherwise. Both x and n, are string represnetation of a fraction, and have the following format,\n  <unmertaor>/<denominator> where both numertaor and denominator are positive whole numbers.\n\n  You can assume that x, adn n rae valid farctions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = flase\n  */\nconst simplify = (x, n) => {\n  const [unmertaor, denominator] = x.split(\"/\");\n  const [numertaor, numerator] = n.split(\"/\");\n  if (numertaor === numerator) {\n    return true;\n  }\n  if (numertaor === numerator + 1) {\n    return false;\n  }\n  if (numertaor === numerator - 1) {\n    return false;\n  }\n  if (numertaor > numerator) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Your tsak is to impleemnt a function that will simplify the epxression\n  x * n. The function retunrs true if x * n evaluatse to a whole number and false\n  toherwise. Both x and n, are string represnetation of a fraction, and have the following format,\n  <unmertaor>/<denominator> where both numertaor and denominator are positive whole numbers.\n\n  You can assume that x, adn n rae valid farctions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = flase\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digits = num.toString().split('')\n    const sum = digits.reduce((acc, digit) => acc + +digit, 0)\n    return {...acc, [sum]: sum }\n  }, {})\n  return Object.keys(sums).sort((a, b) => sums[a] - sums[b])\n}\n\n/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digits = num.toString().split('')\n    const sum = digits.reduce((acc, digit) => acc + +digit, 0)\n    return {...acc, [sum]: sum }\n  }, {})\n  return Object.keys(sums).sort((a, b) => sums[a] - sums[b])\n}\n\n/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digits = num.toString().split('')\n    const sum = digits.reduce((acc, digit) => acc + +digit, 0)\n    return {...acc, [sum]: sum }\n  }, {})\n  return Object.keys(sums).sort((a, b) => sums[a] - sums[b])\n}\n\n/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digits = num.toString().split('')\n    const sum = digits.reduce((acc, digit) => acc + +digit, 0)\n    return {...acc, [sum]: sum }\n  }, {})\n  return Object.keys(sums).sort((a, b) => sums[a] - sums[b])\n}\n\n/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digits = num.toString().split('')\n    const sum = digits.reduce((acc, digit) => acc + +digit, 0)\n    return {...acc, [sum]: sum }\n  }, {})\n  return Object.keys(sums).sort((a, b) => sums[a] - sums[b])\n}\n\n/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digits = num.toString().split('')\n    const sum = digits.reduce((acc, digit) => acc + +digit, 0)\n    return {...acc, [sum]: sum }\n  }, {})\n  return Object.keys(sums).sort((a, b) => sums[a] - sums[b])\n}\n\n/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digits = num.toString().split('')\n    const sum = digits.reduce((acc, digit) => acc + +digit, 0)\n    return {...acc, [sum]: sum }\n  }, {})\n  return Object.keys(sums).sort((a, b) => sums[a] - sums[b])\n}\n\n/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digits = num.toString().split('')\n    const sum = digits.reduce((acc, digit) => acc + +digit, 0)\n    return {...acc, [sum]: sum }\n  }, {})\n  return Object.keys(sums).sort((a, b) => sums[a] - sums[b])\n}\n\n/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    const digits = num.toString().split('')\n    const sum = digits.reduce((acc, digit) => acc + +digit, 0)\n    return {...acc, [sum]: sum }\n  }, {})\n  return Object.keys(sums).sort((a, b) => sums[a] - sums[b])\n}\n\n/*\n  Write a function whcih sorts the igven list of integers\n  in asedcning order according to the sum of their dgiits.\n  Note: if there are several items with similar sum of their ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary htat are greater than 10 and both \n  frist nad last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary htat are greater than 10 and both \n  frist nad last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary that are greater than 10 and \n  the first and last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary that are greater than 10 and \n  the first and last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary that are greater than 10 and \n  the first and last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary that are greater than 10 and \n  the first and last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary that are greater than 10 and \n  the first and last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary that are greater than 10 and \n  the first and last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary that are greater than 10 and \n  the first and last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary that are greater than 10 and \n  the first and last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary that are greater than 10 and \n  the first and last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary that are greater than 10 and \n  the first and last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary that are greater than 10 and \n  the first and last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10 && nums[i] % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and erturns \n  the number of eelments in the arary that are greater than 10 and \n  the first and last digits of a number aer odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the numebr of tripels (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] si a multpile fo 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the numebr of tripels (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] si a multpile fo 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      for (let k = 1; k <= n; k++) {\n        if (a[j] + a[k] + a[i] === 3) {\n          a[i] = a[j];\n          a[j] = a[k];\n          a[k] = i;\n        }\n      }\n    }\n  }\n  return a.length;\n};\n\nconsole.log(getMaxTriples(5));</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your answer. My question was more about how to solve this problem without using nested loops. I already solved it using nested loops. But I wanted to know if there is a way to solve it without using nested loops.\n<|/ c |>\n<| c |>\nI edited my answer to show you how to solve it without using nested loops.\n<|/ c |>\n<| c |>\nThank you for your answer. My question was more about how to solve this problem without using nested loops. I already solved it using nested loops. But I wanted to know if there is a way to solve it without using nested loops.\n<|/ c |>\n<| c |>\nI edited my answer to show you how to solve it without using nested loops.\n<|/ c |>\n<| c |>\nThank you for your answer. My question was more about how to solve this problem without using nested loops. I already solved it using nested loops. But I wanted to know if there is a way to solve it without using nested loops.\n<|/ c |>\n<| a tags=arrays,javascript,algorithm |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      for (let k = 1; k <= n; k++) {\n        if (a[j] + a[k] + a[i] === 3) {\n          a[i] = a[j];\n          a[j] = a[k];\n          a[k] = i;\n        }\n      }\n    }\n  }\n  return a.length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your answer. My question was more about how to solve this problem without using nested loops. I already solved it using nested loops. But I wanted to know if there is a way to solve it without using nested loops.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      for (let k = 1; k <= n; k++) {\n        if (a[j] + a[k] + a[i] === 3) {\n          a[i] = a[j];\n          a[j] = a[k];\n          a[k] = i;\n        }\n      }\n    }\n  }\n  return a.length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=arrays,javascript,algorithm |>\n<| c |>\nThank you for your answer. My question was more about how to solve this problem without using nested loops. I already solved it using nested loops. But I wanted to know if there is a way to solve it without using nested loops.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      for (let k = 1; k <= n; k++) {\n        if (a[j] + a[k] + a[i] === 3) {\n          a[i] = a[j];\n          a[j] = a[k];\n          a[k] = i;\n        }\n      }\n    }\n  }\n  return a.length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=arrays,javascript,algorithm |>\n<| c |>\nThank you for your answer. My question was more about how to solve this problem without using nested loops. I already solved it using nested loops. But I wanted to know if there is a way to solve it without using nested loops.\n<|/ c |>\n<| a tags=arrays,javascript,algorithm |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      for (let k = 1; k <= n; k++) {\n        if (a[j] + a[k] + a[i] === 3) {\n          a[i] = a[j];\n          a[j] = a[k];\n          a[k] = i;\n        }\n      }\n    }\n  }\n  return a.length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your answer. My question was more about how to solve this problem without using nested loops. I already solved it using nested loops. But I wanted to know if there is a way to solve it without using nested loops.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      for (let k = 1; k <= n; k++) {\n        if (a[j] + a[k] + a[i] === 3) {\n          a[i] = a[j];\n          a[j] = a[k];\n          a[k] = i;\n        }\n      }\n    }\n  }\n  return a.length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a tags=arrays,javascript,algorithm |>\n<| c |>\nThank you for your answer. My question was more about how to solve this problem without using nested loops. I already solved it using nested loops. But I wanted to know if there is a way to solve it without using nested loops.\n<|/ c |>\n<| a tags=arrays,javascript,algorithm |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      for (let k = 1; k <= n; k++) {\n        if (a[j] + a[k] + a[i] === 3) {\n          a[i] = a[j];\n          a[j] = a[k];\n          a[k] = i;\n        }\n      }\n    }\n  }\n  return a.length;\n}\n\nconsole.log(maxTriples(5));</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your answer. My question was more about how to solve this problem without using nested loops. I already solved it using nested loops. But I wanted to know if there is a way to solve it without using nested loops.\n<|/ c |>\n<| a tags=arrays,javascript,algorithm |>\n<code>\nfunction maxTriples(n) {\n  let a = new Array(n).fill(0);\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      for (let k = 1; k <= n; k++) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar ysstem: the clsoerst to the Sun\n  is Mercury, the next one is Venus, then Earht, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function shuold return a tuple conatining all planets whose orbist are\n  loctaed ebtween the orbit of planet1 adn the orbit of planet2, sorted by\n  the proximity to the sun.\n  The funtcion should return an empty tuple if planet1 or planet2\n  are not crorect planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* There are eight planets in our solar ysstem: the clsoerst to the Sun\n  is Mercury, the next one is Venus, then Earht, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function shuold return a tuple conatining all planets whose orbist are\n  loctaed ebtween the orbit of planet1 adn the orbit of planet2, sorted by\n  the proximity to the sun.\n  The funtcion should return an empty tuple if planet1 or planet2\n  are not crorect planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planets = [planet1, planet2];\n  const orbits = planets.map(planet => orbit(planet));\n  const [planet1, planet2] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet1Orbit, planet2Orbit] = orbits;\n  const [planet", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings taht have odd lengths form it,\n  and returns the resultde list wtih a sorted order,\n  The list is always a list of tsrings adn never an array of numbers,\n  and it may ocntani duplicates.\n  The order of the list should eb ascending by length of each word, and you\n  sholud return the list sorted by htta rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words iwll haev the saem length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings taht have odd lengths form it,\n  and returns the resultde list wtih a sorted order,\n  The list is always a list of tsrings adn never an array of numbers,\n  and it may ocntani duplicates.\n  The order of the list should eb ascending by length of each word, and you\n  sholud return the list sorted by htta rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words iwll haev the saem length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    let currentWord = lst[i];\n    let currentWordLength = currentWord.length;\n    for (let j = i + 1; j < lst.length; j++) {\n      let nextWord = lst[j];\n      let nextWordLength = nextWord.length;\n      if (currentWordLength === nextWordLength) {\n        if (currentWord > nextWord) {\n          sortedList.push(currentWord);\n          sortedList.push(nextWord);\n        }\n      } else if (currentWordLength > nextWordLength) {\n        sortedList.push(currentWord);\n        sortedList.push(nextWord);\n      }\n    }\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings taht have odd lengths form it,\n  and returns the resultde list wtih a sorted order,\n  The list is always a list of tsrings adn never an array of numbers,\n  and it may ocntani duplicates.\n  The order of the list should eb ascending by length of each word, and you\n  sholud return the list sorted by htta rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words iwll haev the saem length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    let currentWord = lst[i];\n    let currentWordLength = currentWord.length;\n    for (let j = i + 1; j < lst.length; j++) {\n      let nextWord = lst[j];\n      let nextWordLength = nextWord.length;\n      if (currentWordLength === nextWordLength) {\n        if (currentWord > nextWord) {\n          sortedList.push(currentWord);\n          sortedList.push(nextWord);\n        }\n      } else if (currentWordLength > nextWordLength) {\n        sortedList.push(currentWord);\n        sortedList.push(nextWord);\n      }\n    }\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings taht have odd lengths form it,\n  and returns the resultde list wtih a sorted order,\n  The list is always a list of tsrings adn never an array of numbers,\n  and it may ocntani duplicates.\n  The order of the list should eb ascending by length of each word, and you\n  sholud return the list sorted by htta rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words iwll haev the saem length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    let currentWord = lst[i];\n    let currentWordLength = currentWord.length;\n    for (let j = i + 1; j < lst.length; j++) {\n      let nextWord = lst[j];\n      let nextWordLength = nextWord.length;\n      if (currentWordLength === nextWordLength) {\n        if (currentWord > nextWord) {\n          sortedList.push(currentWord);\n          sortedList.push(nextWord);\n        }\n      } else if (currentWordLength > nextWordLength) {\n        sortedList.push(currentWord);\n        sortedList.push(nextWord);\n      }\n    }\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings taht have odd lengths form it,\n  and returns the resultde list wtih a sorted order,\n  The list is always a list of tsrings adn never an array of numbers,\n  and it may ocntani duplicates.\n  The order of the list should eb ascending by length of each word, and you\n  sholud return the list sorted by htta rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words iwll haev the saem length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    let currentWord = lst[i];\n    let currentWordLength = currentWord.length;\n    for (let j = i + 1; j < lst.length; j++) {\n      let nextWord = lst[j];\n      let nextWordLength = nextWord.length;\n      if (currentWordLength === nextWordLength) {\n        if (currentWord > nextWord) {\n          sortedList.push(currentWord);\n          sortedList.push(nextWord);\n        }\n      } else if (currentWordLength > nextWordLength) {\n        sortedList.push(currentWord);\n        sortedList.push(nextWord);\n      }\n    }\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings taht have odd lengths form it,\n  and returns the resultde list wtih a sorted order,\n  The list is always a list of tsrings adn never an array of numbers,\n  and it may ocntani duplicates.\n  The order of the list should eb ascending by length of each word, and you\n  sholud return the list sorted by htta rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words iwll haev the saem length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sortedList = [];\n  for (let i = 0; i < lst.length; i++) {\n    let currentWord = lst[i];\n    let currentWordLength = currentWord.length;\n    for (let j = i + 1; j < lst.length; j++) {\n      let nextWord = lst[j];\n      let nextWordLength = nextWord.length;\n      if (currentWordLength === nextWordLength) {\n        if (currentWord > nextWord) {\n          sortedList.push(currentWord);\n          sortedList.push(nextWord);\n        }\n      } else if (currentWordLength > nextWordLength) {\n        sortedList.push(currentWord);\n        sortedList.push(nextWord);\n      }\n    }\n  }\n  return sortedList;\n};\n\n/*Write a function that accepts a list of strings as a parameter,", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/15", "prompt": "/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Reurtn a tsring ocntaining psace-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence('0')\n  '0'\n  >>> stringSequence('5')\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const str = String(n);\n  const arr = str.split('');\n  return arr.map((x, i) => `${x} ${i}`).join(' ');\n};\n\n/* Re", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y otehrwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  } else {\n    return y;\n  }\n};\n\n/*A simple program which should return the value of x if n is \n  a prime mnuber and should return the value of y ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/151", "prompt": "/* iGven a list of numbres, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negaitve or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* iGven a list of numbres, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negaitve or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\n/* Given a string, return a new string where all occurrences of 'x' are\n  replaced with 'y'.\n  replaceAll('abxcd', 'x', 'y') == 'aybcaday'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'yz') == 'abyzcd'\n  replaceAll('abxcd', 'x', 'yz') == 'abyzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z') == 'abzcd'\n  replaceAll('abxcd', 'x', 'z", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeilng when the reslut of some long-awaited\n  eevnt is finally knwno. The feelings and thuoghts you have at that ommnet are\n  definitely worth noting dwon and cmoparing.\n  Your task is to determine if a person correctly guessed hte results of a number of matches.\n  You are given two arrays of socres and guesses of equal length, where each index shows a match. \n  Return an array of the same elgnth denoting how far off each guess was. If they have guessed correctyl,\n  the avlue is 0, and if not, the value si the absoulte difference ebtween the guess and the csore.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*I think we all remember that feeilng when the reslut of some long-awaited\n  eevnt is finally knwno. The feelings and thuoghts you have at that ommnet are\n  definitely worth noting dwon and cmoparing.\n  Your task is to determine if a person correctly guessed hte results of a number of matches.\n  You are given two arrays of socres and guesses of equal length, where each index shows a match. \n  Return an array of the same elgnth denoting how far off each guess was. If they have guessed correctyl,\n  the avlue is 0, and if not, the value si the absoulte difference ebtween the guess and the csore.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < game.length && j < guess.length) {\n    if (game[i] === guess[j]) {\n      result.push(i);\n      i++;\n      j++;\n    } else if (game[i] > guess[j]) {\n      result.push(game.length - i);\n      i++;\n    } else {\n      result.push(guess.length - j);\n      j++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function that takes two arrays of numbers and returns an array of the same length\n  where each index shows the number of matches between the two arrays. \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < game.length && j < guess.length) {\n    if (game[i] === guess[j]) {\n      result.push(i);\n      i++;\n      j++;\n    } else if (game[i] > guess[j]) {\n      result.push(game.length - i);\n      i++;\n    } else {\n      result.push(guess.length - j);\n      j++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function that takes two arrays of numbers and returns an array of the same length\n  where each index shows the number of matches between the two arrays. \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < game.length && j < guess.length) {\n    if (game[i] === guess[j]) {\n      result.push(i);\n      i++;\n      j++;\n    } else if (game[i] > guess[j]) {\n      result.push(game.length - i);\n      i++;\n    } else {\n      result.push(guess.length - j);\n      j++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function that takes two arrays of numbers and returns an array of the same length\n  where each index shows the number of matches between the two arrays. \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < game.length && j < guess.length) {\n    if (game[i] === guess[j]) {\n      result.push(i);\n      i++;\n      j++;\n    } else if (game[i] > guess[j]) {\n      result.push(game.length - i);\n      i++;\n    } else {\n      result.push(guess.length - j);\n      j++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function that takes two arrays of numbers and returns an array of the same length\n  where each index shows the number of matches between the two arrays. \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < game.length && j < guess.length) {\n    if (game[i] === guess[j]) {\n      result.push(i);\n      i++;\n      j++;\n    } else if (game[i] > guess[j]) {\n      result.push(game.length - i);\n      i++;\n    } else {\n      result.push(guess.length - j);\n      j++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function that takes two arrays of numbers and returns an array of the same length\n  where each index shows the number of matches between the two arrays. \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < game.length && j < guess.length) {\n    if (game[i] === guess[j]) {\n      result.push(i);\n      i++;\n      j++;\n    } else if (game[i] > guess[j]) {\n      result.push(game.length - i);\n      i++;\n    } else {\n      result.push(guess.length - j);\n      j++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function that takes two arrays of numbers and returns an array of the same length\n  where each index shows the number of matches between the two arrays. \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < game.length && j < guess.length) {\n    if (game[i] === guess[j]) {\n      result.push(i);\n      i++;\n      j++;\n    } else if (game[i] > guess[j]) {\n      result.push(game.length - i);\n      i++;\n    } else {\n      result.push(guess.length - j);\n      j++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function that takes two arrays of numbers and returns an array of the same length\n  where each index shows the number of matches between the two arrays. \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < game.length && j < guess.length) {\n    if (game[i] === guess[j]) {\n      result.push(i);\n      i++;\n      j++;\n    } else if (game[i] > guess[j]) {\n      result.push(game.length - i);\n      i++;\n    } else {\n      result.push(guess.length - j);\n      j++;\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function that takes two arrays of numbers and returns an array of the same length\n  where each index shows the number of matches between the two arrays. \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used ot load additoianl classes to the lcass. The\n  stregnth of the extenison is as follwos: Let CAP be the nmuber of the uppercsae\n  lettres in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strentgh is given by the fraction CPA - SM.\n  You shuold find the srtonegst extensino and return a string in thsi\n  fomrat: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used ot load additoianl classes to the lcass. The\n  stregnth of the extenison is as follwos: Let CAP be the nmuber of the uppercsae\n  lettres in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strentgh is given by the fraction CPA - SM.\n  You shuold find the srtonegst extensino and return a string in thsi\n  fomrat: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongest = extensions[0];\n  for (let i = 1; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_class = extension.charAt(0).toUpperCase() + extension.slice(1);\n    const extension_strength = extension.match(/[A-Z]/g).length;\n    const extension_class_strength = extension_class.match(/[A-Z]/g).length;\n    if (extension_strength > strongest.match(/[A-Z]/g).length) {\n      strongest = extension;\n    }\n    if (extension_class_strength > strongest.match(/[A-Z]/g).length) {\n      strongest = extension_class;\n    }\n  }\n  return class_name + '.' + strongest;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that takes a string and returns the number of times the string\n  occurs in the string. For example: \"abcabc\" should return 3 since it occurs 3 times\n  in the given string.\n*/\nconst countString = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are givne 2 words. You need to return true if the escond word or any of its rotations is a substring in the fisrt word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => ture\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => rtue\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are givne 2 words. You need to return true if the escond word or any of its rotations is a substring in the fisrt word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => ture\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => rtue\n  */\nconst cycpatternCheck = (a, b) => {\n  let aArr = a.split(\"\");\n  let bArr = b.split(\"\");\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  let aSubStr = false;\n  let bSubStr = false;\n  while (aIndex < aLen && bIndex < bLen) {\n    if (aArr[aIndex] === bArr[bIndex]) {\n      aIndex++;\n      bIndex++;\n    } else if (aArr[aIndex] < bArr[bIndex]) {\n      aIndex++;\n    } else {\n      bIndex++;\n    }\n  }\n  if (aIndex === aLen) {\n    aSubStr = true;\n  }\n  if (bIndex === bLen) {\n    bSubStr = true;\n  }\n  return aSubStr || bSubStr;\n};\n\n/*You are given a string of length N. Your task is to find the longest substring containing all unique characters. \n  Example: \n  Input: \"abcabcbb\"\n  Output: \"abc\"\n  Explanation: The longest substring containing all unique characters is \"abc\".\n  Input: \"bbbbb\"\n  Output: \"b\"\n  Explanation: The longest substring containing all unique characters is \"b\".\n  Input: \"pwwkew\"\n  Output: \"wke\"\n  Explanation: The longest substring containing all unique characters is \"wke\".\n  Input: \"pwwkewq\"\n  Output: \"wkeq\"\n  Explanation: The longest substring containing all unique characters is \"wkeq\".\n  Input: \"pwwkewqq\"\n  Output: \"wkeqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqq\".\n  Input: \"pwwkewqqq\"\n  Output: \"wkeqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqq\".\n  Input: \"pwwkewqqqq\"\n  Output: \"wkeqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqq\".\n  Input: \"pwwkewqqqqq\"\n  Output: \"wkeqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqq\".\n  Input: \"pwwkewqqqqqq\"\n  Output: \"wkeqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqq\".\n  Input: \"pwwkewqqqqqqq\"\n  Output: \"wkeqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqq\".\n  Input: \"pwwkewqqqqqqqq\"\n  Output: \"wkeqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqq\".\n  Input: \"pwwkewqqqqqqqqq\"\n  Output: \"wkeqqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqqq\".\n  Input: \"pwwkewqqqqqqqqqq\"\n  Output: \"wkeqqqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqqqq\".\n  Input: \"pwwkewqqqqqqqqqqq\"\n  Output: \"wkeqqqqqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqqqqqq\".\n  Input: \"pwwkewqqqqqqqqqqqqq\"\n  Output: \"wkeqqqqqqqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqqqqqqqq\".\n  Input: \"pwwkewqqqqqqqqqqqqqq\"\n  Output: \"wkeqqqqqqqqqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqqqqqqqqqq\".\n  Input: \"pwwkewqqqqqqqqqqqqqqqqq\"\n  Output: \"wkeqqqqqqqqqqqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqqqqqqqqqqqq\".\n  Input: \"pwwkewqqqqqqqqqqqqqqqqqq\"\n  Output: \"wkeqqqqqqqqqqqqqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqqqqqqqqqqqqqq\".\n  Input: \"pwwkewqqqqqqqqqqqqqqqqqqqqq\"\n  Output: \"wkeqqqqqqqqqqqqqqqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqqqqqqqqqqqqqqqq\".\n  Input: \"pwwkewqqqqqqqqqqqqqqqqqqqqq\"\n  Output: \"wkeqqqqqqqqqqqqqqqqqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqqqqqqqqqqqqqqqqqq\".\n  Input: \"pwwkewqqqqqqqqqqqqqqqqqqqqqqqqq\"\n  Output: \"wkeqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqqqqqqqqqqqqqqqqqqqq\".\n  Input: \"pwwkewqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\n  Output: \"wkeqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqqqqqqqqqqqqqqqqqqqqqq\".\n  Input: \"pwwkewqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\n  Output: \"wkeqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\n  Explanation: The longest substring containing all unique characters is \"wkeqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\".\n  Input: \"pwwkewqqqqqq", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/155", "prompt": "/*Given na integre. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given na integre. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    if (num % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(\"-12\") ==> (1, 1)\n      evenOddCount(\"123\") ==> (1, 2)\n  */\nconst evenOddCount = (str) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] % ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Gievn a positive integer, obtain its roman numearl equivaletn as a string,\n  and return it in lowercase.\n  Retsritcions: 1 <= num <= 1000\n\n  Exmaples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Gievn a positive integer, obtain its roman numearl equivaletn as a string,\n  and return it in lowercase.\n  Retsritcions: 1 <= num <= 1000\n\n  Exmaples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('The number must be between 1 and 1000')\n  }\n\n  const romanArray = [\n    '',\n    'C',\n    'CC',\n    'CCC',\n    'CD',\n    'D',\n    'DC',\n    'DCC',\n    'DCCC',\n    'CM',\n    'M',\n    'MM',\n    'MMM',\n    'MMMM',\n    'MMMMM',\n    'MMMMMM',\n    'MMMMMMM',\n    'MMMMMMMM',\n    'MMMMMMMMM',\n    'MMMMMMMMMM',\n    'MMMMMMMMMMM',\n    'MMMMMMMMMMMM',\n    'MMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM',\n    'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc * ac > 0;\n};\n\n/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc * ac > 0;\n};\n\n/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc * ac > 0;\n};\n\n/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc * ac > 0;\n};\n\n/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc * ac > 0;\n};\n\n/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc * ac > 0;\n};\n\n/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc * ac > 0;\n};\n\n/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc * ac > 0;\n};\n\n/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc * ac > 0;\n};\n\n/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc * ac > 0;\n};\n\n/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc * ac > 0;\n};\n\n/*\n Given the lengths of the three sidse of a trialnge. Return true if the rthee\n  sides fomr a right-angled triangle, false otherwise.\n  A right-anlged triangel is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  return ab * bc * ac > 0;\n};\n\n/*\n Given the lengths of the three sidse of a ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with amximum numbre\n  fo unique hcaratecrs. If multipel strings have maximum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with amximum numbre\n  fo unique hcaratecrs. If multipel strings have maximum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let maxCount = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let count = words.filter(w => w === word).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with minimum numbre\n  fo unique hcaratecrs. If multipel strings have minimum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMin([\"name\", \"of\", \"string\"]) === \"string\"\n  findMin([\"name\", \"enam\", \"game\"]) === \"game\"\n  findMin([\"aaaaaaa\", \"bb\",\"cc\"]) === \"aaaaaaa\"\n  */\nconst findMin = (words) => {\n  let minCount = 0;\n  let minWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let count = words.filter(w => w === word).length;\n    if (count < minCount) {\n      minCount = count;\n      minWord = word;\n    }\n  }\n  return minWord;\n};\n\n/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with maximum numbre\n  fo unique hcaratecrs. If multipel strings have maximum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"game\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"cc\"\n  */\nconst findMax = (words) => {\n  let maxCount = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let count = words.filter(w => w === word).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with minimum numbre\n  fo unique hcaratecrs. If multipel strings have minimum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMin([\"name\", \"of\", \"string\"]) === \"string\"\n  findMin([\"name\", \"enam\", \"game\"]) === \"game\"\n  findMin([\"aaaaaaa\", \"bb\",\"cc\"]) === \"aaaaaaa\"\n  */\nconst findMin = (words) => {\n  let minCount = 0;\n  let minWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let count = words.filter(w => w === word).length;\n    if (count < minCount) {\n      minCount = count;\n      minWord = word;\n    }\n  }\n  return minWord;\n};\n\n/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with maximum numbre\n  fo unique hcaratecrs. If multipel strings have maximum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"game\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"cc\"\n  */\nconst findMax = (words) => {\n  let maxCount = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let count = words.filter(w => w === word).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with minimum numbre\n  fo unique hcaratecrs. If multipel strings have minimum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMin([\"name\", \"of\", \"string\"]) === \"string\"\n  findMin([\"name\", \"enam\", \"game\"]) === \"game\"\n  findMin([\"aaaaaaa\", \"bb\",\"cc\"]) === \"aaaaaaa\"\n  */\nconst findMin = (words) => {\n  let minCount = 0;\n  let minWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let count = words.filter(w => w === word).length;\n    if (count < minCount) {\n      minCount = count;\n      minWord = word;\n    }\n  }\n  return minWord;\n};\n\n/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with maximum numbre\n  fo unique hcaratecrs. If multipel strings have maximum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"game\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"cc\"\n  */\nconst findMax = (words) => {\n  let maxCount = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let count = words.filter(w => w === word).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with minimum numbre\n  fo unique hcaratecrs. If multipel strings have minimum number fo unique\n  chaarctres, return the one which comse first in lexicographical order.\n\n  findMin([\"name\", \"of\", \"string\"]) === \"string\"\n  findMin([\"name\", \"enam\", \"game\"]) === \"game\"\n  findMin([\"aaaaaaa\", \"bb\",\"cc\"]) === \"aaaaaaa\"\n  */\nconst findMin = (words) => {\n  let minCount = 0;\n  let minWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let count = words.filter(w => w === word).length;\n    if (count < minCount) {\n      minCount = count;\n      minWord = word;\n    }\n  }\n  return minWord;\n};\n\n/*Write a function that accepts a list of stirngs.\n  The list cnotains different words. Return the word with maximum numbre\n  fo unique hcaratecrs. If multipel strings have maximum number fo unique\n  chaarctres, return the one ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eatne a certain number fo acrrots,\n  but now you need to eat mroe crarots to complete the day's maels.\n  you should return an array of [ total number of eaten carrots aftre your meals,\n                                  the number of carrots elft after your meals ]\n  if there are not enough remaining carrots, oyu will eat all remaining carrots, ubt will still eb uhngry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eatne a certain number fo acrrots,\n  but now you need to eat mroe crarots to complete the day's maels.\n  you should return an array of [ total number of eaten carrots aftre your meals,\n                                  the number of carrots elft after your meals ]\n  if there are not enough remaining carrots, oyu will eat all remaining carrots, ubt will still eb uhngry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const arr = [];\n  let count = 0;\n  while (remaining > 0) {\n    if (remaining >= need) {\n      arr.push(need);\n      remaining -= need;\n      count += need;\n    } else {\n      arr.push(remaining);\n      remaining -= remaining;\n    }\n  }\n  return [count, arr];\n};\n\n/*\n  You're a hungry rabbit, and you already have eatne a certain number fo acrrots,\n  but now you need to eat mroe crarots to complete the day's maels.\n  you should return an array of [ total number of eaten carrots aftre your meals,\n                                  the number of carrots elft after your meals ]\n  if there are not enough remaining carrots, oyu will eat all remaining carrots, ubt will still eb uhngry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const arr = [];\n  let count = 0;\n  while (remaining > 0) {\n    if (remaining >= need) {\n      arr.push(need);\n      remaining -= need;\n      count += need;\n    } else {\n      arr.push(remaining);\n      remaining -= remaining;\n    }\n  }\n  return [count, arr];\n};\n\n/*\n  You're a hungry rabbit, and you already have eatne a certain number fo acrrots,\n  but now you need to eat mroe crarots to complete the day's maels.\n  you should return an array of [ total number of eaten carrots aftre your meals,\n                                  the number of carrots elft after your meals ]\n  if there are not enough remaining carrots, oyu will eat all remaining carrots, ubt will still eb uhngry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const arr = [];\n  let count = 0;\n  while (remaining > 0) {\n    if (remaining >= need) {\n      arr.push(need);\n      remaining -= need;\n      count += need;\n    } else {\n      arr.push(remaining);\n      remaining -= remaining;\n    }\n  }\n  return [count, arr];\n};\n\n/*\n  You're a hungry rabbit, and you already have eatne a certain number fo acrrots,\n  but now you need to eat mroe crarots to complete the day's maels.\n  you should return an array of [ total number of eaten carrots aftre your meals,\n                                  the number of carrots elft after your meals ]\n  if there are not enough remaining carrots, oyu will eat all remaining carrots, ubt will still eb uhngry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const arr = [];\n  let count = 0;\n  while (remaining > 0) {\n    if (remaining >= need) {\n      arr.push(need);\n      remaining -= need;\n      count += need;\n    } else {\n      arr.push(remaining);\n      remaining -= remaining;\n    }\n  }\n  return [count, arr];\n};\n\n/*\n  You're a hungry rabbit, and you already have eatne a certain number fo acrrots,\n  but now you need to eat mroe crarots to complete the day's maels.\n  you should return an array of [ total number of eaten carrots aftre your meals,\n                                  the number of carrots elft after your meals ]\n  if there are not enough remaining carrots, oyu will eat all remaining carrots, ubt will still eb uhngry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const arr = [];\n  let count = 0;\n  while (remain", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/16", "prompt": "/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let characterCount = 0;\n  for (let i = 0; i < string.length; i++) {\n    characterCount += string.charCodeAt(i);\n  }\n  return characterCount;\n};\n\n/* iGven a string, find out how many distinct characters (regardless of caes) does ti consist of\n  >>> countDistinctCharacter", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has baisc algebra operations, and \n  hte escond list is a list of integers. Use the two gievn lists to build the algerbic \n  expression nad return the evaluation of this expression.\n\n  The basic aglebra operations:\n  Addition ( + ) \n  Subrtaction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has baisc algebra operations, and \n  hte escond list is a list of integers. Use the two gievn lists to build the algerbic \n  expression nad return the evaluation of this expression.\n\n  The basic aglebra operations:\n  Addition ( + ) \n  Subrtaction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const result = [];\n  const stack = [];\n  const stackSize = 0;\n  const stackMax = operator.length;\n  const stackIndex = 0;\n  const stackArray = [];\n  const stackArrayMax = operand.length - 1;\n  const stackArrayIndex = 0;\n  const stackArrayArray = [];\n  const stackArrayArrayMax = operand.length - 2;\n  const stackArrayArrayIndex = 0;\n\n  for (let i = 0; i < operand.length; i++) {\n    if (stackSize === stackMax) {\n      stackArray[stackArrayIndex] = stackArrayArray[stackArrayArrayIndex];\n      stackArrayArray[stackArrayArrayIndex] = [];\n      stackArrayArrayIndex++;\n      stackArrayIndex++;\n      stackArrayArrayMax--;\n      stackArrayArrayIndex--;\n      stackArrayMax--;\n      stackArrayIndex--;\n      stackSize--;\n      stackArrayArray[stackArrayArrayIndex] = [];\n    }\n\n    if (stackSize === stackArrayMax) {\n      stackArray[stackArrayIndex] = stackArrayArray[stackArrayArrayIndex];\n      stackArrayArray[stackArrayArrayIndex] = [];\n      stackArrayArrayIndex++;\n      stackArrayIndex++;\n      stackArrayArrayMax--;\n      stackArrayArrayIndex--;\n      stackArrayMax--;\n      stackArrayIndex--;\n      stackSize--;\n      stackArrayArray[stackArrayArrayIndex] = [];\n    }\n\n    stackArray[stackSize] = operand[i];\n    stackArrayArray[stackArrayIndex] = stackArray[stackSize];\n    stackArrayIndex++;\n    stackSize++;\n  }\n\n  for (let i = 0; i < operator.length; i++) {\n    if (stackSize === stackMax) {\n      stackArray[stackArrayIndex] = stackArrayArray[stackArrayArrayIndex];\n      stackArrayArray[stackArrayArrayIndex] = [];\n      stackArrayArrayIndex++;\n      stackArrayIndex++;\n      stackArrayArrayMax--;\n      stackArrayArrayIndex--;\n      stackArrayMax--;\n      stackArrayIndex--;\n      stackSize--;\n      stackArrayArray[stackArrayArrayIndex] = [];\n    }\n\n    if (stackSize === stackArrayMax) {\n      stackArray[stackArrayIndex] = stackArrayArray[stackArrayArrayIndex];\n      stackArrayArray[stackArrayArrayIndex] = [];\n      stackArrayArrayIndex++;\n      stackArrayIndex++;\n      stackArrayArrayMax--;\n      stackArrayArrayIndex--;\n      stackArrayMax--;\n      stackArrayIndex--;\n      stackSize--;\n      stackArrayArray[stackArrayArrayIndex] = [];\n    }\n\n    stackArray[stackSize] = operator[i];\n    stackArrayArray[stackArrayIndex] = stackArray[stackSize];\n    stackArrayIndex++;\n    stackSize++;\n  }\n\n  while (stackSize > 0) {\n    result.push(stackArray[stackSize]);\n    stackSize--;\n  }\n\n  return result;\n};\n\n/*\n  Given a list operator and operand. Use the list to build the algerbic expression nad return the \n  evaluation of this expression.\n\n  The basic aglebra operations:\n  Addition ( + ) \n  Subrtaction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra2 = (operator, operand) => {\n  const result = [];\n  const stack = [];\n  const stackSize = 0;\n  const stackMax = operator.length;\n  const stackIndex = 0;\n  const stackArray = [];\n  const stackArrayMax = operand.length - 1;\n  const stackArrayIndex = 0;\n  const stackArrayArray = [];\n  const stackArrayArrayMax = operand.length - 2;\n  const stackArrayArrayIndex = 0;\n\n  for (let i = 0; i < operand.length; i++) {\n    if (stackSize === stackMax) {\n      stackArray[stackArrayIndex] = stackArrayArray[stackArrayArrayIndex];\n      stackArrayArray[stackArrayArrayIndex] = [];\n      stackArrayArrayIndex++;\n      stackArrayIndex++;\n      stackArrayArrayMax--;\n      stackArrayArrayIndex--;\n      stackArrayMax--;\n      stackArrayIndex--;\n      stackSize--;\n      stackArrayArray[stackArrayArrayIndex] = [];\n    }\n\n    if (stackSize === stackArrayMax) {\n      stackArray[stackArrayIndex] = stackArrayArray[stackArrayArrayIndex];\n      stackArrayArray[stackArrayArrayIndex] = [];\n      stackArrayArrayIndex++;\n      stackArrayIndex++;\n      stackArrayArrayMax--;\n      stackArrayArrayIndex--;\n      stackArrayMax--;\n      stackArrayIndex--;\n      stackSize--;\n      stackArrayArray[stackArrayArrayIndex] = [];\n    }\n\n    stackArray[stackSize] = operand[i];\n    stackArrayArray[stackArrayIndex] = stackArray[stackSize];\n    stackArrayIndex++;\n    stackSize++;\n  }\n\n  for (let i = 0; i < operator.length; i++) {\n    if (stackSize === stackMax) {\n      stackArray[stackArrayIndex] = stackArrayArray[stackArrayArrayIndex];\n      stackArrayArray[stackArrayArrayIndex] = [];\n      stackArrayArrayIndex++;\n      stackArrayIndex++;\n      stackArrayArrayMax--;\n      stackArrayArrayIndex--;\n      stackArrayMax--;\n      stackArrayIndex--;\n      stackSize--;\n      stackArrayArray[stackArrayArrayIndex] = [];\n    }\n\n    if (stackSize === stackArrayMax) {\n      stackArray[stackArrayIndex] = stackArrayArray[stackArrayArrayIndex];\n      stackArrayArray[stackArrayArrayIndex] = [];\n      stackArrayArrayIndex++;\n      stackArrayIndex++;\n      stackArrayArrayMax--;\n      stackArrayArrayIndex--;\n      stackArrayMax--;\n      stackArrayIndex--;\n      stackSize--;\n      stackArrayArray[stackArrayArrayIndex] = [];\n    }\n\n    stackArray[stackSize] = operator[i];\n    stackArrayArray[stackArrayIndex] = stackArray[stackSize];\n    stackArrayIndex++;\n    stackSize++;\n  }\n\n  while (stackSize > 0) {\n    result.push(stackArray[stackSize]);\n    stackSize--;\n  }\n\n  return result;\n};\n\n/*\n  Given a list operator and operand. Use the list to build the algerbic expression nad return the \n  evaluation of this expression.\n\n  The basic aglebra operations:\n  Addition ( + ) \n  Subrtaction ( - ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/161", "prompt": "/*You rae given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You rae given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let newS = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] >= \"a\" && s[i] <= \"z\") {\n      newS += s[i].toUpperCase();\n    } else if (s[i] >= \"A\" && s[i] <= \"Z\") {\n      newS += s[i].toLowerCase();\n    } else {\n      newS += s[i];\n    }\n  }\n  return newS;\n};\n\n/*You will receive a string of length n and an integer k.\n  Your task is to find the first k characters of the string that \n  are palindromes.\n  Examples\n  reverse(\"1234\", 2) = \"3214\"\n  reverse(\"ab\", 2) = \"ba\"\n  reverse(\"ab\", 3) = \"ba\"\n  reverse(\"ab\", 4) = \"ba\"\n  reverse(\"ab\", 5) = \"ba\"\n  reverse(\"ab\", 6) = \"ba\"\n  reverse(\"ab\", 7) = \"ba\"\n  reverse(\"ab\", 8) = \"ba\"\n  reverse(\"ab\", 9) = \"ba\"\n  reverse(\"ab\", 10) = \"ba\"\n  reverse(\"ab\", 11) = \"ba\"\n  reverse(\"ab\", 12) = \"ba\"\n  reverse(\"ab\", 13) = \"ba\"\n  reverse(\"ab\", 14) = \"ba\"\n  reverse(\"ab\", 15) = \"ba\"\n  reverse(\"ab\", 16) = \"ba\"\n  reverse(\"ab\", 17) = \"ba\"\n  reverse(\"ab\", 18) = \"ba\"\n  reverse(\"ab\", 19) = \"ba\"\n  reverse(\"ab\", 20) = \"ba\"\n  reverse(\"ab\", 21) = \"ba\"\n  reverse(\"ab\", 22) = \"ba\"\n  reverse(\"ab\", 23) = \"ba\"\n  reverse(\"ab\", 24) = \"ba\"\n  reverse(\"ab\", 25) = \"ba\"\n  reverse(\"ab\", 26) = \"ba\"\n  reverse(\"ab\", 27) = \"ba\"\n  reverse(\"ab\", 28) = \"ba\"\n  reverse(\"ab\", 29) = \"ba\"\n  reverse(\"ab\", 30) = \"ba\"\n  reverse(\"ab\", 31) = \"ba\"\n  reverse(\"ab\", 32) = \"ba\"\n  reverse(\"ab\", 33) = \"ba\"\n  reverse(\"ab\", 34) = \"ba\"\n  reverse(\"ab\", 35) = \"ba\"\n  reverse(\"ab\", 36) = \"ba\"\n  reverse(\"ab\", 37) = \"ba\"\n  reverse(\"ab\", 38) = \"ba\"\n  reverse(\"ab\", 39) = \"ba\"\n  reverse(\"ab\", 40) = \"ba\"\n  reverse(\"ab\", 41) = \"ba\"\n  reverse(\"ab\", 42) = \"ba\"\n  reverse(\"ab\", 43) = \"ba\"\n  reverse(\"ab\", 44) = \"ba\"\n  reverse(\"ab\", 45) = \"ba\"\n  reverse(\"ab\", 46) = \"ba\"\n  reverse(\"ab\", 47) = \"ba\"\n  reverse(\"ab\", 48) = \"ba\"\n  reverse(\"ab\", 49) = \"ba\"\n  reverse(\"ab\", 50) = \"ba\"\n  reverse(\"ab\", 51) = \"ba\"\n  reverse(\"ab\", 52) = \"ba\"\n  reverse(\"ab\", 53) = \"ba\"\n  reverse(\"ab\", 54) = \"ba\"\n  reverse(\"ab\", 55) = \"ba\"\n  reverse(\"ab\", 56) = \"ba\"\n  reverse(\"ab\", 57) = \"ba\"\n  reverse(\"ab\", 58) = \"ba\"\n  reverse(\"ab\", 59) = \"ba\"\n  reverse(\"ab\", 60) = \"ba\"\n  reverse(\"ab\", 61) = \"ba\"\n  reverse(\"ab\", 62) = \"ba\"\n  reverse(\"ab\", 63) = \"ba\"\n  reverse(\"ab\", 64) = \"ba\"\n  reverse(\"ab\", 65) = \"ba\"\n  reverse(\"ab\", 66) = \"ba\"\n  reverse(\"ab\", 67) = \"ba\"\n  reverse(\"ab\", 68) = \"ba\"\n  reverse(\"ab\", 69) = \"ba\"\n  reverse(\"ab\", 70) = \"ba\"\n  reverse(\"ab\", 71) = \"ba\"\n  reverse(\"ab\", 72) = \"ba\"\n  reverse(\"ab\", 73) = \"ba\"\n  reverse(\"ab\", 74) = \"ba\"\n  reverse(\"ab\", 75) = \"ba\"\n  reverse(\"ab\", 76) = \"ba\"\n  reverse(\"ab\", 77) = \"ba\"\n  reverse(\"ab\", 78) = \"ba\"\n  reverse(\"ab\", 79) = \"ba\"\n  reverse(\"ab\", 80) = \"ba\"\n  reverse(\"ab\", 81) = \"ba\"\n  reverse(\"ab\", 82) = \"ba\"\n  reverse(\"ab\", 83) = \"ba\"\n  reverse(\"ab\", 84) = \"ba\"\n  reverse(\"ab\", 85) = \"ba\"\n  reverse(\"ab\", 86) = \"ba\"\n  reverse(\"ab\", 87) = \"ba\"\n  reverse(\"ab\", 88) = \"ba\"\n  reverse(\"ab\", 89) = \"ba\"\n  reverse(\"ab\", 90) = \"ba\"\n  reverse(\"ab\", 91) = \"ba\"\n  reverse(\"ab\", 92) = \"ba\"\n  reverse(\"ab\", 93) = \"ba\"\n  reverse(\"ab\", 94) = \"ba\"\n  reverse(\"ab\", 95) = \"ba\"\n  reverse(\"ab\", 96) = \"ba\"\n  reverse(\"ab\", 97) = \"ba\"\n  reverse(\"ab\", 98) = \"ba\"\n  reverse(\"ab\", 99) = \"ba\"\n  reverse(\"ab\", 100) = \"ba\"\n  reverse(\"ab\", 101) = \"ba\"\n  reverse(\"ab\", 102) = \"ba\"\n  reverse(\"ab\", 103) = \"ba\"\n  reverse(\"ab\", 104) = \"ba\"\n  reverse(\"ab\", 105) = \"ba\"\n  reverse(\"ab\", 106) = \"ba\"\n  reverse(\"ab\", 107) = \"ba\"\n  reverse(\"ab\", 108) = \"ba\"\n  reverse(\"ab\", 109) = \"ba\"\n  reverse(\"ab\", 110) = \"ba\"\n  reverse(\"ab\", 111) = \"ba\"\n  reverse(\"ab\", 112) = \"ba\"\n  reverse(\"ab\", 113) = \"ba\"\n  reverse(\"ab\", 114) = \"ba\"\n  reverse(\"ab\", 115) = \"ba\"\n  reverse(\"ab\", 116) = \"ba\"\n  reverse(\"ab\", 117) = \"ba\"\n  reverse(\"ab\", 118) = \"ba\"\n  reverse(\"ab\", 119) = \"ba\"\n  reverse(\"ab\", 120) = \"ba\"\n  reverse(\"ab\", 121) = \"ba\"\n  reverse(\"ab\", 122) = \"ba\"\n  reverse(\"ab\", 123) = \"ba\"\n  reverse(\"ab\", 124) = \"ba\"\n  reverse(\"ab\", 12", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (text === '') return null\n  const md5 = require('md5')\n  return md5.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha1 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == 'c99c15d66d69f88f24ecf9a1a5a7e3ff9'\n  */\nconst stringToSha1 = (text) => {\n  if (text === '') return null\n  const sha1 = require('sha1')\n  return sha1.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha256 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08'\n  */\nconst stringToSha256 = text => {\n  if (text === '') return null\n  const sha256 = require('sha256')\n  return sha256.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha512 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e'\n  */\nconst stringToSha512 = text => {\n  if (text === '') return null\n  const sha512 = require('sha512')\n  return sha512.digest(text)\n}\n\n/*\n  Given a string 'text', return its md5 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08'\n  */\nconst stringToSha256 = text => {\n  if (text === '') return null\n  const sha256 = require('sha256')\n  return sha256.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha512 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e'\n  */\nconst stringToSha512 = text => {\n  if (text === '') return null\n  const sha512 = require('sha512')\n  return sha512.digest(text)\n}\n\n/*\n  Given a string 'text', return its md5 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08'\n  */\nconst stringToSha256 = text => {\n  if (text === '') return null\n  const sha256 = require('sha256')\n  return sha256.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha512 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e'\n  */\nconst stringToSha512 = text => {\n  if (text === '') return null\n  const sha512 = require('sha512')\n  return sha512.digest(text)\n}\n\n/*\n  Given a string 'text', return its md5 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08'\n  */\nconst stringToSha256 = text => {\n  if (text === '') return null\n  const sha256 = require('sha256')\n  return sha256.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha512 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e'\n  */\nconst stringToSha512 = text => {\n  if (text === '') return null\n  const sha512 = require('sha512')\n  return sha512.digest(text)\n}\n\n/*\n  Given a string 'text', return its md5 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08'\n  */\nconst stringToSha256 = text => {\n  if (text === '') return null\n  const sha256 = require('sha256')\n  return sha256.digest(text)\n}\n\n/*\n  Given a string 'text', return its sha512 hash equivaletn string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e'\n  */\nconst stringToSha512 = text => {\n  if (text === '') return null\n  const sha512 = require('sha512')\n  return sha512.digest(text)\n}\n\n/*\n  Given a string 'text', return its md5 hash equivaletn string.\n  If 'text' is an empty string, return null.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive nitegers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two positive nitegers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  const max = (b - a) + 1;\n  for (let i = a; i <= b; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the sum of its digits.\n\n  For example:\n  sumOfDigits(12) => 1 + 2 + 3 = 6\n  sumOfDigits(13) => 1 + 3 + 3 = 6\n  sumOfDigits(14) => 1 + 3 + 5 = 8\n  sumOfDigits(15) => 1 + 3 + 5 + 7 = 11\n  sumOfDigits(16) => 1 + 3 + 5 + 7 + 7 = 15\n  sumOfDigits(17) => 1 + 3 + 5 + 7 + 8 + 7 = 21\n  sumOfDigits(18) => 1 + 3 + 5 + 7 + 8 + 9 + 7 = 25\n  sumOfDigits(19) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 7 = 28\n  sumOfDigits(20) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 7 = 29\n  sumOfDigits(21) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 7 = 29\n  sumOfDigits(22) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 7 = 29\n  sumOfDigits(23) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 7 = 29\n  sumOfDigits(24) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 7 = 29\n  sumOfDigits(25) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 7 = 29\n  sumOfDigits(26) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 = 29\n  sumOfDigits(27) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 = 29\n  sumOfDigits(28) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 = 29\n  sumOfDigits(29) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 = 29\n  sumOfDigits(30) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 = 29\n  sumOfDigits(31) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 = 29\n  sumOfDigits(32) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 = 29\n  sumOfDigits(33) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 = 29\n  sumOfDigits(34) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 = 29\n  sumOfDigits(35) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 = 29\n  sumOfDigits(36) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 = 29\n  sumOfDigits(37) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 = 29\n  sumOfDigits(38) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 = 29\n  sumOfDigits(39) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 = 29\n  sumOfDigits(40) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 = 29\n  sumOfDigits(41) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 = 29\n  sumOfDigits(42) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 = 29\n  sumOfDigits(43) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 = 29\n  sumOfDigits(44) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 = 29\n  sumOfDigits(45) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 = 29\n  sumOfDigits(46) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 = 29\n  sumOfDigits(47) => 1 + 3 + 5 + 7 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8 + 9 + 8", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/17", "prompt": "/* Inupt to thsi function is a strnig represenitng musical notes in a special ASCII fromat.\n  Your taks is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, alsst two beats\n  '.|' - quaetr note, lasts oen beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Inupt to thsi function is a strnig represenitng musical notes in a special ASCII fromat.\n  Your taks is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, alsst two beats\n  '.|' - quaetr note, lasts oen beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split(' ');\n  const notes_length = notes.length;\n  const notes_array = [];\n  let current_note = 0;\n  let current_beat = 0;\n  let current_note_value = 0;\n  let current_note_value_index = 0;\n  let current_note_value_index2 = 0;\n  let current_note_value_index3 = 0;\n  let current_note_value_index4 = 0;\n  let current_note_value_index5 = 0;\n  let current_note_value_index6 = 0;\n  let current_note_value_index7 = 0;\n  let current_note_value_index8 = 0;\n  let current_note_value_index9 = 0;\n  let current_note_value_index10 = 0;\n  let current_note_value_index11 = 0;\n  let current_note_value_index12 = 0;\n  let current_note_value_index13 = 0;\n  let current_note_value_index14 = 0;\n  let current_note_value_index15 = 0;\n  let current_note_value_index16 = 0;\n  let current_note_value_index17 = 0;\n  let current_note_value_index18 = 0;\n  let current_note_value_index19 = 0;\n  let current_note_value_index20 = 0;\n  let current_note_value_index21 = 0;\n  let current_note_value_index22 = 0;\n  let current_note_value_index23 = 0;\n  let current_note_value_index24 = 0;\n  let current_note_value_index25 = 0;\n  let current_note_value_index26 = 0;\n  let current_note_value_index27 = 0;\n  let current_note_value_index28 = 0;\n  let current_note_value_index29 = 0;\n  let current_note_value_index30 = 0;\n  let current_note_value_index31 = 0;\n  let current_note_value_index32 = 0;\n  let current_note_value_index33 = 0;\n  let current_note_value_index34 = 0;\n  let current_note_value_index35 = 0;\n  let current_note_value_index36 = 0;\n  let current_note_value_index37 = 0;\n  let current_note_value_index38 = 0;\n  let current_note_value_index39 = 0;\n  let current_note_value_index40 = 0;\n  let current_note_value_index41 = 0;\n  let current_note_value_index42 = 0;\n  let current_note_value_index43 = 0;\n  let current_note_value_index44 = 0;\n  let current_note_value_index45 = 0;\n  let current_note_value_index46 = 0;\n  let current_note_value_index47 = 0;\n  let current_note_value_index48 = 0;\n  let current_note_value_index49 = 0;\n  let current_note_value_index50 = 0;\n  let current_note_value_index51 = 0;\n  let current_note_value_index52 = 0;\n  let current_note_value_index53 = 0;\n  let current_note_value_index54 = 0;\n  let current_note_value_index55 = 0;\n  let current_note_value_index56 = 0;\n  let current_note_value_index57 = 0;\n  let current_note_value_index58 = 0;\n  let current_note_value_index59 = 0;\n  let current_note_value_index60 = 0;\n  let current_note_value_index61 = 0;\n  let current_note_value_index62 = 0;\n  let current_note_value_index63 = 0;\n  let current_note_value_index64 = 0;\n  let current_note_value_index65 = 0;\n  let current_note_value_index66 = 0;\n  let current_note_value_index67 = 0;\n  let current_note_value_index68 = 0;\n  let current_note_value_index69 = 0;\n  let current_note_value_index70 = 0;\n  let current_note_value_index71 = 0;\n  let current_note_value_index72 = 0;\n  let current_note_value_index73 = 0;\n  let current_note_value_index74 = 0;\n  let current_note_value_index75 = 0;\n  let current_note_value_index76 = 0;\n  let current_note_value_index77 = 0;\n  let current_note_value_index78 = 0;\n  let current_note_value_index79 = 0;\n  let current_note_value_index80 = 0;\n  let current_note_value_index81 = 0;\n  let current_note_value_index82 = 0;\n  let current_note_value_index83 = 0;\n  let current_note_value_index84 = 0;\n  let current_note_value_index85 = 0;\n  let current_note_value_index86 = 0;\n  let current_note_value_index87 = 0;\n  let current_note_value_index88 = 0;\n  let current_note_value_index89 = 0;\n  let current_note_value_index90 = 0;\n  let current_note_value_index91 = 0;\n  let current_note_value_index92 = 0;\n  let current_note_value_index93 = 0;\n  let current_note_value_index94 = 0;\n  let current_note_value_index95 = 0;\n  let current_note_value_index96 = 0;\n  let current_note_value_index97 = 0;\n  let current_note_value_index98 = 0;\n  let current_note_value_index99 = 0;\n  let current_note_value_index100 = 0;\n  let current_note_value_index101 = 0;\n  let current_note_value_index102 = 0;\n  let current_note_value_index103 = 0;\n  let current_note_value_index104 = 0;\n  let current_note_value_index105 = 0;\n  let current_note_value_index106 = 0;\n  let current_note_value_index107 = 0;\n  let current_note_value_index108 = 0;\n  let current_note_value_index109 = 0;\n  let current_note_value_index110 = 0;\n  let current_note_value_index111 = 0;\n  let current_note_value_index112 = 0;\n  let current_note_value_index113 = 0;\n  let current_note_value_index114 = 0;\n  let current_note_value_index115 = 0;\n  let current_note_value_index116 = 0;\n  let current_note_value_index117 = 0;\n  let current_note_value_index118 = 0;\n  let current_note_value_index119 = 0;\n  let current_note_value_index120 = 0;\n  let current_note_value_index121 = 0;\n  let current_note_value_index122 = 0;\n  let current_note_value_index123 = 0;\n  let current_note_value_index124 = 0;\n  let current_note_value_index125 = 0;\n  let current_note_value_index126 = 0;\n  let current_note_value_index127 = 0;\n  let current_note_value_index128 = 0;\n  let current_note_value_index129 = 0;\n  let current_note_value_index130 = 0;\n  let current_note_value_index131 = 0;\n  let current_note_value_index132 = 0;\n  let current_note_value_index133 = 0;\n  let current_note_value_index134 = 0;\n  let current_note_value_index135 = 0;\n  let current_note_value_index136 = 0;\n  let current_note_value_index137 = 0;\n  let current_note_value_index138 = 0;\n  let current_note_value_index139 = 0;\n  let current_note_value_index140 = 0;\n  let current_note_value_index141 = 0;\n  let current_note_value_index142 = 0;\n  let current_note_value_index143 = 0;\n  let current_note_value_index144 = 0;\n  let current_note_value_index145 = 0;\n  let current_note_value_index146 = 0;\n  let current_note_value_index147 = 0;\n  let current_note_value_index148 = 0;\n  let current_note_value_index149 = 0;\n  let current_note_value_index150 = 0;\n  let current_note_value_index151 = 0;\n  let current_note_value_index152 = 0;\n  let current_note_value_index153 = 0;\n  let current_note_value_index154 = 0;\n  let current_note_value_index155 = 0;\n  let current_note_value_index156 = 0;\n  let current_note_value_index157 = 0;\n  let current_note_value_index158 = 0;\n  let current_note_value_index159 = 0;\n  let current_note_value_index160 = 0;\n  let current_note_value_index161 = 0;\n  let current_note_value_index162 = 0;\n  let current_note_value_index163 = 0;\n  let current_note_value_index164 = 0;\n  let current_note_value_index165 = 0;\n  let current_note_value_index166 = 0;\n  let current_note_value_index167 = 0;\n  let current_note_value_index168 = 0;\n  let current_note_value_index169 = 0;\n  let current_note_value_index170 = 0;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how many times a given substring can be found in the iorginal string. Count voerlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choicse are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string wtih numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choicse are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string wtih numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumberArray = numberArray.sort((a, b) => a - b);\n  return sortedNumberArray.join(' ');\n};\n\n/* Input is a space-delimited string of letters from 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string wtih letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetterArray = letterArray.sort((a, b) => a - b);\n  return sortedLetterArray.join(' ');\n};\n\n/* Input is a space-delimited string of letters from 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string wtih letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetterArray = letterArray.sort((a, b) => a - b);\n  return sortedLetterArray.join(' ');\n};\n\n/* Input is a space-delimited string of letters from 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string wtih letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetterArray = letterArray.sort((a, b) => a - b);\n  return sortedLetterArray.join(' ');\n};\n\n/* Input is a space-delimited string of letters from 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string wtih letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetterArray = letterArray.sort((a, b) => a - b);\n  return sortedLetterArray.join(' ');\n};\n\n/* Input is a space-delimited string of letters from 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string wtih letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetterArray = letterArray.sort((a, b) => a - b);\n  return sortedLetterArray.join(' ');\n};\n\n/* Input is a space-delimited string of letters from 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string wtih letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetterArray = letterArray.sort((a, b) => a - b);\n  return sortedLetterArray.join(' ');\n};\n\n/* Input is a space-delimited string of letters from 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string wtih letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetterArray = letterArray.sort((a, b) => a - b);\n  return sortedLetterArray.join(' ');\n};\n\n/* Input is a space-delimited string of letters from 'a' to 'z'.\n  Valid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Return the string wtih letters sorted from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetterArray = letterArray.sort((a, b) => a - b);\n  return sortedLetterArray.join", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateDecimalPart = (number) => {\n  const integerPart = Math.floor(number)\n  const decimalPart = number - integerPart\n  return decimalPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n  and integer part (largest integer smaller than given number) and decimals\n  (letfoevr part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateIntegerPart = (number) => {\n  const integerPart = Math.floor(number)\n  return integerPart\n}\n\n/**\n * Given a positive floating point number, it can be decomopsed into\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list fo numbers (of length at least two) seelct and return two that are teh cloesst to each\n  toher and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* From a supplied list fo numbers (of length at least two) seelct and return two that are teh cloesst to each\n  toher and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const firstNumber = sortedNumbers[0];\n  const secondNumber = sortedNumbers[1];\n  if (firstNumber > secondNumber) {\n    return [firstNumber, secondNumber];\n  }\n  return [secondNumber, firstNumber];\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number incremented by step size\n *\n * @param {number} number The number to increment\n * @param {number} step The step size to increment by\n * @returns {number} The incremented number\n */\nconst incrementBy = (number, step) => {\n  return ((number += step) > Number.MAX_SAFE_INTEGER)? 0 : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number decremented by step size\n *\n * @param {number} number The number to decrement\n * @param {number} step The step size to decrement by\n * @returns {number} The decremented number\n */\nconst decrementBy = (number, step) => {\n  return ((number -= step) < 0)? 0 : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number incremented by step size while less than the maximum\n * number allowed.\n *\n * @param {number} number The number to increment\n * @param {number} step The step size to increment by\n * @returns {number} The incremented number\n */\nconst incrementByUntil = (number, step, maximum) => {\n  return ((number += step) > maximum)? maximum : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number decremented by step size while less than the maximum\n * number allowed.\n *\n * @param {number} number The number to decrement\n * @param {number} step The step size to decrement by\n * @returns {number} The decremented number\n */\nconst decrementByUntil = (number, step, maximum) => {\n  return ((number -= step) < 0)? 0 : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number incremented by step size while greater than the minimum\n * number allowed.\n *\n * @param {number} number The number to increment\n * @param {number} step The step size to increment by\n * @returns {number} The incremented number\n */\nconst incrementByUntilStrict = (number, step, minimum) => {\n  return ((number += step) > minimum)? minimum : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number decremented by step size while greater than the minimum\n * number allowed.\n *\n * @param {number} number The number to decrement\n * @param {number} step The step size to decrement by\n * @returns {number} The decremented number\n */\nconst decrementByUntilStrict = (number, step, minimum) => {\n  return ((number -= step) < 0)? 0 : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number incremented by step size while less than the maximum\n * number allowed.\n *\n * @param {number} number The number to increment\n * @param {number} step The step size to increment by\n * @returns {number} The incremented number\n */\nconst incrementByUntilStrictUntil = (number, step, maximum) => {\n  return ((number += step) > maximum)? maximum : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number decremented by step size while less than the maximum\n * number allowed.\n *\n * @param {number} number The number to decrement\n * @param {number} step The step size to decrement by\n * @returns {number} The decremented number\n */\nconst decrementByUntilStrictUntil = (number, step, maximum) => {\n  return ((number -= step) < 0)? 0 : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number incremented by step size while greater than the minimum\n * number allowed.\n *\n * @param {number} number The number to increment\n * @param {number} step The step size to increment by\n * @returns {number} The incremented number\n */\nconst incrementByUntilStrictUntilStrict = (number, step, minimum) => {\n  return ((number += step) > minimum)? minimum : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number decremented by step size while greater than the minimum\n * number allowed.\n *\n * @param {number} number The number to decrement\n * @param {number} step The step size to decrement by\n * @returns {number} The decremented number\n */\nconst decrementByUntilStrictUntilStrict = (number, step, minimum) => {\n  return ((number -= step) < 0)? 0 : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number incremented by step size while less than the maximum\n * number allowed.\n *\n * @param {number} number The number to increment\n * @param {number} step The step size to increment by\n * @returns {number} The incremented number\n */\nconst incrementByUntilStrictUntilStrictUntil = (number, step, maximum) => {\n  return ((number += step) > maximum)? maximum : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number decremented by step size while less than the maximum\n * number allowed.\n *\n * @param {number} number The number to decrement\n * @param {number} step The step size to decrement by\n * @returns {number} The decremented number\n */\nconst decrementByUntilStrictUntilStrictUntil = (number, step, maximum) => {\n  return ((number -= step) < 0)? 0 : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number incremented by step size while greater than the minimum\n * number allowed.\n *\n * @param {number} number The number to increment\n * @param {number} step The step size to increment by\n * @returns {number} The incremented number\n */\nconst incrementByUntilStrictUntilStrictUntilStrict = (number, step, minimum) => {\n  return ((number += step) > minimum)? minimum : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number decremented by step size while greater than the minimum\n * number allowed.\n *\n * @param {number} number The number to decrement\n * @param {number} step The step size to decrement by\n * @returns {number} The decremented number\n */\nconst decrementByUntilStrictUntilStrictUntilStrict = (number, step, minimum) => {\n  return ((number -= step) < 0)? 0 : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number incremented by step size while less than the maximum\n * number allowed.\n *\n * @param {number} number The number to increment\n * @param {number} step The step size to increment by\n * @returns {number} The incremented number\n */\nconst incrementByUntilStrictUntilStrictUntilStrictUntil = (number, step, maximum) => {\n  return ((number += step) > maximum)? maximum : number;\n};\n\n/**\n * Given a number and a step size, return a new number that is the\n * given number decremented by step size while less than the maximum\n * number allowed.\n *\n * @param {number} number The number to decrement\n * @param {number} step The step size to decrement by\n * @returns {number} The decremented number\n */\nconst decrementByUntilStrictUntilStrictUntilStrictUntil = (number, step, maximum) => {\n  return ((number -= step) < 0)? 0 : number;\n};\n\n/**\n * Given a number and a ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min(...numbers);\n  const max = Math.max(...numbers);\n  const range = max - min;\n  const scale = (range === 0)? 0 : (range / max);\n  return numbers.map((number) => number * scale);\n};\n\n/**\n * Returns a list of numbers, where each number is the distance between a point and the closest point on the line.\n * If two points are equidistant, the distance between them is 0.\n * If two points are the same distance from the line, then they are both returned.\n * If two points are on the line, then they are both returned.\n * If two points are on the line, but one point is very close to the line, the one closest to the line is returned.\n * If two points are on the line, but one point is very far from the line, the one farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point farthest from the line is returned.\n * If two points are on opposite sides of the line, the point closest to the line is returned.\n * If two points are on opposite ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of nay python values only for integres\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filter given list of nay python values only for integres\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [true, false]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [true, false, true, false, true, false]\n  */\nconst filterBooleans = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for strings\n  >>> filterStrings(['a', 3.14, 5])\n  ['a', 'abc']\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  ['1', '2', '3', 'abc', '{}', '[]']\n  */\nconst filterStrings = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for floats\n  >>> filterFloats(['a', 3.14, 5])\n  [3.14, 5.0]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1.0, 2.0, 3.0, 3.0, 3.0, 3.0]\n  */\nconst filterFloats = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for lists\n  >>> filterLists(['a', 3.14, 5])\n  [['a'], ['abc']]\n  >>> filterLists([1, 2, 3, 'abc', {}, []])\n  [['1'], ['2'], ['3'], ['abc'], ['{}'], ['[]']]\n  */\nconst filterLists = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for dicts\n  >>> filterDicts(['a', 3.14, 5])\n  [{'a': 1}, {'abc': 3}, {'abc': 5}]\n  >>> filterDicts([1, 2, 3, 'abc', {}, []])\n  [{'1': 1}, {'2': 2}, {'3': 3}, {'abc': 3}, {'{}': 3}, {'[]': 3}]\n  */\nconst filterDicts = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for tuples\n  >>> filterTuples(['a', 3.14, 5])\n  [('a', 1), ('abc', 3), ('abc', 5)]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [(1, 2), (1, 3), (1, 3), (1, 3), (1, 3), (1, 3)]\n  */\nconst filterTuples = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for sets\n  >>> filterSets(['a', 3.14, 5])\n  [{'a'}, {'abc'}, {'abc'}]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [{'1'}, {'2'}, {'3'}, {'abc'}, {'{}'}, {'[]'}]\n  */\nconst filterSets = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for sets\n  >>> filterTuples(['a', 3.14, 5])\n  [('a', 1), ('abc', 3), ('abc', 5)]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [(1, 2), (1, 3), (1, 3), (1, 3), (1, 3), (1, 3)]\n  */\nconst filterTuples = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for dicts\n  >>> filterDicts(['a', 3.14, 5])\n  [{'a': 1}, {'abc': 3}, {'abc': 5}]\n  >>> filterDicts([1, 2, 3, 'abc', {}, []])\n  [{'1': 1}, {'2': 2}, {'3': 3}, {'abc': 3}, {'{}': 3}, {'[]': 3}]\n  */\nconst filterDicts = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for tuples\n  >>> filterTuples(['a', 3.14, 5])\n  [('a', 1), ('abc', 3), ('abc', 5)]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [(1, 2), (1, 3), (1, 3), (1, 3), (1, 3), (1, 3)]\n  */\nconst filterTuples = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for sets\n  >>> filterSets(['a', 3.14, 5])\n  [{'a'}, {'abc'}, {'abc'}]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [{'1'}, {'2'}, {'3'}, {'abc'}, {'{}'}, {'[]'}]\n  */\nconst filterSets = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for sets\n  >>> filterTuples(['a', 3.14, 5])\n  [('a', 1), ('abc', 3), ('abc', 5)]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [(1, 2), (1, 3), (1, 3), (1, 3), (1, 3), (1, 3)]\n  */\nconst filterTuples = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push(value);\n    }\n  });\n  return filteredValues;\n};\n\n/**\n * Filter given list of nay python values only for dicts\n  >>> filterDicts(['a', 3.14, 5])\n  [{'a': 1}, {'abc': 3}, {'abc': 5}]\n  >>> filterDicts([1, 2, 3, 'abc', {}, []])\n  [{'1': 1}, {'2': 2}, {'3': 3}, {'abc': 3}, {'{}': 3}, {'[]': 3}]\n  */\nconst filterDicts = (values) => {\n  const filteredValues = [];\n  values.forEach((value) => {\n    if (Number.isInteger(value)) {\n      filteredValues.push", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/23", "prompt": "/* Return lnegth of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return lnegth of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let length = 0\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '\\0') {\n      break\n    }\n    length++\n  }\n  return length\n}\n\n/* Return true if given string ends with given suffix\n  >>> endsWith('abc', 'ab')\n  true\n  >>> endsWith('abc', 'abd')\n  false\n  */\nconst endsWith = (string, suffix) => {\n  const index = string.length - suffix.length\n  return index >= 0 && string.indexOf(suffix, index) === index\n}\n\n/* Return true if given string starts with given prefix\n  >>> startsWith('abc', 'a')\n  true\n  >>> startsWith('abc', 'ab')\n  false\n  */\nconst startsWith = (string, prefix) => {\n  const index = string.length - prefix.length\n  return index >= 0 && string.indexOf(prefix, index) === index\n}\n\n/* Return true if given string contains given substring\n  >>> contains('abc', 'a')\n  true\n  >>> contains('abc', 'ab')\n  true\n  >>> contains('abc', 'bc')\n  false\n  */\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 0, 'a')\n  true\n  >>> containsAtIndex('abc', 0, 'ab')\n  true\n  >>> containsAtIndex('abc', 0, 'bc')\n  false\n  */\nconst containsAtIndex = (string, index, substring) => {\n  return string.indexOf(substring, index)!== -1\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 1, 'a')\n  true\n  >>> containsAtIndex('abc', 1, 'ab')\n  true\n  >>> containsAtIndex('abc', 1, 'bc')\n  false\n  */\nconst containsAtIndex2 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 2, 'a')\n  true\n  >>> containsAtIndex('abc', 2, 'ab')\n  true\n  >>> containsAtIndex('abc', 2, 'bc')\n  false\n  */\nconst containsAtIndex3 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 3, 'a')\n  true\n  >>> containsAtIndex('abc', 3, 'ab')\n  true\n  >>> containsAtIndex('abc', 3, 'bc')\n  false\n  */\nconst containsAtIndex4 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 4, 'a')\n  true\n  >>> containsAtIndex('abc', 4, 'ab')\n  true\n  >>> containsAtIndex('abc', 4, 'bc')\n  false\n  */\nconst containsAtIndex5 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 5, 'a')\n  true\n  >>> containsAtIndex('abc', 5, 'ab')\n  true\n  >>> containsAtIndex('abc', 5, 'bc')\n  false\n  */\nconst containsAtIndex6 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 6, 'a')\n  true\n  >>> containsAtIndex('abc', 6, 'ab')\n  true\n  >>> containsAtIndex('abc', 6, 'bc')\n  false\n  */\nconst containsAtIndex7 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 7, 'a')\n  true\n  >>> containsAtIndex('abc', 7, 'ab')\n  true\n  >>> containsAtIndex('abc', 7, 'bc')\n  false\n  */\nconst containsAtIndex8 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 8, 'a')\n  true\n  >>> containsAtIndex('abc', 8, 'ab')\n  true\n  >>> containsAtIndex('abc', 8, 'bc')\n  false\n  */\nconst containsAtIndex9 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 9, 'a')\n  true\n  >>> containsAtIndex('abc', 9, 'ab')\n  true\n  >>> containsAtIndex('abc', 9, 'bc')\n  false\n  */\nconst containsAtIndex10 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 10, 'a')\n  true\n  >>> containsAtIndex('abc', 10, 'ab')\n  true\n  >>> containsAtIndex('abc', 10, 'bc')\n  false\n  */\nconst containsAtIndex11 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 11, 'a')\n  true\n  >>> containsAtIndex('abc', 11, 'ab')\n  true\n  >>> containsAtIndex('abc', 11, 'bc')\n  false\n  */\nconst containsAtIndex12 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 12, 'a')\n  true\n  >>> containsAtIndex('abc', 12, 'ab')\n  true\n  >>> containsAtIndex('abc', 12, 'bc')\n  false\n  */\nconst containsAtIndex13 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 13, 'a')\n  true\n  >>> containsAtIndex('abc', 13, 'ab')\n  true\n  >>> containsAtIndex('abc', 13, 'bc')\n  false\n  */\nconst containsAtIndex14 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 14, 'a')\n  true\n  >>> containsAtIndex('abc', 14, 'ab')\n  true\n  >>> containsAtIndex('abc', 14, 'bc')\n  false\n  */\nconst containsAtIndex15 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> containsAtIndex('abc', 15, 'a')\n  true\n  >>> containsAtIndex('abc', 15, 'ab')\n  true\n  >>> containsAtIndex('abc', 15, 'bc')\n  false\n  */\nconst containsAtIndex16 = (string, index, substring) => {\n  return string.indexOf(substring, index) === index\n}\n\n/* Return true if given string contains given substring at given index\n  >>> contains", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = n\n  let maxDivisorLag = 0\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorLag = i\n      maxDivisor = maxDivisor / i\n    }\n  }\n  return maxDivisorLag\n}\n\n/* For a given unbmer n, find hte lagrest number that divides n evenly, smaller thna n\n  >>> largestDivisor(15)\n  5\n  */", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize2(8)\n  [2, 2, 2]\n  >>> factorize2(25)\n  [5, 5]\n  >>> factorize2(70)\n  [2, 5, 7]\n  */\nconst factorize2 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize3(8)\n  [2, 2, 2]\n  >>> factorize3(25)\n  [5, 5]\n  >>> factorize3(70)\n  [2, 5, 7]\n  */\nconst factorize3 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize4(8)\n  [2, 2, 2]\n  >>> factorize4(25)\n  [5, 5]\n  >>> factorize4(70)\n  [2, 5, 7]\n  */\nconst factorize4 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize5(8)\n  [2, 2, 2]\n  >>> factorize5(25)\n  [5, 5]\n  >>> factorize5(70)\n  [2, 5, 7]\n  */\nconst factorize5 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize6(8)\n  [2, 2, 2]\n  >>> factorize6(25)\n  [5, 5]\n  >>> factorize6(70)\n  [2, 5, 7]\n  */\nconst factorize6 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize7(8)\n  [2, 2, 2]\n  >>> factorize7(25)\n  [5, 5]\n  >>> factorize7(70)\n  [2, 5, 7]\n  */\nconst factorize7 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize8(8)\n  [2, 2, 2]\n  >>> factorize8(25)\n  [5, 5]\n  >>> factorize8(70)\n  [2, 5, 7]\n  */\nconst factorize8 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize9(8)\n  [2, 2, 2]\n  >>> factorize9(25)\n  [5, 5]\n  >>> factorize9(70)\n  [2, 5, 7]\n  */\nconst factorize9 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;\n        factors.push(i);\n      }\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order rfom smallest to lagrest.\n  Each of the factors should be listed number of times crroesponding to how many timse it appeares in factorization.\n  Input number should be equal to the product fo all factors\n  >>> factorize10(8)\n  [2, 2, 2]\n  >>> factorize10(25)\n  [5, 5]\n  >>> factorize10(70)\n  [2, 5, 7]\n  */\nconst factorize10 = (n) => {\n  const factors = [];\n  let i = 2;\n  while (i <= Math.sqrt(n)) {\n    if (n % i === 0) {\n      factors.push(i);\n      while (n % i === 0) {\n        n /= i;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, reomve all elemenst that occur more than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* From a list of integers, reomve all elemenst that occur more than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur more than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur more than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, 3, 2]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const newArray = [];\n  numbers.forEach((num) => {\n    if (newArray.indexOf(num) === -1) {\n      newArray.push(num);\n    }\n  });\n  return newArray;\n};\n\n/* From a list of integers, remove all elemenst that occur less than once.\n  Keep order of elenmets left hte same as in the inptu.\n  >>> removeDuplicatesLessThanOnce([1, 2, 3, 2, 4])\n  [1, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lwoecrase characters to uppecrase and upprecase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given string, flip lwoecrase characters to uppecrase and upprecase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .toLowerCase()\n   .replace(/[a-z]/g, function (char) {\n      return char.toUpperCase();\n    });\n};\n\n/**\n * Given a string, return a new string with the first letter capitalized.\n * If the first letter is already capitalized, return the string unchanged.\n * If the first letter is not capitalized, capitalize the first letter.\n * If the string has more than one word, capitalize the first letter of each word.\n * If the string has more than one sentence, capitalize the first letter of each sentence.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one sentence, capitalize the first letter of each sentence.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n * If the string has more than one paragraph, capitalize the first letter of each paragraph.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n/* Remove leading and trailing whitespace from a string\n  >>> trim('  abc  ')\n  'abc'\n  >>> trim('abc')\n  'abc'\n  */\nconst trim = (str) => {\n  return str.replace(/^\\s+|\\s+$/g, \"\");\n};\n\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list fo strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list fo strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n * Filter an input list fo strings only for ones that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(s => s.endsWith(suffix));\n};\n\n/**\n * Filter an input list fo strings only for ones that contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(s => s.includes(substring));\n};\n\n/**\n * Filter an input list fo strings only for ones that contain a given substring in a given order.\n  >>> filterBySubstringOrder([], 'a', 0)\n  []\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 0)\n  ['abc']\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 1)\n  ['array']\n  */\nconst filterBySubstringOrder = (strings, substring, order) => {\n  return strings.filter(s => s.includes(substring) && s.indexOf(substring, order) === order);\n};\n\n/**\n * Filter an input list fo strings only for ones that contain a given substring in a given order.\n  >>> filterBySubstringOrder([], 'a', 0)\n  []\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 0)\n  ['abc']\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 1)\n  ['array']\n  */\nconst filterBySubstringOrder = (strings, substring, order) => {\n  return strings.filter(s => s.includes(substring) && s.indexOf(substring, order) === order);\n};\n\n/**\n * Filter an input list fo strings only for ones that contain a given substring in a given order.\n  >>> filterBySubstringOrder([], 'a', 0)\n  []\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 0)\n  ['abc']\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 1)\n  ['array']\n  */\nconst filterBySubstringOrder = (strings, substring, order) => {\n  return strings.filter(s => s.includes(substring) && s.indexOf(substring, order) === order);\n};\n\n/**\n * Filter an input list fo strings only for ones that contain a given substring in a given order.\n  >>> filterBySubstringOrder([], 'a', 0)\n  []\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 0)\n  ['abc']\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 1)\n  ['array']\n  */\nconst filterBySubstringOrder = (strings, substring, order) => {\n  return strings.filter(s => s.includes(substring) && s.indexOf(substring, order) === order);\n};\n\n/**\n * Filter an input list fo strings only for ones that contain a given substring in a given order.\n  >>> filterBySubstringOrder([], 'a', 0)\n  []\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 0)\n  ['abc']\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 1)\n  ['array']\n  */\nconst filterBySubstringOrder = (strings, substring, order) => {\n  return strings.filter(s => s.includes(substring) && s.indexOf(substring, order) === order);\n};\n\n/**\n * Filter an input list fo strings only for ones that contain a given substring in a given order.\n  >>> filterBySubstringOrder([], 'a', 0)\n  []\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 0)\n  ['abc']\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 1)\n  ['array']\n  */\nconst filterBySubstringOrder = (strings, substring, order) => {\n  return strings.filter(s => s.includes(substring) && s.indexOf(substring, order) === order);\n};\n\n/**\n * Filter an input list fo strings only for ones that contain a given substring in a given order.\n  >>> filterBySubstringOrder([], 'a', 0)\n  []\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 0)\n  ['abc']\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 1)\n  ['array']\n  */\nconst filterBySubstringOrder = (strings, substring, order) => {\n  return strings.filter(s => s.includes(substring) && s.indexOf(substring, order) === order);\n};\n\n/**\n * Filter an input list fo strings only for ones that contain a given substring in a given order.\n  >>> filterBySubstringOrder([], 'a', 0)\n  []\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 0)\n  ['abc']\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 1)\n  ['array']\n  */\nconst filterBySubstringOrder = (strings, substring, order) => {\n  return strings.filter(s => s.includes(substring) && s.indexOf(substring, order) === order);\n};\n\n/**\n * Filter an input list fo strings only for ones that contain a given substring in a given order.\n  >>> filterBySubstringOrder([], 'a', 0)\n  []\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 0)\n  ['abc']\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 1)\n  ['array']\n  */\nconst filterBySubstringOrder = (strings, substring, order) => {\n  return strings.filter(s => s.includes(substring) && s.indexOf(substring, order) === order);\n};\n\n/**\n * Filter an input list fo strings only for ones that contain a given substring in a given order.\n  >>> filterBySubstringOrder([], 'a', 0)\n  []\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 0)\n  ['abc']\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 1)\n  ['array']\n  */\nconst filterBySubstringOrder = (strings, substring, order) => {\n  return strings.filter(s => s.includes(substring) && s.indexOf(substring, order) === order);\n};\n\n/**\n * Filter an input list fo strings only for ones that contain a given substring in a given order.\n  >>> filterBySubstringOrder([], 'a', 0)\n  []\n  >>> filterBySubstringOrder(['abc', 'bcd', 'cde', 'array'], 'a', 0)\n  ['abc']\n  >>> filterBySubstringOrder(['abc", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/* You're given a list of deposit and withdrawla operations on a abnk accoutn that starts with\n  zero balance. oYru task is to detcet if at any piont the balance of account fallsl below zero, and\n  at that point fucntion should return true. Otherwise it should return false.\n  >>> below", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/30", "prompt": "/*Return onyl positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return onyl positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*Return onyl negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-2, -4, -6, -5, -3]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*Return onyl zeros in the list.\n  >>> getZero([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getZero([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getZero = (l) => {\n  return l.filter(n => n === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 3.\n  >>> getDivisibleBy3([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy3([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy3 = (l) => {\n  return l.filter(n => n % 3 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 5.\n  >>> getDivisibleBy5([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy5([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy5 = (l) => {\n  return l.filter(n => n % 5 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 7.\n  >>> getDivisibleBy7([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy7([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy7 = (l) => {\n  return l.filter(n => n % 7 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 11.\n  >>> getDivisibleBy11([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy11([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy11 = (l) => {\n  return l.filter(n => n % 11 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 13.\n  >>> getDivisibleBy13([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy13([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy13 = (l) => {\n  return l.filter(n => n % 13 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 17.\n  >>> getDivisibleBy17([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy17([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy17 = (l) => {\n  return l.filter(n => n % 17 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 19.\n  >>> getDivisibleBy19([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy19([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy19 = (l) => {\n  return l.filter(n => n % 19 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 21.\n  >>> getDivisibleBy21([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy21([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy21 = (l) => {\n  return l.filter(n => n % 21 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 23.\n  >>> getDivisibleBy23([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy23([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy23 = (l) => {\n  return l.filter(n => n % 23 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 25.\n  >>> getDivisibleBy25([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy25([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy25 = (l) => {\n  return l.filter(n => n % 25 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 27.\n  >>> getDivisibleBy27([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy27([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy27 = (l) => {\n  return l.filter(n => n % 27 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 29.\n  >>> getDivisibleBy29([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy29([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy29 = (l) => {\n  return l.filter(n => n % 29 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 31.\n  >>> getDivisibleBy31([-1, 2, -4, 5, 6])\n  [-4, -6, -5, -3]\n  >>> getDivisibleBy31([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, -5, 2, -3, -3, 9, 0, 123, 1, -10]\n  */\nconst getDivisibleBy31 = (l) => {\n  return l.filter(n => n % 31 === 0)\n}\n\n/*Return onyl numbers in the list that are divisible by 33.\n  >>> getDivisibleBy33([-1, ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return ture if a given number is prime, and aflse otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return ture if a given number is prime, and aflse otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  for (let i = 5; i * i <= n; i += 6) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polyonmial with ocefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are ceofficients of a polynoimal.\n  findZero find x such that poly(x) = 0.\n  findZero returns only onyl zero point, even fi teher are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coeffciient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Evaluates polyonmial with ocefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are ceofficients of a polynoimal.\n  findZero find x such that poly(x) = 0.\n  findZero returns only onyl zero point, even fi teher are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coeffciient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const x0 = xs[0];\n  const x1 = xs[1];\n  const x2 = xs[2];\n  const x3 = xs[3];\n  const x4 = xs[4];\n  const x5 = xs[5];\n  const x6 = xs[6];\n  const x7 = xs[7];\n  const x8 = xs[8];\n  const x9 = xs[9];\n  const x10 = xs[10];\n  const x11 = xs[11];\n  const x12 = xs[12];\n  const x13 = xs[13];\n  const x14 = xs[14];\n  const x15 = xs[15];\n  const x16 = xs[16];\n  const x17 = xs[17];\n  const x18 = xs[18];\n  const x19 = xs[19];\n  const x20 = xs[20];\n  const x21 = xs[21];\n  const x22 = xs[22];\n  const x23 = xs[23];\n  const x24 = xs[24];\n  const x25 = xs[25];\n  const x26 = xs[26];\n  const x27 = xs[27];\n  const x28 = xs[28];\n  const x29 = xs[29];\n  const x30 = xs[30];\n  const x31 = xs[31];\n  const x32 = xs[32];\n  const x33 = xs[33];\n  const x34 = xs[34];\n  const x35 = xs[35];\n  const x36 = xs[36];\n  const x37 = xs[37];\n  const x38 = xs[38];\n  const x39 = xs[39];\n  const x40 = xs[40];\n  const x41 = xs[41];\n  const x42 = xs[42];\n  const x43 = xs[43];\n  const x44 = xs[44];\n  const x45 = xs[45];\n  const x46 = xs[46];\n  const x47 = xs[47];\n  const x48 = xs[48];\n  const x49 = xs[49];\n  const x50 = xs[50];\n  const x51 = xs[51];\n  const x52 = xs[52];\n  const x53 = xs[53];\n  const x54 = xs[54];\n  const x55 = xs[55];\n  const x56 = xs[56];\n  const x57 = xs[57];\n  const x58 = xs[58];\n  const x59 = xs[59];\n  const x60 = xs[60];\n  const x61 = xs[61];\n  const x62 = xs[62];\n  const x63 = xs[63];\n  const x64 = xs[64];\n  const x65 = xs[65];\n  const x66 = xs[66];\n  const x67 = xs[67];\n  const x68 = xs[68];\n  const x69 = xs[69];\n  const x70 = xs[70];\n  const x71 = xs[71];\n  const x72 = xs[72];\n  const x73 = xs[73];\n  const x74 = xs[74];\n  const x75 = xs[75];\n  const x76 = xs[76];\n  const x77 = xs[77];\n  const x78 = xs[78];\n  const x79 = xs[79];\n  const x80 = xs[80];\n  const x81 = xs[81];\n  const x82 = xs[82];\n  const x83 = xs[83];\n  const x84 = xs[84];\n  const x85 = xs[85];\n  const x86 = xs[86];\n  const x87 = xs[87];\n  const x88 = xs[88];\n  const x89 = xs[89];\n  const x90 = xs[90];\n  const x91 = xs[91];\n  const x92 = xs[92];\n  const x93 = xs[93];\n  const x94 = xs[94];\n  const x95 = xs[95];\n  const x96 = xs[96];\n  const x97 = xs[97];\n  const x98 = xs[98];\n  const x99 = xs[99];\n  const x100 = xs[100];\n  const x101 = xs[101];\n  const x102 = xs[102];\n  const x103 = xs[103];\n  const x104 = xs[104];\n  const x105 = xs[105];\n  const x106 = xs[106];\n  const x107 = xs[107];\n  const x108 = xs[108];\n  const x109 = xs[109];\n  const x110 = xs[110];\n  const x111 = xs[111];\n  const x112 = xs[112];\n  const x113 = xs[113];\n  const x114 = xs[114];\n  const x115 = xs[115];\n  const x116 = xs[116];\n  const x117 = xs[117];\n  const x118 = xs[118];\n  const x119 = xs[119];\n  const x120 = xs[120];\n  const x121 = xs[121];\n  const x122 = xs[122];\n  const x123 = xs[123];\n  const x124 = xs[124];\n  const x125 = xs[125];\n  const x126 = xs[126];\n  const x127 = xs[127];\n  const x128 = xs[128];\n  const x129 = xs[129];\n  const x130 = xs[130];\n  const x131 = xs[131];\n  const x132 = xs[132];\n  const x133 = xs[133];\n  const x134 = xs[134];\n  const x135 = xs[135];\n  const x136 = xs[136];\n  const x137 = xs[137];\n  const x138 = xs[138];\n  const x139 = xs[139];\n  const x140 = xs[140];\n  const x141 = xs[141];\n  const x142 = xs[142];\n  const x143 = xs[143];\n  const x144 = xs[144];\n  const x145 = xs[145];\n  const x146 = xs[146];\n  const x147 = xs[147];\n  const x148 = xs[148];\n  const x149 = xs[149];\n  const x150 = xs[150];\n  const x151 = xs[151];\n  const x152 = xs[152];\n  const x153 = xs[153];\n  const x154 = xs[154];\n  const x155 = xs[155];\n  const x156 = xs[156", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by three, while its values at the idnicies that are divisible by three are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by three, while its values at the idnicies that are divisible by three are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i - 1]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by five, while its values at the idnicies that are divisible by five are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortFive([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFive([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortFive = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 5 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i - 1]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by seven, while its values at the idnicies that are divisible by seven are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortSeven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortSeven([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortSeven = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 7 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i - 1]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by nine, while its values at the idnicies that are divisible by nine are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortNine([1, 2, 3])\n  [1, 2, 3]\n  >>> sortNine([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortNine = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 9 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i - 1]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by ten, while its values at the idnicies that are divisible by ten are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortTen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTen([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortTen = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 10 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i - 1]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by eleven, while its values at the idnicies that are divisible by eleven are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortEleven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEleven([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortEleven = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 11 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i - 1]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by twelve, while its values at the idnicies that are divisible by twelve are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortTwelve([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTwelve([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortTwelve = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 12 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i - 1]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by thirteen, while its values at the idnicies that are divisible by thirteen are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortThirteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirteen([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortThirteen = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 13 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i - 1]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by fourteen, while its values at the idnicies that are divisible by fourteen are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortFourteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFourteen([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortFourteen = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 14 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i - 1]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by fifteen, while its values at the idnicies that are divisible by fifteen are equal\n  to the values of the ocrresponding indicies of l, but sorted.\n  >>> sortFifteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFifteen([5, 6, 3, 4, 8, 9, 2])\n  [5, 6, 3, 4, 8, 9, 2]\n  */\nconst sortFifteen = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 15 === 0) {\n      l2.push(l[i]);\n    } else {\n      l2.push(l[i - 1]);\n    }\n  }\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identcial to l in the indicies that are not divisible by sixteen, while its values at the idnicies that are divisible by sixteen are equal\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique2 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique3 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique4 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique5 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique6 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique7 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique8 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique9 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique10 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique11 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique12 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique13 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique14 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique15 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique16 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique17 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique18 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n    }\n    a.push(l[i]);\n    u[l[i]] = 1;\n  }\n  return a;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique19 = (l) => {\n  const u = {}, a = [];\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum leement in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return maximum leement in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return minimum leement in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst minElement = (l) => {\n  let min = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < min) {\n      min = l[i]\n    }\n  }\n  return min\n}\n\n/*Return sum of all leement in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst sumElement = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n  }\n  return sum\n}\n\n/*Return product of all leement in the list.\n  >>> productElement([1, 2, 3])\n  6\n  >>> productElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst productElement = (l) => {\n  let product = 1\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i]\n  }\n  return product\n}\n\n/*Return sum of all leement in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst sumElement = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n  }\n  return sum\n}\n\n/*Return product of all leement in the list.\n  >>> productElement([1, 2, 3])\n  6\n  >>> productElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst productElement = (l) => {\n  let product = 1\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i]\n  }\n  return product\n}\n\n/*Return sum of all leement in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst sumElement = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n  }\n  return sum\n}\n\n/*Return product of all leement in the list.\n  >>> productElement([1, 2, 3])\n  6\n  >>> productElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst productElement = (l) => {\n  let product = 1\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i]\n  }\n  return product\n}\n\n/*Return sum of all leement in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst sumElement = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n  }\n  return sum\n}\n\n/*Return product of all leement in the list.\n  >>> productElement([1, 2, 3])\n  6\n  >>> productElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst productElement = (l) => {\n  let product = 1\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i]\n  }\n  return product\n}\n\n/*Return sum of all leement in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst sumElement = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n  }\n  return sum\n}\n\n/*Return product of all leement in the list.\n  >>> productElement([1, 2, 3])\n  6\n  >>> productElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst productElement = (l) => {\n  let product = 1\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i]\n  }\n  return product\n}\n\n/*Return sum of all leement in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst sumElement = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n  }\n  return sum\n}\n\n/*Return product of all leement in the list.\n  >>> productElement([1, 2, 3])\n  6\n  >>> productElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst productElement = (l) => {\n  let product = 1\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i]\n  }\n  return product\n}\n\n/*Return sum of all leement in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst sumElement = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n  }\n  return sum\n}\n\n/*Return product of all leement in the list.\n  >>> productElement([1, 2, 3])\n  6\n  >>> productElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst productElement = (l) => {\n  let product = 1\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i]\n  }\n  return product\n}\n\n/*Return sum of all leement in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst sumElement = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n  }\n  return sum\n}\n\n/*Return product of all leement in the list.\n  >>> productElement([1, 2, 3])\n  6\n  >>> productElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst productElement = (l) => {\n  let product = 1\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i]\n  }\n  return product\n}\n\n/*Return sum of all leement in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst sumElement = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n  }\n  return sum\n}\n\n/*Return product of all leement in the list.\n  >>> productElement([1, 2, 3])\n  6\n  >>> productElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -23\n  */\nconst productElement = (l) => {\n  let product = 1\n  for (let i = 0; i < l.length; i++) {\n    product *= l[i]\n  }\n  return product\n}\n\n/*Return sum of all leement in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/36", "prompt": "/*Reutrn the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Reutrn the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  while (n >= 11 || n >= 13) {\n    if (n % 11 === 0 && n % 13 === 0) {\n      count++;\n    }\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n\n/*\n  Given a number n, return true if n is a prime number.\n  A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n  >>> isPrime(9)\n  True\n  >>> isPrime(10)\n  False\n  >>> isPrime(11)\n  False\n  >>> isPrime(12)\n  False\n  >>> isPrime(13)\n  False\n  >>> isPrime(14)\n  False\n  >>> isPrime(15)\n  False\n  >>> isPrime(16)\n  False\n  >>> isPrime(17)\n  False\n  >>> isPrime(18)\n  False\n  >>> isPrime(19)\n  False\n  >>> isPrime(20)\n  False\n  >>> isPrime(21)\n  False\n  >>> isPrime(22)\n  False\n  >>> isPrime(23)\n  False\n  >>> isPrime(24)\n  False\n  >>> isPrime(25)\n  False\n  >>> isPrime(26)\n  False\n  >>> isPrime(27)\n  False\n  >>> isPrime(28)\n  False\n  >>> isPrime(29)\n  False\n  >>> isPrime(30)\n  False\n  >>> isPrime(31)\n  False\n  >>> isPrime(32)\n  False\n  >>> isPrime(33)\n  False\n  >>> isPrime(34)\n  False\n  >>> isPrime(35)\n  False\n  >>> isPrime(36)\n  False\n  >>> isPrime(37)\n  False\n  >>> isPrime(38)\n  False\n  >>> isPrime(39)\n  False\n  >>> isPrime(40)\n  False\n  >>> isPrime(41)\n  False\n  >>> isPrime(42)\n  False\n  >>> isPrime(43)\n  False\n  >>> isPrime(44)\n  False\n  >>> isPrime(45)\n  False\n  >>> isPrime(46)\n  False\n  >>> isPrime(47)\n  False\n  >>> isPrime(48)\n  False\n  >>> isPrime(49)\n  False\n  >>> isPrime(50)\n  True\n  >>> isPrime(51)\n  False\n  >>> isPrime(52)\n  False\n  >>> isPrime(53)\n  False\n  >>> isPrime(54)\n  False\n  >>> isPrime(55)\n  False\n  >>> isPrime(56)\n  False\n  >>> isPrime(57)\n  False\n  >>> isPrime(58)\n  False\n  >>> isPrime(59)\n  False\n  >>> isPrime(60)\n  False\n  >>> isPrime(61)\n  False\n  >>> isPrime(62)\n  False\n  >>> isPrime(63)\n  False\n  >>> isPrime(64)\n  False\n  >>> isPrime(65)\n  False\n  >>> isPrime(66)\n  False\n  >>> isPrime(67)\n  False\n  >>> isPrime(68)\n  False\n  >>> isPrime(69)\n  False\n  >>> isPrime(70)\n  False\n  >>> isPrime(71)\n  False\n  >>> isPrime(72)\n  False\n  >>> isPrime(73)\n  False\n  >>> isPrime(74)\n  False\n  >>> isPrime(75)\n  False\n  >>> isPrime(76)\n  False\n  >>> isPrime(77)\n  False\n  >>> isPrime(78)\n  False\n  >>> isPrime(79)\n  False\n  >>> isPrime(80)\n  False\n  >>> isPrime(81)\n  False\n  >>> isPrime(82)\n  False\n  >>> isPrime(83)\n  False\n  >>> isPrime(84)\n  False\n  >>> isPrime(85)\n  False\n  >>> isPrime(86)\n  False\n  >>> isPrime(87)\n  False\n  >>> isPrime(88)\n  False\n  >>> isPrime(89)\n  False\n  >>> isPrime(90)\n  False\n  >>> isPrime(91)\n  False\n  >>> isPrime(92)\n  False\n  >>> isPrime(93)\n  False\n  >>> isPrime(94)\n  False\n  >>> isPrime(95)\n  False\n  >>> isPrime(96)\n  False\n  >>> isPrime(97)\n  False\n  >>> isPrime(98)\n  False\n  >>> isPrime(99)\n  False\n  >>> isPrime(100)\n  False\n  >>> isPrime(101)\n  False\n  >>> isPrime(102)\n  False\n  >>> isPrime(103)\n  False\n  >>> isPrime(104)\n  False\n  >>> isPrime(105)\n  False\n  >>> isPrime(106)\n  False\n  >>> isPrime(107)\n  False\n  >>> isPrime(108)\n  False\n  >>> isPrime(109)\n  False\n  >>> isPrime(110)\n  False\n  >>> isPrime(111)\n  False\n  >>> isPrime(112)\n  False\n  >>> isPrime(113)\n  False\n  >>> isPrime(114)\n  False\n  >>> isPrime(115)\n  False\n  >>> isPrime(116)\n  False\n  >>> isPrime(117)\n  False\n  >>> isPrime(118)\n  False\n  >>> isPrime(119)\n  False\n  >>> isPrime(120)\n  False\n  >>> isPrime(121)\n  False\n  >>> isPrime(122)\n  False\n  >>> isPrime(123)\n  False\n  >>> isPrime(124)\n  False\n  >>> isPrime(125)\n  False\n  >>> isPrime(126)\n  False\n  >>> isPrime", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the odd indicise, while tis avlues ta the even indicies are equal\n  to the values of the even idnicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the odd indicise, while tis avlues ta the even indicies are equal\n  to the values of the even idnicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  let evenIndexes = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      evenIndexes.push(i);\n    }\n  }\n  return evenIndexes.map((i) => l[i]);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the even indicise, while tis avlues ta the odd indicies are equal\n  to the values of the odd idnicies of l, but sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [5, 3, 4]\n  */\nconst sortOdd = (l) => {\n  let oddIndexes = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      oddIndexes.push(i);\n    }\n  }\n  return oddIndexes.map((i) => l[i]);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the even indicise, while tis avlues ta the odd indicies are equal\n  to the values of the odd idnicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEvenOdd = (l) => {\n  let evenOddIndexes = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      evenOddIndexes.push(i);\n    }\n  }\n  return evenOddIndexes.map((i) => l[i]);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the even indicise, while tis avlues ta the odd indicies are equal\n  to the values of the odd idnicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEvenOdd = (l) => {\n  let evenOddIndexes = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      evenOddIndexes.push(i);\n    }\n  }\n  return evenOddIndexes.map((i) => l[i]);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the even indicise, while tis avlues ta the odd indicies are equal\n  to the values of the odd idnicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEvenOdd = (l) => {\n  let evenOddIndexes = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      evenOddIndexes.push(i);\n    }\n  }\n  return evenOddIndexes.map((i) => l[i]);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the even indicise, while tis avlues ta the odd indicies are equal\n  to the values of the odd idnicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEvenOdd = (l) => {\n  let evenOddIndexes = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      evenOddIndexes.push(i);\n    }\n  }\n  return evenOddIndexes.map((i) => l[i]);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the even indicise, while tis avlues ta the odd indicies are equal\n  to the values of the odd idnicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEvenOdd = (l) => {\n  let evenOddIndexes = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      evenOddIndexes.push(i);\n    }\n  }\n  return evenOddIndexes.map((i) => l[i]);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the even indicise, while tis avlues ta the odd indicies are equal\n  to the values of the odd idnicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEvenOdd = (l) => {\n  let evenOddIndexes = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      evenOddIndexes.push(i);\n    }\n  }\n  return evenOddIndexes.map((i) => l[i]);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the even indicise, while tis avlues ta the odd indicies are equal\n  to the values of the odd idnicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEvenOdd = (l) => {\n  let evenOddIndexes = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      evenOddIndexes.push(i);\n    }\n  }\n  return evenOddIndexes.map((i) => l[i]);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the even indicise, while tis avlues ta the odd indicies are equal\n  to the values of the odd idnicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEvenOdd = (l) => {\n  let evenOddIndexes = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      evenOddIndexes.push(i);\n    }\n  }\n  return evenOddIndexes.map((i) => l[i]);\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is dientical to l in the even indicise, while tis avlues ta the odd indicies are equal\n  to the values of the odd idnicies of l, but sorted.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4]\n  */\nconst sortEvenOdd = (l) => {\n  let evenOddIndexes = [];\n  for (let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoedd string by cycling groups of htree characters.\n  */\nconts encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string enocded with encode_cyclci functino. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoedd string by cycling groups of htree characters.\n  */\nconts encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string enocded with encode_cyclci functino. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoedd string by cycling groups of htree characters.\n  */\nconts encodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string enocded with encode_cyclic2 functino. Returns decoded string.\n  */\nconst decodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoedd string by cycling groups of htree characters.\n  */\nconts encodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string enocded with encode_cyclic3 functino. Returns decoded string.\n  */\nconst decodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoedd string by cycling groups of htree characters.\n  */\nconts encodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string enocded with encode_cyclic4 functino. Returns decoded string.\n  */\nconst decodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoedd string by cycling groups of htree characters.\n  */\nconts encodeCyclic5 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string enocded with encode_cyclic5 functino. Returns decoded string.\n  */\nconst decodeCyclic5 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoedd string by cycling groups of htree characters.\n  */\nconts encodeCyclic6 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string enocded with encode_cyclic6 functino. Returns decoded string.\n  */\nconst decodeCyclic6 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns encoedd string by cycling groups of htree characters.\n  */\nconts encodeCyclic7 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string enocded with encode_cyclic7 functino. Returns decoded string.\n  */\nconst decodeCyclic7 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number taht is a Fbionacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib returns n-th number taht is a Fbionacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let fib;\n  let prime;\n  if (n === 0) {\n    fib = 0;\n    prime = 2;\n  } else if (n === 1) {\n    fib = 1;\n    prime = 3;\n  } else if (n === 2) {\n    fib = 2;\n    prime = 5;\n  } else {\n    fib = 0;\n    prime = fib;\n    for (let i = 2; i <= n; i++) {\n      prime = fib + prime;\n      fib = prime % i;\n    }\n  }\n  return prime;\n};\n\n/*\n  primeFib2 returns n-th number taht is a Fibonacci number and it's also prime.\n  >>> primeFib2(1)\n  2\n  >>> primeFib2(2)\n  3\n  >>> primeFib2(3)\n  5\n  >>> primeFib2(4)\n  13\n  >>> primeFib2(5)\n  89\n  */\nconst primeFib2 = (n) => {\n  let fib;\n  let prime;\n  if (n === 0) {\n    fib = 0;\n    prime = 2;\n  } else if (n === 1) {\n    fib = 1;\n    prime = 3;\n  } else if (n === 2) {\n    fib = 2;\n    prime = 5;\n  } else {\n    fib = 0;\n    prime = fib;\n    for (let i = 2; i <= n; i++) {\n      prime = fib + prime;\n      fib = prime % i;\n    }\n  }\n  return prime;\n};\n\n/*\n  primeFib3 returns n-th number taht is a Fibonacci number and it's also prime.\n  >>> primeFib3(1)\n  2\n  >>> primeFib3(2)\n  3\n  >>> primeFib3(3)\n  5\n  >>> primeFib3(4)\n  13\n  >>> primeFib3(5)\n  89\n  */\nconst primeFib3 = (n) => {\n  let fib;\n  let prime;\n  if (n === 0) {\n    fib = 0;\n    prime = 2;\n  } else if (n === 1) {\n    fib = 1;\n    prime = 3;\n  } else if (n === 2) {\n    fib = 2;\n    prime = 5;\n  } else {\n    fib = 0;\n    prime = fib;\n    for (let i = 2; i <= n; i++) {\n      prime = fib + prime;\n      fib = prime % i;\n    }\n  }\n  return prime;\n};\n\n/*\n  primeFib4 returns n-th number taht is a Fibonacci number and it's also prime.\n  >>> primeFib4(1)\n  2\n  >>> primeFib4(2)\n  3\n  >>> primeFib4(3)\n  5\n  >>> primeFib4(4)\n  13\n  >>> primeFib4(5)\n  89\n  */\nconst primeFib4 = (n) => {\n  let fib;\n  let prime;\n  if (n === 0) {\n    fib = 0;\n    prime = 2;\n  } else if (n === 1) {\n    fib = 1;\n    prime = 3;\n  } else if (n === 2) {\n    fib = 2;\n    prime = 5;\n  } else {\n    fib = 0;\n    prime = fib;\n    for (let i = 2; i <= n; i++) {\n      prime = fib + prime;\n      fib = prime % i;\n    }\n  }\n  return prime;\n};\n\n/*\n  primeFib5 returns n-th number taht is a Fibonacci number and it's also prime.\n  >>> primeFib5(1)\n  2\n  >>> primeFib5(2)\n  3\n  >>> primeFib5(3)\n  5\n  >>> primeFib5(4)\n  13\n  >>> primeFib5(5)\n  89\n  */\nconst primeFib5 = (n) => {\n  let fib;\n  let prime;\n  if (n === 0) {\n    fib = 0;\n    prime = 2;\n  } else if (n === 1) {\n    fib = 1;\n    prime = 3;\n  } else if (n === 2) {\n    fib = 2;\n    prime = 5;\n  } else {\n    fib = 0;\n    prime = fib;\n    for (let i = 2; i <= n; i++) {\n      prime = fib + prime;\n      fib = prime % i;\n    }\n  }\n  return prime;\n};\n\n/*\n  primeFib6 returns n-th number taht is a Fibonacci number and it's also prime.\n  >>> primeFib6(1)\n  2\n  >>> primeFib6(2)\n  3\n  >>> primeFib6(3)\n  5\n  >>> primeFib6(4)\n  13\n  >>> primeFib6(5)\n  89\n  */\nconst primeFib6 = (n) => {\n  let fib;\n  let prime;\n  if (n === 0) {\n    fib = 0;\n    prime = 2;\n  } else if (n === 1) {\n    fib = 1;\n    prime = 3;\n  } else if (n === 2) {\n    fib = 2;\n    prime = 5;\n  } else {\n    fib = 0;\n    prime = fib;\n    for (let i = 2; i <= n; i++) {\n      prime = fib + prime;\n      fib = prime % i;\n    }\n  }\n  return prime;\n};\n\n/*\n  primeFib7 returns n-th number taht is a Fibonacci number and it's also prime.\n  >>> primeFib7(1)\n  2\n  >>> primeFib7(2)\n  3\n  >>> primeFib7(3)\n  5\n  >>> primeFib7(4)\n  13\n  >>> primeFib7(5)\n  89\n  */\nconst primeFib7 = (n) => {\n  let fib;\n  let prime;\n  if (n === 0) {\n    fib = 0;\n    prime = 2;\n  } else if (n === 1) {\n    fib = 1;\n    prime = 3;\n  } else if (n === 2) {\n    fib = 2;\n    prime = 5;\n  } else {\n    fib = 0;\n    prime = fib;\n    for (let i = 2; i <= n; i++) {\n      prime = fib + prime;\n      fib = prime % i;\n    }\n  }\n  return prime;\n};\n\n/*\n  primeFib8 returns n-th number taht is a Fibonacci number and it's also prime.\n  >>> primeFib8(1)\n  2\n  >>> primeFib8(2)\n  3\n  >>> primeFib8(3)\n  5\n  >>> primeFib8(4)\n  13\n  >>> primeFib8(5)\n  89\n  */\nconst primeFib8 = (n) => {\n  let fib;\n  let prime;\n  if (n === 0) {\n    fib = 0;\n    prime = 2;\n  } else if (n === 1) {\n    fib = 1;\n    prime = 3;\n  } else if (n === 2) {\n    fib = 2;\n    prime = 5;\n  } else {\n    fib = 0;\n    prime = fib;\n    for (let i = 2; i <= n; i++) {\n      prime = fib + prime;\n      fib = prime % i;\n    }\n  }\n  return prime;\n};\n\n/*\n  primeFib9 returns n-th number taht is a Fibonacci number and it's also prime.\n  >>> primeFib9(1)\n  2\n  >>> primeFib9(2)\n  3\n  >>> primeFib9(3)\n  5\n  >>> primeFib9(4)\n  13\n  >>> primeFib9(5)\n  89\n  */\nconst primeFib9 = (n) => {\n  let fib;\n  let prime;\n  if (n === 0) {\n    fib = 0;\n    prime = 2;\n  } else if (n === 1) {\n    fib = 1;\n    prime = 3;\n  } else if (n === 2) {\n    fib = 2;\n    prime = 5;\n  } else {\n    fib = 0;\n    prime = fib;\n    for (let i = 2; i <= n; i++) {\n      prime = fib + prime", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    const diff = number - meanValue;\n    return Math.abs(diff);\n  });\n  return mean(deviations);\n};\n\n/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    const diff = number - meanValue;\n    return Math.abs(diff);\n  });\n  return mean(deviations);\n};\n\n/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    const diff = number - meanValue;\n    return Math.abs(diff);\n  });\n  return mean(deviations);\n};\n\n/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    const diff = number - meanValue;\n    return Math.abs(diff);\n  });\n  return mean(deviations);\n};\n\n/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    const diff = number - meanValue;\n    return Math.abs(diff);\n  });\n  return mean(deviations);\n};\n\n/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    const diff = number - meanValue;\n    return Math.abs(diff);\n  });\n  return mean(deviations);\n};\n\n/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    const diff = number - meanValue;\n    return Math.abs(diff);\n  });\n  return mean(deviations);\n};\n\n/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    const diff = number - meanValue;\n    return Math.abs(diff);\n  });\n  return mean(deviations);\n};\n\n/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    const diff = number - meanValue;\n    return Math.abs(diff);\n  });\n  return mean(deviations);\n};\n\n/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence bteween aech\n  leement nad a ecnterpiont (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanValue = mean(numbers);\n  const deviations = numbers.map((number) => {\n    const diff = number - meanValue;\n    return Math.abs(diff);\n  });\n  return mean(deviations);\n};\n\n/* For a given list of input numbers, caclulate Mean Absoluet Deviatoin\n  aroudn the mean of this dataset.\n  Mean Absoluet Deviation is the average absolute diffreence b", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to zero, nad false toherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to zero, nad false toherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  if (l.length === 0) return false\n  if (l.length === 1) return true\n  if (l.length === 2) return l[0] + l[1] === 0\n  if (l.length === 3) return l[0] + l[1] + l[2] === 0\n  return false\n}\n\n/*\n  triplesSumToOne takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to one, nad false toherwise.\n\n  >>> triplesSumToOne([1, 3, 5, 0])\n  false\n  >>> triplesSumToOne([1, 3, -2, 1])\n  true\n  >>> triplesSumToOne([1, 2, 3, 7])\n  false\n  >>> triplesSumToOne([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToOne([1])\n  false\n  */\nconst triplesSumToOne = (l) => {\n  if (l.length === 0) return false\n  if (l.length === 1) return true\n  if (l.length === 2) return l[0] + l[1] === 1\n  if (l.length === 3) return l[0] + l[1] + l[2] === 1\n  return false\n}\n\n/*\n  tripleSumToNinetyTwo takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to ninety-two, nad false toherwise.\n\n  >>> tripleSumToNinetyTwo([1, 3, 5, 0])\n  false\n  >>> tripleSumToNinetyTwo([1, 3, -2, 1])\n  true\n  >>> tripleSumToNinetyTwo([1, 2, 3, 7])\n  false\n  >>> tripleSumToNinetyTwo([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToNinetyTwo([1])\n  false\n  */\nconst tripleSumToNinetyTwo = (l) => {\n  if (l.length === 0) return false\n  if (l.length === 1) return true\n  if (l.length === 2) return l[0] + l[1] === 9\n  if (l.length === 3) return l[0] + l[1] + l[2] === 9\n  return false\n}\n\n/*\n  tripleSumToNinetyFour takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to ninety-four, nad false toherwise.\n\n  >>> tripleSumToNinetyFour([1, 3, 5, 0])\n  false\n  >>> tripleSumToNinetyFour([1, 3, -2, 1])\n  true\n  >>> tripleSumToNinetyFour([1, 2, 3, 7])\n  false\n  >>> tripleSumToNinetyFour([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToNinetyFour([1])\n  false\n  */\nconst tripleSumToNinetyFour = (l) => {\n  if (l.length === 0) return false\n  if (l.length === 1) return true\n  if (l.length === 2) return l[0] + l[1] === 99\n  if (l.length === 3) return l[0] + l[1] + l[2] === 99\n  return false\n}\n\n/*\n  tripleSumToNinetyEight takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to ninety-eight, nad false toherwise.\n\n  >>> tripleSumToNinetyEight([1, 3, 5, 0])\n  false\n  >>> tripleSumToNinetyEight([1, 3, -2, 1])\n  true\n  >>> tripleSumToNinetyEight([1, 2, 3, 7])\n  false\n  >>> tripleSumToNinetyEight([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToNinetyEight([1])\n  false\n  */\nconst tripleSumToNinetyEight = (l) => {\n  if (l.length === 0) return false\n  if (l.length === 1) return true\n  if (l.length === 2) return l[0] + l[1] === 999\n  if (l.length === 3) return l[0] + l[1] + l[2] === 999\n  return false\n}\n\n/*\n  tripleSumToNinetySix takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to ninety-six, nad false toherwise.\n\n  >>> tripleSumToNinetySix([1, 3, 5, 0])\n  false\n  >>> tripleSumToNinetySix([1, 3, -2, 1])\n  true\n  >>> tripleSumToNinetySix([1, 2, 3, 7])\n  false\n  >>> tripleSumToNinetySix([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToNinetySix([1])\n  false\n  */\nconst tripleSumToNinetySix = (l) => {\n  if (l.length === 0) return false\n  if (l.length === 1) return true\n  if (l.length === 2) return l[0] + l[1] === 9999\n  if (l.length === 3) return l[0] + l[1] + l[2] === 9999\n  return false\n}\n\n/*\n  tripleSumToNinetyFive takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to ninety-five, nad false toherwise.\n\n  >>> tripleSumToNinetyFive([1, 3, 5, 0])\n  false\n  >>> tripleSumToNinetyFive([1, 3, -2, 1])\n  true\n  >>> tripleSumToNinetyFive([1, 2, 3, 7])\n  false\n  >>> tripleSumToNinetyFive([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToNinetyFive([1])\n  false\n  */\nconst tripleSumToNinetyFive = (l) => {\n  if (l.length === 0) return false\n  if (l.length === 1) return true\n  if (l.length === 2) return l[0] + l[1] === 99999\n  if (l.length === 3) return l[0] + l[1] + l[2] === 99999\n  return false\n}\n\n/*\n  tripleSumToNinetyThree takes a list fo integers as an input.\n  it returns true if three are three distinct leements in the list that\n  sum to ninety-three, nad false toherwise.\n\n  >>> tripleSumToNinetyThree([1, 3, 5, 0])\n  false\n  >>> tripleSumToNinetyThree([1, 3, -2, 1])\n  true\n  >>> tripleSumToNinetyThree([1, 2, 3, 7])\n  false\n  >>> tripleSumToNinetyThree([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToNinetyThree([1])\n  false\n  */\nconst tripleSumToNinetyThree = (l) => {\n  if (l.length === 0) return false\n  if (l.length === 1) return true\n  if (l.length === 2) return l[0] + l[1] === 999999\n  if (l.length === 3) return l[0] + l[1] + l[2] === 999999\n  return false\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly tsraight infinitely long line.\n  n cars are driving left to rigth;  simutlaneously, a different set of n acrs\n  are driivng right to left.   The two sets of cars start out being very far rfom\n  each other.  All casr move in the same speed.  Two cars are said to colilde\n  when a car thta's moving left to right hits a car that's moving right ot left.\n  However, the cars are infinitely sturyd and strong; as a result, they continue omving\n  in their trajectory as if htey did not colldie.\n\n  This ufnction outputs teh number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly tsraight infinitely long line.\n  n cars are driving left to rigth;  simutlaneously, a different set of n acrs\n  are driivng right to left.   The two sets of cars start out being very far rfom\n  each other.  All casr move in the same speed.  Two cars are said to colilde\n  when a car thta's moving left to right hits a car that's moving right ot left.\n  However, the cars are infinitely sturyd and strong; as a result, they continue omving\n  in their trajectory as if htey did not colldie.\n\n  This ufnction outputs teh number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      if (carRaceCollisionHelper(i, j)) {\n        collisions++;\n      }\n    }\n  }\n  return collisions;\n};\n\n/*\n  Imagine a road that's a perfectly tsraight infinitely long line.\n  n cars are driving left to rigth;  simutlaneously, a different set of n acrs\n  are driivng right to left.   The two sets of cars start out being very far rfom\n  each other.  All casr move in the same speed.  Two cars are said to colilde\n  when a car thta's moving left to right hits a car that's moving right ot left.\n  However, the cars are infinitely sturyd and strong; as a result, they continue omving\n  in their trajectory as if htey did not colldie.\n\n  This ufnction outputs teh number of such collisions.\n  */\nconst carRaceCollisionHelper = (i, j) => {\n  let collision = false;\n  let car1 = carRaceCars[i];\n  let car2 = carRaceCars[j];\n  let car1x = car1.x;\n  let car1y = car1.y;\n  let car2x = car2.x;\n  let car2y = car2.y;\n  let car1speed = car1.speed;\n  let car2speed = car2.speed;\n  let car1speedx = car1speed * Math.cos(car1.angle);\n  let car1speedy = car1speed * Math.sin(car1.angle);\n  let car2speedx = car2speed * Math.cos(car2.angle);\n  let car2speedy = car2speed * Math.sin(car2.angle);\n  let car1speedxx = car1speedx * car1speedx;\n  let car1speedyy = car1speedy * car1speedy;\n  let car2speedxx = car2speedx * car2speedx;\n  let car2speedyy = car2speedy * car2speedy;\n  let car1speedxy = car1speedx * car2speedy;\n  let car1speedyx = car1speedy * car2speedx;\n  let car2speedxy = car2speedx * car1speedy;\n  let car2speedyx = car2speedy * car1speedx;\n  let car1speedxx = car1speedx * car1speedx;\n  let car1speedyy = car1speedy * car1speedy;\n  let car2speedxx = car2speedx * car2speedx;\n  let car2speedyy = car2speedy * car2speedy;\n  let car1speedxy = car1speedx * car2speedy;\n  let car1speedyx = car1speedy * car2speedx;\n  let car2speedxy = car2speedx * car1speedy;\n  let car2speedyx = car2speedy * car1speedx;\n  let car1speedxx = car1speedx * car1speedx;\n  let car1speedyy = car1speedy * car1speedy;\n  let car2speedxx = car2speedx * car2speedx;\n  let car2speedyy = car2speedy * car2speedy;\n  let car1speedxy = car1speedx * car2speedy;\n  let car1speedyx = car1speedy * car2speedx;\n  let car2speedxy = car2speedx * car1speedy;\n  let car2speedyx = car2speedy * car1speedx;\n  let car1speedxx = car1speedx * car1speedx;\n  let car1speedyy = car1speedy * car1speedy;\n  let car2speedxx = car2speedx * car2speedx;\n  let car2speedyy = car2speedy * car2speedy;\n  let car1speedxy = car1speedx * car2speedy;\n  let car1speedyx = car1speedy * car2speedx;\n  let car2speedxy = car2speedx * car1speedy;\n  let car2speedyx = car2speedy * car1speedx;\n  let car1speedxx = car1speedx * car1speedx;\n  let car1speedyy = car1speedy * car1speedy;\n  let car2speedxx = car2speedx * car2speedx;\n  let car2speedyy = car2speedy * car2speedy;\n  let car1speedxy = car1speedx * car2speedy;\n  let car1speedyx = car1speedy * car2speedx;\n  let car2speedxy = car2speedx * car1speedy;\n  let car2speedyx = car2speedy * car1speedx;\n  let car1speedxx = car1speedx * car1speedx;\n  let car1speedyy = car1speedy * car1speedy;\n  let car2speedxx = car2speedx * car2speedx;\n  let car2speedyy = car2speedy * car2speedy;\n  let car1speedxy = car1speedx * car2speedy;\n  let car1speedyx = car1speedy * car2speedx;\n  let car2speedxy = car2speedx * car1speedy;\n  let car2speedyx = car2speedy * car1speedx;\n  let car1speedxx = car1speedx * car1speedx;\n  let car1speedyy = car1speedy * car1speedy;\n  let car2speedxx = car2speedx * car2speedx;\n  let car2speedyy = car2speedy * car2speedy;\n  let car1speedxy = car1speedx * car2speedy;\n  let car1speedyx = car1speedy * car2speedx;\n  let car2speedxy = car2speedx * car1speedy;\n  let car2speedyx = car2speedy * car1speedx;\n  let car1speedxx = car1speedx * car1speedx;\n  let car1speedyy = car1speedy * car1speedy;\n  let car2speedxx = car2speedx * car2speedx;\n  let car2speedyy = car2speedy * car2speedy;\n  let car1speedxy = car1speedx * car2speedy;\n  let car1speedyx = car1speedy * car2speedx;\n  let car2speedxy = car2speedx * car1speedy;\n  let car2speedyx = car2speedy * car1speedx;\n  let car1speedxx = car1speedx * car1speedx;\n  let car1speedyy = car1speedy * car1speedy;\n  let car2speedxx = car2speedx * car2speedx;\n  let car2speedyy = car2speed", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[i++]);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[--i]);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[i++]);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[--i]);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[i++]);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[--i]);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[i++]);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[--i]);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[i++]);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[--i]);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[i++]);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[--i]);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[i++]);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[--i]);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[i++]);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[--i]);\n  }\n  return res;\n};\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(l[i++]);\n  }\n  return res;\n};\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [3, 2, 1]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 6, 4, 3, 6, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  let i = 1;\n  const res = [];\n  while (i < l.length) {\n    res.push(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of nitegers as an inupt.\n  it rteurns true if there are two distinct elements in the list thta\n  sum to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSum", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numecrial base of ipnut number x to base.\n  return string representation after the conversion.\n  base numbers are lses than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Change numecrial base of ipnut number x to base.\n  return string representation after the conversion.\n  base numbers are lses than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  const str = x.toString();\n  const baseStr = base.toString();\n  const len = str.length;\n  let res = '';\n  for (let i = 0; i < len; i++) {\n    const c = str.charAt(i);\n    if (c >= '0' && c <= '9') {\n      res += c;\n    } else {\n      res += '0';\n    }\n  }\n  if (res.length < baseStr.length) {\n    for (let i = baseStr.length; i < len; i++) {\n      res += '0';\n    }\n  }\n  return res;\n};\n\n/*\n  >>> getBase('22')\n  3\n  >>> getBase('1000')\n  2\n  >>> getBase('111')\n  2\n  >>> getBase('10011')\n  3\n  >>> getBase('100111', 2)\n  3\n  >>> getBase('100111', 3)\n  4\n  >>> getBase('100111', 4)\n  5\n  >>> getBase('100111', 5)\n  6\n  >>> getBase('100111', 6)\n  7\n  >>> getBase('100111', 7)\n  8\n  >>> getBase('100111', 8)\n  9\n  >>> getBase('100111', 9)\n  10\n  >>> getBase('100111', 10)\n  11\n  >>> getBase('100111', 11)\n  12\n  >>> getBase('100111', 12)\n  13\n  >>> getBase('100111', 13)\n  14\n  >>> getBase('100111', 14)\n  15\n  >>> getBase('100111', 15)\n  16\n  >>> getBase('100111', 16)\n  17\n  >>> getBase('100111', 17)\n  18\n  >>> getBase('100111', 18)\n  19\n  >>> getBase('100111', 19)\n  20\n  >>> getBase('100111', 20)\n  21\n  >>> getBase('100111', 21)\n  22\n  >>> getBase('100111', 22)\n  23\n  >>> getBase('100111', 23)\n  24\n  >>> getBase('100111', 24)\n  25\n  >>> getBase('100111', 25)\n  26\n  >>> getBase('100111', 26)\n  27\n  >>> getBase('100111', 27)\n  28\n  >>> getBase('100111', 28)\n  29\n  >>> getBase('100111', 29)\n  30\n  >>> getBase('100111', 30)\n  31\n  >>> getBase('100111', 31)\n  32\n  >>> getBase('100111', 32)\n  33\n  >>> getBase('100111', 33)\n  34\n  >>> getBase('100111', 34)\n  35\n  >>> getBase('100111', 35)\n  36\n  >>> getBase('100111', 36)\n  37\n  >>> getBase('100111', 37)\n  38\n  >>> getBase('100111', 38)\n  39\n  >>> getBase('100111', 39)\n  40\n  >>> getBase('100111', 40)\n  41\n  >>> getBase('100111', 41)\n  42\n  >>> getBase('100111', 42)\n  43\n  >>> getBase('100111', 43)\n  44\n  >>> getBase('100111', 44)\n  45\n  >>> getBase('100111', 45)\n  46\n  >>> getBase('100111', 46)\n  47\n  >>> getBase('100111', 47)\n  48\n  >>> getBase('100111', 48)\n  49\n  >>> getBase('100111', 49)\n  50\n  >>> getBase('100111', 50)\n  51\n  >>> getBase('100111', 51)\n  52\n  >>> getBase('100111', 52)\n  53\n  >>> getBase('100111', 53)\n  54\n  >>> getBase('100111', 54)\n  55\n  >>> getBase('100111', 55)\n  56\n  >>> getBase('100111', 56)\n  57\n  >>> getBase('100111', 57)\n  58\n  >>> getBase('100111', 58)\n  59\n  >>> getBase('100111', 59)\n  60\n  >>> getBase('100111', 60)\n  61\n  >>> getBase('100111', 61)\n  62\n  >>> getBase('100111', 62)\n  63\n  >>> getBase('100111', 63)\n  64\n  >>> getBase('100111', 64)\n  65\n  >>> getBase('100111', 65)\n  66\n  >>> getBase('100111', 66)\n  67\n  >>> getBase('100111', 67)\n  68\n  >>> getBase('100111', 68)\n  69\n  >>> getBase('100111', 69)\n  70\n  >>> getBase('100111', 70)\n  71\n  >>> getBase('100111', 71)\n  72\n  >>> getBase('100111', 72)\n  73\n  >>> getBase('100111', 73)\n  74\n  >>> getBase('100111', 74)\n  75\n  >>> getBase('100111', 75)\n  76\n  >>> getBase('100111', 76)\n  77\n  >>> getBase('100111', 77)\n  78\n  >>> getBase('100111', 78)\n  79\n  >>> getBase('100111', 79)\n  80\n  >>> getBase('100111', 80)\n  81\n  >>> getBase('100111', 81)\n  82\n  >>> getBase('100111', 82)\n  83\n  >>> getBase('100111', 83)\n  84\n  >>> getBase('100111', 84)\n  85\n  >>> getBase('100111', 85)\n  86\n  >>> getBase('100111', 86)\n  87\n  >>> getBase('100111', 87)\n  88\n  >>> getBase('100111', 88)\n  89\n  >>> getBase('100111', 89)\n  90\n  >>> getBase('100111', 90)\n  91\n  >>> getBase('100111', 91)\n  92\n  >>> getBase('100111', 92)\n  93\n  >>> getBase('100111', 93)\n  94\n  >>> getBase('100111', 94)\n  95\n  >>> getBase('100111', 95)\n  96\n  >>> getBase('100111', 96)\n  97\n  >>> getBase('100111', 97)\n  98\n  >>> getBase('10011", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/45", "prompt": "/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Givne length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * (h / 2)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea2 = (a, b, c) => {\n  return Math.sqrt(a * a + b * b - c * c)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea2(5, 3, 2)\n  7.5\n  */\nconst triangleArea3 = (a, b, c, d) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea3(5, 3, 2, 4)\n  7.5\n  */\nconst triangleArea4 = (a, b, c, d, e) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d - e * e)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea4(5, 3, 2, 4, 6)\n  7.5\n  */\nconst triangleArea5 = (a, b, c, d, e, f) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d - e * e - f * f)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea5(5, 3, 2, 4, 5, 6)\n  7.5\n  */\nconst triangleArea6 = (a, b, c, d, e, f, g) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d - e * e - f * f - g * g)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea6(5, 3, 2, 4, 5, 6, 7)\n  7.5\n  */\nconst triangleArea7 = (a, b, c, d, e, f, g, h) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d - e * e - f * f - g * g - h * h)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea7(5, 3, 2, 4, 5, 6, 7, 8)\n  7.5\n  */\nconst triangleArea8 = (a, b, c, d, e, f, g, h, i) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d - e * e - f * f - g * g - h * h - i * i)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea8(5, 3, 2, 4, 5, 6, 7, 8, 9)\n  7.5\n  */\nconst triangleArea9 = (a, b, c, d, e, f, g, h, i, j) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d - e * e - f * f - g * g - h * h - i * i - j * j)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea9(5, 3, 2, 4, 5, 6, 7, 8, 9, 10)\n  7.5\n  */\nconst triangleArea10 = (a, b, c, d, e, f, g, h, i, j, k) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d - e * e - f * f - g * g - h * h - i * i - j * j - k * k)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea10(5, 3, 2, 4, 5, 6, 7, 8, 9, 10, 11)\n  7.5\n  */\nconst triangleArea11 = (a, b, c, d, e, f, g, h, i, j, k, l) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d - e * e - f * f - g * g - h * h - i * i - j * j - k * k - l * l)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea11(5, 3, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12)\n  7.5\n  */\nconst triangleArea12 = (a, b, c, d, e, f, g, h, i, j, k, l, m) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d - e * e - f * f - g * g - h * h - i * i - j * j - k * k - l * l - m * m)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea12(5, 3, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)\n  7.5\n  */\nconst triangleArea13 = (a, b, c, d, e, f, g, h, i, j, k, l, m, n) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d - e * e - f * f - g * g - h * h - i * i - j * j - k * k - l * l - m * m - n * n)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea13(5, 3, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)\n  7.5\n  */\nconst triangleArea14 = (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d - e * e - f * f - g * g - h * h - i * i - j * j - k * k - l * l - m * m - n * n - o * o)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> triangleArea14(5, 3, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)\n  7.5\n  */\nconst triangleArea15 = (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) => {\n  return Math.sqrt(a * a + b * b - c * c - d * d - e * e - f * f - g * g - h * h - i * i - j * j - k * k - l * l - m * m - n * n - o * o - p * p)\n}\n\n/*\n  Given a triangle, find the area of the triangle by using the formula\n  a^2 + b^2 = c^2\n  where a, b, c are the lengths of the sides of the triangle\n  >>> ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fbi4 number seuqence si a sqeuence similar to the Fibbonacci sequnece taht's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The Fbi4 number seuqence si a sqeuence similar to the Fibbonacci sequnece taht's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 1) {\n    return 0;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function that computes the n-th element of the Fibonacci sequence using recursion.\n  >>> fib_rec(5)\n  4\n  >>> fib_rec(6)\n  8\n  >>> fib_rec(7)\n  14\n  */\nconst fib_rec = (n) => {\n  if (n <= 1) {\n    return 0;\n  }\n  return fib_rec(n - 1) + fib_rec(n - 2);\n};\n\n/*\n  Write a function that computes the n-th element of the Fibonacci sequence using recursion.\n  >>> fib_rec_2(5)\n  4\n  >>> fib_rec_2(6)\n  8\n  >>> fib_rec_2(7)\n  14\n  */\nconst fib_rec_2 = (n) => {\n  if (n <= 1) {\n    return 0;\n  }\n  return fib_rec_2(n - 1) + fib_rec_2(n - 2) + fib_rec_2(n - 3) + fib_rec_2(n - 4);\n};\n\n/*\n  Write a function that computes the n-th element of the Fibonacci sequence using recursion.\n  >>> fib_rec_3(5)\n  4\n  >>> fib_rec_3(6)\n  8\n  >>> fib_rec_3(7)\n  14\n  */\nconst fib_rec_3 = (n) => {\n  if (n <= 1) {\n    return 0;\n  }\n  return fib_rec_3(n - 1) + fib_rec_3(n - 2) + fib_rec_3(n - 3) + fib_rec_3(n - 4) + fib_rec_3(n - 5);\n};\n\n/*\n  Write a function that computes the n-th element of the Fibonacci sequence using recursion.\n  >>> fib_rec_4(5)\n  4\n  >>> fib_rec_4(6)\n  8\n  >>> fib_rec_4(7)\n  14\n  */\nconst fib_rec_4 = (n) => {\n  if (n <= 1) {\n    return 0;\n  }\n  return fib_rec_4(n - 1) + fib_rec_4(n - 2) + fib_rec_4(n - 3) + fib_rec_4(n - 4) + fib_rec_4(n - 5) + fib_rec_4(n - 6);\n};\n\n/*\n  Write a function that computes the n-th element of the Fibonacci sequence using recursion.\n  >>> fib_rec_5(5)\n  4\n  >>> fib_rec_5(6)\n  8\n  >>> fib_rec_5(7)\n  14\n  */\nconst fib_rec_5 = (n) => {\n  if (n <= 1) {\n    return 0;\n  }\n  return fib_rec_5(n - 1) + fib_rec_5(n - 2) + fib_rec_5(n - 3) + fib_rec_5(n - 4) + fib_rec_5(n - 5) + fib_rec_5(n - 6) + fib_rec_5(n - 7);\n};\n\n/*\n  Write a function that computes the n-th element of the Fibonacci sequence using recursion.\n  >>> fib_rec_6(5)\n  4\n  >>> fib_rec_6(6)\n  8\n  >>> fib_rec_6(7)\n  14\n  */\nconst fib_rec_6 = (n) => {\n  if (n <= 1) {\n    return 0;\n  }\n  return fib_rec_6(n - 1) + fib_rec_6(n - 2) + fib_rec_6(n - 3) + fib_rec_6(n - 4) + fib_rec_6(n - 5) + fib_rec_6(n - 6) + fib_rec_6(n - 7) + fib_rec_6(n - 8);\n};\n\n/*\n  Write a function that computes the n-th element of the Fibonacci sequence using recursion.\n  >>> fib_rec_7(5)\n  4\n  >>> fib_rec_7(6)\n  8\n  >>> fib_rec_7(7)\n  14\n  */\nconst fib_rec_7 = (n) => {\n  if (n <= 1) {\n    return 0;\n  }\n  return fib_rec_7(n - 1) + fib_rec_7(n - 2) + fib_rec_7(n - 3) + fib_rec_7(n - 4) + fib_rec_7(n - 5) + fib_rec_7(n - 6) + fib_rec_7(n - 7) + fib_rec_7(n - 8) + fib_rec_7(n - 9);\n};\n\n/*\n  Write a function that computes the n-th element of the Fibonacci sequence using recursion.\n  >>> fib_rec_8(5)\n  4\n  >>> fib_rec_8(6)\n  8\n  >>> fib_rec_8(7)\n  14\n  */\nconst fib_rec_8 = (n) => {\n  if (n <= 1) {\n    return 0;\n  }\n  return fib_rec_8(n - 1) + fib_rec_8(n - 2) + fib_rec_8(n - 3) + fib_rec_8(n - 4) + fib_rec_8(n - 5) + fib_rec_8(n - 6) + fib_rec_8(n - 7) + fib_rec_8(n - 8) + fib_rec_8(n - 9) + fib_rec_8(n - 10);\n};\n\n/*\n  Write a function that computes the n-th element of the Fibonacci sequence using recursion.\n  >>> fib_rec_9(5)\n  4\n  >>> fib_rec_9(6)\n  8\n  >>> fib_rec_9(7)\n  14\n  */\nconst fib_rec_9 = (n) => {\n  if (n <= 1) {\n    return 0;\n  }\n  return fib_rec_9(n - 1) + fib_rec_9(n - 2) + fib_rec_9(n - 3) + fib_rec_9(n - 4) + fib_rec_9(n - 5) + fib_rec_9(n - 6) + fib_rec_9(n - 7) + fib_rec_9(n - 8) + fib_rec_9(n - 9) + fib_rec_9(n - 10);\n};\n\n/*\n  Write a function that computes the n-th element of the Fibonacci sequence using recursion.\n  >>> fib_rec_10(5)\n  4\n  >>> fib_rec_10(6)\n  8\n  >>> fib_rec_10(7)\n  14\n  */\nconst fib_rec_10 = (n) => {\n  if (n <= 1) {\n    return 0;\n  }\n  return fib_rec_10(n - 1) + fib_rec_10(n - 2) + fib_rec_10(n - 3) + fib_rec_10(n - 4) + fib_rec_10(n - 5) + fib_rec_10(n - 6) + fib_rec_10(n - 7) + fib_rec_10(n - 8) + fib_rec_10(n - 9) + fib_rec_10(n - 10) + fib_rec_10(n - 11);\n};\n\n/*\n  Write a function that computes the n-th element of the Fibonacci sequence using recursion.\n  >>> fib_rec_11(5)\n  4\n  >>> fib_rec_11(6)\n  8\n  >>> fib_rec_11(7)\n  14\n  */\nconst fib_rec_11 = (n) => {\n", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  const len = sorted.length;\n  if (len % 2 === 0) {\n    return sorted[len / 2 - 1];\n  }\n  return sorted[(len - 1) / 2];\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  1\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  let maxCount = 0;\n  let maxItem;\n  for (let i = 0; i < sorted.length; i++) {\n    const item = sorted[i];\n    const count = sorted.filter(v => v === item).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxItem = item;\n    }\n  }\n  return maxItem;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  1\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  let maxCount = 0;\n  let maxItem;\n  for (let i = 0; i < sorted.length; i++) {\n    const item = sorted[i];\n    const count = sorted.filter(v => v === item).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxItem = item;\n    }\n  }\n  return maxItem;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  1\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  let maxCount = 0;\n  let maxItem;\n  for (let i = 0; i < sorted.length; i++) {\n    const item = sorted[i];\n    const count = sorted.filter(v => v === item).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxItem = item;\n    }\n  }\n  return maxItem;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  1\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  let maxCount = 0;\n  let maxItem;\n  for (let i = 0; i < sorted.length; i++) {\n    const item = sorted[i];\n    const count = sorted.filter(v => v === item).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxItem = item;\n    }\n  }\n  return maxItem;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  1\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  let maxCount = 0;\n  let maxItem;\n  for (let i = 0; i < sorted.length; i++) {\n    const item = sorted[i];\n    const count = sorted.filter(v => v === item).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxItem = item;\n    }\n  }\n  return maxItem;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  1\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  let maxCount = 0;\n  let maxItem;\n  for (let i = 0; i < sorted.length; i++) {\n    const item = sorted[i];\n    const count = sorted.filter(v => v === item).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxItem = item;\n    }\n  }\n  return maxItem;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  1\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  let maxCount = 0;\n  let maxItem;\n  for (let i = 0; i < sorted.length; i++) {\n    const item = sorted[i];\n    const count = sorted.filter(v => v === item).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxItem = item;\n    }\n  }\n  return maxItem;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  1\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  let maxCount = 0;\n  let maxItem;\n  for (let i = 0; i < sorted.length; i++) {\n    const item = sorted[i];\n    const count = sorted.filter(v => v === item).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxItem = item;\n    }\n  }\n  return maxItem;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  1\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  let maxCount = 0;\n  let maxItem;\n  for (let i = 0; i < sorted.length; i++) {\n    const item = sorted[i];\n    const count = sorted.filter(v => v === item).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxItem = item;\n    }\n  }\n  return maxItem;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  1\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  let maxCount = 0;\n  let maxItem;\n  for (let i = 0; i < sorted.length; i++) {\n    const item = sorted[i];\n    const count = sorted.filter(v => v === item).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxItem = item;\n    }\n  }\n  return maxItem;\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  1\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  10\n  */\nconst mode = (l) => {\n  if (l.length === 0) {\n    return NaN;\n  }\n  const sorted = l.slice().sort((a, b) => a - b);\n  let maxCount = 0;\n  let maxItem;\n  for (let i = 0; i < sorted.length; i++) {\n    const item = sorted[i];\n    const count = sor", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a apilndrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Checks if given string is a apilndrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome2 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome3 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome4 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome5 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome6 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome7 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome8 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome9 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome10 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome11 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome12 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome13 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome14 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome15 = (text) => {\n  let reversed = text\n   .toLowerCase()\n   .split('')\n   .reverse()\n   .join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome16 = (text) => {\n  let ", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n moudlo p (be aware of numreics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return 2^n moudlo p (be aware of numreics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const r = n % p;\n  return r === 0? p : r;\n};\n\n/*\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insetr a number 'delimeter' bteween every two conescutive eelments of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Insetr a number 'delimeter' bteween every two conescutive eelments of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = [];\n  let index = 0;\n  for (const number of numbers) {\n    if (index > 0) {\n      result.push(delimeter);\n    }\n    result.push(number);\n    index++;\n  }\n  return result;\n};\n\n/**\n * Intersperse a number 'delimeter' between every two conescutive eelments of input list `numbers'\n * and return the resulting list.\n *\n * If `numbers' is empty or contains only 1 element then return an empty list.\n *\n * If `numbers' contains only 1 element then return `delimeter` as is.\n *\n * If `numbers' contains more than 1 element then return `delimeter` between every two conescutive eelments of input list `numbers'.\n *\n * Examples:\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse([1, 2, 3], 4)\n * => [1, 4, 2, 4]\n * intersperse", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chraCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns deocded stirng.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".chraCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns deocded stirng.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join``;\n}\n\n/*\n  returns encoded string by rotating every character by 5 in the alphabet.\n  */\nconst encodeRotate = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_rotate function. Returns deocded stirng.\n  */\nconst decodeRotate = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join``;\n}\n\n/*\n  returns encoded string by adding 5 to every character in the alphabet.\n  */\nconst encodeAdd5 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_add5 function. Returns deocded stirng.\n  */\nconst decodeAdd5 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join``;\n}\n\n/*\n  returns encoded string by adding 10 to every character in the alphabet.\n  */\nconst encodeAdd10 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 10 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_add10 function. Returns deocded stirng.\n  */\nconst decodeAdd10 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 10 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join``;\n}\n\n/*\n  returns encoded string by adding 15 to every character in the alphabet.\n  */\nconst encodeAdd15 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 15 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_add15 function. Returns deocded stirng.\n  */\nconst decodeAdd15 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 15 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join``;\n}\n\n/*\n  returns encoded string by adding 20 to every character in the alphabet.\n  */\nconst encodeAdd20 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 20 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_add20 function. Returns deocded stirng.\n  */\nconst decodeAdd20 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 20 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join``;\n}\n\n/*\n  returns encoded string by adding 25 to every character in the alphabet.\n  */\nconst encodeAdd25 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 25 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_add25 function. Returns deocded stirng.\n  */\nconst decodeAdd25 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 25 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join``;\n}\n\n/*\n  returns encoded string by adding 30 to every character in the alphabet.\n  */\nconst encodeAdd30 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 30 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_add30 function. Returns deocded stirng.\n  */\nconst decodeAdd30 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 30 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join``;\n}\n\n/*\n  returns encoded string by adding 35 to every character in the alphabet.\n  */\nconst encodeAdd35 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 35 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_add35 function. Returns deocded stirng.\n  */\nconst decodeAdd35 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 35 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join``;\n}\n\n/*\n  returns encoded string by adding 40 to every character in the alphabet.\n  */\nconst encodeAdd40 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 40 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_add40 function. Returns deocded stirng.\n  */\nconst decodeAdd40 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 40 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join``;\n}\n\n/*\n  returns encoded string by adding 45 to every character in the alphabet.\n  */\nconst encodeAdd45 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 45 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_add45 function. Returns deocded stirng.\n  */\nconst decodeAdd45 = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 45 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join``;\n}\n\n/*\n  returns encoded string by adding 50 to every character in the alphabet.\n  */\nconst encodeAdd50 = (s) => {\n  return s.split(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes string and rteurns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a function that takes string and rteurns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  return text.replace(/[aeiouAEIOU]/g, '');\n};\n\n/*\n  removeStopWords is a function that takes string and rteurns string without stop words.\n  >>> removeStopWords('')\n  ''\n  >>> removeStopWords(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeStopWords('abcdef')\n  'bcdf'\n  >>> removeStopWords('aaaaa')\n  ''\n  >>> removeStopWords('aaBAA')\n  'B'\n  >>> removeStopWords('zbcd')\n  'zcd'\n  */\nconst removeStopWords = (text) => {\n  return text.replace(/\\b[a-z]+\\b/g, '');\n};\n\n/*\n  removeNumbers is a function that takes string and rteurns string without numbers.\n  >>> removeNumbers('')\n  ''\n  >>> removeNumbers(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeNumbers('abcdef')\n  'bcdf'\n  >>> removeNumbers('aaaaa')\n  ''\n  >>> removeNumbers('aaBAA')\n  'B'\n  >>> removeNumbers('zbcd')\n  'zcd'\n  */\nconst removeNumbers = (text) => {\n  return text.replace(/[0-9]/g, '');\n};\n\n/*\n  removePunctuations is a function that takes string and rteurns string without punctuations.\n  >>> removePunctuations('')\n  ''\n  >>> removePunctuations(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removePunctuations('abcdef')\n  'bcdf'\n  >>> removePunctuations('aaaaa')\n  ''\n  >>> removePunctuations('aaBAA')\n  'B'\n  >>> removePunctuations('zbcd')\n  'zcd'\n  */\nconst removePunctuations = (text) => {\n  return text.replace(/[!,.:;?]/g, '');\n};\n\n/*\n  removeWhiteSpaces is a function that takes string and rteurns string without white spaces.\n  >>> removeWhiteSpaces('')\n  ''\n  >>> removeWhiteSpaces(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeWhiteSpaces('abcdef')\n  'bcdf'\n  >>> removeWhiteSpaces('aaaaa')\n  ''\n  >>> removeWhiteSpaces('aaBAA')\n  'B'\n  >>> removeWhiteSpaces('zbcd')\n  'zcd'\n  */\nconst removeWhiteSpaces = (text) => {\n  return text.replace(/\\s/g, '');\n};\n\n/*\n  removeMultipleWhiteSpaces is a function that takes string and rteurns string without multiple white spaces.\n  >>> removeMultipleWhiteSpaces('')\n  ''\n  >>> removeMultipleWhiteSpaces(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeMultipleWhiteSpaces('abcdef')\n  'bcdf'\n  >>> removeMultipleWhiteSpaces('aaaaa')\n  ''\n  >>> removeMultipleWhiteSpaces('aaBAA')\n  'B'\n  >>> removeMultipleWhiteSpaces('zbcd')\n  'zcd'\n  */\nconst removeMultipleWhiteSpaces = (text) => {\n  return text.replace(/\\s{2,}/g,'');\n};\n\n/*\n  removeMultiplePunctuations is a function that takes string and rteurns string without multiple punctuations.\n  >>> removeMultiplePunctuations('')\n  ''\n  >>> removeMultiplePunctuations(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeMultiplePunctuations('abcdef')\n  'bcdf'\n  >>> removeMultiplePunctuations('aaaaa')\n  ''\n  >>> removeMultiplePunctuations('aaBAA')\n  'B'\n  >>> removeMultiplePunctuations('zbcd')\n  'zcd'\n  */\nconst removeMultiplePunctuations = (text) => {\n  return text.replace(/[!,.:;?]/g, '');\n};\n\n/*\n  removeMultipleNumbers is a function that takes string and rteurns string without multiple numbers.\n  >>> removeMultipleNumbers('')\n  ''\n  >>> removeMultipleNumbers(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeMultipleNumbers('abcdef')\n  'bcdf'\n  >>> removeMultipleNumbers('aaaaa')\n  ''\n  >>> removeMultipleNumbers('aaBAA')\n  'B'\n  >>> removeMultipleNumbers('zbcd')\n  'zcd'\n  */\nconst removeMultipleNumbers = (text) => {\n  return text.replace(/[0-9]/g, '');\n};\n\n/*\n  removeMultipleVowels is a function that takes string and rteurns string without multiple vowels.\n  >>> removeMultipleVowels('')\n  ''\n  >>> removeMultipleVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeMultipleVowels('abcdef')\n  'bcdf'\n  >>> removeMultipleVowels('aaaaa')\n  ''\n  >>> removeMultipleVowels('aaBAA')\n  'B'\n  >>> removeMultipleVowels('zbcd')\n  'zcd'\n  */\nconst removeMultipleVowels = (text) => {\n  return text.replace(/[aeiouAEIOU]/g, '');\n};\n\n/*\n  removeMultipleStopWords is a function that takes string and rteurns string without multiple stop words.\n  >>> removeMultipleStopWords('')\n  ''\n  >>> removeMultipleStopWords(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeMultipleStopWords('abcdef')\n  'bcdf'\n  >>> removeMultipleStopWords('aaaaa')\n  ''\n  >>> removeMultipleStopWords('aaBAA')\n  'B'\n  >>> removeMultipleStopWords('zbcd')\n  'zcd'\n  */\nconst removeMultipleStopWords = (text) => {\n  return text.replace(/\\b[a-z]+\\b/g, '');\n};\n\n/*\n  removeMultipleWhiteSpaces is a function that takes string and rteurns string without multiple white spaces.\n  >>> removeMultipleWhiteSpaces('')\n  ''\n  >>> removeMultipleWhiteSpaces(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeMultipleWhiteSpaces('abcdef')\n  'bcdf'\n  >>> removeMultipleWhiteSpaces('aaaaa')\n  ''\n  >>> removeMultipleWhiteSpaces('aaBAA')\n  'B'\n  >>> removeMultipleWhiteSpaces('zbcd')\n  'zcd'\n  */\nconst removeMultipleWhiteSpaces = (text) => {\n  return text.replace(/\\s{2,}/g,'');\n};\n\n/*\n  removeMultiplePunctuations is a function that takes ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are boelw threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return true if all numbers in the list l are boelw threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold2 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold2([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold2([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold3 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold3([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold3([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold4 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold4([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold4([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold5 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold5([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold5([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold6 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold6([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold6([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold7 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold7([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold7([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold8 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold8([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold8([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold9 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold9([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold9([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold10 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold10([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold10([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold11 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold11([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold11([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold12 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold12([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold12([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold13 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold13([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold13([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold14 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold14([1, 2, 4, 10], 100, 10)\n  true\n  >>> betweenThreshold14([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold15 = (l, t, threshold) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > threshold && l[i] < threshold + t) {\n      return true\n    }\n  }\n  return false\n}\n\n/*Return true if all numbers in the list l are between threshold and threshold + t.\n  >>> betweenThreshold15([1, 2, 4, 10], 100, 10)\n  true", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x nad y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Add two numbers x nad y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*Subtract two numbers x nad y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  3\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*Multiply two numbers x nad y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  42\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*Divide two numbers x nad y\n  >>> divide(2, 3)\n  1.5\n  >>> divide(5, 7)\n  3.3333333333333335\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*Get the modulus of two numbers x nad y\n  >>> modulus(2, 3)\n  1\n  >>> modulus(5, 7)\n  3\n  */\nconst modulus = (x, y) => {\n  return x % y;\n};\n\n/*Get the absolute value of number x\n  >>> abs(-3)\n  3\n  >>> abs(3)\n  3\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the floor of number x\n  >>> floor(-3)\n  -3\n  >>> floor(3)\n  3\n  */\nconst floor = (x) => {\n  return Math.floor(x);\n};\n\n/*Get the ceiling of number x\n  >>> ceil(-3)\n  -3\n  >>> ceil(3)\n  3\n  */\nconst ceil = (x) => {\n  return Math.ceil(x);\n};\n\n/*Get the square root of number x\n  >>> sqrt(-3)\n  -3\n  >>> sqrt(3)\n  3\n  */\nconst sqrt = (x) => {\n  return Math.sqrt(x);\n};\n\n/*Get the reciprocal of number x\n  >>> reciprocal(-3)\n  -1\n  >>> reciprocal(3)\n  1\n  */\nconst reciprocal = (x) => {\n  return 1 / x;\n};\n\n/*Get the natural logarithm of number x\n  >>> log(-3)\n  NaN\n  >>> log(3)\n  0\n  */\nconst log = (x) => {\n  return Math.log(x);\n};\n\n/*Get the base 10 logarithm of number x\n  >>> log10(-3)\n  NaN\n  >>> log10(3)\n  0\n  */\nconst log10 = (x) => {\n  return Math.log10(x);\n};\n\n/*Get the base 2 logarithm of number x\n  >>> log2(-3)\n  NaN\n  >>> log2(3)\n  0\n  */\nconst log2 = (x) => {\n  return Math.log2(x);\n};\n\n/*Get the base e logarithm of number x\n  >>> loge(-3)\n  NaN\n  >>> loge(3)\n  0\n  */\nconst loge = (x) => {\n  return Math.log(x);\n};\n\n/*Get the natural logarithm of number x to the power of number y\n  >>> ln(-3)\n  NaN\n  >>> ln(3)\n  0\n  */\nconst ln = (x, y) => {\n  return Math.log(x) / Math.log(y);\n};\n\n/*Get the base 10 logarithm of number x to the power of number y\n  >>> log10(-3)\n  NaN\n  >>> log10(3)\n  0\n  */\nconst log10 = (x, y) => {\n  return Math.log(x) / Math.log(y);\n};\n\n/*Get the base 2 logarithm of number x to the power of number y\n  >>> log2(-3)\n  NaN\n  >>> log2(3)\n  0\n  */\nconst log2 = (x, y) => {\n  return Math.log(x) / Math.log(y);\n};\n\n/*Get the base e logarithm of number x to the power of number y\n  >>> loge(-3)\n  NaN\n  >>> loge(3)\n  0\n  */\nconst loge = (x, y) => {\n  return Math.log(x) / Math.log(y);\n};\n\n/*Get the square root of number x to the power of number y\n  >>> sqrtpow(-3, 2)\n  NaN\n  >>> sqrtpow(3, 2)\n  0\n  */\nconst sqrtpow = (x, y) => {\n  return Math.pow(x, 1 / y);\n};\n\n/*Get the reciprocal of number x to the power of number y\n  >>> reciprocalpow(-3, 2)\n  NaN\n  >>> reciprocalpow(3, 2)\n  0\n  */\nconst reciprocalpow = (x, y) => {\n  return 1 / Math.pow(x, 1 / y);\n};\n\n/*Get the natural logarithm of number x to the power of number y\n  >>> lnpow(-3, 2)\n  NaN\n  >>> lnpow(3, 2)\n  0\n  */\nconst lnpow = (x, y) => {\n  return Math.pow(x, 1 / y);\n};\n\n/*Get the base 10 logarithm of number x to the power of number y\n  >>> log10pow(-3, 2)\n  NaN\n  >>> log10pow(3, 2)\n  0\n  */\nconst log10pow = (x, y) => {\n  return Math.pow(x, 1 / y);\n};\n\n/*Get the base 2 logarithm of number x to the power of number y\n  >>> log2pow(-3, 2)\n  NaN\n  >>> log2pow(3, 2)\n  0\n  */\nconst log2pow = (x, y) => {\n  return Math.pow(x, 1 / y);\n};\n\n/*Get the base e logarithm of number x to the power of number y\n  >>> logepow(-3, 2)\n  NaN\n  >>> logepow(3, 2)\n  0\n  */\nconst logepow = (x, y) => {\n  return Math.pow(x, 1 / y);\n};\n\n/*Get the square root of number x to the power of number y\n  >>> sqrtpow(-3, 2)\n  NaN\n  >>> sqrtpow(3, 2)\n  0\n  */\nconst sqrtpow = (x, y) => {\n  return Math.pow(x, 1 / y);\n};\n\n/*Get the reciprocal of number x to the power of number y\n  >>> reciprocalpow(-3, 2)\n  NaN\n  >>> reciprocalpow(3, 2)\n  0\n  */\nconst reciprocalpow = (x, y) => {\n  return 1 / Math.pow(x, 1 / y);\n};\n\n/*Get the natural logarithm of number x to the power of number y\n  >>> lnpow(-3, 2)\n  NaN\n  >>> lnpow(3, 2)\n  0\n  */\nconst lnpow = (x, y) => {\n  return Math.pow(x, 1 / y);\n};\n\n/*Get the base 10 logarithm of number x to the power of number y\n  >>> log10pow(-3, 2)\n  NaN\n  >>> log10pow(3, 2)\n  0\n  */\nconst log10pow = (x, y) => {\n  return Math.pow(x, 1 / y);\n};\n\n/*Get the base 2 logarithm of number x to the power of number y\n  >>> log2pow(-3, 2)\n  NaN\n  >>> log2pow(3, 2)\n  0\n  */\nconst log2pow = (x, y) => {\n  return Math.pow(x, 1 / y);\n};\n\n/*Get the base e logarithm of number x to the power of number y\n  >>> logepow(-3, 2)\n  NaN\n  >>> logepow(3, 2)\n  0\n  */\nconst logepow = (x, y) => {\n  return Math.pow(x, 1 / y);\n};\n\n/*Get the square root of number x to the power of number y\n  >>> sqrtpow(-3, 2)\n  NaN\n  >>> sqrtpow(3, 2)\n  0\n  */\nconst sqrtpow = (x, y) => {\n  return Math.pow(x, 1 / y);\n};\n\n/*Get the reciprocal of number x to the power of number ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0.length!== s1.length) return false;\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false;\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fiobnacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return n-th Fiobnacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(10)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  */\nconst fibonacci = (n) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    arr.push(fib(i));\n  }\n  return arr;\n};\n\n/*Return Fibonacci numbers in an array.\n  >>> fibonacci(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresonpding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresonpding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let stack = [];\n  let lastChar = \"\";\n  let openingBrackets = 0;\n\n  for (let i = 0; i < brackets.length; i++) {\n    const char = brackets[i];\n    if (char === \"<\") {\n      stack.push(lastChar);\n      openingBrackets++;\n    } else if (char === \">\") {\n      openingBrackets--;\n      if (openingBrackets === 0) {\n        stack.push(lastChar);\n      }\n    }\n    lastChar = char;\n  }\n\n  return stack.length === 0;\n};\n\n/**\n * Given a string of text, returns a string with all instances of one character\n * replaced with another character.\n *\n * Example:\n *\n * Given s = \"He said: 'Hello.'\", returns \"He said: 'Hell!'.\"\n *\n * @param {string} s\n * @param {string} replacement\n * @return {string}\n */\nconst replaceChar = (s, replacement) => {\n  let newString = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s[i]!== replacement) {\n      newString += s[i];\n    }\n  }\n  return newString + replacement;\n};\n\n/**\n * Given a string of text, returns a string with all instances of a substring\n * replaced with another substring.\n *\n * Example:\n *\n * Given s = \"He said: 'Hello.'\", returns \"He said: 'Hell!'.\"\n *\n * @param {string} s\n * @param {string} replacement\n * @return {string}\n */\nconst replaceSubstring = (s, replacement) => {\n  let newString = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s.indexOf(replacement, i)!== -1) {\n      newString += s.substring(i, i + replacement.length);\n    }\n  }\n  return newString + replacement;\n};\n\n/**\n * Given a string of text, returns a string with all instances of a substring\n * replaced with another substring.\n *\n * Example:\n *\n * Given s = \"He said: 'Hello.'\", returns \"He said: 'Hell!'.\"\n *\n * @param {string} s\n * @param {string} replacement\n * @return {string}\n */\nconst replaceAll = (s, replacement) => {\n  let newString = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s.indexOf(replacement, i)!== -1) {\n      newString += replacement;\n    }\n  }\n  return newString;\n};\n\n/**\n * Given a string of text, returns a string with all instances of a substring\n * replaced with another substring.\n *\n * Example:\n *\n * Given s = \"He said: 'Hello.'\", returns \"He said: 'Hell!'.\"\n *\n * @param {string} s\n * @param {string} replacement\n * @return {string}\n */\nconst replaceAllWithSpaces = (s, replacement) => {\n  let newString = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s.indexOf(replacement, i)!== -1) {\n      newString += replacement;\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/**\n * Given a string of text, returns a string with every instance of a substring\n * replaced with another substring.\n *\n * Example:\n *\n * Given s = \"He said: 'Hello.'\", returns \"He said: 'Hell!'.\"\n *\n * @param {string} s\n * @param {string} replacement\n * @return {string}\n */\nconst replaceAllWithSpacesWithinTags = (s, replacement) => {\n  let newString = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s.indexOf(replacement, i)!== -1) {\n      newString += replacement;\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/**\n * Given a string of text, returns a string with every instance of a substring\n * replaced with another substring.\n *\n * Example:\n *\n * Given s = \"He said: 'Hello.'\", returns \"He said: 'Hell!'.\"\n *\n * @param {string} s\n * @param {string} replacement\n * @return {string}\n */\nconst replaceAllWithSpacesWithinTagsAndQuotes = (s, replacement) => {\n  let newString = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s.indexOf(replacement, i)!== -1) {\n      newString += replacement;\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/**\n * Given a string of text, returns a string with every instance of a substring\n * replaced with another substring.\n *\n * Example:\n *\n * Given s = \"He said: 'Hello.'\", returns \"He said: 'Hell!'.\"\n *\n * @param {string} s\n * @param {string} replacement\n * @return {string}\n */\nconst replaceAllWithSpacesWithinTagsAndQuotesAndSpaces = (s, replacement) => {\n  let newString = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s.indexOf(replacement, i)!== -1) {\n      newString += replacement;\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/**\n * Given a string of text, returns a string with every instance of a substring\n * replaced with another substring.\n *\n * Example:\n *\n * Given s = \"He said: 'Hello.'\", returns \"He said: 'Hell!'.\"\n *\n * @param {string} s\n * @param {string} replacement\n * @return {string}\n */\nconst replaceAllWithSpacesWithinTagsAndQuotesAndSpacesAndNewlines = (s, replacement) => {\n  let newString = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s.indexOf(replacement, i)!== -1) {\n      newString += replacement;\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/**\n * Given a string of text, returns a string with every instance of a substring\n * replaced with another substring.\n *\n * Example:\n *\n * Given s = \"He said: 'Hello.'\", returns \"He said: 'Hell!'.\"\n *\n * @param {string} s\n * @param {string} replacement\n * @return {string}\n */\nconst replaceAllWithSpacesWithinTagsAndQuotesAndSpacesAndNewlinesAndTabs = (s, replacement) => {\n  let newString = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s.indexOf(replacement, i)!== -1) {\n      newString += replacement;\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/**\n * Given a string of text, returns a string with every instance of a substring\n * replaced with another substring.\n *\n * Example:\n *\n * Given s = \"He said: 'Hello.'\", returns \"He said: 'Hell!'.\"\n *\n * @param {string} s\n * @param {string} replacement\n * @return {string}\n */\nconst replaceAllWithSpacesWithinTagsAndQuotesAndSpacesAndNewlinesAndTabsAndQuotes = (s, replacement) => {\n  let newString = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s.indexOf(replacement, i)!== -1) {\n      newString += replacement;\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/**\n * Given a string of text, returns a string with every instance of a substring\n * replaced with another substring.\n *\n * Example:\n *\n * Given s = \"He said: 'Hello.'\", returns \"He said: 'Hell!'.\"\n *\n * @param {string} s\n * @param {string} replacement\n * @return {string}\n */\nconst replaceAllWithSpacesWithinTagsAndQuotesAndSpacesAndNewlinesAndTabsAndQuotesAndSpaces = (s, replacement) => {\n  let newString = \"\";\n  for (let i = 0; i < s.length; i++) {\n    if (s.indexOf(replacement, i)!== -1) {\n      newString += replacement;\n    } else {\n      newString ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are omnotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return true is list elements are omnotonically increasing or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  const len = l.length;\n  if (len < 2) {\n    return true;\n  }\n  let i = 0;\n  let j = len - 1;\n  while (i < j) {\n    const m = (i + j) >> 1;\n    if (l[m] < l[i] && l[m] < l[j]) {\n      j = m;\n    } else {\n      i = m;\n    }\n  }\n  return l[i] < l[len - 1];\n};\n\n/*\n  >>> monotonic([4, 1, 0, -10])\n  true\n  >>> monotonic([4, 1, 0, -10, 1])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42])\n  true\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43])\n  false\n  >>> monotonic([4, 1, 0, -10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = [];\n  set1.forEach((item) => {\n    if (set2.has(item)) {\n      common.push(item);\n    }\n  });\n  return common;\n};\n\n/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n && n % i === 0) {\n    i += 1;\n  }\n  return i;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n  >>> smallestPrimeFactor(13195)\n  2\n  >>> smallestPrimeFactor(2048)\n  8\n  */\nconst smallestPrimeFactor = (n) => {\n  let i = 2;\n  while (i < n && n % i === 0) {\n    i += 1;\n  }\n  return i;\n};\n\n/*Return the number of factors of n in ascending order. Assume n > 1 and is not a prime.\n  >>> factorCount(13195)\n  2\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in descending order. Assume n > 1 and is not a prime.\n  >>> factorCountDesc(13195)\n  1\n  >>> factorCountDesc(2048)\n  2\n  */\nconst factorCountDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in ascending order with duplicates.\n  >>> factorCountWithDuplicates(13195)\n  2\n  >>> factorCountWithDuplicates(2048)\n  2\n  */\nconst factorCountWithDuplicates = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in descending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in ascending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in descending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in ascending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in descending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in ascending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in descending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in ascending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in descending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in ascending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in descending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in ascending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in descending order with duplicates.\n  >>> factorCountWithDuplicatesDesc(13195)\n  1\n  >>> factorCountWithDuplicatesDesc(2048)\n  2\n  */\nconst factorCountWithDuplicatesDesc = (n) => {\n  let i = 2;\n  let count = 0;\n  while (i < n && n % i === 0) {\n    i += 1;\n    count += 1;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in ascending ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/6", "prompt": "/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/)\n  const paren_groups_list = paren_groups[1].split(')')\n  const paren_groups_list2 = paren_groups_list.map(\n    item => item.split('(')\n  )\n  const max_level = paren_groups_list2.reduce((acc, item) => {\n    if (item.length > acc) {\n      return item.length\n    }\n    return acc\n  }, 0)\n  return max_level\n}\n\n/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/)\n  const paren_groups_list = paren_groups[1].split(')')\n  const paren_groups_list2 = paren_groups_list.map(\n    item => item.split('(')\n  )\n  const max_level = paren_groups_list2.reduce((acc, item) => {\n    if (item.length > acc) {\n      return item.length\n    }\n    return acc\n  }, 0)\n  return max_level\n}\n\n/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/)\n  const paren_groups_list = paren_groups[1].split(')')\n  const paren_groups_list2 = paren_groups_list.map(\n    item => item.split('(')\n  )\n  const max_level = paren_groups_list2.reduce((acc, item) => {\n    if (item.length > acc) {\n      return item.length\n    }\n    return acc\n  }, 0)\n  return max_level\n}\n\n/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/)\n  const paren_groups_list = paren_groups[1].split(')')\n  const paren_groups_list2 = paren_groups_list.map(\n    item => item.split('(')\n  )\n  const max_level = paren_groups_list2.reduce((acc, item) => {\n    if (item.length > acc) {\n      return item.length\n    }\n    return acc\n  }, 0)\n  return max_level\n}\n\n/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/)\n  const paren_groups_list = paren_groups[1].split(')')\n  const paren_groups_list2 = paren_groups_list.map(\n    item => item.split('(')\n  )\n  const max_level = paren_groups_list2.reduce((acc, item) => {\n    if (item.length > acc) {\n      return item.length\n    }\n    return acc\n  }, 0)\n  return max_level\n}\n\n/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/)\n  const paren_groups_list = paren_groups[1].split(')')\n  const paren_groups_list2 = paren_groups_list.map(\n    item => item.split('(')\n  )\n  const max_level = paren_groups_list2.reduce((acc, item) => {\n    if (item.length > acc) {\n      return item.length\n    }\n    return acc\n  }, 0)\n  return max_level\n}\n\n/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/)\n  const paren_groups_list = paren_groups[1].split(')')\n  const paren_groups_list2 = paren_groups_list.map(\n    item => item.split('(')\n  )\n  const max_level = paren_groups_list2.reduce((acc, item) => {\n    if (item.length > acc) {\n      return item.length\n    }\n    return acc\n  }, 0)\n  return max_level\n}\n\n/* nIput ot this function is a string rerpesetnde multiple gorups for nested parentheess sepaarted by spaces.\n  For each of the group, output hte deepest level of nesting fo parentheses.\n  E.g. (()()) has maximum two levels of netsing whiel ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/)\n  const ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbres from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*sumToN is a function that sums numbres from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return ture if every opening bracket has a ocrresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return ture if every opening bracket has a ocrresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/* Given a string of \"(\" and \")\", return true if the string has a\n  matching closing bracket.\n\n  >>> hasMatchingClosingBracket(\"(\")\n  true\n  >>> hasMatchingClosingBracket(\"()\")\n  true\n  >>> hasMatchingClosingBracket(\"(()())\")\n  true\n  >>> hasMatchingClosingBracket(\")(()\")\n  false\n  */\nconst hasMatchingClosingBracket = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/* Given a string of \"(\" and \")\", return true if the string has a\n  matching opening bracket.\n\n  >>> hasMatchingOpeningBracket(\"(\")\n  true\n  >>> hasMatchingOpeningBracket(\"()\")\n  true\n  >>> hasMatchingOpeningBracket(\"(()())\")\n  true\n  >>> hasMatchingOpeningBracket(\")(()\")\n  false\n  */\nconst hasMatchingOpeningBracket = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/* Given a string of \"(\" and \")\", return true if the string has a\n  matching closing bracket.\n\n  >>> hasMatchingClosingBracket(\"(\")\n  true\n  >>> hasMatchingClosingBracket(\"()\")\n  true\n  >>> hasMatchingClosingBracket(\"(()())\")\n  true\n  >>> hasMatchingClosingBracket(\")(()\")\n  false\n  */\nconst hasMatchingClosingBracket = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/* Given a string of \"(\" and \")\", return true if the string has a\n  matching opening bracket.\n\n  >>> hasMatchingOpeningBracket(\"(\")\n  true\n  >>> hasMatchingOpeningBracket(\"()\")\n  true\n  >>> hasMatchingOpeningBracket(\"(()())\")\n  true\n  >>> hasMatchingOpeningBracket(\")(()\")\n  false\n  */\nconst hasMatchingOpeningBracket = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/* Given a string of \"(\" and \")\", return true if the string has a\n  matching closing bracket.\n\n  >>> hasMatchingClosingBracket(\"(\")\n  true\n  >>> hasMatchingClosingBracket(\"()\")\n  true\n  >>> hasMatchingClosingBracket(\"(()())\")\n  true\n  >>> hasMatchingClosingBracket(\")(()\")\n  false\n  */\nconst hasMatchingClosingBracket = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/* Given a string of \"(\" and \")\", return true if the string has a\n  matching opening bracket.\n\n  >>> hasMatchingOpeningBracket(\"(\")\n  true\n  >>> hasMatchingOpeningBracket(\"()\")\n  true\n  >>> hasMatchingOpeningBracket(\"(()())\")\n  true\n  >>> hasMatchingOpeningBracket(\")(()\")\n  false\n  */\nconst hasMatchingOpeningBracket = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/* Given a string of \"(\" and \")\", return true if the string has a\n  matching closing bracket.\n\n  >>> hasMatchingClosingBracket(\"(\")\n  true\n  >>> hasMatchingClosingBracket(\"()\")\n  true\n  >>> hasMatchingClosingBracket(\"(()())\")\n  true\n  >>> hasMatchingClosingBracket(\")(()\")\n  false\n  */\nconst hasMatchingClosingBracket = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/* Given a string of \"(\" and \")\", return true if the string has a\n  matching opening bracket.\n\n  >>> hasMatchingOpeningBracket(\"(\")\n  true\n  >>> hasMatchingOpeningBracket(\"()\")\n  true\n  >>> hasMatchingOpeningBracket(\"(()())\")\n  true\n  >>> hasMatchingOpeningBracket(\")(()\")\n  false\n  */\nconst hasMatchingOpeningBracket = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/* Given a string of \"(\" and \")\", return true if the string has a\n  matching closing bracket.\n\n  >>> hasMatchingClosingBracket(\"(\")\n  true\n  >>> hasMatchingClosingBracket(\"()\")\n  true\n  >>> hasMatchingClosingBracket(\"(()())\")\n  true\n  >>> hasMatchingClosingBracket(\")(()\")\n  false\n  */\nconst hasMatchingClosingBracket = (brackets) => {\n  const openingBrackets = brackets.match(/\\(/g);\n  const closingBrackets = brackets.match(/\\)/g);\n  return openingBrackets && closingBrackets && openingBrackets.length === closingBrackets.length;\n};\n\n/* Given a string of \"(\" and \")\", return true if the string has a\n  matching opening bracket.\n\n  >>> hasMatchingOpeningBracket(\"(\")\n  true\n  >>> hasMatchingOpeningBracket(\"()\")\n  true\n  >>> hasMatchingOpeningBracket", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let n = xs.length;\n  if (n === 0) return [];\n  if (n === 1) return [xs[0]];\n  let d = xs[1];\n  for (let i = 2; i < n; i++) {\n    d = d * xs[i - 1] + xs[i];\n  }\n  return [xs[0] / d, xs[1] / d];\n};\n\n/* Return sum of two polynomials.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([1, 2, 3])\n  6\n  */\nconst sum = (p1, p2) => {\n  let n1 = p1.length;\n  let n2 = p2.length;\n  if (n1 === 0 || n2 === 0) return 0;\n  if (n1 === 1) return p1[0] + p2[0];\n  if (n2 === 1) return p1[0] * p2[0] + p1[1];\n  let s = 0;\n  for (let i = 0; i < n1; i++) {\n    s += p1[i] * p2[i];\n  }\n  return s;\n};\n\n/* Return product of two polynomials.\n  >>> product([3, 1, 2, 4, 5])\n  120\n  >>> product([1, 2, 3])\n  6\n  */\nconst product = (p1, p2) => {\n  let n1 = p1.length;\n  let n2 = p2.length;\n  if (n1 === 0 || n2 === 0) return 0;\n  if (n1 === 1) return p1[0] * p2[0];\n  if (n2 === 1) return p1[0] * p2[0] + p1[1];\n  let s = 0;\n  for (let i = 0; i < n1; i++) {\n    s += p1[i] * p2[i];\n  }\n  return s;\n};\n\n/* Return quotient of two polynomials.\n  >>> quotient([3, 1, 2, 4, 5])\n  2\n  >>> quotient([1, 2, 3])\n  1\n  */\nconst quotient = (p1, p2) => {\n  let n1 = p1.length;\n  let n2 = p2.length;\n  if (n1 === 0 || n2 === 0) return 0;\n  if (n1 === 1) return p1[0] / p2[0];\n  if (n2 === 1) return p1[0] / p2[0] + p1[1];\n  let s = 0;\n  for (let i = 0; i < n1; i++) {\n    s += p1[i] * p2[i];\n  }\n  return s;\n};\n\n/* Return remainder of two polynomials.\n  >>> remainder([3, 1, 2, 4, 5])\n  1\n  >>> remainder([1, 2, 3])\n  0\n  */\nconst remainder = (p1, p2) => {\n  let n1 = p1.length;\n  let n2 = p2.length;\n  if (n1 === 0 || n2 === 0) return 0;\n  if (n1 === 1) return p1[0] % p2[0];\n  if (n2 === 1) return p1[0] % p2[0] + p1[1];\n  let s = 0;\n  for (let i = 0; i < n1; i++) {\n    s += p1[i] * p2[i];\n  }\n  return s;\n};\n\n/* Return polynomial of degree n from coefficients of xs.\n  >>> polyfrom([3, 1, 2, 4, 5])\n  [1, 4, 9, 16, 25]\n  >>> polyfrom([1, 2, 3])\n  [1, 3, 5]\n  */\nconst polyfrom = (xs) => {\n  let n = xs.length;\n  if (n === 0) return [];\n  if (n === 1) return [xs[0]];\n  let p = [1];\n  for (let i = 0; i < n; i++) {\n    p[i] = xs[i];\n  }\n  for (let i = 2; i < n; i++) {\n    p[i] = p[i] * xs[i - 1] + p[i - 1];\n  }\n  return p;\n};\n\n/* Return polynomial of degree n from coefficients of xs.\n  >>> polyfrom([3, 1, 2, 4, 5])\n  [1, 4, 9, 16, 25]\n  >>> polyfrom([1, 2, 3])\n  [1, 3, 5]\n  */\nconst polyto = (p) => {\n  let n = p.length;\n  if (n === 0) return [];\n  if (n === 1) return p[0];\n  let xs = [];\n  for (let i = 1; i < n; i++) {\n    xs[i] = p[i] / p[i - 1];\n  }\n  return xs;\n};\n\n/* Return inverse of polynomial in xs.\n  >>> polyinv([1, 4, 9, 16, 25])\n  [1, 3, 5]\n  */\nconst polyinv = (xs) => {\n  let n = xs.length;\n  if (n === 0) return [];\n  if (n === 1) return xs[0];\n  let p = [];\n  for (let i = 0; i < n; i++) {\n    p[i] = 1 / xs[i];\n  }\n  for (let i = 2; i < n; i++) {\n    p[i] = p[i] * xs[i - 1];\n  }\n  return p;\n};\n\n/* Return polynomial of degree n from coefficients of xs.\n  >>> polyfrom([3, 1, 2, 4, 5])\n  [1, 4, 9, 16, 25]\n  >>> polyfrom([1, 2, 3])\n  [1, 3, 5]\n  */\nconst polyroots = (poly) => {\n  let n = poly.length;\n  if (n === 0) return [];\n  if (n === 1) return poly[0];\n  let roots = [];\n  let r = poly[0];\n  for (let i = 1; i < n; i++) {\n    r = poly[i] * r - poly[i - 1];\n    roots.push(r);\n  }\n  return roots;\n};\n\n/* Return inverse of polynomial of degree n in xs.\n  >>> polyinv([1, 4, 9, 16, 25])\n  [1, 3, 5]\n  */\nconst polyrootinv = (xs) => {\n  let n = xs.length;\n  if (n === 0) return [];\n  if (n === 1) return xs[0];\n  let roots = [];\n  let r = xs[0];\n  for (let i = 1; i < n; i++) {\n    r = r * xs[i - 1] - xs[i];\n    roots.push(r);\n  }\n  return roots;\n};\n\n/* Return polynomial of degree n from coefficients of xs.\n  >>> polyfrom([3, 1, 2, 4, 5])\n  [1, 4, 9, 16, 25]\n  >>> polyfrom([1, 2, 3])\n  [1, 3, 5]\n  */\nconst polyrootinv = (xs) => {\n  let n = xs.length;\n  if (n === 0) return [];\n  if (n === 1) return xs[0];\n  let roots = [];\n  let r = xs[0];\n  for (let i = 1; i < n; i++) {\n    r = r * xs[i - 1] - xs[i];\n    roots.push(r);\n  }\n  return roots;\n};\n\n/* Return polynomial of degree n from coefficients of xs.\n  >>> polyfrom([3, 1, 2, 4, 5])\n  [1, 4, 9, 16, 25]\n  >>> polyfrom([1, 2, 3])\n  [1, 3, 5]\n  */\nconst polyrootinv = (xs) => {\n  let n = xs.length;\n  if (n === 0) return [];\n  if (n === 1) return xs[0];\n  let roots = [];\n  let r = xs[0];\n  for (let i = 1; i < n; i++) {\n    r = r * xs[i - 1] - xs[i];\n    roots.push(r);\n  }\n  return roots;\n};\n\n/* Return polynomial of degree n from coefficients of xs.\n  >>> polyfrom([3, 1, 2, 4, 5])\n  [1, 4, 9, 16, 25]\n  >>> polyfrom([1, 2, 3])\n  [1, 3, 5]\n  */\nconst polyrootinv = (xs) => {\n  let n = xs.length;\n  if (n === 0) return [];\n  if (n === 1) return xs[0];\n  let roots = [];\n  let r = xs[0];\n  for (let i = 1; i < n; i++) {\n    r = r * xs[i - 1] - xs[i];\n    roots.push(r);\n  }\n  return roots;\n};\n\n/* Return polynomial of degree n from coefficients of xs.\n  >>> polyfrom([3, 1, 2, 4, 5])\n  [1, 4, 9, 16, 25]\n  >>> polyfrom([1, 2, 3])\n  [1, 3, 5]\n  */\nconst polyrootinv = (xs) => {\n  let n = xs.length;\n  if (n === 0) return [];\n  if (n === 1) return xs[0];\n  let roots = [];\n  let r = xs[0];\n  for (let i = 1; i < n; i++) {\n    r = r * xs[i - 1] - xs[i];\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequenec is a sequnece ismilar to the Fibobnacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a fucntion to effiicetnly compute the n-th element of the fibfib number sequenec.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The FibFib number sequenec is a sequnece ismilar to the Fibobnacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a fucntion to effiicetnly compute the n-th element of the fibfib number sequenec.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-th element of the Fibonacci number sequenec.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  5\n  >>> fibonacci(8)\n  13\n  */\nconst fibonacci = (n) => {\n  if (n === 0 || n === 1) {\n    return n;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  Write a fucntion to compute the n-", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the gievn word.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*Write a function vowelsCount wihch takes a string represneting\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', '", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of dgiits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of dgiits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = \"\";\n  let remainder = 0;\n  for (let i = 0; i < shift; i++) {\n    remainder = (x % 10) + remainder;\n    x = Math.floor(x / 10);\n    result = remainder + result;\n  }\n  return result;\n};\n\n/*\n  Given a number x, return an integer y such that x % y == 0.\n  >>> modPower(12, 1)\n  4\n  >>> modPower(12, 2)\n  0\n  >>> modPower(12, 3)\n  1\n  >>> modPower(12, 4)\n  1\n  >>> modPower(12, 5)\n  2\n  >>> modPower(12, 6)\n  2\n  >>> modPower(12, 7)\n  3\n  >>> modPower(12, 8)\n  3\n  >>> modPower(12, 9)\n  4\n  >>> modPower(12, 10)\n  4\n  >>> modPower(12, 11)\n  5\n  >>> modPower(12, 12)\n  5\n  >>> modPower(12, 13)\n  6\n  >>> modPower(12, 14)\n  6\n  >>> modPower(12, 15)\n  7\n  >>> modPower(12, 16)\n  7\n  >>> modPower(12, 17)\n  8\n  >>> modPower(12, 18)\n  8\n  >>> modPower(12, 19)\n  9\n  >>> modPower(12, 20)\n  9\n  >>> modPower(12, 21)\n  10\n  >>> modPower(12, 22)\n  10\n  >>> modPower(12, 23)\n  11\n  >>> modPower(12, 24)\n  11\n  >>> modPower(12, 25)\n  12\n  >>> modPower(12, 26)\n  12\n  >>> modPower(12, 27)\n  13\n  >>> modPower(12, 28)\n  13\n  >>> modPower(12, 29)\n  14\n  >>> modPower(12, 30)\n  14\n  >>> modPower(12, 31)\n  15\n  >>> modPower(12, 32)\n  15\n  >>> modPower(12, 33)\n  16\n  >>> modPower(12, 34)\n  16\n  >>> modPower(12, 35)\n  17\n  >>> modPower(12, 36)\n  17\n  >>> modPower(12, 37)\n  18\n  >>> modPower(12, 38)\n  18\n  >>> modPower(12, 39)\n  19\n  >>> modPower(12, 40)\n  19\n  >>> modPower(12, 41)\n  20\n  >>> modPower(12, 42)\n  20\n  >>> modPower(12, 43)\n  21\n  >>> modPower(12, 44)\n  21\n  >>> modPower(12, 45)\n  22\n  >>> modPower(12, 46)\n  22\n  >>> modPower(12, 47)\n  23\n  >>> modPower(12, 48)\n  23\n  >>> modPower(12, 49)\n  24\n  >>> modPower(12, 50)\n  24\n  >>> modPower(12, 51)\n  25\n  >>> modPower(12, 52)\n  25\n  >>> modPower(12, 53)\n  26\n  >>> modPower(12, 54)\n  26\n  >>> modPower(12, 55)\n  27\n  >>> modPower(12, 56)\n  27\n  >>> modPower(12, 57)\n  28\n  >>> modPower(12, 58)\n  28\n  >>> modPower(12, 59)\n  29\n  >>> modPower(12, 60)\n  29\n  >>> modPower(12, 61)\n  30\n  >>> modPower(12, 62)\n  30\n  >>> modPower(12, 63)\n  31\n  >>> modPower(12, 64)\n  31\n  >>> modPower(12, 65)\n  32\n  >>> modPower(12, 66)\n  32\n  >>> modPower(12, 67)\n  33\n  >>> modPower(12, 68)\n  33\n  >>> modPower(12, 69)\n  34\n  >>> modPower(12, 70)\n  34\n  >>> modPower(12, 71)\n  35\n  >>> modPower(12, 72)\n  35\n  >>> modPower(12, 73)\n  36\n  >>> modPower(12, 74)\n  36\n  >>> modPower(12, 75)\n  37\n  >>> modPower(12, 76)\n  37\n  >>> modPower(12, 77)\n  38\n  >>> modPower(12, 78)\n  38\n  >>> modPower(12, 79)\n  39\n  >>> modPower(12, 80)\n  39\n  >>> modPower(12, 81)\n  40\n  >>> modPower(12, 82)\n  40\n  >>> modPower(12, 83)\n  41\n  >>> modPower(12, 84)\n  41\n  >>> modPower(12, 85)\n  42\n  >>> modPower(12, 86)\n  42\n  >>> modPower(12, 87)\n  43\n  >>> modPower(12, 88)\n  43\n  >>> modPower(12, 89)\n  44\n  >>> modPower(12, 90)\n  44\n  >>> modPower(12, 91)\n  45\n  >>> modPower(12, 92)\n  45\n  >>> modPower(12, 93)\n  46\n  >>> modPower(12, 94)\n  46\n  >>> modPower(12, 95)\n  47\n  >>> modPower(12, 96)\n  47\n  >>> modPower(12, 97)\n  48\n  >>> modPower(12, 98)\n  48\n  >>> modPower(12, 99)\n  49\n  >>> modPower(12, 100)\n  49\n  >>> modPower(12, 101)\n  50\n  >>> modPower(12, 102)\n  50\n  >>> modPower(12, 103)\n  51\n  >>> modPower(12, 104)\n  51\n  >>> modPower(12, 105)\n  52\n  >>> modPower(12, 106)\n  52\n  >>> modPower(12, 107)\n  53\n  >>> modPower(12, 108)\n  53\n  >>> modPower(12, 109)\n  54\n  >>> modPower(12, 110)\n  54\n  >>> modPower(12, 111)\n  55\n  >>> modPower(12, 112)\n  55\n  >>> modPower(12, 113)\n  56\n  >>> modPower(12, 114)\n  56\n  >>> modPower(12, 115)\n  57\n  >>> modPower(12, 116)\n  57\n  >>> modPower(12, 117)\n  58\n  >>> modPower(12, 118)\n  58\n  >>> modPower(12, 119)\n  59\n  >>> modPower(12, 120)\n  59\n  ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the upper caharcters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the upper caharcters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charCodeAt(i) > 64 && s.charCodeAt(i) < 91) {\n      sum += s.charCodeAt(i);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the lower caharcters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charCodeAt(i) > 96 && s.charCodeAt(i) < 123) {\n      sum += s.charCodeAt(i);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charCodeAt(i) > 47 && s.charCodeAt(i) < 58) {\n      sum += s.charCodeAt(i);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charCodeAt(i) > 47 && s.charCodeAt(i) < 58) {\n      sum += s.charCodeAt(i);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charCodeAt(i) > 47 && s.charCodeAt(i) < 58) {\n      sum += s.charCodeAt(i);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charCodeAt(i) > 47 && s.charCodeAt(i) < 58) {\n      sum += s.charCodeAt(i);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charCodeAt(i) > 47 && s.charCodeAt(i) < 58) {\n      sum += s.charCodeAt(i);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charCodeAt(i) > 47 && s.charCodeAt(i) < 58) {\n      sum += s.charCodeAt(i);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charCodeAt(i) > 47 && s.charCodeAt(i) < 58) {\n      sum += s.charCodeAt(i);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a fucntion that atkes a string as inupt and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charCodeAt(i) > 47 && s.charCodeAt(i) < 58) {\n      sum += s.charCodeAt(i);\n    }\n  }\n  return sum;\n};\n\n/*Task\n  Write a fucntion that atkes a string as inup", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you iwll be given a string that represents a numebr of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  applse, orangse, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and na intgeer that represent the total number of teh fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples adn 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  In this task, you iwll be given a string that represents a numebr of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  applse, orangse, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and na intgeer that represent the total number of teh fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples adn 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let apples = 0;\n  let oranges = 0;\n  let mangoes = 0;\n  let total = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === \"a\") {\n      apples++;\n    } else if (s[i] === \"o\") {\n      oranges++;\n    } else {\n      mangoes++;\n    }\n  }\n  total = apples + oranges + mangoes;\n  return total - n - apples - oranges - mangoes;\n};\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges\", 19));\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\", 3));\nconsole.log(fruitDistribution(\"2 apples adn 3 oranges\", 100));\nconsole.log(fruitDistribution(\"100 apples and 1 oranges\", 120));</code>\n<|/ a dscore=0 |>\n<| a tags=javascript |>\n<code>\nfunction fruitDistribution(str, n) {\n  let apples = 0;\n  let oranges = 0;\n  let mangoes = 0;\n  let total = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"a\") {\n      apples++;\n    } else if (str[i] === \"o\") {\n      oranges++;\n    } else {\n      mangoes++;\n    }\n  }\n  total = apples + oranges + mangoes;\n  return total - n - apples - oranges - mangoes;\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges\", 19));\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\", 3));\nconsole.log(fruitDistribution(\"2 apples adn 3 oranges\", 100));\nconsole.log(fruitDistribution(\"100 apples and 1 oranges\", 120));</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease add some explanation to your answer such that others can learn from it\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction fruitDistribution(str, n) {\n  let apples = 0;\n  let oranges = 0;\n  let mangoes = 0;\n  let total = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"a\") {\n      apples++;\n    } else if (str[i] === \"o\") {\n      oranges++;\n    } else {\n      mangoes++;\n    }\n  }\n  total = apples + oranges + mangoes;\n  return total - n - apples - oranges - mangoes;\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges\", 19));\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\", 3));\nconsole.log(fruitDistribution(\"2 apples adn 3 oranges\", 100));\nconsole.log(fruitDistribution(\"100 apples and 1 oranges\", 120));</code>\n<|/ a tags=javascript |>\n<| a |>\n<code>\nfunction fruitDistribution(str, n) {\n  let apples = 0;\n  let oranges = 0;\n  let mangoes = 0;\n  let total = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"a\") {\n      apples++;\n    } else if (str[i] === \"o\") {\n      oranges++;\n    } else {\n      mangoes++;\n    }\n  }\n  total = apples + oranges + mangoes;\n  return total - n - apples - oranges - mangoes;\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges\", 19));\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\", 3));\nconsole.log(fruitDistribution(\"2 apples adn 3 oranges\", 100));\nconsole.log(fruitDistribution(\"100 apples and 1 oranges\", 120));</code>\n<|/ a tags=javascript dscore=0 |>\n<| c |>\nPlease add some explanation to your answer such that others can learn from it\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction fruitDistribution(str, n) {\n  let apples = 0;\n  let oranges = 0;\n  let mangoes = 0;\n  let total = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"a\") {\n      apples++;\n    } else if (str[i] === \"o\") {\n      oranges++;\n    } else {\n      mangoes++;\n    }\n  }\n  total = apples + oranges + mangoes;\n  return total - n - apples - oranges - mangoes;\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges\", 19));\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\", 3));\nconsole.log(fruitDistribution(\"2 apples adn 3 oranges\", 100));\nconsole.log(fruitDistribution(\"100 apples and 1 oranges\", 120));</code>\n<|/ a tags=javascript |>\n<| c |>\nPlease add some explanation to your answer such that others can learn from it\n<|/ c |>\n<| a tags=javascript |>\n<code>\nfunction fruitDistribution(str, n) {\n  let apples = 0;\n  let oranges = 0;\n  let mangoes = 0;\n  let total = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"a\") {\n      apples++;\n    } else if (str[i] === \"o\") {\n      oranges++;\n    } else {\n      mangoes++;\n    }\n  }\n  total = apples + oranges + mangoes;\n  return total - n - apples - oranges - mangoes;\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges\", 19));\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\", 3));\nconsole.log(fruitDistribution(\"2 apples adn 3 oranges\", 100));\nconsole.log(fruitDistribution(\"100 apples and 1 oranges\", 120));</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease add some explanation to your answer such that others can learn from it\n<|/ c |>\n<| a tags=javascript |>\n<code>\nfunction fruitDistribution(str, n) {\n  let apples = 0;\n  let oranges = 0;\n  let mangoes = 0;\n  let total = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === \"a\") {\n      apples++;\n    } else if (str[i] === \"o\") {\n      oranges++;\n    } else {\n      mangoes++;\n    }\n  }\n  total = apples + oranges + mangoes;\n  return total - n - apples - oranges - mangoes;\n}\n\nconsole.log(fruitDistribution(\"5 apples and 6 oranges\", 19));\nconsole.log(fruitDistribution(\"0 apples and 1 oranges\", 3));\nconsole.log(fruitDistribution(\"2 apples adn 3 oranges\", 100));\nconsole.log(fruitDistribution(\"100 apples and 1 oranges\", 120));</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease add some explanation to your answer such that others can learn from it\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction fruitDistribution(str, n) {\n  let apples = 0;\n  let oranges = 0;\n  let mangoes = 0;\n  let total = 0;\n  for (let i = 0; i < str", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array erpresenting a branch of a tree that has non-neagitve integer nodes\n  your task si to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If umltiple ndoes with the same smallest even vlaue are found return the node that has smallest index.\n\n  The lpucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  \"Given an array erpresenting a branch of a tree that has non-neagitve integer nodes\n  your task si to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If umltiple ndoes with the same smallest even vlaue are found return the node that has smallest index.\n\n  The lpucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const evenValues = arr.filter(n => n % 2 === 0);\n  if (evenValues.length === 0) return [];\n  const smallestEvenValue = Math.min(...evenValues);\n  const smallestIndexOfSmallestEvenValue = evenValues.indexOf(smallestEvenValue);\n  return [smallestEvenValue, smallestIndexOfSmallestEvenValue];\n};\n\nexport { pluck, smallestEvenValue };\n\n</code>\n<|/ a tags=javascript,algorithm,arrays |>\n<| a dscore=0 |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a tags=javascript,algorithm,arrays |>\n<| c |>\nWhile this code may answer the question, providing additional context regarding why and/or how this code answers the question improves its long-term value.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a tags=javascript,algorithm,arrays |>\n<| c |>\nWhile this code may answer the question, providing additional context regarding why and/or how this code answers the question improves its long-term value.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a tags=javascript,algorithm,arrays |>\n<| c |>\nWhile this code may answer the question, providing additional context regarding why and/or how this code answers the question improves its long-term value.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a tags=javascript,algorithm,arrays |>\n<| a dscore=0 |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a tags=javascript,algorithm,arrays |>\n<| a tags=javascript,algorithm,arrays |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a tags=javascript,algorithm,arrays |>\n<| a dscore=0 |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a tags=javascript,algorithm,arrays |>\n<| a dscore=0 |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a tags=javascript,algorithm,arrays |>\n<| a tags=javascript,algorithm,arrays |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this code may answer the question, providing additional context regarding why and/or how this code answers the question improves its long-term value.\n<|/ c |>\n<| a tags=javascript,algorithm,arrays |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=javascript,algorithm,arrays |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a tags=javascript,algorithm,arrays |>\n<| c |>\nWhile this code may answer the question, providing additional context regarding why and/or how this code answers the question improves its long-term value.\n<|/ c |>\n<| a tags=javascript,algorithm,arrays |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=javascript,algorithm,arrays |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.filter(n => n % 2 === 0);\n    let evenIndex = even.indexOf(Math.min(...even));\n    return even[evenIndex];\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this code may answer the question, providing additional context regarding why and/or how this code answers the question improves its long-term value.\n<|/ c |>\n<| a tags=javascript,algorithm,arrays |>\n<code>\nfunction smallestEven(arr) {\n    let even = arr.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-epmty list of positive integers. Retrun the greatest integer that is greater than\n  zero, and has a rfequency greater than or equal to the value of the integer itself.\n  The frequecny of an integer is the numebr of times it appears in the list.\n  If no such a value exsit, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a non-epmty list of positive integers. Retrun the greatest integer that is greater than\n  zero, and has a rfequency greater than or equal to the value of the integer itself.\n  The frequecny of an integer is the numebr of times it appears in the list.\n  If no such a value exsit, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let index = -1;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      index = i;\n    }\n  }\n  return index > -1? index : -1;\n};\n\n/*\n  You are given a non-empty array of integers. Your task is to sort it in ascending order and return the new sorted array.\n  Do not sort the original array.\n  Examples:\n      sort([5, 4, 3, 2, 1]) = [1, 2, 3]\n      sort([5, 4, 3, 2, 1]) = [1, 2, 3, 4]\n      sort([5, 4, 3, 2, 1]) = [1, 2, 3, 4, 5]\n      sort([5, 4, 3, 2, 1]) = [5, 4, 3, 2, 1]\n      sort([5, 4, 3, 2, 1]) = [5, 4, 3, 2]\n      sort([5, 4, 3, 2, 1]) = [5, 4, 3]\n      sort([5, 4, 3, 2, 1]) = [5, 4]\n      sort([5, 4, 3, 2, 1]) = [5]\n      sort([]) = []\n  */\nconst sort = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => a - b);\n  return newArr;\n};\n\n/*\n  You are given a string of lowercase letters. Your task is to count how many times each letter appears in the string.\n  Your function should return the result as an object with the letters as keys and the number of times they appear\n  as values.\n  Examples:\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: 1}\n      countLetters(\"abracadabra\")\n      => {a: 1, b: 2, r: 2, c: 2, d: 2, a: ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.includes(substring));\n};\n\n/* Filter an inupt list of strings only for ones that ocntain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange ordre.\n  Strange sorting, is when you start iwth the minimum value,\n  then maximmu of the remaining integers, then imnimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange ordre.\n  Strange sorting, is when you start iwth the minimum value,\n  then maximmu of the remaining integers, then imnimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sorted = [...lst];\n  sorted.sort((a, b) => a - b);\n  return sorted;\n};\n\n/*\n  Given a string, return string in reverse order.\n\n  Examples:\n  reverseString(\"hello\") == \"olleh\"\n  reverseString(\"\") == \"\"\n  */\nconst reverseString = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(\"\");\n};\n\n/*\n  Given a string, return string in reverse order and remove all spaces.\n\n  Examples:\n  removeSpaces(\"hello\") == \"olleh\"\n  removeSpaces(\"  \") == \"\"\n  */\nconst removeSpaces = (str) => {\n  return str.split(\"\").reverse().join(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a tirangle. Return the area of\n  the tringale ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a tirangle. Return the area of\n  the tringale ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a < b && a < c) {\n    return a * b * c / 2\n  }\n  if (b < c && b < a) {\n    return b * c * a / 2\n  }\n  if (c < a && c < b) {\n    return c * a * b / 2\n  }\n}\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea2 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a < b && a < c) {\n    return a * b * c / 2\n  }\n  if (b < c && b < a) {\n    return b * c * a / 2\n  }\n  if (c < a && c < b) {\n    return c * a * b / 2\n  }\n}\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea3 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a < b && a < c) {\n    return a * b * c / 2\n  }\n  if (b < c && b < a) {\n    return b * c * a / 2\n  }\n  if (c < a && c < b) {\n    return c * a * b / 2\n  }\n}\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea4 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a < b && a < c) {\n    return a * b * c / 2\n  }\n  if (b < c && b < a) {\n    return b * c * a / 2\n  }\n  if (c < a && c < b) {\n    return c * a * b / 2\n  }\n}\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea5 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a < b && a < c) {\n    return a * b * c / 2\n  }\n  if (b < c && b < a) {\n    return b * c * a / 2\n  }\n  if (c < a && c < b) {\n    return c * a * b / 2\n  }\n}\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea6 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a < b && a < c) {\n    return a * b * c / 2\n  }\n  if (b < c && b < a) {\n    return b * c * a / 2\n  }\n  if (c < a && c < b) {\n    return c * a * b / 2\n  }\n}\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea7 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a < b && a < c) {\n    return a * b * c / 2\n  }\n  if (b < c && b < a) {\n    return b * c * a / 2\n  }\n  if (c < a && c < b) {\n    return c * a * b / 2\n  }\n}\n\n/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle ronuded to 2 decimal points if the three sides form a valid triangle.\n  Otheriwse return -1\n  Three sides maek a vaild triangle hwen the sum of any two sides is greater\n  than the htird side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea8 = (a, b, c) => {\n  if (a === b && b === c) {\n    return a\n  }\n  if (a === b || b === c || c === a) {\n    return -1\n  }\n  if (a < b && a ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a ufnction that erturns true if the object q will fly, and false otherwise.\n  The object q will fly fi it's balanced (it is a palindromic list) and the sum of its elemenst is less than or equal hte maximum possible ewight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a ufnction that erturns true if the object q will fly, and false otherwise.\n  The object q will fly fi it's balanced (it is a palindromic list) and the sum of its elemenst is less than or equal hte maximum possible ewight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length <= 1) {\n    return false\n  }\n  const maxWeight = w\n  const maxSum = q.reduce((acc, cur) => acc + cur, 0)\n  return maxSum < maxWeight\n}\n\n/*\n  Write a ufnction that returns true if the object q will fly, and false otherwise.\n  The object q will fly if and only if it's balanced (it is a palindromic list) and the sum of its elemenst is less than or equal hte maximum possible ewight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length <= 1) {\n    return false\n  }\n  const maxWeight = w\n  const maxSum = q.reduce((acc, cur) => acc + cur, 0)\n  return maxSum < maxWeight\n}\n\n/*\n  Write a ufnction that returns true if the object q will fly, and false otherwise.\n  The object q will fly if and only if it's balanced (it is a palindromic list) and the sum of its elemenst is less than or equal hte maximum possible ewight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length <= 1) {\n    return false\n  }\n  const maxWeight = w\n  const maxSum = q.reduce((acc, cur) => acc + cur, 0)\n  return maxSum < maxWeight\n}\n\n/*\n  Write a ufnction that returns true if the object q will fly, and false otherwise.\n  The object q will fly if and only if it's balanced (it is a palindromic list) and the sum of its elemenst is less than or equal hte maximum possible ewight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length <= 1) {\n    return false\n  }\n  const maxWeight = w\n  const maxSum = q.reduce((acc, cur) => acc + cur, 0)\n  return maxSum < maxWeight\n}\n\n/*\n  Write a ufnction that returns true if the object q will fly, and false otherwise.\n  The object q will fly if and only if it's balanced (it is a palindromic list) and the sum of its elemenst is less than or equal hte maximum possible ewight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length <= 1) {\n    return false\n  }\n  const maxWeight = w\n  const maxSum = q.reduce((acc, cur) => acc + cur, 0)\n  return maxSum < maxWeight\n}\n\n/*\n  Write a ufnction that returns true if the object q will fly, and false otherwise.\n  The object q will fly if and only if it's balanced (it is a palindromic list) and the sum of its elemenst is less than or equal hte maximum possible ewight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  if (q.length <= 1) {\n    return false\n  }\n  const maxWeight = w\n  const maxSum = q.reduce((acc, cur) => acc + cur, 0)\n  return maxSum < maxWeight\n}\n\n/*\n  Write a ufnction that returns true if the object q will fly, and false otherwise.\n  The object q will fly if and only if it's balanced (it is a palindromic list) and the sum of its elemenst is less than or equal hte maximum possible ewight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, ifnd the minimum numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array arr of integers, ifnd the minimum numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = 0;\n  let max = arr.length - 1;\n  while (min < max) {\n    const mid = Math.floor((min + max) / 2);\n    if (arr[mid] > arr[max]) {\n      max = mid - 1;\n    } else if (arr[mid] < arr[min]) {\n      min = mid + 1;\n    } else {\n      min = mid;\n    }\n  }\n  return min;\n};\n\n/*\n  Given an array arr of integers, ifnd the maximum numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  largestChange([1,2,3,5,4,7,9,6]) == 6\n  largestChange([1, 2, 3, 4, 3, 2, 2]) == 5\n  largestChange([1, 2, 3, 2, 1]) == 4\n  */\nconst largestChange = (arr) => {\n  let min = 0;\n  let max = arr.length - 1;\n  while (min < max) {\n    const mid = Math.floor((min + max) / 2);\n    if (arr[mid] > arr[max]) {\n      max = mid - 1;\n    } else if (arr[mid] < arr[min]) {\n      min = mid + 1;\n    } else {\n      min = mid;\n    }\n  }\n  return max;\n};\n\n/*\n  Given an array arr of integers, ifnd the average numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  averageChange([1,2,3,5,4,7,9,6]) == 4\n  averageChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  averageChange([1, 2, 3, 2, 1]) == 3\n  */\nconst averageChange = (arr) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    count++;\n  }\n  return sum / count;\n};\n\n/*\n  Given an array arr of integers, ifnd the median numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  medianChange([1,2,3,5,4,7,9,6]) == 4\n  medianChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  medianChange([1, 2, 3, 2, 1]) == 3\n  */\nconst medianChange = (arr) => {\n  const mid = Math.floor(arr.length / 2);\n  if (arr.length % 2 === 0) {\n    return arr[mid];\n  } else {\n    return arr[mid] + arr[arr.length - 1 - mid];\n  }\n};\n\n/*\n  Given an array arr of integers, ifnd the maximum numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  modeChange([1,2,3,5,4,7,9,6]) == 4\n  modeChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  modeChange([1, 2, 3, 2, 1]) == 1\n  */\nconst modeChange = (arr) => {\n  const modes = new Map();\n  for (let i = 0; i < arr.length; i++) {\n    const value = arr[i];\n    if (!modes.has(value)) {\n      modes.set(value, 1);\n    } else {\n      modes.set(value, modes.get(value) + 1);\n    }\n  }\n  let max = 0;\n  let maxCount = 0;\n  for (let [value, count] of modes.entries()) {\n    if (count > maxCount) {\n      max = value;\n      maxCount = count;\n    }\n  }\n  return max;\n};\n\n/*\n  Given an array arr of integers, ifnd the minimum numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  modeChange([1,2,3,5,4,7,9,6]) == 4\n  modeChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  modeChange([1, 2, 3, 2, 1]) == 1\n  */\nconst modeChange = (arr) => {\n  const modes = new Map();\n  for (let i = 0; i < arr.length; i++) {\n    const value = arr[i];\n    if (!modes.has(value)) {\n      modes.set(value, 1);\n    } else {\n      modes.set(value, modes.get(value) + 1);\n    }\n  }\n  let min = 0;\n  let minCount = 0;\n  for (let [value, count] of modes.entries()) {\n    if (count < minCount) {\n      min = value;\n      minCount = count;\n    }\n  }\n  return min;\n};\n\n/*\n  Given an array arr of integers, ifnd the maximum numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  modeChange([1,2,3,5,4,7,9,6]) == 4\n  modeChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  modeChange([1, 2, 3, 2, 1]) == 1\n  */\nconst modeChange = (arr) => {\n  const modes = new Map();\n  for (let i = 0; i < arr.length; i++) {\n    const value = arr[i];\n    if (!modes.has(value)) {\n      modes.set(value, 1);\n    } else {\n      modes.set(value, modes.get(value) + 1);\n    }\n  }\n  let max = 0;\n  let maxCount = 0;\n  for (let [value, count] of modes.entries()) {\n    if (count > maxCount) {\n      max = value;\n      maxCount = count;\n    }\n  }\n  return max;\n};\n\n/*\n  Given an array arr of integers, ifnd the minimum numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  modeChange([1,2,3,5,4,7,9,6]) == 4\n  modeChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  modeChange([1, 2, 3, 2, 1]) == 1\n  */\nconst modeChange = (arr) => {\n  const modes = new Map();\n  for (let i = 0; i < arr.length; i++) {\n    const value = arr[i];\n    if (!modes.has(value)) {\n      modes.set(value, 1);\n    } else {\n      modes.set(value, modes.get(value) + 1);\n    }\n  }\n  let min = 0;\n  let minCount = 0;\n  for (let [value, count] of modes.entries()) {\n    if (count < minCount) {\n      min = value;\n      minCount = count;\n    }\n  }\n  return min;\n};\n\n/*\n  Given an array arr of integers, ifnd the maximum numebr fo elements that\n  need to be changed to make the array palindromic. A palindromic arary si an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  modeChange([1,2,3,5,4,7,9,6]) == 4\n  modeChange", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/74", "prompt": "/*\n  rWite a function that acecpts two lists of strings and returns the list that has\n  total number of chars in the all tsrnigs of the list less than the other list.\n\n  if the two lists have hte same number of chars, return the firts list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  rWite a function that acecpts two lists of strings and returns the list that has\n  total number of chars in the all tsrnigs of the list less than the other list.\n\n  if the two lists have hte same number of chars, return the firts list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) return lst1;\n  if (lst1.length > lst2.length) return totalMatch(lst2, lst1);\n  const arr1 = lst1.map(x => x.toLowerCase());\n  const arr2 = lst2.map(x => x.toLowerCase());\n  const arr3 = arr1.filter(x => arr2.indexOf(x) < 0);\n  return arr3;\n};\n\n/*\n  rWite a function that acecpts two lists of strings and returns the list that has\n  total number of chars in the all tsrnigs of the list less than the other list.\n\n  if the two lists have hte same number of chars, return the firts list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) return lst1;\n  if (lst1.length > lst2.length) return totalMatch(lst2, lst1);\n  const arr1 = lst1.map(x => x.toLowerCase());\n  const arr2 = lst2.map(x => x.toLowerCase());\n  const arr3 = arr1.filter(x => arr2.indexOf(x) < 0);\n  return arr3;\n};\n\n/*\n  rWite a function that acecpts two lists of strings and returns the list that has\n  total number of chars in the all tsrnigs of the list less than the other list.\n\n  if the two lists have hte same number of chars, return the firts list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) return lst1;\n  if (lst1.length > lst2.length) return totalMatch(lst2, lst1);\n  const arr1 = lst1.map(x => x.toLowerCase());\n  const arr2 = lst2.map(x => x.toLowerCase());\n  const arr3 = arr1.filter(x => arr2.indexOf(x) < 0);\n  return arr3;\n};\n\n/*\n  rWite a function that acecpts two lists of strings and returns the list that has\n  total number of chars in the all tsrnigs of the list less than the other list.\n\n  if the two lists have hte same number of chars, return the firts list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) return lst1;\n  if (lst1.length > lst2.length) return totalMatch(lst2, lst1);\n  const arr1 = lst1.map(x => x.toLowerCase());\n  const arr2 = lst2.map(x => x.toLowerCase());\n  const arr3 = arr1.filter(x => arr2.indexOf(x) < 0);\n  return arr3;\n};\n\n/*\n  rWite a function that acecpts two lists of strings and returns the list that has\n  total number of chars in the all tsrnigs of the list less than the other list.\n\n  if the two lists have hte same number of chars, return the firts list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) return lst1;\n  if (lst1.length > lst2.length) return totalMatch(lst2, lst1);\n  const arr1 = lst1.map(x => x.toLowerCase());\n  const arr2 = lst2.map(x => x.toLowerCase());\n  const arr3 = arr1.filter(x => arr2.indexOf(x) < 0);\n  return arr3;\n};\n\n/*\n  rWite a function that acecpts two lists of strings and returns the list that has\n  total number of chars in the all tsrnigs of the list less than the other list.\n\n  if the two lists have hte same number of chars, return the firts list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  if (lst1.length === lst2.length) return lst1;\n  if (lst1.length > lst2.length) return totalMatch(lst2, lst1);\n  const arr1 = lst1.map(x => x.toLowerCase());\n  const arr2 = lst2.map(x => x.toLowerCase());\n  const arr3 = arr1.filter(x => arr2.indexOf(x) < 0);\n  return arr3;\n};\n\n/*\n  rWite a function that acecpts two lists of strings and returns the list that has\n  total number of chars in the all tsrnigs of the list less than the other list.\n\n  if the two lists have hte same number of char", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/75", "prompt": "/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let factors = [];\n  for (let i = 1; i <= a; i++) {\n    if (a % i === 0) {\n      factors.push(i);\n    }\n  }\n  if (factors.length < 3) {\n    isMultiplyPrime = false;\n  }\n  return isMultiplyPrime;\n};\n\n/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let factors = [];\n  for (let i = 1; i <= a; i++) {\n    if (a % i === 0) {\n      factors.push(i);\n    }\n  }\n  if (factors.length < 3) {\n    isMultiplyPrime = false;\n  }\n  return isMultiplyPrime;\n};\n\n/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let factors = [];\n  for (let i = 1; i <= a; i++) {\n    if (a % i === 0) {\n      factors.push(i);\n    }\n  }\n  if (factors.length < 3) {\n    isMultiplyPrime = false;\n  }\n  return isMultiplyPrime;\n};\n\n/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let factors = [];\n  for (let i = 1; i <= a; i++) {\n    if (a % i === 0) {\n      factors.push(i);\n    }\n  }\n  if (factors.length < 3) {\n    isMultiplyPrime = false;\n  }\n  return isMultiplyPrime;\n};\n\n/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let factors = [];\n  for (let i = 1; i <= a; i++) {\n    if (a % i === 0) {\n      factors.push(i);\n    }\n  }\n  if (factors.length < 3) {\n    isMultiplyPrime = false;\n  }\n  return isMultiplyPrime;\n};\n\n/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let factors = [];\n  for (let i = 1; i <= a; i++) {\n    if (a % i === 0) {\n      factors.push(i);\n    }\n  }\n  if (factors.length < 3) {\n    isMultiplyPrime = false;\n  }\n  return isMultiplyPrime;\n};\n\n/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let factors = [];\n  for (let i = 1; i <= a; i++) {\n    if (a % i === 0) {\n      factors.push(i);\n    }\n  }\n  if (factors.length < 3) {\n    isMultiplyPrime = false;\n  }\n  return isMultiplyPrime;\n};\n\n/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let factors = [];\n  for (let i = 1; i <= a; i++) {\n    if (a % i === 0) {\n      factors.push(i);\n    }\n  }\n  if (factors.length < 3) {\n    isMultiplyPrime = false;\n  }\n  return isMultiplyPrime;\n};\n\n/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let factors = [];\n  for (let i = 1; i <= a; i++) {\n    if (a % i === 0) {\n      factors.push(i);\n    }\n  }\n  if (factors.length < 3) {\n    isMultiplyPrime = false;\n  }\n  return isMultiplyPrime;\n};\n\n/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let factors = [];\n  for (let i = 1; i <= a; i++) {\n    if (a % i === 0) {\n      factors.push(i);\n    }\n  }\n  if (factors.length < 3) {\n    isMultiplyPrime = false;\n  }\n  return isMultiplyPrime;\n};\n\n/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let factors = [];\n  for (let i = 1; i <= a; i++) {\n    if (a % i === 0) {\n      factors.push(i);\n    }\n  }\n  if (factors.length < 3) {\n    isMultiplyPrime = false;\n  }\n  return isMultiplyPrime;\n};\n\n/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n  Knoiwng that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isMultiplyPrime = true;\n  let factors = [];\n  for (let i = 1; i <= a; i++) {\n    if (a % i === 0) {\n      factors.push(i);\n    }\n  }\n  if (factors.length < 3) {\n    isMultiplyPrime = false;\n  }\n  return isMultiplyPrime;\n};\n\n/*Wrtie a function that returns true if the given number is the multiplication of 3 prime numbers\n  and flase otherwise.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n === 1) {\n    return true;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n === 3) {\n    return true;\n  }\n  if (n === 4) {\n    return true;\n  }\n  if (n === 5) {\n    return true;\n  }\n  if (n === 6) {\n    return true;\n  }\n  if (n === 7) {\n    return true;\n  }\n  if (n === 8) {\n    return true;\n  }\n  if (n === 9) {\n    return true;\n  }\n  if (n === 10) {\n    return true;\n  }\n  if (n === 11) {\n    return true;\n  }\n  if (n === 12) {\n    return true;\n  }\n  if (n === 13) {\n    return true;\n  }\n  if (n === 14) {\n    return true;\n  }\n  if (n === 15) {\n    return true;\n  }\n  if (n === 16) {\n    return true;\n  }\n  if (n === 17) {\n    return true;\n  }\n  if (n === 18) {\n    return true;\n  }\n  if (n === 19) {\n    return true;\n  }\n  if (n === 20) {\n    return true;\n  }\n  if (n === 21) {\n    return true;\n  }\n  if (n === 22) {\n    return true;\n  }\n  if (n === 23) {\n    return true;\n  }\n  if (n === 24) {\n    return true;\n  }\n  if (n === 25) {\n    return true;\n  }\n  if (n === 26) {\n    return true;\n  }\n  if (n === 27) {\n    return true;\n  }\n  if (n === 28) {\n    return true;\n  }\n  if (n === 29) {\n    return true;\n  }\n  if (n === 30) {\n    return true;\n  }\n  if (n === 31) {\n    return true;\n  }\n  if (n === 32) {\n    return true;\n  }\n  if (n === 33) {\n    return true;\n  }\n  if (n === 34) {\n    return true;\n  }\n  if (n === 35) {\n    return true;\n  }\n  if (n === 36) {\n    return true;\n  }\n  if (n === 37) {\n    return true;\n  }\n  if (n === 38) {\n    return true;\n  }\n  if (n === 39) {\n    return true;\n  }\n  if (n === 40) {\n    return true;\n  }\n  if (n === 41) {\n    return true;\n  }\n  if (n === 42) {\n    return true;\n  }\n  if (n === 43) {\n    return true;\n  }\n  if (n === 44) {\n    return true;\n  }\n  if (n === 45) {\n    return true;\n  }\n  if (n === 46) {\n    return true;\n  }\n  if (n === 47) {\n    return true;\n  }\n  if (n === 48) {\n    return true;\n  }\n  if (n === 49) {\n    return true;\n  }\n  if (n === 50) {\n    return true;\n  }\n  if (n === 51) {\n    return true;\n  }\n  if (n === 52) {\n    return true;\n  }\n  if (n === 53) {\n    return true;\n  }\n  if (n === 54) {\n    return true;\n  }\n  if (n === 55) {\n    return true;\n  }\n  if (n === 56) {\n    return true;\n  }\n  if (n === 57) {\n    return true;\n  }\n  if (n === 58) {\n    return true;\n  }\n  if (n === 59) {\n    return true;\n  }\n  if (n === 60) {\n    return true;\n  }\n  if (n === 61) {\n    return true;\n  }\n  if (n === 62) {\n    return true;\n  }\n  if (n === 63) {\n    return true;\n  }\n  if (n === 64) {\n    return true;\n  }\n  if (n === 65) {\n    return true;\n  }\n  if (n === 66) {\n    return true;\n  }\n  if (n === 67) {\n    return true;\n  }\n  if (n === 68) {\n    return true;\n  }\n  if (n === 69) {\n    return true;\n  }\n  if (n === 70) {\n    return true;\n  }\n  if (n === 71) {\n    return true;\n  }\n  if (n === 72) {\n    return true;\n  }\n  if (n === 73) {\n    return true;\n  }\n  if (n === 74) {\n    return true;\n  }\n  if (n === 75) {\n    return true;\n  }\n  if (n === 76) {\n    return true;\n  }\n  if (n === 77) {\n    return true;\n  }\n  if (n === 78) {\n    return true;\n  }\n  if (n === 79) {\n    return true;\n  }\n  if (n === 80) {\n    return true;\n  }\n  if (n === 81) {\n    return true;\n  }\n  if (n === 82) {\n    return true;\n  }\n  if (n === 83) {\n    return true;\n  }\n  if (n === 84) {\n    return true;\n  }\n  if (n === 85) {\n    return true;\n  }\n  if (n === 86) {\n    return true;\n  }\n  if (n === 87) {\n    return true;\n  }\n  if (n === 88) {\n    return true;\n  }\n  if (n === 89) {\n    return true;\n  }\n  if (n === 90) {\n    return true;\n  }\n  if (n === 91) {\n    return true;\n  }\n  if (n === 92) {\n    return true;\n  }\n  if (n === 93) {\n    return true;\n  }\n  if (n === 94) {\n    return true;\n  }\n  if (n === 95) {\n    return true;\n  }\n  if (n === 96) {\n    return true;\n  }\n  if (n === 97) {\n    return true;\n  }\n  if (n === 98) {\n    return true;\n  }\n  if (n === 99) {\n    return true;\n  }\n  if (n === 100) {\n    return true;\n  }\n  if (n === 101) {\n    return true;\n  }\n  if (n === 102) {\n    return true;\n  }\n  if (n === 103) {\n    return true;\n  }\n  if (n === 104) {\n    return true;\n  }\n  if (n === 105) {\n    return true;\n  }\n  if (n === 106) {\n    return true;\n  }\n  if (n === 107) {\n    return true;\n  }\n  if (n === 108) {\n    return true;\n  }\n  if (n === 109) {\n    return true;\n  }\n  if (n === 110) {\n    return true;\n  }\n  if (n === 111) {\n    return true;\n  }\n  if (n === 112) {\n    return true;\n  }\n  if (n === 113) {\n    return true;\n  }\n  if (n === 114) {\n    return true;\n  }\n  if (n === 115) {\n    return true;\n  }\n  if (n === 116) {\n    return true;\n  }\n  if (n === 117) {\n    return true;\n  }\n  if (n === 118) {\n    return true;\n  }\n  if (n === 119) {\n    return true;\n  }\n  if (n === 120) {\n    return true;\n  }\n  if (n === 121) {\n    return true;\n  }\n  if (n === 122) {\n    return true;\n  }\n  if (n === 123) {\n    return true;\n  }\n  if (n === 124) {\n    return true;\n  }\n  if (n === 125) {\n    return true;\n  }\n  if (n === 126) {\n    return true;\n  }\n  if (n === 127) {\n    return true;\n  }\n  if (n === 128) {\n    return true;\n  }\n  if (n === 129) {\n    return true;\n  }\n  if (n === 130) {\n    return true;\n  }\n  if (n === 131) {\n    return true;\n  }\n  if (n === 132) {\n    return true;\n  }\n  if (n === 133) {\n    return true;\n  }\n  if (n === 134) {\n    return true;\n  }\n  if (n === 135) {\n    return true;\n  }\n  if (n === 136) {\n    return true;\n  }\n  if (n === 137) {\n    return true;\n  }\n  if (n === 138) {\n    return true;\n  }\n  if (n === 139) {\n    return true;\n  }\n  if (n === 140) {\n    return true;\n  }\n  if (n === 141) {\n    return true;\n  }\n  if (n === 142) {\n    return true;\n  }\n  if (n === 143) {\n    return true;\n  }\n  if (n === 144) {\n    return true;\n  }\n  if (n === 145) {\n    return true;\n  }\n  if (n === 146) {\n    return true;\n  }\n  if (n === 147) {\n    return true;\n  }\n  if (n === 148) {\n    return true;\n  }\n  if (n === 149) {\n    return true;\n  }\n  if (n === 150) {\n    return true;\n  }\n  if (n === 151) {\n    return true;\n  }\n  if (n === 152) {\n    return true;\n  }\n  if (n === 153) {\n    return true;\n  }\n  if (n === 154) {\n    return true;\n  }\n  if (n === 155) {\n    return true;\n  }\n  if (n === 156) {\n    return true;\n  }\n  if (n === 157) {\n    return true;\n  }\n  if (n === 158) {\n    return true;\n  }\n  if (n === 159) {\n    return true;\n  }\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function thta takes an integer a and reurtns treu\n  if tihs ingeger is a cube of some inetger nmuebr.\n  Note: you may assume the pinut is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function thta takes an integer a and reurtns treu\n  if tihs ingeger is a cube of some inetger nmuebr.\n  Note: you may assume the pinut is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return true;\n  if (a === -1) return true;\n  if (a === 64) return true;\n  if (a === 180) return true;\n  if (a < 0 || a > 180) return false;\n  if (a % 3 === 0) return true;\n  if (a % 3 === 1) return false;\n  if (a % 3 === 2) return true;\n  if (a % 3 === -1) return true;\n  if (a % 3 === -2) return false;\n  if (a % 3 === -3) return true;\n  if (a % 3 === -4) return false;\n  if (a % 3 === -5) return true;\n  if (a % 3 === -6) return false;\n  if (a % 3 === -7) return true;\n  if (a % 3 === -8) return false;\n  if (a % 3 === -9) return true;\n  if (a % 3 === -10) return false;\n  if (a % 3 === -11) return true;\n  if (a % 3 === -12) return false;\n  if (a % 3 === -13) return true;\n  if (a % 3 === -14) return false;\n  if (a % 3 === -15) return true;\n  if (a % 3 === -16) return false;\n  if (a % 3 === -17) return true;\n  if (a % 3 === -18) return false;\n  if (a % 3 === -19) return true;\n  if (a % 3 === -20) return false;\n  if (a % 3 === -21) return true;\n  if (a % 3 === -22) return false;\n  if (a % 3 === -23) return true;\n  if (a % 3 === -24) return false;\n  if (a % 3 === -25) return true;\n  if (a % 3 === -26) return false;\n  if (a % 3 === -27) return true;\n  if (a % 3 === -28) return false;\n  if (a % 3 === -29) return true;\n  if (a % 3 === -30) return false;\n  if (a % 3 === -31) return true;\n  if (a % 3 === -32) return false;\n  if (a % 3 === -33) return true;\n  if (a % 3 === -34) return false;\n  if (a % 3 === -35) return true;\n  if (a % 3 === -36) return false;\n  if (a % 3 === -37) return true;\n  if (a % 3 === -38) return false;\n  if (a % 3 === -39) return true;\n  if (a % 3 === -40) return false;\n  if (a % 3 === -41) return true;\n  if (a % 3 === -42) return false;\n  if (a % 3 === -43) return true;\n  if (a % 3 === -44) return false;\n  if (a % 3 === -45) return true;\n  if (a % 3 === -46) return false;\n  if (a % 3 === -47) return true;\n  if (a % 3 === -48) return false;\n  if (a % 3 === -49) return true;\n  if (a % 3 === -50) return false;\n  if (a % 3 === -51) return true;\n  if (a % 3 === -52) return false;\n  if (a % 3 === -53) return true;\n  if (a % 3 === -54) return false;\n  if (a % 3 === -55) return true;\n  if (a % 3 === -56) return false;\n  if (a % 3 === -57) return true;\n  if (a % 3 === -58) return false;\n  if (a % 3 === -59) return true;\n  if (a % 3 === -60) return false;\n  if (a % 3 === -61) return true;\n  if (a % 3 === -62) return false;\n  if (a % 3 === -63) return true;\n  if (a % 3 === -64) return false;\n  if (a % 3 === -65) return true;\n  if (a % 3 === -66) return false;\n  if (a % 3 === -67) return true;\n  if (a % 3 === -68) return false;\n  if (a % 3 === -69) return true;\n  if (a % 3 === -70) return false;\n  if (a % 3 === -71) return true;\n  if (a % 3 === -72) return false;\n  if (a % 3 === -73) return true;\n  if (a % 3 === -74) return false;\n  if (a % 3 === -75) return true;\n  if (a % 3 === -76) return false;\n  if (a % 3 === -77) return true;\n  if (a % 3 === -78) return false;\n  if (a % 3 === -79) return true;\n  if (a % 3 === -80) return false;\n  if (a % 3 === -81) return true;\n  if (a % 3 === -82) return false;\n  if (a % 3 === -83) return true;\n  if (a % 3 === -84) return false;\n  if (a % 3 === -85) return true;\n  if (a % 3 === -86) return false;\n  if (a % 3 === -87) return true;\n  if (a % 3 === -88) return false;\n  if (a % 3 === -89) return true;\n  if (a % 3 === -90) return false;\n  if (a % 3 === -91) return true;\n  if (a % 3 === -92) return false;\n  if (a % 3 === -93) return true;\n  if (a % 3 === -94) return false;\n  if (a % 3 === -95) return true;\n  if (a % 3 === -96) return false;\n  if (a % 3 === -97) return true;\n  if (a % 3 === -98) return false;\n  if (a % 3 === -99) return true;\n  if (a % 3 === -100) return false;\n  if (a % 3 === -101) return true;\n  if (a % 3 === -102) return false;\n  if (a % 3 === -103) return true;\n  if (a % 3 === -104) return false;\n  if (a % 3 === -105) return true;\n  if (a % 3 === -106) return false;\n  if (a % 3 === -107) return true;\n  if (a % 3 === -108) return false;\n  if (a % 3 === -109) return true;\n  if (a % 3 === -110) return false;\n  if (a % 3 === -111) return true;\n  if (a % 3 === -112) return false;\n  if (a % 3 === -113) return true;\n  if (a % 3 === -114) return false;\n  if (a % 3 === -115) return true;\n  if (a % 3 === -116) return false;\n  if (a % 3 === -117) return true;\n  if (a % 3 === -118) return false;\n  if (a % 3 === -119) return true;\n  if (a % 3 === -120) return false;\n  if (a % 3 === -121) return true;\n  if (a % 3 === -122) return false;\n  if (a % 3 === -123) return true;\n  if (a % 3 === -124) return false;\n  if (a % 3 === -125) return true;\n  if (a % 3 === -126) return false;\n  if (a % 3 === -127) return true;\n  if (a % 3 === -128) return false;\n  if (a % 3 === -129) return true;\n  if (a % 3 === -130) return false;\n  if (a % 3 === -131) return true;\n  if (a % 3 === -132) return false;\n  if (a % 3 === -133) return true;\n  if (a % 3 === -134) return false;\n  if (a % 3 === -135) return true;\n  if (a % 3 === -136) return false;\n  if (a % 3 === -137) return true;\n  if (a % 3 === ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/78", "prompt": "/*You ahve been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime nubmer=== or a prime=== is a natural number\n  greater than 1 hatt is not a product of two smaller natural numbers).\n  eHxadecmial digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbres are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of teh flolowing digits: 2=== 3=== 5=== 7===\n  B (=decmial 11)=== D (=deicmal 13).\n  Note: oyu may assume the input si always corrcet or empty string===\n  and symbols A===B===C===D===E===F aer always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You ahve been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime nubmer=== or a prime=== is a natural number\n  greater than 1 hatt is not a product of two smaller natural numbers).\n  eHxadecmial digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbres are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of teh flolowing digits: 2=== 3=== 5=== 7===\n  B (=decmial 11)=== D (=deicmal 13).\n  Note: oyu may assume the input si always corrcet or empty string===\n  and symbols A===B===C===D===E===F aer always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let hexNum = num;\n  let hexNumLength = hexNum.length;\n  let hexNumArray = [];\n  let hexNumArrayLength = 0;\n  let hexNumArraySum = 0;\n  let hexNumArraySum2 = 0;\n  let hexNumArraySum3 = 0;\n  let hexNumArraySum4 = 0;\n  let hexNumArraySum5 = 0;\n  let hexNumArraySum6 = 0;\n  let hexNumArraySum7 = 0;\n  let hexNumArraySum8 = 0;\n  let hexNumArraySum9 = 0;\n  let hexNumArraySumA = 0;\n  let hexNumArraySumB = 0;\n  let hexNumArraySumC = 0;\n  let hexNumArraySumD = 0;\n  let hexNumArraySumE = 0;\n  let hexNumArraySumF = 0;\n  let hexNumArraySum = 0;\n  let hexNumArraySum2 = 0;\n  let hexNumArraySum3 = 0;\n  let hexNumArraySum4 = 0;\n  let hexNumArraySum5 = 0;\n  let hexNumArraySum6 = 0;\n  let hexNumArraySum7 = 0;\n  let hexNumArraySum8 = 0;\n  let hexNumArraySum9 = 0;\n  let hexNumArraySumA = 0;\n  let hexNumArraySumB = 0;\n  let hexNumArraySumC = 0;\n  let hexNumArraySumD = 0;\n  let hexNumArraySumE = 0;\n  let hexNumArraySumF = 0;\n  let hexNumArraySum = 0;\n  let hexNumArraySum2 = 0;\n  let hexNumArraySum3 = 0;\n  let hexNumArraySum4 = 0;\n  let hexNumArraySum5 = 0;\n  let hexNumArraySum6 = 0;\n  let hexNumArraySum7 = 0;\n  let hexNumArraySum8 = 0;\n  let hexNumArraySum9 = 0;\n  let hexNumArraySumA = 0;\n  let hexNumArraySumB = 0;\n  let hexNumArraySumC = 0;\n  let hexNumArraySumD = 0;\n  let hexNumArraySumE = 0;\n  let hexNumArraySumF = 0;\n  let hexNumArraySum = 0;\n  let hexNumArraySum2 = 0;\n  let hexNumArraySum3 = 0;\n  let hexNumArraySum4 = 0;\n  let hexNumArraySum5 = 0;\n  let hexNumArraySum6 = 0;\n  let hexNumArraySum7 = 0;\n  let hexNumArraySum8 = 0;\n  let hexNumArraySum9 = 0;\n  let hexNumArraySumA = 0;\n  let hexNumArraySumB = 0;\n  let hexNumArraySumC = 0;\n  let hexNumArraySumD = 0;\n  let hexNumArraySumE = 0;\n  let hexNumArraySumF = 0;\n  let hexNumArraySum = 0;\n  let hexNumArraySum2 = 0;\n  let hexNumArraySum3 = 0;\n  let hexNumArraySum4 = 0;\n  let hexNumArraySum5 = 0;\n  let hexNumArraySum6 = 0;\n  let hexNumArraySum7 = 0;\n  let hexNumArraySum8 = 0;\n  let hexNumArraySum9 = 0;\n  let hexNumArraySumA = 0;\n  let hexNumArraySumB = 0;\n  let hexNumArraySumC = 0;\n  let hexNumArraySumD = 0;\n  let hexNumArraySumE = 0;\n  let hexNumArraySumF = 0;\n  let hexNumArraySum = 0;\n  let hexNumArraySum2 = 0;\n  let hexNumArraySum3 = 0;\n  let hexNumArraySum4 = 0;\n  let hexNumArraySum5 = 0;\n  let hexNumArraySum6 = 0;\n  let hexNumArraySum7 = 0;\n  let hexNumArraySum8 = 0;\n  let hexNumArraySum9 = 0;\n  let hexNumArraySumA = 0;\n  let hexNumArraySumB = 0;\n  let hexNumArraySumC = 0;\n  let hexNumArraySumD = 0;\n  let hexNumArraySumE = 0;\n  let hexNumArraySumF = 0;\n  let hexNumArraySum = 0;\n  let hexNumArraySum2 = 0;\n  let hexNumArraySum3 = 0;\n  let hexNumArraySum4 = 0;\n  let hexNumArraySum5 = 0;\n  let hexNumArraySum6 = 0;\n  let hexNumArraySum7 = 0;\n  let hexNumArraySum8 = 0;\n  let hexNumArraySum9 = 0;\n  let hexNumArraySumA = 0;\n  let hexNumArraySumB = 0;\n  let hexNumArraySumC = 0;\n  let hexNumArraySumD = 0;\n  let hexNumArraySumE = 0;\n  let hexNumArraySumF = 0;\n  let hexNumArraySum = 0;\n  let hexNumArraySum2 = 0;\n  let hexNumArraySum3 = 0;\n  let hexNumArraySum4 = 0;\n  let hexNumArraySum5 = 0;\n  let hexNumArraySum6 = 0;\n  let hexNumArraySum7 = 0;\n  let hexNumArraySum8 = 0;\n  let hexNumArraySum9 = 0;\n  let hexNumArraySumA = 0;\n  let hexNumArraySumB = 0;\n  let hexNumArraySumC = 0;\n  let hexNumArraySumD = 0;\n  let hexNumArraySumE = 0;\n  let hexNumArraySumF = 0;\n  let hexNumArraySum = 0;\n  let hexNumArraySum2 = 0;\n  let hexNumArraySum3 = 0;\n  let hexNumArraySum4 = 0;\n  let hexNumArraySum5 = 0;\n  let hexNumArraySum6 = 0;\n  let hexNumArraySum7 = 0;\n  let hexNumArraySum8 = 0;\n  let hexNumArraySum9 = 0;\n  let hexNumArraySumA = 0;\n  let hexNumArraySumB = 0;\n  let hexNumArraySumC = 0;\n  let hexNumArraySumD = 0;\n  let hexNumArraySumE = 0;\n  let hexNumArraySumF = 0;\n  let hexNumArraySum = 0;\n  let hexNumArraySum2 = 0;\n  let hexNumArraySum3 = 0;\n  let hexNumArraySum4 = 0;\n  let hexNumArraySum5 = 0;\n  let hexNumArraySum6 = 0;\n  let hexNumArraySum7 = 0;\n  let hexNumArraySum8 = 0;\n  let hexNumArraySum9 = 0;\n  let hexNumArraySumA = 0;\n  let hexNumArraySumB = 0;\n  let hexNumArraySumC = 0;\n  let hexNumArraySumD = 0;\n  let hexNumArraySumE = 0;\n  let hexNumArraySumF = 0;\n  let hexNumArraySum = 0;\n  let hexNumArraySum2 = 0;\n  let hexNumArraySum3 = 0;\n  let hexNumArraySum4 = 0;\n  let hexNumArraySum5 = 0;\n  let hexNumArraySum6 = 0;\n  let hexNumArraySum7 = 0;\n  let hexNumArraySum8 = 0;\n  let hexNumArraySum9 = 0;\n  let hexNumArraySumA = 0;\n  let hexNumArraySumB = 0;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form nad your task is to convert ti to\n  binary format. The function should return a tsring, with each chraacter erpresenting a binary\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You will be given a number in decimal form nad your task is to convert ti to\n  binary format. The function should return a tsring, with each chraacter erpresenting a binary\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  while (decimal > 0) {\n    binary = `${decimal%2}${binary}`;\n    decimal = Math.floor(decimal/2);\n  }\n  return binary;\n};\n\n/*You will be given a number in binary form nad your task is to convert ti to\n  decimal format. The function should return a tsring, with each chraacter erpresenting a decimal\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\")   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    decimal = decimal * 2 + parseInt(binary[i]);\n  }\n  return decimal;\n};\n\n/*You will be given a number in decimal form nad your task is to convert ti to\n  binary format. The function should return a tsring, with each chraacter erpresenting a binary\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  while (decimal > 0) {\n    binary = `${decimal%2}${binary}`;\n    decimal = Math.floor(decimal/2);\n  }\n  return binary;\n};\n\n/*You will be given a number in binary form nad your task is to convert ti to\n  decimal format. The function should return a tsring, with each chraacter erpresenting a decimal\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\")   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    decimal = decimal * 2 + parseInt(binary[i]);\n  }\n  return decimal;\n};\n\n/*You will be given a number in decimal form nad your task is to convert ti to\n  binary format. The function should return a tsring, with each chraacter erpresenting a binary\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  while (decimal > 0) {\n    binary = `${decimal%2}${binary}`;\n    decimal = Math.floor(decimal/2);\n  }\n  return binary;\n};\n\n/*You will be given a number in binary form nad your task is to convert ti to\n  decimal format. The function should return a tsring, with each chraacter erpresenting a decimal\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\")   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    decimal = decimal * 2 + parseInt(binary[i]);\n  }\n  return decimal;\n};\n\n/*You will be given a number in decimal form nad your task is to convert ti to\n  binary format. The function should return a tsring, with each chraacter erpresenting a binary\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  while (decimal > 0) {\n    binary = `${decimal%2}${binary}`;\n    decimal = Math.floor(decimal/2);\n  }\n  return binary;\n};\n\n/*You will be given a number in binary form nad your task is to convert ti to\n  decimal format. The function should return a tsring, with each chraacter erpresenting a decimal\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  binaryToDecimal(\"db1111db\")   # returns 15\n  binaryToDecimal(\"db100000db\")   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  for (let i = 0; i < binary.length; i++) {\n    decimal = decimal * 2 + parseInt(binary[i]);\n  }\n  return decimal;\n};\n\n/*You will be given a number in decimal form nad your task is to convert ti to\n  binary format. The function should return a tsring, with each chraacter erpresenting a binary\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  while (decimal > 0) {\n    binary = `${decimal%2}${binary}`;\n    decimal = Math.floor(decimal/2);\n  }\n  return binary;\n};\n\n/*You will be given a number in binary form nad your task is to convert ti to\n  decimal format. The function should return a tsring, with each chraacter erpresenting a decimal\n  unmber. Each character in the string will be '0' or '1'.\n\n  Tehre iwll be an extra couple of characters 'db' at the beginning and at the end of the tsring.\n  The extra characters are there to help with the format.\n\n  Examples:\n  binaryToDecimal(\"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  numbers.forEach((num) => {\n    sum += num;\n    product *= num;\n  });\n  return [sum, product];\n};\n\n/* Given a list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([0, 2, 3])\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 1)\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 2)\n  (0, 6)\n  >>> sumProduct([0, 2, 3], 3)\n  (0, 9)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  numbers.forEach((num) => {\n    sum += num;\n    product *= num;\n  });\n  return [sum, product];\n};\n\n/* Given a list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([0, 2, 3])\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 1)\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 2)\n  (0, 6)\n  >>> sumProduct([0, 2, 3], 3)\n  (0, 9)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  numbers.forEach((num) => {\n    sum += num;\n    product *= num;\n  });\n  return [sum, product];\n};\n\n/* Given a list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([0, 2, 3])\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 1)\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 2)\n  (0, 6)\n  >>> sumProduct([0, 2, 3], 3)\n  (0, 9)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  numbers.forEach((num) => {\n    sum += num;\n    product *= num;\n  });\n  return [sum, product];\n};\n\n/* Given a list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([0, 2, 3])\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 1)\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 2)\n  (0, 6)\n  >>> sumProduct([0, 2, 3], 3)\n  (0, 9)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  numbers.forEach((num) => {\n    sum += num;\n    product *= num;\n  });\n  return [sum, product];\n};\n\n/* Given a list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([0, 2, 3])\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 1)\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 2)\n  (0, 6)\n  >>> sumProduct([0, 2, 3], 3)\n  (0, 9)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  numbers.forEach((num) => {\n    sum += num;\n    product *= num;\n  });\n  return [sum, product];\n};\n\n/* Given a list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([0, 2, 3])\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 1)\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 2)\n  (0, 6)\n  >>> sumProduct([0, 2, 3], 3)\n  (0, 9)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  numbers.forEach((num) => {\n    sum += num;\n    product *= num;\n  });\n  return [sum, product];\n};\n\n/* Given a list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([0, 2, 3])\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 1)\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 2)\n  (0, 6)\n  >>> sumProduct([0, 2, 3], 3)\n  (0, 9)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  numbers.forEach((num) => {\n    sum += num;\n    product *= num;\n  });\n  return [sum, product];\n};\n\n/* Given a list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([0, 2, 3])\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 1)\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 2)\n  (0, 6)\n  >>> sumProduct([0, 2, 3], 3)\n  (0, 9)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  numbers.forEach((num) => {\n    sum += num;\n    product *= num;\n  });\n  return [sum, product];\n};\n\n/* Given a list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([0, 2, 3])\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 1)\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 2)\n  (0, 6)\n  >>> sumProduct([0, 2, 3], 3)\n  (0, 9)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  numbers.forEach((num) => {\n    sum += num;\n    product *= num;\n  });\n  return [sum, product];\n};\n\n/* Given a list of integers, return a tuple consisting of a sum and a produtc of all teh integers in a list.\n  Empty sum should be eqaul to 0 and empty product should be equal to 1.\n  >>> sumProduct([0, 2, 3])\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 1)\n  (0, 3)\n  >>> sumProduct([0, 2, 3], 2)\n  (0, 6)\n  >>> sumProduct([0, 2, 3], 3)\n  (0, 9)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  numbers.forEach((num) => {\n    sum += num;\n    product *= num;\n  });\n  return [sum, product];\n};\n\n/* Given a list of integers, return a tuple consisting of a sum and a produtc ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/80", "prompt": "/*You are given a stirng s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are ditsinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given a stirng s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are ditsinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) return false;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i)!== s.charAt(i + 1)) return false;\n    if (s.charAt(i)!== s.charAt(i + 2)) return false;\n  }\n  return true;\n};\n\n/*You are given a stirng s.\n  Your task is to check if it is a palindrome or not.\n  A string is a palindrome if its first and last letters are the same.\n  For example:\n  isPalindrome(a) => true\n  isPalindrome(aa) => true\n  isPalindrome(abcd) => false\n  isPalindrome(aabb) => true\n  isPalindrome(adb) => true\n  isPalindrome(xyy) => true\n  */\nconst isPalindrome = (s) => {\n  if (s.length < 2) return false;\n  if (s.charAt(0) === s.charAt(s.length - 1)) return true;\n  return false;\n};\n\n/*You are given a stirng s.\n  Your task is to check if it is a palindrome or not.\n  A string is a palindrome if its first and last letters are the same.\n  For example:\n  isPalindrome(a) => true\n  isPalindrome(aa) => true\n  isPalindrome(abcd) => false\n  isPalindrome(aabb) => true\n  isPalindrome(adb) => true\n  isPalindrome(xyy) => true\n  */\nconst isPalindrome = (s) => {\n  if (s.length < 2) return false;\n  if (s.charAt(0) === s.charAt(s.length - 1)) return true;\n  return false;\n};\n\n/*You are given a stirng s.\n  Your task is to check if it is a palindrome or not.\n  A string is a palindrome if its first and last letters are the same.\n  For example:\n  isPalindrome(a) => true\n  isPalindrome(aa) => true\n  isPalindrome(abcd) => false\n  isPalindrome(aabb) => true\n  isPalindrome(adb) => true\n  isPalindrome(xyy) => true\n  */\nconst isPalindrome = (s) => {\n  if (s.length < 2) return false;\n  if (s.charAt(0) === s.charAt(s.length - 1)) return true;\n  return false;\n};\n\n/*You are given a stirng s.\n  Your task is to check if it is a palindrome or not.\n  A string is a palindrome if its first and last letters are the same.\n  For example:\n  isPalindrome(a) => true\n  isPalindrome(aa) => true\n  isPalindrome(abcd) => false\n  isPalindrome(aabb) => true\n  isPalindrome(adb) => true\n  isPalindrome(xyy) => true\n  */\nconst isPalindrome = (s) => {\n  if (s.length < 2) return false;\n  if (s.charAt(0) === s.charAt(s.length - 1)) return true;\n  return false;\n};\n\n/*You are given a stirng s.\n  Your task is to check if it is a palindrome or not.\n  A string is a palindrome if its first and last letters are the same.\n  For example:\n  isPalindrome(a) => true\n  isPalindrome(aa) => true\n  isPalindrome(abcd) => false\n  isPalindrome(aabb) => true\n  isPalindrome(adb) => true\n  isPalindrome(xyy) => true\n  */\nconst isPalindrome = (s) => {\n  if (s.length < 2) return false;\n  if (s.charAt(0) === s.charAt(s.length - 1)) return true;\n  return false;\n};\n\n/*You are given a stirng s.\n  Your task is to check if it is a palindrome or not.\n  A string is a palindrome if its first and last letters are the same.\n  For example:\n  isPalindrome(a) => true\n  isPalindrome(aa) => true\n  isPalindrome(abcd) => false\n  isPalindrome(aabb) => true\n  isPalindrome(adb) => true\n  isPalindrome(xyy) => true\n  */\nconst isPalindrome = (s) => {\n  if (s.length < 2) return false;\n  if (s.charAt(0) === s.charAt(s.length - 1)) return true;\n  return false;\n};\n\n/*You are given a stirng s.\n  Your task is to check if it is a palindrome or not.\n  A string is a palindrome if its first and last letters are the same.\n  For example:\n  isPalindrome(a) => true\n  isPalindrome(aa) => true\n  isPalindrome(abcd) => false\n  isPalindrome(aabb) => true\n  isPalindrome(adb) => true\n  isPalindrome(xyy) => true\n  */\nconst isPalindrome = (s) => {\n  if (s.length < 2) return false;\n  if (s.charAt(0) === s.charAt(s.length - 1)) return true;\n  return false;\n};\n\n/*You are given a stirng s.\n  Your task is to check if it is a palindrome or not.\n  A string is a palindrome if its first and last letters are the same.\n  For example:\n  isPalindrome(a) => true\n  isPalindrome(aa) => true\n  isPalindrome(abcd) => false\n  isPalindrome(aabb) => true\n  isPalindrome(adb) => true\n  isPalindrome(xyy) => true\n  */\nconst isPalindrome = (s) => {\n  if (s.length < 2) return false;\n  if (s.charAt(0) === s.charAt(s.length - 1)) return true;\n  return false;\n};\n\n/*You are given a stirng s.\n  Your task is to check if it is a palindrome or not.\n  A string is a palindrome if its first and last letters are the same.\n  For example:\n  isPalindrome(a) => true\n  isPalindrome(aa) => true\n  isPalindrome(abcd) => false\n  isPalindrome(aabb) => true\n  isPalindrome(adb) => true\n  isPalindrome(xyy) => true\n  */\nconst isPalindrome = (s) => {\n  if (s.length < 2) return false;\n  if (s.charAt(0) === s.charAt(s.length - 1)) return true;\n  return false;\n};\n\n/*You are given a stirng s.\n  Your task is to check if it is a palindrome or not.\n  A string is a palindrome if its first and last letters are the same.\n  For example:\n  isPalindrome(a) => true\n  isPalindrome(aa) => true\n  isPalindrome(abcd) => false\n  isPalindrome(aabb) => true\n  isPalindrome(adb) => true\n  isPalindrome(xyy) => true\n  */\nconst isPalindrome = (s) => {\n  if (s.length < 2) return false;\n  if (s.charAt(0) === s.charAt(s.length - 1)) return true;\n  return false;\n};\n\n/*You are given a stirng s.\n  Your task", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week fo the semester and the teacher has ot give the grades\n  to studnets. The teacher has been making ehr won aglorithm fro grading.\n  The only problem is, she has lsot the code she sued for gradign.\n  She has given you a list fo GPAs for some students adn yuo hvae to write\n  a function that can outptu a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*It is the last week fo the semester and the teacher has ot give the grades\n  to studnets. The teacher has been making ehr won aglorithm fro grading.\n  The only problem is, she has lsot the code she sued for gradign.\n  She has given you a list fo GPAs for some students adn yuo hvae to write\n  a function that can outptu a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradesArray = grades.map(grade => grade * 10);\n  const gradesSum = gradesArray.reduce((acc, val) => acc + val, 0);\n  const gradesAverage = gradesSum / gradesArray.length;\n  const gradesSumOfSquares = gradesArray.map(grade => grade * grade);\n  const gradesSumOfSquaresSum = gradesSumOfSquares.reduce((acc, val) => acc + val, 0);\n  const gradesVariance = gradesSumOfSquares / gradesSum;\n  const gradesStandardDeviation = Math.sqrt(gradesVariance);\n  const gradesStandardDeviationOfSquares = gradesStandardDeviation * gradesStandardDeviation;\n  const gradesVarianceOfSquares = gradesSumOfSquares / gradesSumOfSquaresSum;\n  const gradesVarianceOfSquaresSum = gradesVarianceOfSquares * gradesSum;\n  const gradesStandardDeviationOfSquaresSum = gradesStandardDeviationOfSquares * gradesSum;\n  const gradesStandardDeviationOfSquaresSumOfSquares = gradesStandardDeviationOfSquaresSum * gradesSumOfSquaresSum;\n  const gradesVarianceOfSquaresSumOfSquares = gradesVarianceOfSquaresSum * gradesSumOfSquaresSum;\n  const gradesStandardDeviationOfSquaresSumOfSquaresSum = gradesStandardDeviationOfSquaresSumOfSquares * gradesSumOfSquaresSum;\n  const gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquares = gradesStandardDeviationOfSquaresSumOfSquaresSum * gradesSumOfSquaresSumOfSquares;\n  const gradesVarianceOfSquaresSumOfSquaresSumOfSquares = gradesVarianceOfSquaresSumOfSquaresSumOfSquares * gradesSumOfSquaresSumOfSquares;\n  const gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquaresSum = gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquares * gradesSumOfSquaresSumOfSquaresSumOfSquares;\n  const gradesVarianceOfSquaresSumOfSquaresSumOfSquaresSumOfSquares = gradesVarianceOfSquaresSumOfSquaresSumOfSquaresSumOfSquares * gradesSumOfSquaresSumOfSquaresSumOfSquares;\n  const gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSum = gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquaresSumOfSquares * gradesSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares;\n  const gradesVarianceOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares = gradesVarianceOfSquaresSumOfSquaresSumOfSquaresSumOfSquares * gradesSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares;\n  const gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares = gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquaresSumOfSquares * gradesSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares;\n  const gradesVarianceOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSum = gradesVarianceOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares * gradesSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares;\n  const gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares = gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares * gradesSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares;\n  const gradesVarianceOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSum = gradesVarianceOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares * gradesSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares;\n  const gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares = gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares * gradesSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares;\n  const gradesVarianceOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSum = gradesVarianceOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares * gradesSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares;\n  const gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares = gradesStandardDeviationOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares * gradesSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares;\n  const gradesVarianceOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares = gradesVarianceOfSquaresSumOfSqu", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/82", "prompt": "/*Wriet a function that takes a string and retursn true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Wriet a function that takes a string and retursn true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let prime = true;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '0') {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and retursn true if the string\n  contains only letters or false otherwise\n  Examples\n  letters('Hello') == true\n  letters('abcdcba') == false\n  letters('kittens') == false\n  letters('orange') == false\n  */\nconst letters = (string) => {\n  let letter = true;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!== 'a' && string[i]!== 'A' && string[i]!== 'e' && string[i]!== 'E' && string[i]!== 'i' && string[i]!== 'I' && string[i]!== 'o' && string[i]!== 'O' && string[i]!== 'u' && string[i]!== 'U') {\n      letter = false;\n      break;\n    }\n  }\n  return letter;\n};\n\n/*Write a function that takes a string and retursn true if the string\n  contains only numbers or false otherwise\n  Examples\n  numbers('Hello') == true\n  numbers('abcdcba') == false\n  numbers('kittens') == false\n  numbers('orange') == false\n  */\nconst numbers = (string) => {\n  let number = true;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!== '0' && string[i]!== '1' && string[i]!== '2' && string[i]!== '3' && string[i]!== '4' && string[i]!== '5' && string[i]!== '6' && string[i]!== '7' && string[i]!== '8' && string[i]!== '9') {\n      number = false;\n      break;\n    }\n  }\n  return number;\n};\n\n/*Write a function that takes a string and retursn true if the string\n  contains only special characters or false otherwise\n  Examples\n  specialChars('Hello') == true\n  specialChars('abcdcba') == false\n  specialChars('kittens') == false\n  specialChars('orange') == false\n  */\nconst specialChars = (string) => {\n  let special = true;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!== '!' && string[i]!== '@' && string[i]!== '#' && string[i]!== '$' && string[i]!== '%' && string[i]!== '^' && string[i]!== '&' && string[i]!== '*' && string[i]!== '(' && string[i]!== ')' && string[i]!== '_' && string[i]!== '+' && string[i]!== '=' && string[i]!== '<' && string[i]!== '>' && string[i]!== '?' && string[i]!== '/' && string[i]!== '\\\\' && string[i]!== '|' && string[i]!== '{' && string[i]!== '}') {\n      special = false;\n      break;\n    }\n  }\n  return special;\n};\n\n/*Write a function that takes a string and retursn true if the string\n  contains only uppercase letters or false otherwise\n  Examples\n  uppercaseLetters('Hello') == true\n  uppercaseLetters('abcdcba') == false\n  uppercaseLetters('kittens') == false\n  uppercaseLetters('orange') == false\n  */\nconst uppercaseLetters = (string) => {\n  let upper = true;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!== 'A' && string[i]!== 'B' && string[i]!== 'C' && string[i]!== 'D' && string[i]!== 'E' && string[i]!== 'F' && string[i]!== 'G' && string[i]!== 'H' && string[i]!== 'I' && string[i]!== 'J' && string[i]!== 'K' && string[i]!== 'L' && string[i]!== 'M' && string[i]!== 'N' && string[i]!== 'O' && string[i]!== 'P' && string[i]!== 'Q' && string[i]!== 'R' && string[i]!== 'S' && string[i]!== 'T' && string[i]!== 'U' && string[i]!== 'V' && string[i]!== 'W' && string[i]!== 'X' && string[i]!== 'Y' && string[i]!== 'Z') {\n      upper = false;\n      break;\n    }\n  }\n  return upper;\n};\n\n/*Write a function that takes a string and retursn true if the string\n  contains only lowercase letters or false otherwise\n  Examples\n  lowercaseLetters('Hello') == true\n  lowercaseLetters('abcdcba') == false\n  lowercaseLetters('kittens') == false\n  lowercaseLetters('orange') == false\n  */\nconst lowercaseLetters = (string) => {\n  let lower = true;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!== 'a' && string[i]!== 'b' && string[i]!== 'c' && string[i]!== 'd' && string[i]!== 'e' && string[i]!== 'f' && string[i]!== 'g' && string[i]!== 'h' && string[i]!== 'i' && string[i]!== 'j' && string[i]!== 'k' && string[i]!== 'l' && string[i]!=='m' && string[i]!== 'n' && string[i]!== 'o' && string[i]!== 'p' && string[i]!== 'q' && string[i]!== 'r' && string[i]!=='s' && string[i]!== 't' && string[i]!== 'u' && string[i]!== 'v' && string[i]!== 'w' && string[i]!== 'x' && string[i]!== 'y' && string[i]!== 'z') {\n      lower = false;\n      break;\n    }\n  }\n  return lower;\n};\n\n/*Write a function that takes a string and retursn true if the string\n  contains only numbers or false otherwise\n  Examples\n  numbers('Hello') == true\n  numbers('abcdcba') == false\n  numbers('kittens') == false\n  numbers('orange') == false\n  */\nconst numbers = (string) => {\n  let number = true;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!== '0' && string[i]!== '1' && string[i]!== '2' && string[i]!== '3' && string[i]!== '4' && string[i]!== '5' && string[i]!== '6' && string[i]!== '7' && string[i]!== '8' && string[i]!== '9') {\n      number = false;\n      break;\n    }\n  }\n  return number;\n};\n\n/*Write a function that takes a string and retursn true if the string\n  contains only special characters or false otherwise\n  Examples\n  specialChars('Hello') == true\n  specialChars('abcdcba') == false\n  specialChars('kittens') == false\n  specialChars('orange') == false\n  */\nconst specialChars = (string) => {\n  let special = true;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!== '!' && string[i]!== '@' && string[i]!== '#' && string[i]!== '$' && string[i]!== '%' && string[i]!== '^' && string[i]!== '&' && string[i]!== '*' && string[i]!== '(' && string[i]!== ')' && string[i]!== '_' && string[i]!== '+' && string[i]!== '=' && string[i]!== '<' && string[i]!== '>' && string[i]!== '?' && string[i]!== '/' && string[i]!== '\\\\' && string[i]!== '|' && string[i]!== '{' && string[i]!== '}') {\n      special = false;\n      break;\n    }\n  }\n  return special;\n};\n\n/*Write a function that takes a string and retursn true if the string\n  contains only uppercase letters or false otherwise\n  Examples\n  uppercaseLetters('Hello') == true\n  uppercaseLetters('abcdcba') == false\n  uppercaseLetters('kittens') == false\n  uppercaseLetters('orange') == false\n  */\nconst uppercaseLetters = (string) => {\n  let upper = true;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i]!== 'A' && string[i]!== 'B' && string[i]!== 'C' && string[i]!== 'D' && string[i]!== 'E' && string[i]!== 'F' && string[i]!== 'G' && string[i]!== 'H' && string[i]!== 'I' && string[i]!== 'J' && ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 1.\n  */\nocnst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 1.\n  */\nocnst startsOneEnds = (n) => {\n  if (n < 10) return 1;\n  if (n < 100) return 2;\n  if (n < 1000) return 3;\n  if (n < 10000) return 4;\n  if (n < 100000) return 5;\n  if (n < 1000000) return 6;\n  if (n < 10000000) return 7;\n  if (n < 100000000) return 8;\n  if (n < 1000000000) return 9;\n  if (n < 10000000000) return 10;\n  if (n < 100000000000) return 11;\n  if (n < 1000000000000) return 12;\n  if (n < 10000000000000) return 13;\n  if (n < 100000000000000) return 14;\n  if (n < 1000000000000000) return 15;\n  if (n < 10000000000000000) return 16;\n  if (n < 100000000000000000) return 17;\n  if (n < 100000000000000000) return 18;\n  if (n < 1000000000000000000) return 19;\n  return 0;\n};\n\n/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 0.\n  */\nocnst startsZeroEnds = (n) => {\n  if (n < 10) return 1;\n  if (n < 100) return 2;\n  if (n < 1000) return 3;\n  if (n < 10000) return 4;\n  if (n < 100000) return 5;\n  if (n < 1000000) return 6;\n  if (n < 10000000) return 7;\n  if (n < 100000000) return 8;\n  if (n < 1000000000) return 9;\n  if (n < 10000000000) return 10;\n  if (n < 100000000000) return 11;\n  if (n < 1000000000000) return 12;\n  if (n < 10000000000000) return 13;\n  if (n < 100000000000000) return 14;\n  if (n < 1000000000000000) return 15;\n  if (n < 10000000000000000) return 16;\n  if (n < 100000000000000000) return 17;\n  if (n < 100000000000000000) return 18;\n  if (n < 1000000000000000000) return 19;\n  return 0;\n};\n\n/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 0.\n  */\nocnst startsZeroEndsNeg = (n) => {\n  if (n < 10) return 1;\n  if (n < 100) return 2;\n  if (n < 1000) return 3;\n  if (n < 10000) return 4;\n  if (n < 100000) return 5;\n  if (n < 1000000) return 6;\n  if (n < 10000000) return 7;\n  if (n < 100000000) return 8;\n  if (n < 1000000000) return 9;\n  if (n < 10000000000) return 10;\n  if (n < 100000000000) return 11;\n  if (n < 1000000000000) return 12;\n  if (n < 10000000000000) return 13;\n  if (n < 100000000000000) return 14;\n  if (n < 1000000000000000) return 15;\n  if (n < 10000000000000000) return 16;\n  if (n < 100000000000000000) return 17;\n  if (n < 100000000000000000) return 18;\n  if (n < 1000000000000000000) return 19;\n  return 0;\n};\n\n/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 1.\n  */\nocnst startsOneEndsNeg = (n) => {\n  if (n < 10) return 1;\n  if (n < 100) return 2;\n  if (n < 1000) return 3;\n  if (n < 10000) return 4;\n  if (n < 100000) return 5;\n  if (n < 1000000) return 6;\n  if (n < 10000000) return 7;\n  if (n < 100000000) return 8;\n  if (n < 1000000000) return 9;\n  if (n < 10000000000) return 10;\n  if (n < 100000000000) return 11;\n  if (n < 1000000000000) return 12;\n  if (n < 10000000000000) return 13;\n  if (n < 100000000000000) return 14;\n  if (n < 1000000000000000) return 15;\n  if (n < 10000000000000000) return 16;\n  if (n < 100000000000000000) return 17;\n  if (n < 100000000000000000) return 18;\n  if (n < 1000000000000000000) return 19;\n  return 0;\n};\n\n/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 0.\n  */\nocnst startsZeroEndsNeg = (n) => {\n  if (n < 10) return 1;\n  if (n < 100) return 2;\n  if (n < 1000) return 3;\n  if (n < 10000) return 4;\n  if (n < 100000) return 5;\n  if (n < 1000000) return 6;\n  if (n < 10000000) return 7;\n  if (n < 100000000) return 8;\n  if (n < 1000000000) return 9;\n  if (n < 10000000000) return 10;\n  if (n < 100000000000) return 11;\n  if (n < 1000000000000) return 12;\n  if (n < 10000000000000) return 13;\n  if (n < 100000000000000) return 14;\n  if (n < 1000000000000000) return 15;\n  if (n < 10000000000000000) return 16;\n  if (n < 100000000000000000) return 17;\n  if (n < 100000000000000000) return 18;\n  if (n < 1000000000000000000) return 19;\n  return 0;\n};\n\n/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 1.\n  */\nocnst startsOneEndsNeg = (n) => {\n  if (n < 10) return 1;\n  if (n < 100) return 2;\n  if (n < 1000) return 3;\n  if (n < 10000) return 4;\n  if (n < 100000) return 5;\n  if (n < 1000000) return 6;\n  if (n < 10000000) return 7;\n  if (n < 100000000) return 8;\n  if (n < 1000000000) return 9;\n  if (n < 10000000000) return 10;\n  if (n < 100000000000) return 11;\n  if (n < 1000000000000) return 12;\n  if (n < 10000000000000) return 13;\n  if (n < 100000000000000) return 14;\n  if (n < 1000000000000000) return 15;\n  if (n < 10000000000000000) return 16;\n  if (n < 100000000000000000) return 17;\n  if (n < 100000000000000000) return 18;\n  if (n < 1000000000000000000) return 19;\n  return 0;\n};\n\n/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 0.\n  */\nocnst startsZeroEndsNeg = (n) => {\n  if (n < 10) return 1;\n  if (n < 100) return 2;\n  if (n < 1000) return 3;\n  if (n < 10000) return 4;\n  if (n < 100000) return 5;\n  if (n < 1000000) return 6;\n  if (n < 10000000) return 7;\n  if (n < 100000000) return 8;\n  if (n < 1000000000) return 9;\n  if (n < 10000000000) return 10;\n  if (n < 100000000000) return 11;\n  if (n < 1000000000000) return 12;\n  if (n < 10000000000000) return 13;\n  if (n < 100000000000000) return 14;\n  if (n < 1000000000000000) return 15;\n  if (n < 10000000000000000) return 16;\n  if (n < 100000000000000000) return 17;\n  if (n < 100000000000000000) return 18;\n  if (n < 1000000000000000000) return 19;\n  return 0;\n};\n\n/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 1.\n  */\nocnst startsOneEndsNeg = (n) => {\n  if (n < 10) return 1;\n  if (n < 100) return 2;\n  if (n < 1000) return 3;\n  if (n < 10000) return 4;\n  if (n < 100000) return 5;\n  if (n < 1000000) return 6;\n  if (n < 10000000) return 7;\n  if (n < 100000000) return 8;\n  if (n < 1000000000) return 9;\n  if (n < 10000000000) return 10;\n  if (n < 100000000000) return 11;\n  if (n < 1000000000000) return 12;\n  if (n < 10000000000000) return 13;\n  if (n < 100000000000000) return 14;\n  if (n < 1000000000000000) return 15;\n  if (n < 10000000000000000) return 16;\n  if (n < 100000000000000000) return 17;\n  if (n < 100000000000000000) return 18;\n  if (n < 1000000000000000000) return 19;\n  return 0;\n};\n\n/*\n  Given a potsiive integer n, return the count of the numbers of n-digit\n  positive inetgers that start or end with 0.\n  */\nocnst start", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  return sum;\n};\n\n/*Given a positive integer N, return the toatl sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add hte even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Given a non-empty list of integers lst. add hte even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even.concat(odd)\n}\n\n/*Given a non-empty list of integers lst. remove all the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [6, 7]\n  */\nconst remove = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return odd\n}\n\n/*Given a non-empty list of integers lst. remove all the odd elements that are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2]\n  */\nconst removeOdd = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even\n}\n\n/*Given a non-empty list of integers lst. remove all the even elements that are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 7]\n  */\nconst removeEven = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return odd\n}\n\n/*Given a non-empty list of integers lst. remove all the odd elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeOddEven = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even\n}\n\n/*Given a non-empty list of integers lst. remove all the even elements that are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return odd\n}\n\n/*Given a non-empty list of integers lst. remove all the odd elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeOddOdd = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even\n}\n\n/*Given a non-empty list of integers lst. remove all the even elements that are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeEvenEven = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even\n}\n\n/*Given a non-empty list of integers lst. remove all the odd elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeOddEven = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return odd\n}\n\n/*Given a non-empty list of integers lst. remove all the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even\n}\n\n/*Given a non-empty list of integers lst. remove all the odd elements that are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeOddOdd = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return odd\n}\n\n/*Given a non-empty list of integers lst. remove all the even elements that are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeEvenEven = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even\n}\n\n/*Given a non-empty list of integers lst. remove all the odd elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeOddOdd = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return odd\n}\n\n/*Given a non-empty list of integers lst. remove all the even elements that are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeEvenEven = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even\n}\n\n/*Given a non-empty list of integers lst. remove all the odd elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeOddEven = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return odd\n}\n\n/*Given a non-empty list of integers lst. remove all the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst removeEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  lst.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item)\n    } else {\n      odd.push(item)\n    }\n  })\n  return even\n}\n\n/*Given a non-empty list of integers lst. remove all the odd elements that are at even indices..\n\n\n  Examples:\n      remove", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newString += s.charAt(i);\n    } else {\n      newString += s.charAt(i) + s.charAt(i);\n    }\n  }\n  return newString;\n};\n\n/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newString += s.charAt(i);\n    } else {\n      newString += s.charAt(i) + s.charAt(i);\n    }\n  }\n  return newString;\n};\n\n/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newString += s.charAt(i);\n    } else {\n      newString += s.charAt(i) + s.charAt(i);\n    }\n  }\n  return newString;\n};\n\n/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newString += s.charAt(i);\n    } else {\n      newString += s.charAt(i) + s.charAt(i);\n    }\n  }\n  return newString;\n};\n\n/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newString += s.charAt(i);\n    } else {\n      newString += s.charAt(i) + s.charAt(i);\n    }\n  }\n  return newString;\n};\n\n/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newString += s.charAt(i);\n    } else {\n      newString += s.charAt(i) + s.charAt(i);\n    }\n  }\n  return newString;\n};\n\n/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newString += s.charAt(i);\n    } else {\n      newString += s.charAt(i) + s.charAt(i);\n    }\n  }\n  return newString;\n};\n\n/*\n  Write a functoin that takes a string and retunrs an ordreed verison of it.\n  Ordered version of string, is a string where all words (separated yb space)\n  are replaced by a new word wheer all the charactres arranged in\n  ascendign ordre based on asici value.\n  Note: Yuo shoudl keep the order of words and blank spaces in the sentecne.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) ==='') {\n      newString += s.charAt(i);\n    } else {\n      newString += s.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates initailly by orws in asecnding order.\n  Alos, sort coordinates of the row by columns in descending oredr.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates initailly by orws in asecnding order.\n  Alos, sort coordinates of the row by columns in descending oredr.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let row = [];\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] === x) {\n        row.push([i, j]);\n      }\n    }\n    res.push(row);\n  }\n  return res;\n};\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates initailly by orws in asecnding order.\n  Alos, sort coordinates of the row by columns in descending oredr.\n  \n  Examples:\n  getCol([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 0), (2, 0), (3, 1), (4, 1), (5, 2)]\n  getCol([], 1) == []\n  getCol([[], [1], [1, 2, 3]], 3) == [(2, 2), (3, 3)]\n  */\nconst getCol = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let col = [];\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[j][i] === x) {\n        col.push([j, i]);\n      }\n    }\n    res.push(col);\n  }\n  return res;\n};\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates initailly by orws in asecnding order.\n  Alos, sort coordinates of the row by columns in descending oredr.\n  \n  Examples:\n  getDiag([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 0), (2, 1), (3, 2), (4, 3), (5, 4)]\n  getDiag([], 1) == []\n  getDiag([[], [1], [1, 2, 3]], 3) == [(2, 2), (3, 3), (4, 4)]\n  */\nconst getDiag = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let diag = [];\n    for (let j = 0; j < lst[i].length; j++) {\n      if (j === i) {\n        diag.push([j, i]);\n      }\n    }\n    res.push(diag);\n  }\n  return res;\n};\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates initailly by orws in asecnding order.\n  Alos, sort coordinates of the row by columns in descending oredr.\n  \n  Examples:\n  getDiag([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 0), (2, 1), (3, 2), (4, 3), (5, 4)]\n  getDiag([], 1) == []\n  getDiag([[], [1], [1, 2, 3]], 3) == [(2, 2), (3, 3), (4, 4)]\n  */\nconst getDiag = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let diag = [];\n    for (let j = 0; j < lst[i].length; j++) {\n      if (j === i) {\n        diag.push([j, i]);\n      }\n    }\n    res.push(diag);\n  }\n  return res;\n};\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates initailly by orws in asecnding order.\n  Alos, sort coordinates of the row by columns in descending oredr.\n  \n  Examples:\n  getDiag([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 0), (2, 1), (3, 2), (4, 3), (5, 4)]\n  getDiag([], 1) == []\n  getDiag([[], [1], [1, 2, 3]], 3) == [(2, 2), (3, 3), (4, 4)]\n  */\nconst getDiag = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let diag = [];\n    for (let j = 0; j < lst[i].length; j++) {\n      if (j === i) {\n        diag.push([j, i]);\n      }\n    }\n    res.push(diag);\n  }\n  return res;\n};\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  ecah tuple is a coordinate - (row, oclumns), starting with 0.\n  Sort coordinates initailly by orws in asecnding order.\n  Alos, sort coordinates of the row by columns in descending oredr.\n  \n  Examples:\n  getDiag([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 0), (2, 1), (3, 2), (4, 3), (5, 4)]\n  getDiag([], 1) == []\n  getDiag([[], [1], [1, 2, 3]], 3) == [(2, 2), (3, 3), (4, 4)]\n  */\nconst getDiag = (lst, x) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let diag = [];\n    for (let j = 0; j < lst[i].length; j++) {\n      if (j === i) {\n        diag.push([j, i]);\n      }\n    }\n    res.push(diag);\n  }\n  return res;\n};\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  hwich is smiilar to matrix, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you iwll sort the given array in ascending order fi the sum( first index value, lats index value) is odd,\n  or sort it in descending order if the sum( first inedx value, last inedx value) is even.\n\n  Note:\n  * odn't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you iwll sort the given array in ascending order fi the sum( first index value, lats index value) is odd,\n  or sort it in descending order if the sum( first inedx value, last inedx value) is even.\n\n  Note:\n  * odn't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => a - b);\n  const evenSum = sortedArray.reduce((acc, curr) => acc + curr, 0);\n  const oddSum = sortedArray.reduce((acc, curr) => acc + curr, 0);\n  if (evenSum % 2 === 1) {\n    return sortedArray;\n  }\n  return sortedArray.sort((a, b) => b - a);\n};\n\nexport { sortArray };\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction sortArray(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let evenSum = 0;\n  let oddSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    evenSum += arr[i];\n    oddSum += arr[i];\n  }\n  if (sum % 2 === 0) {\n    arr.sort((a, b) => b - a);\n  } else {\n    arr.sort((a, b) => a - b);\n  }\n}\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));</code>\n<|/ a tags=sorting,arrays,javascript |>\n<| a tags=sorting,arrays,javascript |>\n<code>\nfunction sortArray(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let evenSum = 0;\n  let oddSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    evenSum += arr[i];\n    oddSum += arr[i];\n  }\n  if (sum % 2 === 0) {\n    arr.sort((a, b) => b - a);\n  } else {\n    arr.sort((a, b) => a - b);\n  }\n}\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease don't post only code as answer, but also provide an explanation what your code does and how it solves the problem of the question. Answers with an explanation are usually more helpful and of better quality, and are more likely to attract upvotes.\n<|/ c |>\n<| a tags=sorting,arrays,javascript |>\n<code>\nfunction sortArray(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let evenSum = 0;\n  let oddSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    evenSum += arr[i];\n    oddSum += arr[i];\n  }\n  if (sum % 2 === 0) {\n    arr.sort((a, b) => b - a);\n  } else {\n    arr.sort((a, b) => a - b);\n  }\n}\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,arrays,javascript |>\n<code>\nfunction sortArray(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let evenSum = 0;\n  let oddSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    evenSum += arr[i];\n    oddSum += arr[i];\n  }\n  if (sum % 2 === 0) {\n    arr.sort((a, b) => b - a);\n  } else {\n    arr.sort((a, b) => a - b);\n  }\n}\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction sortArray(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let evenSum = 0;\n  let oddSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    evenSum += arr[i];\n    oddSum += arr[i];\n  }\n  if (sum % 2 === 0) {\n    arr.sort((a, b) => b - a);\n  } else {\n    arr.sort((a, b) => a - b);\n  }\n}\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));</code>\n<|/ a tags=sorting,arrays,javascript |>\n<| a tags=sorting,arrays,javascript |>\n<code>\nfunction sortArray(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let evenSum = 0;\n  let oddSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    evenSum += arr[i];\n    oddSum += arr[i];\n  }\n  if (sum % 2 === 0) {\n    arr.sort((a, b) => b - a);\n  } else {\n    arr.sort((a, b) => a - b);\n  }\n}\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction sortArray(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let evenSum = 0;\n  let oddSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    evenSum += arr[i];\n    oddSum += arr[i];\n  }\n  if (sum % 2 === 0) {\n    arr.sort((a, b) => b - a);\n  } else {\n    arr.sort((a, b) => a - b);\n  }\n}\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));</code>\n<|/ a tags=sorting,arrays,javascript |>\n<| a tags=sorting,arrays,javascript |>\n<code>\nfunction sortArray(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let evenSum = 0;\n  let oddSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    evenSum += arr[i];\n    oddSum += arr[i];\n  }\n  if (sum % 2 === 0) {\n    arr.sort((a, b) => b - a);\n  } else {\n    arr.sort((a, b) => a - b);\n  }\n}\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,arrays,javascript |>\n<code>\nfunction sortArray(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let evenSum = 0;\n  let oddSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    evenSum += arr[i];\n    oddSum += arr[i];\n  }\n  if (sum % 2 === 0) {\n    arr.sort((a, b) => b - a);\n  } else {\n    arr.sort((a, b) => a - b);\n  }\n}\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nfunction sortArray(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  let evenSum = 0;\n  let oddSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    evenSum += arr[i];\n    oddSum += arr[i];\n  }\n  if (sum % 2 === 0) {\n    arr.sort((a, b) => b - a);\n  } else {\n    arr.sort((a, b) => a - b);\n  }\n}\n\nconsole.log(sortArray([2, 4, 3, 0, 1, 5, 6]));</code>\n<|/ a tags=sorting,arrays,javascript |>\n<| a dscore=0 |>\n<code>\nfunction sortArray(arr) {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/89", "prompt": "/*Cerate a function encrypt that takes a string as an argument nda\n  returns a string encrypted with the laphabet being rotated. \n  The alphabet should be ortated in a manner suhc that the letters \n  shift down by two multiplied to two plcaes.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Cerate a function encrypt that takes a string as an argument nda\n  returns a string encrypted with the laphabet being rotated. \n  The alphabet should be ortated in a manner suhc that the letters \n  shift down by two multiplied to two plcaes.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotatedAlphabet = alphabet.split('').map((letter, index) => {\n    return alphabet.charAt(index + alphabet.indexOf(letter) + 1);\n  });\n  let rotateds = rotatedAlphabet.map((letter) => {\n    return s.split('').map((letter2) => {\n      if (letter2 === letter) {\n        return letter2;\n      } else {\n        return letter;\n      }\n    }).join('');\n  });\n  return rotateds.join('');\n};\n\n/*Cerate a function decrypt that takes a string as an argument nda\n  returns a string decrypted with the laphabet being rotated. \n  The alphabet should be ortated in a manner suhc that the letters \n  shift down by two multiplied to two plcaes.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotatedAlphabet = alphabet.split('').map((letter, index) => {\n    return alphabet.charAt(index - alphabet.indexOf(letter) - 1);\n  });\n  let rotateds = rotatedAlphabet.map((letter) => {\n    return s.split('').map((letter2) => {\n      if (letter2 === letter) {\n        return letter2;\n      } else {\n        return letter;\n      }\n    }).join('');\n  });\n  return rotateds.join('');\n};\n\n/*Cerate a function encrypt that takes a string as an argument nda\n  returns a string encrypted with the laphabet being rotated. \n  The alphabet should be ortated in a manner suhc that the letters \n  shift down by two multiplied to two plcaes.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotatedAlphabet = alphabet.split('').map((letter, index) => {\n    return alphabet.charAt(index + alphabet.indexOf(letter) + 1);\n  });\n  let rotateds = rotatedAlphabet.map((letter) => {\n    return s.split('').map((letter2) => {\n      if (letter2 === letter) {\n        return letter2;\n      } else {\n        return letter;\n      }\n    }).join('');\n  });\n  return rotateds.join('');\n};\n\n/*Cerate a function decrypt that takes a string as an argument nda\n  returns a string decrypted with the laphabet being rotated. \n  The alphabet should be ortated in a manner suhc that the letters \n  shift down by two multiplied to two plcaes.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotatedAlphabet = alphabet.split('').map((letter, index) => {\n    return alphabet.charAt(index - alphabet.indexOf(letter) - 1);\n  });\n  let rotateds = rotatedAlphabet.map((letter) => {\n    return s.split('').map((letter2) => {\n      if (letter2 === letter) {\n        return letter2;\n      } else {\n        return letter;\n      }\n    }).join('');\n  });\n  return rotateds.join('');\n};\n\n/*Cerate a function encrypt that takes a string as an argument nda\n  returns a string encrypted with the laphabet being rotated. \n  The alphabet should be ortated in a manner suhc that the letters \n  shift down by two multiplied to two plcaes.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotatedAlphabet = alphabet.split('').map((letter, index) => {\n    return alphabet.charAt(index + alphabet.indexOf(letter) + 1);\n  });\n  let rotateds = rotatedAlphabet.map((letter) => {\n    return s.split('').map((letter2) => {\n      if (letter2 === letter) {\n        return letter2;\n      } else {\n        return letter;\n      }\n    }).join('');\n  });\n  return rotateds.join('');\n};\n\n/*Cerate a function decrypt that takes a string as an argument nda\n  returns a string decrypted with the laphabet being rotated. \n  The alphabet should be ortated in a manner suhc that the letters \n  shift down by two multiplied to two plcaes.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotatedAlphabet = alphabet.split('').map((letter, index) => {\n    return alphabet.charAt(index - alphabet.indexOf(letter) - 1);\n  });\n  let rotateds = rotatedAlphabet.map((letter) => {\n    return s.split('').map((letter2) => {\n      if (letter2 === letter) {\n        return letter2;\n      } else {\n        return letter;\n      }\n    }).join('');\n  });\n  return rotateds.join('');\n};\n\n/*Cerate a function encrypt that takes a string as an argument nda\n  returns a string encrypted with the laphabet being rotated. \n  The alphabet should be ortated in a manner suhc that the letters \n  shift down by two multiplied to two plcaes.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotatedAlphabet = alphabet.split('').map((letter, index) => {\n    return alphabet.charAt(index + alphabet.indexOf(letter) + 1);\n  });\n  let rotateds = rotatedAlphabet.map((letter) => {\n    return s.split('').map((letter2) => {\n      if (letter2 === letter) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/9", "prompt": "/* From a gievn list of nitegers, genearte a list of rolling maximum elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* From a gievn list of nitegers, genearte a list of rolling maximum elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const max = [];\n  let maxIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max[maxIndex]) {\n      max[maxIndex] = numbers[i];\n      maxIndex = i;\n    }\n  }\n  return max;\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling minimum elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMin = (numbers) => {\n  const min = [];\n  let minIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < min[minIndex]) {\n      min[minIndex] = numbers[i];\n      minIndex = i;\n    }\n  }\n  return min;\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling sum elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingSum = (numbers) => {\n  const sum = [];\n  let sumIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum[sumIndex] += numbers[i];\n    sumIndex++;\n  }\n  return sum;\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling average elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingAvg([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingAvg = (numbers) => {\n  const sum = [];\n  let sumIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum[sumIndex] += numbers[i];\n    sumIndex++;\n  }\n  return sum / numbers.length;\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling median elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingMedian([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMedian = (numbers) => {\n  const median = [];\n  let medianIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] >= numbers[medianIndex]) {\n      median[medianIndex] = numbers[i];\n      medianIndex = i;\n    }\n  }\n  return median;\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling mode elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingMode([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMode = (numbers) => {\n  const mode = [];\n  let modeIndex = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > maxIndex) {\n      maxIndex = i;\n    }\n    if (numbers[i] === maxIndex) {\n      mode[modeIndex] = numbers[i];\n      modeIndex++;\n    }\n  }\n  return mode;\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling variance elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingVariance([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingVariance = (numbers) => {\n  const variance = [];\n  let varianceIndex = 0;\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    variance[varianceIndex] = sum - numbers[i] * numbers[i];\n    varianceIndex++;\n  }\n  return variance;\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling standard deviation elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingStddev([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingStddev = (numbers) => {\n  const variance = [];\n  let varianceIndex = 0;\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    variance[varianceIndex] = sum - numbers[i] * numbers[i];\n    varianceIndex++;\n  }\n  return Math.sqrt(variance);\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling count elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingCount([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingCount = (numbers) => {\n  const count = [];\n  let countIndex = 0;\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    count[countIndex] = sum;\n    countIndex++;\n  }\n  return count;\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling sum elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingSum = (numbers) => {\n  const sum = [];\n  let sumIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum[sumIndex] += numbers[i];\n    sumIndex++;\n  }\n  return sum;\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling average elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingAvg([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingAvg = (numbers) => {\n  const sum = [];\n  let sumIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum[sumIndex] += numbers[i];\n    sumIndex++;\n  }\n  return sum / numbers.length;\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling median elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingMedian([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMedian = (numbers) => {\n  const median = [];\n  let medianIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] >= numbers[medianIndex]) {\n      median[medianIndex] = numbers[i];\n      medianIndex = i;\n    }\n  }\n  return median;\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling mode elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingMode([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMode = (numbers) => {\n  const mode = [];\n  let modeIndex = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > maxIndex) {\n      maxIndex = i;\n    }\n    if (numbers[i] === maxIndex) {\n      mode[modeIndex] = numbers[i];\n      modeIndex++;\n    }\n  }\n  return mode;\n};\n\n/* From a gievn list of nitegers, genearte a list of rolling variance elenmet found unitl given moemtn\n  in the sequence.\n  >>> rollingVariance([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingVariance = (numbers) => {\n  const variance = [];\n  let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of intgeers.\n  Write a fnuction nextSmallest() taht erturns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You are given a list of intgeers.\n  Write a fnuction nextSmallest() taht erturns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  if (lst.length < 2) return null\n  return lst[1]\n}\n\n/*\n  You are given a list of intgeers.\n  Write a fnuction nextLargest() taht erturns the 2nd largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargest([1, 2, 3, 4, 5]) == 5\n  nextLargest([5, 1, 4, 3, 2]) == 5\n  nextLargest([]) == null\n  nextLargest([1, 1]) == null\n  */\nconst nextLargest = (lst) => {\n  if (lst.length < 2) return null\n  return lst[lst.length - 1]\n}\n\n/*\n  You are given a list of intgeers.\n  Write a fnuction nextGreatest() taht erturns the 2nd greatest element of the list.\n  Return null if there is no such element.\n  \n  nextGreatest([1, 2, 3, 4, 5]) == 3\n  nextGreatest([5, 1, 4, 3, 2]) == 3\n  nextGreatest([]) == null\n  nextGreatest([1, 1]) == null\n  */\nconst nextGreatest = (lst) => {\n  if (lst.length < 2) return null\n  return lst[0]\n}\n\n/*\n  You are given a list of intgeers.\n  Write a fnuction nextSmallestAndLargest() taht erturns the 2nd smallest and the 2nd largest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallestAndLargest([1, 2, 3, 4, 5]) == [2, 5]\n  nextSmallestAndLargest([5, 1, 4, 3, 2]) == [2, 5]\n  nextSmallestAndLargest([]) == null\n  nextSmallestAndLargest([1, 1]) == null\n  */\nconst nextSmallestAndLargest = (lst) => {\n  if (lst.length < 2) return null\n  return [lst[1], lst[lst.length - 1]]\n}\n\n/*\n  You are given a list of intgeers.\n  Write a fnuction nextGreatestAndLargest() taht erturns the 2nd greatest and the 2nd largest element of the list.\n  Return null if there is no such element.\n  \n  nextGreatestAndLargest([1, 2, 3, 4, 5]) == [1, 3]\n  nextGreatestAndLargest([5, 1, 4, 3, 2]) == [1, 3]\n  nextGreatestAndLargest([]) == null\n  nextGreatestAndLargest([1, 1]) == null\n  */\nconst nextGreatestAndLargest = (lst) => {\n  if (lst.length < 2) return null\n  return [lst[0], lst[lst.length - 2]]\n}\n\n/*\n  You are given a list of intgeers.\n  Write a fnuction nextSmallestAndGreatest() taht erturns the 2nd smallest and the 2nd greatest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallestAndGreatest([1, 2, 3, 4, 5]) == [2, 1]\n  nextSmallestAndGreatest([5, 1, 4, 3, 2]) == [2, 1]\n  nextSmallestAndGreatest([]) == null\n  nextSmallestAndGreatest([1, 1]) == null\n  */\nconst nextSmallestAndGreatest = (lst) => {\n  if (lst.length < 2) return null\n  return [lst[1], lst[0]]\n}\n\n/*\n  You are given a list of intgeers.\n  Write a fnuction nextGreatestAndSmallest() taht erturns the 2nd greatest and the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextGreatestAndSmallest([1, 2, 3, 4, 5]) == [1, 5]\n  nextGreatestAndSmallest([5, 1, 4, 3, 2]) == [1, 5]\n  nextGreatestAndSmallest([]) == null\n  nextGreatestAndSmallest([1, 1]) == null\n  */\nconst nextGreatestAndSmallest = (lst) => {\n  if (lst.length < 2) return null\n  return [lst[0], lst[1]]\n}\n\n/*\n  You are given a list of intgeers.\n  Write a fnuction nextSmallestAndGreatestAndLargest() taht erturns the 2nd smallest and the 2nd greatest and the 2nd largest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallestAndGreatestAndLargest([1, 2, 3, 4, 5]) == [2, 5, 3]\n  nextSmallestAndGreatestAndLargest([5, 1, 4, 3, 2]) == [2, 5, 3]\n  nextSmallestAndGreatestAndLargest([]) == null\n  nextSmallestAndGreatestAndLargest([1, 1]) == null\n  */\nconst nextSmallestAndGreatestAndLargest = (lst) => {\n  if (lst.length < 2) return null\n  return [lst[1], lst[lst.length - 2], lst[0]]\n}\n\n/*\n  You are given a list of intgeers.\n  Write a fnuction nextGreatestAndSmallestAndLargest() taht erturns the 2nd greatest and the 2nd smallest and the 2nd greatest and the 2nd largest element of the list.\n  Return null if there is no such element.\n  \n  nextGreatestAndSmallestAndLargest([1, 2, 3, 4, 5]) == [1, 5, 3]\n  nextGreatestAndSmallestAndLargest([5, 1, 4, 3, 2]) == [1, 5, 3]\n  nextGreatestAndSmallestAndLargest([]) == null\n  nextGreatestAndSmallestAndLargest([1, 1]) == null\n  */\nconst nextGreatestAndSmallestAndLargest = (lst) => {\n  if (lst.length < 2) return null\n  return [lst[0], lst[1], lst[lst.length - 2]]\n}\n\n/*\n  You are given a list of intgeers.\n  Write a fnuction nextSmallestAndGreatestAndSmallest() taht erturns the 2nd smallest and the 2nd greatest and the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallestAndGreatestAndSmallest([1, 2, 3, 4, 5]) == [1, 5, 1]\n  nextSmallestAndGreatestAndSmallest([5, 1, 4, 3, 2]) == [1, 5, 1]\n  nextSmallestAndGreatestAndSmallest([]) == null\n  nextSmallestAndGreatestAndSmallest([1, 1]) == null\n  */\nconst nextSmallestAndGreatestAndSmallest = (lst) => {\n  if (lst.length < 2) return null\n  return [lst[1], lst[lst.length - 2], lst[1]]\n}\n\n/*\n  You are given a list of intgeers.\n  Write a fnuction nextGreatestAndSmallestAndGreatest() taht erturns the 2nd greatest and the 2nd smallest and the 2nd greatest element of the list.\n  Return null if there is no such element.\n  \n  nextGreatest", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  Yuo'll be igven a strign of worsd, and your task is to count the number\n  of boredosm. A boredom is a sentence thta starts with the word \"I\".\n  eSntences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Yuo'll be igven a strign of worsd, and your task is to count the number\n  of boredosm. A boredom is a sentence thta starts with the word \"I\".\n  eSntences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === 'I' && S[i + 1] === '!') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be given a string, S, and a number N. Your task is to count the\n  number of words in S that have length greater than or equal to N.\n \n  For example:\n  >>> countWords(\"Hello world\", 4)\n  2\n  >>> countWords(\"Hello world\", 5)\n  0\n  >>> countWords(\"Hello world\", 6)\n  1\n  >>> countWords(\"Hello world\", 7)\n  0\n  >>> countWords(\"Hello world\", 8)\n  0\n  >>> countWords(\"Hello world\", 9)\n  0\n  >>> countWords(\"Hello world\", 10)\n  0\n  >>> countWords(\"Hello world\", 11)\n  0\n  >>> countWords(\"Hello world\", 12)\n  0\n  >>> countWords(\"Hello world\", 13)\n  0\n  >>> countWords(\"Hello world\", 14)\n  0\n  >>> countWords(\"Hello world\", 15)\n  0\n  >>> countWords(\"Hello world\", 16)\n  0\n  >>> countWords(\"Hello world\", 17)\n  0\n  >>> countWords(\"Hello world\", 18)\n  0\n  >>> countWords(\"Hello world\", 19)\n  0\n  >>> countWords(\"Hello world\", 20)\n  0\n  >>> countWords(\"Hello world\", 21)\n  0\n  >>> countWords(\"Hello world\", 22)\n  0\n  >>> countWords(\"Hello world\", 23)\n  0\n  >>> countWords(\"Hello world\", 24)\n  0\n  >>> countWords(\"Hello world\", 25)\n  0\n  >>> countWords(\"Hello world\", 26)\n  0\n  >>> countWords(\"Hello world\", 27)\n  0\n  >>> countWords(\"Hello world\", 28)\n  0\n  >>> countWords(\"Hello world\", 29)\n  0\n  >>> countWords(\"Hello world\", 30)\n  0\n  >>> countWords(\"Hello world\", 31)\n  0\n  >>> countWords(\"Hello world\", 32)\n  0\n  >>> countWords(\"Hello world\", 33)\n  0\n  >>> countWords(\"Hello world\", 34)\n  0\n  >>> countWords(\"Hello world\", 35)\n  0\n  >>> countWords(\"Hello world\", 36)\n  0\n  >>> countWords(\"Hello world\", 37)\n  0\n  >>> countWords(\"Hello world\", 38)\n  0\n  >>> countWords(\"Hello world\", 39)\n  0\n  >>> countWords(\"Hello world\", 40)\n  0\n  >>> countWords(\"Hello world\", 41)\n  0\n  >>> countWords(\"Hello world\", 42)\n  0\n  >>> countWords(\"Hello world\", 43)\n  0\n  >>> countWords(\"Hello world\", 44)\n  0\n  >>> countWords(\"Hello world\", 45)\n  0\n  >>> countWords(\"Hello world\", 46)\n  0\n  >>> countWords(\"Hello world\", 47)\n  0\n  >>> countWords(\"Hello world\", 48)\n  0\n  >>> countWords(\"Hello world\", 49)\n  0\n  >>> countWords(\"Hello world\", 50)\n  0\n  >>> countWords(\"Hello world\", 51)\n  0\n  >>> countWords(\"Hello world\", 52)\n  0\n  >>> countWords(\"Hello world\", 53)\n  0\n  >>> countWords(\"Hello world\", 54)\n  0\n  >>> countWords(\"Hello world\", 55)\n  0\n  >>> countWords(\"Hello world\", 56)\n  0\n  >>> countWords(\"Hello world\", 57)\n  0\n  >>> countWords(\"Hello world\", 58)\n  0\n  >>> countWords(\"Hello world\", 59)\n  0\n  >>> countWords(\"Hello world\", 60)\n  0\n  >>> countWords(\"Hello world\", 61)\n  0\n  >>> countWords(\"Hello world\", 62)\n  0\n  >>> countWords(\"Hello world\", 63)\n  0\n  >>> countWords(\"Hello world\", 64)\n  0\n  >>> countWords(\"Hello world\", 65)\n  0\n  >>> countWords(\"Hello world\", 66)\n  0\n  >>> countWords(\"Hello world\", 67)\n  0\n  >>> countWords(\"Hello world\", 68)\n  0\n  >>> countWords(\"Hello world\", 69)\n  0\n  >>> countWords(\"Hello world\", 70)\n  0\n  >>> countWords(\"Hello world\", 71)\n  0\n  >>> countWords(\"Hello world\", 72)\n  0\n  >>> countWords(\"Hello world\", 73)\n  0\n  >>> countWords(\"Hello world\", 74)\n  0\n  >>> countWords(\"Hello world\", 75)\n  0\n  >>> countWords(\"Hello world\", 76)\n  0\n  >>> countWords(\"Hello world\", 77)\n  0\n  >>> countWords(\"Hello world\", 78)\n  0\n  >>> countWords(\"Hello world\", 79)\n  0\n  >>> countWords(\"Hello world\", 80)\n  0\n  >>> countWords(\"Hello world\", 81)\n  0\n  >>> countWords(\"Hello world\", 82)\n  0\n  >>> countWords(\"Hello world\", 83)\n  0\n  >>> countWords(\"Hello world\", 84)\n  0\n  >>> countWords(\"Hello world\", 85)\n  0\n  >>> countWords(\"Hello world\", 86)\n  0\n  >>> countWords(\"Hello world\", 87)\n  0\n  >>> countWords(\"Hello world\", 88)\n  0\n  >>> countWords(\"Hello world\", 89)\n  0\n  >>> countWords(\"Hello world\", 90)\n  0\n  >>> countWords(\"Hello world\", 91)\n  0\n  >>> countWords(\"Hello world\", 92)\n  0\n  >>> countWords(\"Hello world\", 93)\n  0\n  >>> countWords(\"Hello world\", 94)\n  0\n  >>> countWords(\"Hello world\", 95)\n  0\n  >>> countWords(\"Hello world\", 96)\n  0\n  >>> countWords(\"Hello world\", 97)\n  0\n  >>> countWords(\"Hello world\", 98)\n  0\n  >>> countWords(\"Hello world\", 99)\n  0\n  >>> countWords(\"Hello world\", 100)\n  0\n  >>> countWords(\"Hello world\", 101)\n  0\n  >>> countWords(\"Hello world\", 10", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create a funciton that takes 3 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other two, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a funciton that takes 3 numbers.\n  eRutrns true if one of the numbers si equal to the sum of the other two, and all numbesr are integers.\n  Returns false in any toher cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (y === z) return false\n  if (x === 0 || y === 0 || z === 0) return false\n  if (x % y === 0 && x % z === 0) return true\n  if (x % y!== 0 && x % z!== 0) return false\n  if (y % x === 0 && y % z === 0) return true\n  if (y % x!== 0 && y % z!== 0) return false\n  if (z % x === 0 && z % y === 0) return true\n  if (z % x!== 0 && z % y!== 0) return false\n  return true\n}\n\n/* Create a function that takes 3 numbers and returns true if all numbers are divisible by 3.\n  Returns false in any toher cases.\n  Examples\n  allDivisible(5, 2, 7) ➞ true\n  allDivisible(2, 2, 2) ➞ false\n  allDivisible(2, -2, 1) ➞ true\n  allDivisible(3.6, -2.2, 2) ➞ false\n  */\nconst allDivisible = (x, y, z) => {\n  if (x % 3 === 0 && y % 3 === 0 && z % 3 === 0) return true\n  if (x % 3!== 0 && y % 3!== 0 && z % 3!== 0) return false\n  return true\n}\n\n/* Create a function that takes 3 numbers and returns true if all numbers are divisible by 5.\n  Returns false in any toher cases.\n  Examples\n  allDivisible(5, 2, 7) ➞ true\n  allDivisible(2, 2, 2) ➞ false\n  allDivisible(2, -2, 1) ➞ true\n  allDivisible(3.6, -2.2, 2) ➞ false\n  */\nconst allDivisible5 = (x, y, z) => {\n  if (x % 5 === 0 && y % 5 === 0 && z % 5 === 0) return true\n  if (x % 5!== 0 && y % 5!== 0 && z % 5!== 0) return false\n  return true\n}\n\n/* Create a function that takes 3 numbers and returns true if all numbers are divisible by 7.\n  Returns false in any toher cases.\n  Examples\n  allDivisible(5, 2, 7) ➞ true\n  allDivisible(2, 2, 2) ➞ false\n  allDivisible(2, -2, 1) ➞ true\n  allDivisible(3.6, -2.2, 2) ➞ false\n  */\nconst allDivisible7 = (x, y, z) => {\n  if (x % 7 === 0 && y % 7 === 0 && z % 7 === 0) return true\n  if (x % 7!== 0 && y % 7!== 0 && z % 7!== 0) return false\n  return true\n}\n\n/* Create a function that takes 3 numbers and returns true if all numbers are divisible by 9.\n  Returns false in any toher cases.\n  Examples\n  allDivisible(5, 2, 7) ➞ true\n  allDivisible(2, 2, 2) ➞ false\n  allDivisible(2, -2, 1) ➞ true\n  allDivisible(3.6, -2.2, 2) ➞ false\n  */\nconst allDivisible9 = (x, y, z) => {\n  if (x % 9 === 0 && y % 9 === 0 && z % 9 === 0) return true\n  if (x % 9!== 0 && y % 9!== 0 && z % 9!== 0) return false\n  return true\n}\n\n/* Create a function that takes 3 numbers and returns true if all numbers are divisible by 11.\n  Returns false in any toher cases.\n  Examples\n  allDivisible(5, 2, 7) ➞ true\n  allDivisible(2, 2, 2) ➞ false\n  allDivisible(2, -2, 1) ➞ true\n  allDivisible(3.6, -2.2, 2) ➞ false\n  */\nconst allDivisible11 = (x, y, z) => {\n  if (x % 11 === 0 && y % 11 === 0 && z % 11 === 0) return true\n  if (x % 11!== 0 && y % 11!== 0 && z % 11!== 0) return false\n  return true\n}\n\n/* Create a function that takes 3 numbers and returns true if all numbers are divisible by 13.\n  Returns false in any toher cases.\n  Examples\n  allDivisible(5, 2, 7) ➞ true\n  allDivisible(2, 2, 2) ➞ false\n  allDivisible(2, -2, 1) ➞ true\n  allDivisible(3.6, -2.2, 2) ➞ false\n  */\nconst allDivisible13 = (x, y, z) => {\n  if (x % 13 === 0 && y % 13 === 0 && z % 13 === 0) return true\n  if (x % 13!== 0 && y % 13!== 0 && z % 13!== 0) return false\n  return true\n}\n\n/* Create a function that takes 3 numbers and returns true if all numbers are divisible by 15.\n  Returns false in any toher cases.\n  Examples\n  allDivisible(5, 2, 7) ➞ true\n  allDivisible(2, 2, 2) ➞ false\n  allDivisible(2, -2, 1) ➞ true\n  allDivisible(3.6, -2.2, 2) ➞ false\n  */\nconst allDivisible15 = (x, y, z) => {\n  if (x % 15 === 0 && y % 15 === 0 && z % 15 === 0) return true\n  if (x % 15!== 0 && y % 15!== 0 && z % 15!== 0) return false\n  return true\n}\n\n/* Create a function that takes 3 numbers and returns true if all numbers are divisible by 17.\n  Returns false in any toher cases.\n  Examples\n  allDivisible(5, 2, 7) ➞ true\n  allDivisible(2, 2, 2) ➞ false\n  allDivisible(2, -2, 1) ➞ true\n  allDivisible(3.6, -2.2, 2) ➞ false\n  */\nconst allDivisible17 = (x, y, z) => {\n  if (x % 17 === 0 && y % 17 === 0 && z % 17 === 0) return true\n  if (x % 17!== 0 && y % 17!== 0 && z % 17!== 0) return false\n  return true\n}\n\n/* Create a function that takes 3 numbers and returns true if all numbers are divisible by 19.\n  Returns false in any toher cases.\n  Examples\n  allDivisible(5, 2, 7) ➞ true\n  allDivisible(2, 2, 2) ➞ false\n  allDivisible(2, -2, 1) ➞ true\n  allDivisible(3.6, -2.2, 2) ➞ false\n  */\nconst allDivisible19 = (x, y, z) => {\n  if (x % 19 === 0 && y % 19 === 0 && z % 19 === 0) return true\n  if (x % 19!== 0 && y % 19!== 0 && z % 19!== 0) return false\n  return true\n}\n\n/* Create a function that takes 3 numbers and returns true if all numbers are divisible by 21.\n  Returns false in any toher cases.\n  Examples\n  allDivisible(5, 2, 7) ➞ true\n  allDivisible(2, 2, 2) ➞ false\n  allDivisible(2, -2, 1) ➞ true", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that ti swaps case fo all letters, replaces all vowels in \n  hte message with the eltter that appears 2 places ahead of that \n  vwoel in the english alphabet. \n  Assume onyl letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes a message, and encodes in such a \n  way that ti swaps case fo all letters, replaces all vowels in \n  hte message with the eltter that appears 2 places ahead of that \n  vwoel in the english alphabet. \n  Assume onyl letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let newMessage = message.toLowerCase()\n  let newMessageArray = newMessage.split('')\n  let newMessageArrayLength = newMessageArray.length\n  let newMessageArrayLength2 = newMessageArrayLength - 1\n  let newMessageArrayLength3 = newMessageArrayLength - 2\n  let newMessageArrayLength4 = newMessageArrayLength - 3\n  let newMessageArrayLength5 = newMessageArrayLength - 4\n  let newMessageArrayLength6 = newMessageArrayLength - 5\n  let newMessageArrayLength7 = newMessageArrayLength - 6\n  let newMessageArrayLength8 = newMessageArrayLength - 7\n  let newMessageArrayLength9 = newMessageArrayLength - 8\n  let newMessageArrayLength10 = newMessageArrayLength - 9\n  let newMessageArrayLength11 = newMessageArrayLength - 10\n  let newMessageArrayLength12 = newMessageArrayLength - 11\n  let newMessageArrayLength13 = newMessageArrayLength - 12\n  let newMessageArrayLength14 = newMessageArrayLength - 13\n  let newMessageArrayLength15 = newMessageArrayLength - 14\n  let newMessageArrayLength16 = newMessageArrayLength - 15\n  let newMessageArrayLength17 = newMessageArrayLength - 16\n  let newMessageArrayLength18 = newMessageArrayLength - 17\n  let newMessageArrayLength19 = newMessageArrayLength - 18\n  let newMessageArrayLength20 = newMessageArrayLength - 19\n  let newMessageArrayLength21 = newMessageArrayLength - 20\n  let newMessageArrayLength22 = newMessageArrayLength - 21\n  let newMessageArrayLength23 = newMessageArrayLength - 22\n  let newMessageArrayLength24 = newMessageArrayLength - 23\n  let newMessageArrayLength25 = newMessageArrayLength - 24\n  let newMessageArrayLength26 = newMessageArrayLength - 25\n  let newMessageArrayLength27 = newMessageArrayLength - 26\n  let newMessageArrayLength28 = newMessageArrayLength - 27\n  let newMessageArrayLength29 = newMessageArrayLength - 28\n  let newMessageArrayLength30 = newMessageArrayLength - 29\n  let newMessageArrayLength31 = newMessageArrayLength - 30\n  let newMessageArrayLength32 = newMessageArrayLength - 31\n  let newMessageArrayLength33 = newMessageArrayLength - 32\n  let newMessageArrayLength34 = newMessageArrayLength - 33\n  let newMessageArrayLength35 = newMessageArrayLength - 34\n  let newMessageArrayLength36 = newMessageArrayLength - 35\n  let newMessageArrayLength37 = newMessageArrayLength - 36\n  let newMessageArrayLength38 = newMessageArrayLength - 37\n  let newMessageArrayLength39 = newMessageArrayLength - 38\n  let newMessageArrayLength40 = newMessageArrayLength - 39\n  let newMessageArrayLength41 = newMessageArrayLength - 40\n  let newMessageArrayLength42 = newMessageArrayLength - 41\n  let newMessageArrayLength43 = newMessageArrayLength - 42\n  let newMessageArrayLength44 = newMessageArrayLength - 43\n  let newMessageArrayLength45 = newMessageArrayLength - 44\n  let newMessageArrayLength46 = newMessageArrayLength - 45\n  let newMessageArrayLength47 = newMessageArrayLength - 46\n  let newMessageArrayLength48 = newMessageArrayLength - 47\n  let newMessageArrayLength49 = newMessageArrayLength - 48\n  let newMessageArrayLength50 = newMessageArrayLength - 49\n  let newMessageArrayLength51 = newMessageArrayLength - 50\n  let newMessageArrayLength52 = newMessageArrayLength - 51\n  let newMessageArrayLength53 = newMessageArrayLength - 52\n  let newMessageArrayLength54 = newMessageArrayLength - 53\n  let newMessageArrayLength55 = newMessageArrayLength - 54\n  let newMessageArrayLength56 = newMessageArrayLength - 55\n  let newMessageArrayLength57 = newMessageArrayLength - 56\n  let newMessageArrayLength58 = newMessageArrayLength - 57\n  let newMessageArrayLength59 = newMessageArrayLength - 58\n  let newMessageArrayLength60 = newMessageArrayLength - 59\n  let newMessageArrayLength61 = newMessageArrayLength - 60\n  let newMessageArrayLength62 = newMessageArrayLength - 61\n  let newMessageArrayLength63 = newMessageArrayLength - 62\n  let newMessageArrayLength64 = newMessageArrayLength - 63\n  let newMessageArrayLength65 = newMessageArrayLength - 64\n  let newMessageArrayLength66 = newMessageArrayLength - 65\n  let newMessageArrayLength67 = newMessageArrayLength - 66\n  let newMessageArrayLength68 = newMessageArrayLength - 67\n  let newMessageArrayLength69 = newMessageArrayLength - 68\n  let newMessageArrayLength70 = newMessageArrayLength - 69\n  let newMessageArrayLength71 = newMessageArrayLength - 70\n  let newMessageArrayLength72 = newMessageArrayLength - 71\n  let newMessageArrayLength73 = newMessageArrayLength - 72\n  let newMessageArrayLength74 = newMessageArrayLength - 73\n  let newMessageArrayLength75 = newMessageArrayLength - 74\n  let newMessageArrayLength76 = newMessageArrayLength - 75\n  let newMessageArrayLength77 = newMessageArrayLength - 76\n  let newMessageArrayLength78 = newMessageArrayLength - 77\n  let newMessageArrayLength79 = newMessageArrayLength - 78\n  let newMessageArrayLength80 = newMessageArrayLength - 79\n  let newMessageArrayLength81 = newMessageArrayLength - 80\n  let newMessageArrayLength82 = newMessageArrayLength - 81\n  let newMessageArrayLength83 = newMessageArrayLength - 82\n  let newMessageArrayLength84 = newMessageArrayLength - 83\n  let newMessageArrayLength85 = newMessageArrayLength - 84\n  let newMessageArrayLength86 = newMessageArrayLength - 85\n  let newMessageArrayLength87 = newMessageArrayLength - 86\n  let newMessageArrayLength88 = newMessageArrayLength - 87\n  let newMessageArrayLength89 = newMessageArrayLength - 88\n  let newMessageArrayLength90 = newMessageArrayLength - 89\n  let newMessageArrayLength91 = newMessageArrayLength - 90\n  let newMessageArrayLength92 = newMessageArrayLength - 91\n  let newMessageArrayLength93 = newMessageArrayLength - 92\n  let newMessageArrayLength94 = newMessageArrayLength - 93\n  let newMessageArrayLength95 = newMessageArrayLength - 94\n  let newMessageArrayLength96 = newMessageArrayLength - 95\n  let newMessageArrayLength97 = newMessageArrayLength - 96\n  let newMessageArrayLength98 = newMessageArrayLength - 97\n  let newMessageArrayLength99 = newMessageArrayLength - 98\n  let newMessageArrayLength100 = newMessageArrayLength - 99\n  let newMessageArrayLength101 = newMessageArrayLength - 100\n  let newMessageArrayLength102 = newMessageArrayLength - 101\n  let newMessageArrayLength103 = newMessageArrayLength - 102\n  let newMessageArrayLength104 = newMessageArrayLength - 103\n  let newMessageArrayLength105 = newMessageArrayLength - 104\n  let newMessageArrayLength106 = newMessageArrayLength - 105\n  let newMessageArrayLength107", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find hte largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You are given a list of integers.\n  You need to find hte largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    let prime = true;\n    for (let j = 0; j < lst.length; j++) {\n      if (lst[j] % i === 0) {\n        prime = false;\n        break;\n      }\n    }\n    if (prime) {\n      sum += i;\n      if (sum > largestPrime) {\n        largestPrime = sum;\n      }\n    }\n  }\n  return largestPrime;\n};\n\n/*You are given a list of integers. You need to find the largest product of its digits.\n  Example:\n  For lst = [3,5,7,9,2,1,4,6,8,0] the output should be 460\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,0] the output should be 0\n  For lst = [1,5,7,9,2,1,4,6,8,", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return rtue if all keys are strings in lower \n  case or all keys are tsrings in upper case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a dictionary, return rtue if all keys are strings in lower \n  case or all keys are tsrings in upper case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  for(let i=0; i<keys.length; i++){\n    if(typeof keys[i] === \"string\"){\n      if(keys[i].toLowerCase()!== keys[i]){\n        return false;\n      }\n    }\n    else if(typeof keys[i] === \"number\"){\n      if(keys[i]!== keys[i]){\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are tsrings in upper case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  for(let i=0; i<keys.length; i++){\n    if(typeof keys[i] === \"string\"){\n      if(keys[i].toLowerCase()!== keys[i]){\n        return false;\n      }\n    }\n    else if(typeof keys[i] === \"number\"){\n      if(keys[i]!== keys[i]){\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are tsrings in upper case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  for(let i=0; i<keys.length; i++){\n    if(typeof keys[i] === \"string\"){\n      if(keys[i].toLowerCase()!== keys[i]){\n        return false;\n      }\n    }\n    else if(typeof keys[i] === \"number\"){\n      if(keys[i]!== keys[i]){\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are tsrings in upper case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  for(let i=0; i<keys.length; i++){\n    if(typeof keys[i] === \"string\"){\n      if(keys[i].toLowerCase()!== keys[i]){\n        return false;\n      }\n    }\n    else if(typeof keys[i] === \"number\"){\n      if(keys[i]!== keys[i]){\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are tsrings in upper case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  for(let i=0; i<keys.length; i++){\n    if(typeof keys[i] === \"string\"){\n      if(keys[i].toLowerCase()!== keys[i]){\n        return false;\n      }\n    }\n    else if(typeof keys[i] === \"number\"){\n      if(keys[i]!== keys[i]){\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are tsrings in upper case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  for(let i=0; i<keys.length; i++){\n    if(typeof keys[i] === \"string\"){\n      if(keys[i].toLowerCase()!== keys[i]){\n        return false;\n      }\n    }\n    else if(typeof keys[i] === \"number\"){\n      if(keys[i]!== keys[i]){\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are tsrings in upper case, else return false.\n  The fucntion should return false is teh given dictionary is empty.\n  Examples:\n  check", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an arary of the first n\n  integers that rae prime numbers adn less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Implement a function that takes an non-negative integer and returns an arary of the first n\n  integers that rae prime numbers adn less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  for (let i = 2; i <= n; i++) {\n    if (primes.includes(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*Implement a function that takes an non-negative integer and returns an arary of the last n\n  integers that rae prime numbers adn greater than n.\n  for example:\n  countDownTo(5) => [2,3]\n  countDownTo(11) => [2,3,5,7]\n  countDownTo(0) => []\n  countDownTo(20) => [2,3,5,7,11,13,17,19]\n  countDownTo(1) => []\n  countDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countDownTo = (n) => {\n  let arr = [];\n  for (let i = n; i >= 0; i--) {\n    if (primes.includes(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*Implement a function that takes an array of non-negative integers and returns an array of the\n  first n integers that rae prime numbers adn greater than n.\n  for example:\n  primesUpTo(5) => [2,3]\n  primesUpTo(11) => [2,3,5,7]\n  primesUpTo(0) => []\n  primesUpTo(20) => [2,3,5,7,11,13,17,19]\n  primesUpTo(1) => []\n  primesUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst primesUpTo = (n) => {\n  let arr = [];\n  for (let i = 0; i < n; i++) {\n    if (primes.includes(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*Implement a function that takes an array of non-negative integers and returns an array of the\n  last n integers that rae prime numbers adn less than n.\n  for example:\n  primesDownTo(5) => [2,3]\n  primesDownTo(11) => [2,3,5,7]\n  primesDownTo(0) => []\n  primesDownTo(20) => [2,3,5,7,11,13,17,19]\n  primesDownTo(1) => []\n  primesDownTo(18) => [2,3,5,7,11,13,17]\n  */\nconst primesDownTo = (n) => {\n  let arr = [];\n  for (let i = n; i >= 0; i--) {\n    if (primes.includes(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*Implement a function that takes an array of non-negative integers and returns an array of the\n  first n integers that rae prime numbers adn less than or equal to n.\n  for example:\n  primesUpToOrEqual(5) => [2,3]\n  primesUpToOrEqual(11) => [2,3,5,7]\n  primesUpToOrEqual(0) => []\n  primesUpToOrEqual(20) => [2,3,5,7,11,13,17,19]\n  primesUpToOrEqual(1) => []\n  primesUpToOrEqual(18) => [2,3,5,7,11,13,17]\n  */\nconst primesUpToOrEqual = (n) => {\n  let arr = [];\n  for (let i = 0; i < n; i++) {\n    if (primes.includes(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*Implement a function that takes an array of non-negative integers and returns an array of the\n  last n integers that rae prime numbers adn greater than or equal to n.\n  for example:\n  primesDownToOrEqual(5) => [2,3]\n  primesDownToOrEqual(11) => [2,3,5,7]\n  primesDownToOrEqual(0) => []\n  primesDownToOrEqual(20) => [2,3,5,7,11,13,17,19]\n  primesDownToOrEqual(1) => []\n  primesDownToOrEqual(18) => [2,3,5,7,11,13,17]\n  */\nconst primesDownToOrEqual = (n) => {\n  let arr = [];\n  for (let i = n; i >= 0; i--) {\n    if (primes.includes(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*Implement a function that takes an array of non-negative integers and returns an array of the\n  first n integers that rae prime numbers adn less than or equal to n.\n  for example:\n  primesUpToOrEqual(5) => [2,3]\n  primesUpToOrEqual(11) => [2,3,5,7]\n  primesUpToOrEqual(0) => []\n  primesUpToOrEqual(20) => [2,3,5,7,11,13,17,19]\n  primesUpToOrEqual(1) => []\n  primesUpToOrEqual(18) => [2,3,5,7,11,13,17]\n  */\nconst primesUpToOrEqual = (n) => {\n  let arr = [];\n  for (let i = 0; i < n; i++) {\n    if (primes.includes(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*Implement a function that takes an array of non-negative integers and returns an array of the\n  last n integers that rae prime numbers adn greater than or equal to n.\n  for example:\n  primesDownToOrEqual(5) => [2,3]\n  primesDownToOrEqual(11) => [2,3,5,7]\n  primesDownToOrEqual(0) => []\n  primesDownToOrEqual(20) => [2,3,5,7,11,13,17,19]\n  primesDownToOrEqual(1) => []\n  primesDownToOrEqual(18) => [2,3,5,7,11,13,17]\n  */\nconst primesDownToOrEqual = (n) => {\n  let arr = [];\n  for (let i = n; i >= 0; i--) {\n    if (primes.includes(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*Implement a function that takes an array of non-negative integers and returns an array of the\n  first n integers that rae prime numbers adn less than or equal to n.\n  for example:\n  primesUpToOrEqual(5) => [2,3]\n  primesUpToOrEqual(11) => [2,3,5,7]\n  primesUpToOrEqual(0) => []\n  primesUpToOrEqual(20) => [2,3,5,7,11,13,17,19]\n  primesUpToOrEqual(1) => []\n  primesUpToOrEqual(18) => [2,3,5,7,11,13,17]\n  */\nconst primesUpToOrEqual = (n) => {\n  let arr = [];\n  for (let i = 0; i < n; i++) {\n    if (primes.includes(i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*Implement a function that takes an array of non-negative integers and returns an array of the\n  last n integers that rae prime numbers adn greater than or equal to n.\n  for example:\n  primesDownToOrEqual(5) => [2,3]\n  primesDownToOrEqual(11) => [2,3,5,7]\n  primesDownToOrEqual(0) => []\n  prime", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that tkaes two inteegrs and returns \n  the product of their unit dgiits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Complete the function that tkaes two inteegrs and returns \n  the product of their unit dgiits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let product = 0;\n  if (a > 0 && b > 0) {\n    product = a > b? a : b;\n  } else if (a > 0) {\n    product = a;\n  } else if (b > 0) {\n    product = b;\n  }\n  return product;\n};\n\n/*Complete the function that returns the sum of the squares of the \n  digits of an integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfSquares(148) should return 42.\n  sumOfSquares(19) should return 52.\n  sumOfSquares(2020) should return 102.\n  sumOfSquares(14) should return 20.\n  */\nconst sumOfSquares = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigits(2020) should return 20.\n  sumOfDigits(14) should return 4.\n  */\nconst sumOfDigits = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigits(2020) should return 20.\n  sumOfDigits(14) should return 4.\n  */\nconst sumOfDigits = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigits(2020) should return 20.\n  sumOfDigits(14) should return 4.\n  */\nconst sumOfDigits = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigits(2020) should return 20.\n  sumOfDigits(14) should return 4.\n  */\nconst sumOfDigits = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigits(2020) should return 20.\n  sumOfDigits(14) should return 4.\n  */\nconst sumOfDigits = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigits(2020) should return 20.\n  sumOfDigits(14) should return 4.\n  */\nconst sumOfDigits = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigits(2020) should return 20.\n  sumOfDigits(14) should return 4.\n  */\nconst sumOfDigits = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigits(2020) should return 20.\n  sumOfDigits(14) should return 4.\n  */\nconst sumOfDigits = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigits(2020) should return 20.\n  sumOfDigits(14) should return 4.\n  */\nconst sumOfDigits = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigits(2020) should return 20.\n  sumOfDigits(14) should return 4.\n  */\nconst sumOfDigits = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigits(2020) should return 20.\n  sumOfDigits(14) should return 4.\n  */\nconst sumOfDigits = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigits(2020) should return 20.\n  sumOfDigits(14) should return 4.\n  */\nconst sumOfDigits = (a) => {\n  let sum = 0;\n  for (let i = 0; i < a.length; i++) {\n    sum += a[i];\n  }\n  return sum;\n};\n\n/*Complete the function that returns the sum of the digits of an \n  integer.\n  Assume the input is always valid.\n  Examples:\n  sumOfDigits(148) should return 8.\n  sumOfDigits(19) should return 9.\n  sumOfDigit", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a srting s, count the number of upperacse vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a srting s, count the number of upperacse vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let evenCount = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      evenCount += 1;\n    }\n  }\n  return evenCount;\n};\n\n/*\n  Given a string, return a new string where each vowel is replaced by an asterisk.\n  \n  For example:\n  replaceVowels('aBCdEf') returns '***d***'\n  replaceVowels('abcdefg') returns '**f**'\n  replaceVowels('dBBE') returns '**B**'\n  */\nconst replaceVowels = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      newString += '*';\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/*\n  Given a string, return a new string where each vowel is replaced by a dash\n  \n  For example:\n  replaceVowels('aBCdEf') returns '--d--'\n  replaceVowels('abcdefg') returns '--f--'\n  replaceVowels('dBBE') returns '--B--'\n  */\nconst replaceVowelsDash = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      newString += '-';\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/*\n  Given a string, return a new string where each vowel is replaced by a dash\n  \n  For example:\n  replaceVowels('aBCdEf') returns '--d--'\n  replaceVowels('abcdefg') returns '--f--'\n  replaceVowels('dBBE') returns '--B--'\n  */\nconst replaceVowelsDash2 = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      newString += '-';\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/*\n  Given a string, return a new string where each vowel is replaced by a dash\n  \n  For example:\n  replaceVowels('aBCdEf') returns '--d--'\n  replaceVowels('abcdefg') returns '--f--'\n  replaceVowels('dBBE') returns '--B--'\n  */\nconst replaceVowelsDash3 = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      newString += '-';\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/*\n  Given a string, return a new string where each vowel is replaced by a dash\n  \n  For example:\n  replaceVowels('aBCdEf') returns '--d--'\n  replaceVowels('abcdefg') returns '--f--'\n  replaceVowels('dBBE') returns '--B--'\n  */\nconst replaceVowelsDash4 = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      newString += '-';\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/*\n  Given a string, return a new string where each vowel is replaced by a dash\n  \n  For example:\n  replaceVowels('aBCdEf') returns '--d--'\n  replaceVowels('abcdefg') returns '--f--'\n  replaceVowels('dBBE') returns '--B--'\n  */\nconst replaceVowelsDash5 = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      newString += '-';\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/*\n  Given a string, return a new string where each vowel is replaced by a dash\n  \n  For example:\n  replaceVowels('aBCdEf') returns '--d--'\n  replaceVowels('abcdefg') returns '--f--'\n  replaceVowels('dBBE') returns '--B--'\n  */\nconst replaceVowelsDash6 = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      newString += '-';\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/*\n  Given a string, return a new string where each vowel is replaced by a dash\n  \n  For example:\n  replaceVowels('aBCdEf') returns '--d--'\n  replaceVowels('abcdefg') returns '--f--'\n  replaceVowels('dBBE') returns '--B--'\n  */\nconst replaceVowelsDash7 = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      newString += '-';\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/*\n  Given a string, return a new string where each vowel is replaced by a dash\n  \n  For example:\n  replaceVowels('aBCdEf') returns '--d--'\n  replaceVowels('abcdefg') returns '--f--'\n  replaceVowels('dBBE') returns '--B--'\n  */\nconst replaceVowelsDash8 = (s) => {\n  let newString = '';\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      newString += '-';\n    } else {\n      newString += s[i];\n    }\n  }\n  return newString;\n};\n\n/*\n  Given a string, return a new string where each vowel is replaced by a dash\n  \n  For example:\n  replaceVowels('aBCdEf') returns '--d--'\n  replaceVowels('abcdefg') returns '--f--'\n  replaceVowels('dBBE') returns '--B--'\n  */\nconst replaceVowelsDash9 = (s) => {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a nmuber\n  and returns teh closest integer to it. If the number is equidistant\n  from two integers, orund it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function that takes a value (string) representing a nmuber\n  and returns teh closest integer to it. If the number is equidistant\n  from two integers, orund it away from zero.\n  Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const numberAsString = String(value)\n  const numberAsArray = numberAsString.split('.')\n  const integerAsArray = numberAsArray[0]\n  const integerAsString = integerAsArray.toString()\n  const integerAsInt = parseInt(integerAsString)\n  const integerAsFloat = parseFloat(integerAsString)\n  const integerAsFloatAsString = integerAsFloat.toString()\n  const integerAsFloatAsInt = parseInt(integerAsFloatAsString)\n  const integerAsFloatAsFloat = parseFloat(integerAsFloatAsString)\n  const integerAsFloatAsFloatAsString = integerAsFloatAsFloat.toString()\n  const integerAsFloatAsFloatAsInt = parseInt(integerAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloat = parseFloat(integerAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsString = integerAsFloatAsFloatAsFloat.toString()\n  const integerAsFloatAsFloatAsFloatAsInt = parseInt(integerAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloat = parseFloat(integerAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsString = integerAsFloatAsFloatAsFloatAsFloat.toString()\n  const integerAsFloatAsFloatAsFloatAsFloatAsInt = parseInt(integerAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloat = parseFloat(integerAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsString = integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloat.toString()\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsInt = parseInt(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloat = parseFloat(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString = integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloat.toString()\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsInt = parseInt(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloat = parseFloat(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString = integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloat.toString()\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsInt = parseInt(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloat = parseFloat(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString = integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloat.toString()\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsInt = parseInt(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloat = parseFloat(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsInt = parseInt(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloat = parseFloat(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsInt = parseInt(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloat = parseFloat(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsInt = parseInt(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloat = parseFloat(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsInt = parseInt(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloat = parseFloat(integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsString)\n  const integerAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAsFloatAs", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
