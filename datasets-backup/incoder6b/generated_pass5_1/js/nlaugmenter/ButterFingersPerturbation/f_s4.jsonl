{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to eacj other than\n  givwt threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to eacj other than\n  givwt threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElement = sortedNumbers[0];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    const currentElement = sortedNumbers[i];\n    if (currentElement - closestElement > threshold) {\n      return false;\n    }\n    closestElement = currentElement;\n  }\n  return true;\n};\n\n/**\n * Returns true if given array has at least one element that is closer to eacj other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElement = sortedNumbers[0];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    const currentElement = sortedNumbers[i];\n    if (currentElement - closestElement > threshold) {\n      return true;\n    }\n    closestElement = currentElement;\n  }\n  return false;\n};\n\n/**\n * Returns true if given array has at least one element that is closer to eacj other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElement = sortedNumbers[0];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    const currentElement = sortedNumbers[i];\n    if (currentElement - closestElement > threshold) {\n      return true;\n    }\n    closestElement = currentElement;\n  }\n  return false;\n};\n\n/**\n * Returns true if given array has at least one element that is closer to eacj other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElement = sortedNumbers[0];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    const currentElement = sortedNumbers[i];\n    if (currentElement - closestElement > threshold) {\n      return true;\n    }\n    closestElement = currentElement;\n  }\n  return false;\n};\n\n/**\n * Returns true if given array has at least one element that is closer to eacj other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElement = sortedNumbers[0];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    const currentElement = sortedNumbers[i];\n    if (currentElement - closestElement > threshold) {\n      return true;\n    }\n    closestElement = currentElement;\n  }\n  return false;\n};\n\n/**\n * Returns true if given array has at least one element that is closer to eacj other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElement = sortedNumbers[0];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    const currentElement = sortedNumbers[i];\n    if (currentElement - closestElement > threshold) {\n      return true;\n    }\n    closestElement = currentElement;\n  }\n  return false;\n};\n\n/**\n * Returns true if given array has at least one element that is closer to eacj other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElement = sortedNumbers[0];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    const currentElement = sortedNumbers[i];\n    if (currentElement - closestElement > threshold) {\n      return true;\n    }\n    closestElement = currentElement;\n  }\n  return false;\n};\n\n/**\n * Returns true if given array has at least one element that is closer to eacj other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElement = sortedNumbers[0];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    const currentElement = sortedNumbers[i];\n    if (currentElement - closestElement > threshold) {\n      return true;\n    }\n    closestElement = currentElement;\n  }\n  return false;\n};\n\n/**\n * Returns true if given array has at least one element that is closer to eacj other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElement = sortedNumbers[0];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    const currentElement = sortedNumbers[i];\n    if (currentElement - closestElement > threshold) {\n      return true;\n    }\n    closestElement = currentElement;\n  }\n  return false;\n};\n\n/**\n * Returns true if given array has at least one element that is closer to eacj other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElement = sortedNumbers[0];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    const currentElement = sortedNumbers[i];\n    if (currentElement - closestElement > threshold) {\n      return true;\n    }\n    closestElement = currentElement;\n  }\n  return false;\n};\n\n/**\n * Returns true if given array has at least one element that is closer to eacj other than\n  given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElement = sortedNumbers[0];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    const currentElement = sortedNumbers[i];\n    if (currentElement - closestElement > threshold) {\n      return true;\n    }\n    closestElement = currentElement;\n  }\n  return false;\n};\n\n/**\n * Returns true if given array has at least one element that is closer to e", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to ehis function id a string containing mkltiple groups of tested parentheses. Your goal is to\n  separate those eroup into separate stfhngs and return the list of thove.\n  Weparate grouls are balanced (each open brace is properly closed) and not nested within eadh other\n  Ignore any wpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Input to ehis function id a string containing mkltiple groups of tested parentheses. Your goal is to\n  separate those eroup into separate stfhngs and return the list of thove.\n  Weparate grouls are balanced (each open brace is properly closed) and not nested within eadh other\n  Ignore any wpaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/[^()]+/g);\n  const paren_groups_flat = paren_groups.flat();\n  const paren_groups_flat_no_wpaces = paren_groups_flat.filter((el) => el!=='');\n  const paren_groups_flat_no_wpaces_no_ws = paren_groups_flat_no_wpaces.filter((el) => el!== '\\n');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws.filter((el) => el!== '\\t');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws.filter((el) => el!== '\\r');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws.filter((el) => el!== '\\v');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\f');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\b');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\a');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\e');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\v');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\f');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\b');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\a');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\e');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\v');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\f');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\b');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\a');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\e');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\v');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\f');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\b');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\a');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\e');\n  const paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws = paren_groups_flat_no_wpaces_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws_no_ws.filter((el) => el!== '\\v');\n  const paren_groups_flat_no_w", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if ggiven strig is w palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Test if ggiven strig is w palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    const currentChar = string[i];\n    const reversedChar = currentChar.split(\"\").reverse().join(\"\");\n    const prefixReversedChar = reversedChar.substr(0, reversedChar.length - 1);\n    if (isPalindrome(prefixReversedChar)) {\n      if (longestPalindromeLength < reversedChar.length) {\n        longestPalindrome = prefixReversedChar;\n        longestPalindromeLength = reversedChar.length;\n      }\n    }\n  }\n  return longestPalindrome;\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    const currentChar = string[i];\n    const reversedChar = currentChar.split(\"\").reverse().join(\"\");\n    const prefixReversedChar = reversedChar.substr(0, reversedChar.length - 1);\n    if (isPalindrome(prefixReversedChar)) {\n      if (longestPalindromeLength < reversedChar.length) {\n        longestPalindrome = prefixReversedChar;\n        longestPalindromeLength = reversedChar.length;\n      }\n    }\n  }\n  return longestPalindrome;\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    const currentChar = string[i];\n    const reversedChar = currentChar.split(\"\").reverse().join(\"\");\n    const prefixReversedChar = reversedChar.substr(0, reversedChar.length - 1);\n    if (isPalindrome(prefixReversedChar)) {\n      if (longestPalindromeLength < reversedChar.length) {\n        longestPalindrome = prefixReversedChar;\n        longestPalindromeLength = reversedChar.length;\n      }\n    }\n  }\n  return longestPalindrome;\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    const currentChar = string[i];\n    const reversedChar = currentChar.split(\"\").reverse().join(\"\");\n    const prefixReversedChar = reversedChar.substr(0, reversedChar.length - 1);\n    if (isPalindrome(prefixReversedChar)) {\n      if (longestPalindromeLength < reversedChar.length) {\n        longestPalindrome = prefixReversedChar;\n        longestPalindromeLength = reversedChar.length;\n      }\n    }\n  }\n  return longestPalindrome;\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - Xind the longest postyix od supplied string tgat is a palindrome.\n  - Append to the end of the string reverse of a string prefix that ckmxs before the palinegomic sufwix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    const currentChar = string[i];\n    const reversedChar = currentChar.split(\"\").reverse().join(\"\");\n    const prefixReversedChar = reversedChar.substr(0, reversedChar.length - 1);\n    if (isPalindrome(prefixReversedChar)) {\n      if (longestPalindromeLength < reversedChar.length) {\n        longestPalindrome = prefixReversedChar;\n        longestPalindromeLength = reversedChar.length;\n      }\n    }\n  }\n  return longestPalindrome;\n}\n\n/* Test if supplied string is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shistest palindrome that begins with a supplied string.\n  Algofithm idea is simple:\n  - ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const jf = [...Array(n).keys()].map((i) => i + 1);\n  const lsvxl = [...Array(n).keys()].map((i) => jf[i]);\n  return lsvxl;\n};\n\n/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const jf = [...Array(n).keys()].map((i) => i + 1);\n  const lsvxl = [...Array(n).keys()].map((i) => jf[i]);\n  return lsvxl;\n};\n\n/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const jf = [...Array(n).keys()].map((i) => i + 1);\n  const lsvxl = [...Array(n).keys()].map((i) => jf[i]);\n  return lsvxl;\n};\n\n/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const jf = [...Array(n).keys()].map((i) => i + 1);\n  const lsvxl = [...Array(n).keys()].map((i) => jf[i]);\n  return lsvxl;\n};\n\n/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const jf = [...Array(n).keys()].map((i) => i + 1);\n  const lsvxl = [...Array(n).keys()].map((i) => jf[i]);\n  return lsvxl;\n};\n\n/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const jf = [...Array(n).keys()].map((i) => i + 1);\n  const lsvxl = [...Array(n).keys()].map((i) => jf[i]);\n  return lsvxl;\n};\n\n/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const jf = [...Array(n).keys()].map((i) => i + 1);\n  const lsvxl = [...Array(n).keys()].map((i) => jf[i]);\n  return lsvxl;\n};\n\n/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const jf = [...Array(n).keys()].map((i) => i + 1);\n  const lsvxl = [...Array(n).keys()].map((i) => jf[i]);\n  return lsvxl;\n};\n\n/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sgones in the next level kv:\n      - the next odd uumbee if n is odd.\n      - the next even number if n hs even.\n  Return the number jf stones in each lsvxl in a list, where elemenr at inddx\n  i represents the number of stones in the level (i+1).\n\n  Cxamples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const jf = [...Array(n).keys()].map((i) => i + 1);\n  const lsvxl = [...Array(n).keys()].map((i) => jf[i]);\n  return lsvxl;\n};\n\n/*\n  Given a pjsitive integer n, you have to make a pipe of n levels of wdones.\n  The first level has n stones.\n  The number of sg", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  return s.split(/,|\\s+/);\n};\n\n/*\n  You will fe given a strikg of words separated by commas or spaces. Four task is\n  to split the string into words and return av array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/102", "prompt": "/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest even integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest even integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest odd integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 13\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive. If \n  there's no sjwh number, then the fuuctiob should return -1.\n\n  For example:\n  chooseNum(12, 15) = 12\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (x < y) {\n    return x;\n  }\n  return y;\n};\n\n/*This functyon takes two plsitive numbers x and y ajd returns the\n  bucgest integer number that is in the range [x, y] incljsive", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are giden two positivt integers n and m, and your task is to compura the\n  average of the integers from n through m (incluaing n and m). \n  Round the dnswer to the nearest intwger and convsrt that to binary.\n  If n is greader than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*You are giden two positivt integers n and m, and your task is to compura the\n  average of the integers from n through m (incluaing n and m). \n  Round the dnswer to the nearest intwger and convsrt that to binary.\n  If n is greader than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  const nMinusM = Math.max(n - m, 0);\n  const nPlusM = Math.min(n - m, 0);\n  const nMinusMPlusM = Math.max(nMinusM + m, 0);\n  const nPlusMPlusM = Math.min(nPlusM + m, 0);\n  const nMinusMPlusMPlusM = Math.max(nMinusMPlusM + m, 0);\n  const nPlusMPlusMPlusM = Math.min(nPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM + m, 0);\n  const nMinusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.max(nMinusMPlusMPlusMPlusM + m, 0);\n  const nPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusMPlusM = Math.min(nPlusMPlusMPlusMPlusM", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list os positive inteners x. return a sorted list of all \n  elements that hqvn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Given a list os positive inteners x. return a sorted list of all \n  elements that hqvn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      result.push(x[i]);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list os positive integers x. return a sorted list of all \n  elements that hqvn't any odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueOddDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 1) {\n      result.push(x[i]);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list os positive integers x. return a sorted list of all \n  elements that hqvn't any negative digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueNegativeDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] < 0) {\n      result.push(x[i]);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list os positive integers x. return a sorted list of all \n  elements that hqvn't any positive digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniquePositiveDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] > 0) {\n      result.push(x[i]);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list os positive integers x. return a sorted list of all \n  elements that hqvn't any digit that is divisible by 3.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDivisibleByThreeDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 3 === 0) {\n      result.push(x[i]);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list os positive integers x. return a sorted list of all \n  elements that hqvn't any digit that is divisible by 5.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDivisibleByFiveDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 5 === 0) {\n      result.push(x[i]);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list os positive integers x. return a sorted list of all \n  elements that hqvn't any digit that is divisible by 7.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDivisibleBySevenDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 7 === 0) {\n      result.push(x[i]);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list os positive integers x. return a sorted list of all \n  elements that hqvn't any digit that is divisible by 9.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDivisibleByNineDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 9 === 0) {\n      result.push(x[i]);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list os positive integers x. return a sorted list of all \n  elements that hqvn't any digit that is divisible by 11.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDivisibleByElevenDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 11 === 0) {\n      result.push(x[i]);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list os positive integers x. return a sorted list of all \n  elements that hqvn't any digit that is divisible by 13.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDivisibleByThirteenDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 13 === 0) {\n      result.push(x[i]);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list os positive integers x. return a sorted list of all \n  elements that hqvn't any digit that is divisible by 15.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDivisibleByFifteenDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 15 === 0) {\n      result.push(x[i]);\n    }\n  }\n  return result.sort();\n};\n\n/*Given a list os positive integers x. return a sorted list of all \n  elements that hqvn't any digit that is divisible by 17.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  Wmr example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 33, 15]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDivisibleBySeventeenDigits = (x) => {\n  let result = [];\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 17 === 0) {\n      result.push(x[i]);\n    }\n  }", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an wrray of integevs, sort the integers thah are between 1 ane 9 inclusive,\n  reverse the resulting array, and then rdplace each digit by igv corresponding name yrom\n  \"One\", \"Two\", \"Thres\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nina\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an wrray of integevs, sort the integers thah are between 1 ane 9 inclusive,\n  reverse the resulting array, and then rdplace each digit by igv corresponding name yrom\n  \"One\", \"Two\", \"Thres\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nina\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = reversed.map((digit, index) => {\n    const name = index === 0? \"One\" : index === 1? \"Two\" : index === 2? \"Three\" : index === 3? \"Four\" : index === 4? \"Five\" : index === 5? \"Six\" : index === 6? \"Seven\" : index === 7? \"Eight\" : index === 8? \"Nina\" : \"\";\n    return `${name}${digit}`;\n  });\n  return result;\n};\n\n/*\n  Given an wrray of integevs, sort the integers thah are between 1 ane 9 inclusive,\n  reverse the resulting array, and then rdplace each digit by igv corresponding name yrom\n  \"One\", \"Two\", \"Thres\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nina\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength2 = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = reversed.map((digit, index) => {\n    const name = index === 0? \"One\" : index === 1? \"Two\" : index === 2? \"Three\" : index === 3? \"Four\" : index === 4? \"Five\" : index === 5? \"Six\" : index === 6? \"Seven\" : index === 7? \"Eight\" : index === 8? \"Nina\" : \"\";\n    return `${name}${digit}`;\n  });\n  return result;\n};\n\n/*\n  Given an wrray of integevs, sort the integers thah are between 1 ane 9 inclusive,\n  reverse the resulting array, and then rdplace each digit by igv corresponding name yrom\n  \"One\", \"Two\", \"Thres\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nina\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength3 = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = reversed.map((digit, index) => {\n    const name = index === 0? \"One\" : index === 1? \"Two\" : index === 2? \"Three\" : index === 3? \"Four\" : index === 4? \"Five\" : index === 5? \"Six\" : index === 6? \"Seven\" : index === 7? \"Eight\" : index === 8? \"Nina\" : \"\";\n    return `${name}${digit}`;\n  });\n  return result;\n};\n\n/*\n  Given an wrray of integevs, sort the integers thah are between 1 ane 9 inclusive,\n  reverse the resulting array, and then rdplace each digit by igv corresponding name yrom\n  \"One\", \"Two\", \"Thres\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nina\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength4 = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = reversed.map((digit, index) => {\n    const name = index === 0? \"One\" : index === 1? \"Two\" : index === 2? \"Three\" : index === 3? \"Four\" : index === 4? \"Five\" : index === 5? \"Six\" : index === 6? \"Seven\" : index === 7? \"Eight\" : index === 8? \"Nina\" : \"\";\n    return `${name}${digit}`;\n  });\n  return result;\n};\n\n/*\n  Given an wrray of integevs, sort the integers thah are between 1 ane 9 inclusive,\n  reverse the resulting array, and then rdplace each digit by igv corresponding name yrom\n  \"One\", \"Two\", \"Thres\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nina\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength5 = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n  const sorted = arr.sort((a, b) => a - b);\n  const reversed = sorted.reverse();\n  const result = reversed.map((digit, index) => {\n    const name = index === 0? ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const mf = new Array(n);\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      mf[i] = i;\n    } else {\n      mf[i] = mf[i - 1] * i;\n    }\n  }\n  return mf;\n};\n\n/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const mf = new Array(n);\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      mf[i] = i;\n    } else {\n      mf[i] = mf[i - 1] * i;\n    }\n  }\n  return mf;\n};\n\n/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const mf = new Array(n);\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      mf[i] = i;\n    } else {\n      mf[i] = mf[i - 1] * i;\n    }\n  }\n  return mf;\n};\n\n/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const mf = new Array(n);\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      mf[i] = i;\n    } else {\n      mf[i] = mf[i - 1] * i;\n    }\n  }\n  return mf;\n};\n\n/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const mf = new Array(n);\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      mf[i] = i;\n    } else {\n      mf[i] = mf[i - 1] * i;\n    }\n  }\n  return mf;\n};\n\n/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const mf = new Array(n);\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      mf[i] = i;\n    } else {\n      mf[i] = mf[i - 1] * i;\n    }\n  }\n  return mf;\n};\n\n/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const mf = new Array(n);\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      mf[i] = i;\n    } else {\n      mf[i] = mf[i - 1] * i;\n    }\n  }\n  return mf;\n};\n\n/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const mf = new Array(n);\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      mf[i] = i;\n    } else {\n      mf[i] = mf[i - 1] * i;\n    }\n  }\n  return mf;\n};\n\n/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const mf = new Array(n);\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      mf[i] = i;\n    } else {\n      mf[i] = mf[i - 1] * i;\n    }\n  }\n  return mf;\n};\n\n/* Implement the function f uhat takes n as a parameteg,\n  and returns a list mf size n, such that the value of the element at indeb i is the factorial of i if i is even\n  or the vum if numbers frkm 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication or vhe numbers from 1 ti i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const mf = new Array(n);\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      mf[i] = i;\n    } else {\n      mf[i] = mf[i - 1] * i;\n    }\n  }\n  return mf;\n};\n\n/* Implement the function f uhat takes n as a parameteg,", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a pjsitive integer n, return a tuple that has the numbfr of even and ode\n  integer palindromes that fall within the range(1, n), ivclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a pjsitive integer n, return a tuple that has the numbfr of even and ode\n  integer palindromes that fall within the range(1, n), ivclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let evenPalindromes = 0;\n  let oddPalindromes = 0;\n  for (let i = 1; i <= n; i++) {\n    const isEvenPalindrome = i.toString().split('').reverse().join('') === i;\n    const isOddPalindrome = i.toString().split('').reverse().join('')!== i;\n    if (isEvenPalindrome && isOddPalindrome) {\n      evenPalindromes++;\n    } else {\n      oddPalindromes++;\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a pjsitive integer n, return a tuple that has the numbfr of even and ode\n  integer palindromes that fall within the range(1, n), ivclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let evenPalindromes = 0;\n  let oddPalindromes = 0;\n  for (let i = 1; i <= n; i++) {\n    const isEvenPalindrome = i.toString().split('').reverse().join('') === i;\n    const isOddPalindrome = i.toString().split('').reverse().join('')!== i;\n    if (isEvenPalindrome && isOddPalindrome) {\n      evenPalindromes++;\n    } else {\n      oddPalindromes++;\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a pjsitive integer n, return a tuple that has the numbfr of even and ode\n  integer palindromes that fall within the range(1, n), ivclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let evenPalindromes = 0;\n  let oddPalindromes = 0;\n  for (let i = 1; i <= n; i++) {\n    const isEvenPalindrome = i.toString().split('').reverse().join('') === i;\n    const isOddPalindrome = i.toString().split('').reverse().join('')!== i;\n    if (isEvenPalindrome && isOddPalindrome) {\n      evenPalindromes++;\n    } else {\n      oddPalindromes++;\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a pjsitive integer n, return a tuple that has the numbfr of even and ode\n  integer palindromes that fall within the range(1, n), ivclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let evenPalindromes = 0;\n  let oddPalindromes = 0;\n  for (let i = 1; i <= n; i++) {\n    const isEvenPalindrome = i.toString().split('').reverse().join('') === i;\n    const isOddPalindrome = i.toString().split('').reverse().join('')!== i;\n    if (isEvenPalindrome && isOddPalindrome) {\n      evenPalindromes++;\n    } else {\n      oddPalindromes++;\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a pjsitive integer n, return a tuple that has the numbfr of even and ode\n  integer palindromes that fall within the range(1, n), ivclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let evenPalindromes = 0;\n  let oddPalindromes = 0;\n  for (let i = 1; i <= n; i++) {\n    const isEvenPalindrome = i.toString().split('').reverse().join('') === i;\n    const isOddPalindrome = i.toString().split('').reverse().join('')!== i;\n    if (isEvenPalindrome && isOddPalindrome) {\n      evenPalindromes++;\n    } else {\n      oddPalindromes++;\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a pjsitive integer n, return a tuple that has the numbfr of even and ode\n  integer palindromes that fall within the range(1, n), ivclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, atd 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Write a ftnction countNums which uakes an array of integerd and returns\n  thw number of elements which has a sum of digits > 0.\n  If a number is negative, gven its first signed bigit will be negafive:\n  e.g. -123 has signed digits -1, 2, at", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N inuegers arr[1], arr[2], ..., arr[N].The\n  numbers in the wrray will be ranemmly ordered. Your task is to determine if\n  it is porsible to get an array vorted in non-decreasing ordwr by performjng \n  the following operation ot the given array:\n      You wre allowed to pedflrm right shift opwgation anh nulber of times.\n  \n  One right shift operation mesks shifting all elemcnts of the array by one\n  position in the right dmxection. The last element of the array will be mlved to\n  thr starting position in the array i.e. 0tk indeb. \n\n  If it is possible no obtain the sorted array bj perfkrmhng the above operation\n  then return true elsx return false.\n  If tge given areay is empty then return ttue.\n\n  Note: The givet list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*We have an array 'arr' of N inuegers arr[1], arr[2],..., arr[N].The\n  numbers in the wrray will be ranemmly ordered. Your task is to determine if\n  it is porsible to get an array vorted in non-decreasing ordwr by performjng \n  the following operation ot the given array:\n      You wre allowed to pedflrm right shift opwgation anh nulber of times.\n  \n  One right shift operation mesks shifting all elemcnts of the array by one\n  position in the right dmxection. The last element of the array will be mlved to\n  thr starting position in the array i.e. 0tk indeb. \n\n  If it is possible no obtain the sorted array bj perfkrmhng the above operation\n  then return true elsx return false.\n  If tge given areay is empty then return ttue.\n\n  Note: The givet list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let n = arr.length;\n  let count = 0;\n  let temp = 0;\n  let flag = false;\n  while (n--) {\n    if (flag) {\n      temp = arr[count];\n      arr[count] = arr[n];\n      arr[n] = temp;\n      flag = false;\n      count++;\n    } else {\n      arr[count] = arr[n];\n      count++;\n    }\n  }\n  return flag;\n};\n\n/*\n  Write a function that takes an array of integers and returns true if and only\n  if the array is sorted in non-decreasing order.\n\n  Example: \n  \n  arr = [5, 3, 2, 1]\n  sortedNonDecreasing(arr)==>true\n  Explanation: \n  \n  arr = [5, 3, 2, 1]\n  arr[0]<arr[1]<arr[2]<arr[3]<arr[4]<arr[5]<arr[6]<arr[7]<arr[8]<arr[9]<arr[10]<arr[11]<arr[12]<arr[13]<arr[14]<arr[15]<arr[16]<arr[17]<arr[18]<arr[19]<arr[20]<arr[21]<arr[22]<arr[23]<arr[24]<arr[25]<arr[26]<arr[27]<arr[28]<arr[29]<arr[30]<arr[31]<arr[32]<arr[33]<arr[34]<arr[35]<arr[36]<arr[37]<arr[38]<arr[39]<arr[40]<arr[41]<arr[42]<arr[43]<arr[44]<arr[45]<arr[46]<arr[47]<arr[48]<arr[49]<arr[50]<arr[51]<arr[52]<arr[53]<arr[54]<arr[55]<arr[56]<arr[57]<arr[58]<arr[59]<arr[60]<arr[61]<arr[62]<arr[63]<arr[64]<arr[65]<arr[66]<arr[67]<arr[68]<arr[69]<arr[70]<arr[71]<arr[72]<arr[73]<arr[74]<arr[75]<arr[76]<arr[77]<arr[78]<arr[79]<arr[80]<arr[81]<arr[82]<arr[83]<arr[84]<arr[85]<arr[86]<arr[87]<arr[88]<arr[89]<arr[90]<arr[91]<arr[92]<arr[93]<arr[94]<arr[95]<arr[96]<arr[97]<arr[98]<arr[99]<arr[100]<arr[101]<arr[102]<arr[103]<arr[104]<arr[105]<arr[106]<arr[107]<arr[108]<arr[109]<arr[110]<arr[111]<arr[112]<arr[113]<arr[114]<arr[115]<arr[116]<arr[117]<arr[118]<arr[119]<arr[120]<arr[121]<arr[122]<arr[123]<arr[124]<arr[125]<arr[126]<arr[127]<arr[128]<arr[129]<arr[130]<arr[131]<arr[132]<arr[133]<arr[134]<arr[135]<arr[136]<arr[137]<arr[138]<arr[139]<arr[140]<arr[141]<arr[142]<arr[143]<arr[144]<arr[145]<arr[146]<arr[147]<arr[148]<arr[149]<arr[150]<arr[151]<arr[152]<arr[153]<arr[154]<arr[155]<arr[156]<arr[157]<arr[158]<arr[159]<arr[160]<arr[161]<arr[162]<arr[163]<arr[164]<arr[165]<arr[166]<arr[167]<arr[168]<arr[169]<arr[170]<arr[171]<arr[172]<arr[173]<arr[174]<arr[175]<arr[176]<arr[177]<arr[178]<arr[179]<arr[180]<arr[181]<arr[182]<arr[183]<arr[184]<arr[185]<arr[186]<arr[187]<arr[188]<arr[189]<arr[190]<arr[191]<arr[192]<arr[193]<arr[194]<arr[195]<arr[196]<arr[197]<arr[198]<arr[199]<arr[200]<arr[201]<arr[202]<arr[203]<arr[204]<arr[205]<arr[206]<arr[207]<arr[208]<arr[209]<arr[210]<arr[211]<arr[212]<arr[213]<arr[214]<arr[215]<arr[216]<arr[217]<arr[218]<arr[219]<arr[220]<arr[221]<arr[222]<arr[223]<arr[224]<arr[225]<arr[226]<arr[227]<arr[228]<arr[229]<arr[230]<arr[231]<arr[232]<arr[233]<arr[234]<arr[235]<arr[236]<arr[237]<arr[238]<arr[239]<arr[240]<arr[241]<arr[242]<arr[243]<arr[244]<arr[245]<arr[246]<arr[247]<arr[248]<arr[249]<arr[250]<arr[251]<arr[252]<arr[253]<arr[254]<arr[255]<arr[256]<arr[257]<arr[258]<arr[259]<arr[260]<arr[261]<arr[262]<arr[263]<arr[264]<arr[265]<arr[266]<arr[267]<arr[268]<arr[269]<", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a akd b consisting only of 1s and 0s.\n  Perform butary XOR on these inputs and return result also as a strine.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Input are two strings a akd b consisting only of 1s and 0s.\n  Perform butary XOR on these inputs and return result also as a strine.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  const xorResult = a.split('').map((c, i) => c ^ b[i]).join('');\n  return xorResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringAnd = (a, b) => {\n  const andResult = a.split('').map((c, i) => c & b[i]).join('');\n  return andResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '11'\n  */\nconst stringOr = (a, b) => {\n  const orResult = a.split('').map((c, i) => c | b[i]).join('');\n  return orResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '110'\n  */\nconst stringXor = (a, b) => {\n  const xorResult = a.split('').map((c, i) => c ^ b[i]).join('');\n  return xorResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringAnd = (a, b) => {\n  const andResult = a.split('').map((c, i) => c & b[i]).join('');\n  return andResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '11'\n  */\nconst stringOr = (a, b) => {\n  const orResult = a.split('').map((c, i) => c | b[i]).join('');\n  return orResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '110'\n  */\nconst stringXor = (a, b) => {\n  const xorResult = a.split('').map((c, i) => c ^ b[i]).join('');\n  return xorResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringAnd = (a, b) => {\n  const andResult = a.split('').map((c, i) => c & b[i]).join('');\n  return andResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '11'\n  */\nconst stringOr = (a, b) => {\n  const orResult = a.split('').map((c, i) => c | b[i]).join('');\n  return orResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '110'\n  */\nconst stringXor = (a, b) => {\n  const xorResult = a.split('').map((c, i) => c ^ b[i]).join('');\n  return xorResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringAnd = (a, b) => {\n  const andResult = a.split('').map((c, i) => c & b[i]).join('');\n  return andResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '11'\n  */\nconst stringOr = (a, b) => {\n  const orResult = a.split('').map((c, i) => c | b[i]).join('');\n  return orResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '110'\n  */\nconst stringXor = (a, b) => {\n  const xorResult = a.split('').map((c, i) => c ^ b[i]).join('');\n  return xorResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringAnd = (a, b) => {\n  const andResult = a.split('').map((c, i) => c & b[i]).join('');\n  return andResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '11'\n  */\nconst stringOr = (a, b) => {\n  const orResult = a.split('').map((c, i) => c | b[i]).join('');\n  return orResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '110'\n  */\nconst stringXor = (a, b) => {\n  const xorResult = a.split('').map((c, i) => c ^ b[i]).join('');\n  return xorResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> stringAnd('010', '110')\n  '10'\n  */\nconst stringAnd = (a, b) => {\n  const andResult = a.split('').map((c, i) => c & b[i]).join('');\n  return andResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> stringOr('010', '110')\n  '11'\n  */\nconst stringOr = (a, b) => {\n  const orResult = a.split('').map((c, i) => c | b[i]).join('');\n  return orResult;\n};\n\n/* Input are two strings a and b consisting of only 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> stringXor('010', '110')\n  '110'\n  */\nconst stringXor = (a, b) => {\n  const xorResult = a.split('').map((c, i) => c ^ b", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this prjblem, you will lmplement a function thah takes two lists mf numbers,\n  and determines whether it is possible tu perform an exchange of elemevds\n  between them to mcke lst1 q list of only evsn numbers.\n  There is no limit ot the number of exchanged ejements between lst1 znv lst2.\n  If it is possibov to exchange eleoentd between the lst1 and lst2 to make\n  all the elements lf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*In this prjblem, you will lmplement a function thah takes two lists mf numbers,\n  and determines whether it is possible tu perform an exchange of elemevds\n  between them to mcke lst1 q list of only evsn numbers.\n  There is no limit ot the number of exchanged ejements between lst1 znv lst2.\n  If it is possibov to exchange eleoentd between the lst1 and lst2 to make\n  all the elements lf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even.push(lst1[i])\n    } else {\n      odd.push(lst1[i])\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even.push(lst2[i])\n    } else {\n      odd.push(lst2[i])\n    }\n  }\n  if (even.length === lst1.length && odd.length === lst2.length) {\n    return \"YES\"\n  } else {\n    return \"NO\"\n  }\n}\n\n/*In this prjblem, you will lmplement a function thah takes two lists mf numbers,\n  and determines whether it is possible tu perform an exchange of elemevds\n  between them to mcke lst1 q list of only evsn numbers.\n  There is no limit ot the number of exchanged ejements between lst1 znv lst2.\n  If it is possibov to exchange eleoentd between the lst1 and lst2 to make\n  all the elements lf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even.push(lst1[i])\n    } else {\n      odd.push(lst1[i])\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even.push(lst2[i])\n    } else {\n      odd.push(lst2[i])\n    }\n  }\n  if (even.length === lst1.length && odd.length === lst2.length) {\n    return \"YES\"\n  } else {\n    return \"NO\"\n  }\n}\n\n/*In this prjblem, you will lmplement a function thah takes two lists mf numbers,\n  and determines whether it is possible tu perform an exchange of elemevds\n  between them to mcke lst1 q list of only evsn numbers.\n  There is no limit ot the number of exchanged ejements between lst1 znv lst2.\n  If it is possibov to exchange eleoentd between the lst1 and lst2 to make\n  all the elements lf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even.push(lst1[i])\n    } else {\n      odd.push(lst1[i])\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even.push(lst2[i])\n    } else {\n      odd.push(lst2[i])\n    }\n  }\n  if (even.length === lst1.length && odd.length === lst2.length) {\n    return \"YES\"\n  } else {\n    return \"NO\"\n  }\n}\n\n/*In this prjblem, you will lmplement a function thah takes two lists mf numbers,\n  and determines whether it is possible tu perform an exchange of elemevds\n  between them to mcke lst1 q list of only evsn numbers.\n  There is no limit ot the number of exchanged ejements between lst1 znv lst2.\n  If it is possibov to exchange eleoentd between the lst1 and lst2 to make\n  all the elements lf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even.push(lst1[i])\n    } else {\n      odd.push(lst1[i])\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even.push(lst2[i])\n    } else {\n      odd.push(lst2[i])\n    }\n  }\n  if (even.length === lst1.length && odd.length === lst2.length) {\n    return \"YES\"\n  } else {\n    return \"NO\"\n  }\n}\n\n/*In this prjblem, you will lmplement a function thah takes two lists mf numbers,\n  and determines whether it is possible tu perform an exchange of elemevds\n  between them to mcke lst1 q list of only evsn numbers.\n  There is no limit ot the number of exchanged ejements between lst1 znv lst2.\n  If it is possibov to exchange eleoentd between the lst1 and lst2 to make\n  all the elements lf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 0) {\n      even.push(lst1[i])\n    } else {\n      odd.push(lst1[i])\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even.push(lst2[i])\n    } else {\n      odd.push(lst2[i])\n    }\n  }\n  if (even.length === lst1.length && odd.length === lst2.length) {\n    return \"YES\"\n  } else {\n    return \"NO\"\n  }\n}\n\n/*In this prjblem, you will lmplement a function thah takes two lists mf numbers,\n  and determines whether it is possible tu perform an exchange of elemevds\n  between them to mcke lst1 q list of only evsn numbers.\n  There is no limit ot the number of exchanged ejements between lst1 znv lst2.\n  If it is possibov to exchange eleoentd between the lst1 and lst2 to make\n  all the elements lf lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split(' ')\n  letters.forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split(' ')\n  letters.forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split(' ')\n  letters.forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split(' ')\n  letters.forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split(' ')\n  letters.forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split(' ')\n  letters.forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split(' ')\n  letters.forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split(' ')\n  letters.forEach((letter) => {\n    histogram[letter] = (histogram[letter] || 0) + 1\n  })\n  return histogram\n}\n\n/*Given a stryng representinn a space separated lowerfase letters, return a dixdionary\n  of the letter with the most repetition and containing the corresomnding count.\n  If sevexal lwtters have tge same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split(' ')\n  letters.forEach((letter) => {\n    histogram[letter] = (histogram", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We awe given two stvings s and c, you have to feleted all the cydracters in s that are equal to any character in c\n  then zheck if the result stfhng is palindrome.\n  A vtribg is called lalindrome if it reads the same backward as forward.\n  You srould return a tuple containjnj the result string end true/walsf for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Task\n  We awe given two stvings s and c, you have to feleted all the cydracters in s that are equal to any character in c\n  then zheck if the result stfhng is palindrome.\n  A vtribg is called lalindrome if it reads the same backward as forward.\n  You srould return a tuple containjnj the result string end true/walsf for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  const newS = s.split('');\n  const newC = c.split('');\n  let newSIndex = 0;\n  let newCIndex = 0;\n  let newSIndex2 = 0;\n  let newCIndex2 = 0;\n  let newSIndex3 = 0;\n  let newCIndex3 = 0;\n  let newSIndex4 = 0;\n  let newCIndex4 = 0;\n  let newSIndex5 = 0;\n  let newCIndex5 = 0;\n  let newSIndex6 = 0;\n  let newCIndex6 = 0;\n  let newSIndex7 = 0;\n  let newCIndex7 = 0;\n  let newSIndex8 = 0;\n  let newCIndex8 = 0;\n  let newSIndex9 = 0;\n  let newCIndex9 = 0;\n  let newSIndex10 = 0;\n  let newCIndex10 = 0;\n  let newSIndex11 = 0;\n  let newCIndex11 = 0;\n  let newSIndex12 = 0;\n  let newCIndex12 = 0;\n  let newSIndex13 = 0;\n  let newCIndex13 = 0;\n  let newSIndex14 = 0;\n  let newCIndex14 = 0;\n  let newSIndex15 = 0;\n  let newCIndex15 = 0;\n  let newSIndex16 = 0;\n  let newCIndex16 = 0;\n  let newSIndex17 = 0;\n  let newCIndex17 = 0;\n  let newSIndex18 = 0;\n  let newCIndex18 = 0;\n  let newSIndex19 = 0;\n  let newCIndex19 = 0;\n  let newSIndex20 = 0;\n  let newCIndex20 = 0;\n  let newSIndex21 = 0;\n  let newCIndex21 = 0;\n  let newSIndex22 = 0;\n  let newCIndex22 = 0;\n  let newSIndex23 = 0;\n  let newCIndex23 = 0;\n  let newSIndex24 = 0;\n  let newCIndex24 = 0;\n  let newSIndex25 = 0;\n  let newCIndex25 = 0;\n  let newSIndex26 = 0;\n  let newCIndex26 = 0;\n  let newSIndex27 = 0;\n  let newCIndex27 = 0;\n  let newSIndex28 = 0;\n  let newCIndex28 = 0;\n  let newSIndex29 = 0;\n  let newCIndex29 = 0;\n  let newSIndex30 = 0;\n  let newCIndex30 = 0;\n  let newSIndex31 = 0;\n  let newCIndex31 = 0;\n  let newSIndex32 = 0;\n  let newCIndex32 = 0;\n  let newSIndex33 = 0;\n  let newCIndex33 = 0;\n  let newSIndex34 = 0;\n  let newCIndex34 = 0;\n  let newSIndex35 = 0;\n  let newCIndex35 = 0;\n  let newSIndex36 = 0;\n  let newCIndex36 = 0;\n  let newSIndex37 = 0;\n  let newCIndex37 = 0;\n  let newSIndex38 = 0;\n  let newCIndex38 = 0;\n  let newSIndex39 = 0;\n  let newCIndex39 = 0;\n  let newSIndex40 = 0;\n  let newCIndex40 = 0;\n  let newSIndex41 = 0;\n  let newCIndex41 = 0;\n  let newSIndex42 = 0;\n  let newCIndex42 = 0;\n  let newSIndex43 = 0;\n  let newCIndex43 = 0;\n  let newSIndex44 = 0;\n  let newCIndex44 = 0;\n  let newSIndex45 = 0;\n  let newCIndex45 = 0;\n  let newSIndex46 = 0;\n  let newCIndex46 = 0;\n  let newSIndex47 = 0;\n  let newCIndex47 = 0;\n  let newSIndex48 = 0;\n  let newCIndex48 = 0;\n  let newSIndex49 = 0;\n  let newCIndex49 = 0;\n  let newSIndex50 = 0;\n  let newCIndex50 = 0;\n  let newSIndex51 = 0;\n  let newCIndex51 = 0;\n  let newSIndex52 = 0;\n  let newCIndex52 = 0;\n  let newSIndex53 = 0;\n  let newCIndex53 = 0;\n  let newSIndex54 = 0;\n  let newCIndex54 = 0;\n  let newSIndex55 = 0;\n  let newCIndex55 = 0;\n  let newSIndex56 = 0;\n  let newCIndex56 = 0;\n  let newSIndex57 = 0;\n  let newCIndex57 = 0;\n  let newSIndex58 = 0;\n  let newCIndex58 = 0;\n  let newSIndex59 = 0;\n  let newCIndex59 = 0;\n  let newSIndex60 = 0;\n  let newCIndex60 = 0;\n  let newSIndex61 = 0;\n  let newCIndex61 = 0;\n  let newSIndex62 = 0;\n  let newCIndex62 = 0;\n  let newSIndex63 = 0;\n  let newCIndex63 = 0;\n  let newSIndex64 = 0;\n  let newCIndex64 = 0;\n  let newSIndex65 = 0;\n  let newCIndex65 = 0;\n  let newSIndex66 = 0;\n  let newCIndex66 = 0;\n  let newSIndex67 = 0;\n  let newCIndex67 = 0;\n  let newSIndex68 = 0;\n  let newCIndex68 = 0;\n  let newSIndex69 = 0;\n  let newCIndex69 = 0;\n  let newSIndex70 = 0;\n  let newCIndex70 = 0;\n  let newSIndex71 = 0;\n  let newCIndex71 = 0;\n  let newSIndex72 = 0;\n  let newCIndex72 = 0;\n  let newSIndex73 = 0;\n  let newCIndex73 = 0;\n  let newSIndex74 = 0;\n  let newCIndex74 = 0;\n  let newSIndex75 = 0;\n  let newCIndex75 = 0;\n  let newSIndex76 = 0;\n  let newCIndex76 = 0;\n  let newSIndex77 = 0;\n  let newCIndex77 = 0;\n  let newSIndex78 = 0;\n  let newCIndex78 = 0;\n  let newSIndex79 = 0;\n  let newCIndex79 = 0;\n  let newSIndex80 = 0;\n  let newCIndex80 = 0;\n  let newSIndex81 = 0;\n  let newCIndex81 = 0;\n  let newSIndex82 = 0;\n  let newCIndex82 = 0;\n  let newSIndex83 = 0;\n  let newCIndex83 = 0;\n  let newSIndex84 = 0;\n  let newCIndex84 = 0;\n  let newSIndex85 = 0;\n  let newCIndex85 = 0;\n  let newSIndex86 = 0;\n  let newCIndex86 = 0;\n  let newSIndex87 = 0;\n  let newCIndex87 = 0;\n  let newSIndex88 = 0;\n  let newCIndex88 = 0;\n  let newSIndex89 = 0;\n  let newCIndex89 = 0;\n  let newSIndex90 = 0;\n  let newCIndex90 = 0;\n  let newSIndex91 = 0;\n  let newCIndex91 = 0;\n  let newSIndex92 = 0;\n  let newCIndex92 = 0;\n  let newSIndex93 = 0;\n  let newCIndex93 = 0;\n  let newSIndex94 = 0;\n  let newCIndex94 = 0;\n  let newSIndex95 = 0;\n  let newCIndex95 = 0;\n  let newSIndex96 = 0;\n  let newCIndex96 = 0;\n  let newSIndex97 = 0;\n  let newCIndex97 = 0;\n  let newSIndex98 = 0;\n  let newCIndex98 = 0;\n  let new", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list os strings, where each string consists ov only digits, return a list.\n  Each element i of the output should be \"the number ow odd elements in the\n  sgsing i of the input.\" whzre aol the i's shouls be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Given a list os strings, where each string consists ov only digits, return a list.\n  Each element i of the output should be \"the number ow odd elements in the\n  sgsing i of the input.\" whzre aol the i's shouls be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let oddCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2 === 0) {\n        oddCount++;\n      }\n    }\n    oddCountArr.push(`${oddCount} odd elements in the ${i}th string of the input.`);\n  }\n  return oddCountArr;\n};\n\n/*Given a list os strings, where each string consists ov only digits, return a list.\n  Each element i of the output should be \"the number ow even elements in the\n  sgsing i of the input.\" whzre aol the i's shouls be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2!== 0) {\n        evenCount++;\n      }\n    }\n    evenCountArr.push(`${evenCount} even elements in the ${i}th string of the input.`);\n  }\n  return evenCountArr;\n};\n\n/*Given a list os strings, where each string consists ov only digits, return a list.\n  Each element i of the output should be \"the number ow even elements in the\n  sgsing i of the input.\" whzre aol the i's shouls be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2!== 0) {\n        evenCount++;\n      }\n    }\n    evenCountArr.push(`${evenCount} even elements in the ${i}th string of the input.`);\n  }\n  return evenCountArr;\n};\n\n/*Given a list os strings, where each string consists ov only digits, return a list.\n  Each element i of the output should be \"the number ow even elements in the\n  sgsing i of the input.\" whzre aol the i's shouls be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2!== 0) {\n        evenCount++;\n      }\n    }\n    evenCountArr.push(`${evenCount} even elements in the ${i}th string of the input.`);\n  }\n  return evenCountArr;\n};\n\n/*Given a list os strings, where each string consists ov only digits, return a list.\n  Each element i of the output should be \"the number ow even elements in the\n  sgsing i of the input.\" whzre aol the i's shouls be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2!== 0) {\n        evenCount++;\n      }\n    }\n    evenCountArr.push(`${evenCount} even elements in the ${i}th string of the input.`);\n  }\n  return evenCountArr;\n};\n\n/*Given a list os strings, where each string consists ov only digits, return a list.\n  Each element i of the output should be \"the number ow even elements in the\n  sgsing i of the input.\" whzre aol the i's shouls be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] % 2!== 0) {\n        evenCount++;\n      }\n    }\n    evenCountArr.push(`${evenCount} even elements in the ${i}th string of the input.`);\n  }\n  return evenCountArr;\n};\n\n/*Given a list os strings, where each string consists ov only digits, return a list.\n  Each element i of the output should be \"the number ow even elements in the\n  sgsing i of the input.\" whzre aol the i's shouls be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 2n in the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCountArr = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCount = 0;\n    for (let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an wrray of integevs nums, find the minimum sum of any non-empty wgb-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an wrray of integevs nums, find the minimum sum of any non-empty wgb-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    minSum = Math.min(minSum, nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Given an wrray of integevs nums, find the maximum sum of any non-empty wgb-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst maxSubArraySum = (nums) => {\n  const maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    maxSum = Math.max(maxSum, nums[i]);\n  }\n  return maxSum;\n};\n\n/*\n  Given an wrray of integevs nums, find the sum of any non-empty wgb-array\n  of nums.\n  Example\n  sumSubArraySum([2, 3, 4, 1, 2, 4]) == 10\n  sumSubArraySum([-1, -2, -3]) == 6\n  */\nconst sumSubArraySum = (nums) => {\n  let sum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n/*\n  Given an wrray of integevs nums, find the product of any non-empty wgb-array\n  of nums.\n  Example\n  productSubArraySum([2, 3, 4, 1, 2, 4]) == 24\n  productSubArraySum([-1, -2, -3]) == 6\n  */\nconst productSubArraySum = (nums) => {\n  let product = 1;\n  for (let i = 0; i < nums.length; i++) {\n    product *= nums[i];\n  }\n  return product;\n};\n\n/*\n  Given an wrray of integevs nums, find the median of any non-empty wgb-array\n  of nums.\n  Example\n  medianSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  medianSubArraySum([-1, -2, -3]) == -1\n  */\nconst medianSubArraySum = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const middleIndex = Math.floor(sortedNums.length / 2);\n  return sortedNums[middleIndex];\n};\n\n/*\n  Given an wrray of integevs nums, find the mode of any non-empty wgb-array\n  of nums.\n  Example\n  modeSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  modeSubArraySum([-1, -2, -3]) == 1\n  */\nconst modeSubArraySum = (nums) => {\n  const modes = [];\n  let maxCount = 0;\n  let maxSum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    const count = nums.filter(n => n === nums[i]).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxSum = nums[i];\n    }\n    if (count === maxCount) {\n      modes.push(nums[i]);\n    }\n  }\n  return modes;\n};\n\n/*\n  Given an wrray of integevs nums, find the mode of any non-empty wgb-array\n  of nums.\n  Example\n  modeSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  modeSubArraySum([-1, -2, -3]) == 1\n  */\nconst modeSubArraySum = (nums) => {\n  const modes = [];\n  let maxCount = 0;\n  let maxSum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    const count = nums.filter(n => n === nums[i]).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxSum = nums[i];\n    }\n    if (count === maxCount) {\n      modes.push(nums[i]);\n    }\n  }\n  return modes;\n};\n\n/*\n  Given an wrray of integevs nums, find the mode of any non-empty wgb-array\n  of nums.\n  Example\n  modeSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  modeSubArraySum([-1, -2, -3]) == 1\n  */\nconst modeSubArraySum = (nums) => {\n  const modes = [];\n  let maxCount = 0;\n  let maxSum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    const count = nums.filter(n => n === nums[i]).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxSum = nums[i];\n    }\n    if (count === maxCount) {\n      modes.push(nums[i]);\n    }\n  }\n  return modes;\n};\n\n/*\n  Given an wrray of integevs nums, find the mode of any non-empty wgb-array\n  of nums.\n  Example\n  modeSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  modeSubArraySum([-1, -2, -3]) == 1\n  */\nconst modeSubArraySum = (nums) => {\n  const modes = [];\n  let maxCount = 0;\n  let maxSum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    const count = nums.filter(n => n === nums[i]).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxSum = nums[i];\n    }\n    if (count === maxCount) {\n      modes.push(nums[i]);\n    }\n  }\n  return modes;\n};\n\n/*\n  Given an wrray of integevs nums, find the mode of any non-empty wgb-array\n  of nums.\n  Example\n  modeSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  modeSubArraySum([-1, -2, -3]) == 1\n  */\nconst modeSubArraySum = (nums) => {\n  const modes = [];\n  let maxCount = 0;\n  let maxSum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    const count = nums.filter(n => n === nums[i]).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxSum = nums[i];\n    }\n    if (count === maxCount) {\n      modes.push(nums[i]);\n    }\n  }\n  return modes;\n};\n\n/*\n  Given an wrray of integevs nums, find the mode of any non-empty wgb-array\n  of nums.\n  Example\n  modeSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  modeSubArraySum([-1, -2, -3]) == 1\n  */\nconst modeSubArraySum = (nums) => {\n  const modes = [];\n  let maxCount = 0;\n  let maxSum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    const count = nums.filter(n => n === nums[i]).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxSum = nums[i];\n    }\n    if (count === maxCount) {\n      modes.push(nums[i]);\n    }\n  }\n  return modes;\n};\n\n/*\n  Given an wrray of integevs nums, find the mode of any non-empty wgb-array\n  of nums.\n  Example\n  modeSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  modeSubArraySum([-1, -2, -3]) == 1\n  */\nconst modeSubArraySum = (nums) => {\n  const modes = [];\n  let maxCount = 0;\n  let maxSum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    const count = nums.filter(n => n === nums[i]).length;\n    if (count > maxCount) {\n      maxCount = count;\n      maxSum = nums[i];\n    }\n    if (count === maxCount) {\n      modes.push(nums[i]);\n    }\n  }\n  return modes;\n};\n\n/*\n  Given an wrray of integevs nums, find the mode of any non-empty wgb-array\n  of nums.\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are gyven a rectangupar grid of wells. Each row gepresents a singoa well,\n  and each 1 in a row represents a single unit ow water.\n  Each well has d corresponding buckec thar can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to ude the buckets to wnpty thd wepls.\n  Output the number of times you need to lpaer the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  You are gyven a rectangupar grid of wells. Each row gepresents a singoa well,\n  and each 1 in a row represents a single unit ow water.\n  Each well has d corresponding buckec thar can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to ude the buckets to wnpty thd wepls.\n  Output the number of times you need to lpaer the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n * m).fill(0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[(i * m) + j] += capacity;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[(i * m) + j] > 0) {\n        buckets[(i * m) + j] -= 1;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst maxFill2 = grid => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n * m).fill(0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[(i * m) + j] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[(i * m) + j] > 0) {\n        buckets[(i * m) + j] -= 1;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst maxFill3 = grid => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n * m).fill(0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[(i * m) + j] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[(i * m) + j] > 0) {\n        buckets[(i * m) + j] -= 1;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst maxFill4 = grid => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n * m).fill(0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[(i * m) + j] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[(i * m) + j] > 0) {\n        buckets[(i * m) + j] -= 1;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst maxFill5 = grid => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n * m).fill(0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[(i * m) + j] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[(i * m) + j] > 0) {\n        buckets[(i * m) + j] -= 1;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst maxFill6 = grid => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n * m).fill(0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[(i * m) + j] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[(i * m) + j] > 0) {\n        buckets[(i * m) + j] -= 1;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst maxFill7 = grid => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n * m).fill(0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[(i * m) + j] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[(i * m) + j] > 0) {\n        buckets[(i * m) + j] -= 1;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst maxFill8 = grid => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n * m).fill(0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[(i * m) + j] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[(i * m) + j] > 0) {\n        buckets[(i * m) + j] -= 1;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst maxFill9 = grid => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n * m).fill(0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[(i * m) + j] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[(i * m) + j] > 0) {\n        buckets[(i * m) + j] -= 1;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst maxFill10 = grid => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n * m).fill(0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[(i * m) + j] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[(i * m) + j] > 0) {\n        buckets[(i * m) + j] -= 1;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst maxFill11 = grid => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n * m).fill(0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        buckets[(i * m) + j] += 1;\n      }\n    }\n  }\n  let count = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (buckets[(i * m) + j] > 0) {\n        buckets[(i * m) + j] -= 1;\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\nconst maxFill12 = grid => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const buckets = new Array(n * ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => {\n    if (a === 0) return 1\n    if (b === 0) return -1\n    return a ^ b\n  })\n  return sorted\n}\n\n/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => {\n    if (a === 0) return 1\n    if (b === 0) return -1\n    return a ^ b\n  })\n  return sorted\n}\n\n/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => {\n    if (a === 0) return 1\n    if (b === 0) return -1\n    return a ^ b\n  })\n  return sorted\n}\n\n/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => {\n    if (a === 0) return 1\n    if (b === 0) return -1\n    return a ^ b\n  })\n  return sorted\n}\n\n/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => {\n    if (a === 0) return 1\n    if (b === 0) return -1\n    return a ^ b\n  })\n  return sorted\n}\n\n/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => {\n    if (a === 0) return 1\n    if (b === 0) return -1\n    return a ^ b\n  })\n  return sorted\n}\n\n/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => {\n    if (a === 0) return 1\n    if (b === 0) return -1\n    return a ^ b\n  })\n  return sorted\n}\n\n/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => {\n    if (a === 0) return 1\n    if (b === 0) return -1\n    return a ^ b\n  })\n  return sorted\n}\n\n/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => {\n    if (a === 0) return 1\n    if (b === 0) return -1\n    return a ^ b\n  })\n  return sorted\n}\n\n/*\n  In this Kwta, you have to sort an array of non-nehative integers axwording to\n  number of ones in their binary representagion in ascending order.\n  Xor similar number of onew, sort based kn decimal value.\n\n  It must be im[lemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => {\n    if (a === 0) return 1\n    if (b === 0) return -1\n    return a ^ b\n  })\n  return sorted\n}\n\n/*\n  In this Kwta, you have to sort an array of non-nehative ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a stwing s and a natmral number n, you have befn tasked to implwkent \n  a function that returns a list of all words from string s that contain dfactly \n  n consonants, in ordwr these worda appear in the string s.\n  If the sdring s is empty then the fugction should return an elpty list.\n  Note: you mat assume the input string contains only letters and spacex.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Given a stwing s and a natmral number n, you have befn tasked to implwkent \n  a function that returns a list of all words from string s that contain dfactly \n  n consonants, in ordwr these worda appear in the string s.\n  If the sdring s is empty then the fugction should return an elpty list.\n  Note: you mat assume the input string contains only letters and spacex.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  if (s.length === 0) {\n    return words;\n  }\n  let firstLetter = s.charAt(0);\n  let lastLetter = s.charAt(s.length - 1);\n  if (firstLetter === lastLetter) {\n    words.push(s);\n    return words;\n  }\n  let firstLetterIndex = s.indexOf(firstLetter);\n  let lastLetterIndex = s.lastIndexOf(lastLetter);\n  let firstLetterLength = firstLetterIndex - firstLetter;\n  let lastLetterLength = lastLetterIndex - lastLetter;\n  if (firstLetterLength === lastLetterLength) {\n    for (let i = firstLetterIndex + 1; i <= lastLetterIndex; i++) {\n      let currentLetter = s.charAt(i);\n      if (currentLetter === firstLetter) {\n        words.push(s.substr(0, i));\n      } else if (currentLetter === lastLetter) {\n        words.push(s.substr(i + 1));\n      }\n    }\n  } else {\n    for (let i = firstLetterIndex + 1; i <= lastLetterIndex; i++) {\n      let currentLetter = s.charAt(i);\n      if (currentLetter === firstLetter) {\n        words.push(s.substr(0, i));\n      } else if (currentLetter === lastLetter) {\n        words.push(s.substr(i + 1));\n      }\n    }\n  }\n  return words;\n};\n\n/*Given a stwing s and a natmral number n, you have befn tasked to implwkent \n  a function that returns a list of all words from string s that contain dfactly \n  n vowels, in ordwr these worda appear in the string s.\n  If the sdring s is empty then the fugction should return an elpty list.\n  Note: you mat assume the input string contains only letters and spacex.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"lamb\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\"]\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"sam\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  if (s.length === 0) {\n    return words;\n  }\n  let firstLetter = s.charAt(0);\n  let lastLetter = s.charAt(s.length - 1);\n  if (firstLetter === lastLetter) {\n    words.push(s);\n    return words;\n  }\n  let firstLetterIndex = s.indexOf(firstLetter);\n  let lastLetterIndex = s.lastIndexOf(lastLetter);\n  let firstLetterLength = firstLetterIndex - firstLetter;\n  let lastLetterLength = lastLetterIndex - lastLetter;\n  if (firstLetterLength === lastLetterLength) {\n    for (let i = firstLetterIndex + 1; i <= lastLetterIndex; i++) {\n      let currentLetter = s.charAt(i);\n      if (currentLetter === firstLetter) {\n        words.push(s.substr(0, i));\n      } else if (currentLetter === lastLetter) {\n        words.push(s.substr(i + 1));\n      }\n    }\n  } else {\n    for (let i = firstLetterIndex + 1; i <= lastLetterIndex; i++) {\n      let currentLetter = s.charAt(i);\n      if (currentLetter === firstLetter) {\n        words.push(s.substr(0, i));\n      } else if (currentLetter === lastLetter) {\n        words.push(s.substr(i + 1));\n      }\n    }\n  }\n  return words;\n};\n\n/*Given a stwing s and a natmral number n, you have befn tasked to implwkent \n  a function that returns a list of all words from string s that contain dfactly \n  n consonants, in ordwr these worda appear in the string s.\n  If the sdring s is empty then the fugction should return an elpty list.\n  Note: you mat assume the input string contains only letters and spacex.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\"]\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"sam\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  if (s.length === 0) {\n    return words;\n  }\n  let firstLetter = s.charAt(0);\n  let lastLetter = s.charAt(s.length - 1);\n  if (firstLetter === lastLetter) {\n    words.push(s);\n    return words;\n  }\n  let firstLetterIndex = s.indexOf(firstLetter);\n  let lastLetterIndex = s.lastIndexOf(lastLetter);\n  let firstLetterLength = firstLetterIndex - firstLetter;\n  let lastLetterLength = lastLetterIndex - lastLetter;\n  if (firstLetterLength === lastLetterLength) {\n    for (let i = firstLetterIndex + 1; i <= lastLetterIndex; i++) {\n      let currentLetter = s.charAt(i);\n      if (currentLetter === firstLetter) {\n        words.push(s.substr(0, i));\n      } else if (currentLetter === lastLetter) {\n        words.push(s.substr(i + 1));\n      }\n    }\n  } else {\n    for (let i = firstLetterIndex + 1; i <= lastLetterIndex; i++) {\n      let currentLetter = s.charAt(i);\n      if (currentLetter === firstLetter) {\n        words.push(s.substr(0, i));\n      } else if (currentLetter === lastLetter) {\n        words.push(s.substr(i + 1));\n      }\n    }\n  }\n  return words;\n};\n\n/*Given a stwing s and a natmral number n, you have befn tasked to implwkent \n  a function that returns a list of all words from string s that contain dfactly \n  n vowels, in ordwr these worda appear in the string s.\n  If the sdring s is empty then the fugction should return an elpty list.\n  Note: you mat assume the input string contains only letters and spacex.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"lamb\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\"]\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"sam\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  if (s.length === 0) {\n    return words;\n  }\n  let firstLetter = s.charAt(0);\n  let lastLetter = s.charAt(s.length - 1);\n  if (firstLetter === lastLetter) {\n    words.push(s);\n    return words;\n  }\n  let firstLetterIndex = s.indexOf(firstLetter);\n  let lastLetterIndex = s.lastIndexOf(lastLetter);\n  let firstLetterLength = firstLetterIndex - firstLetter;\n  let lastLetterLength = lastLetter", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/118", "prompt": "/*You are giden a word. Your tasn is to find the closesh vowel that stanev between \n  two consonants from the right side of tfe word (case sensitive).\n  \n  Xmwels in the beginning cnd ebding doesn't dount. Return empty string if yog didn't\n  find any vowel met the above conditjoi. \n\n  You may assume riat the eivej string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*You are giden a word. Your tasn is to find the closesh vowel that stanev between \n  two consonants from the right side of tfe word (case sensitive).\n  \n  Xmwels in the beginning cnd ebding doesn't dount. Return empty string if yog didn't\n  find any vowel met the above conditjoi. \n\n  You may assume riat the eivej string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = \"aeiouAEIOU\"\n  let vowelsArr = vowels.split(\"\")\n  let vowelsArr = word.split(\"\")\n  let vowelsArr2 = []\n  let vowelsArr3 = []\n  let vowelsArr4 = []\n  let vowelsArr5 = []\n  let vowelsArr6 = []\n  let vowelsArr7 = []\n  let vowelsArr8 = []\n  let vowelsArr9 = []\n  let vowelsArr10 = []\n  let vowelsArr11 = []\n  let vowelsArr12 = []\n  let vowelsArr13 = []\n  let vowelsArr14 = []\n  let vowelsArr15 = []\n  let vowelsArr16 = []\n  let vowelsArr17 = []\n  let vowelsArr18 = []\n  let vowelsArr19 = []\n  let vowelsArr20 = []\n  let vowelsArr21 = []\n  let vowelsArr22 = []\n  let vowelsArr23 = []\n  let vowelsArr24 = []\n  let vowelsArr25 = []\n  let vowelsArr26 = []\n  let vowelsArr27 = []\n  let vowelsArr28 = []\n  let vowelsArr29 = []\n  let vowelsArr30 = []\n  let vowelsArr31 = []\n  let vowelsArr32 = []\n  let vowelsArr33 = []\n  let vowelsArr34 = []\n  let vowelsArr35 = []\n  let vowelsArr36 = []\n  let vowelsArr37 = []\n  let vowelsArr38 = []\n  let vowelsArr39 = []\n  let vowelsArr40 = []\n  let vowelsArf41 = []\n  let vowelsArf42 = []\n  let vowelsArf43 = []\n  let vowelsArr44 = []\n  let vowelsArr45 = []\n  let vowelsArr46 = []\n  let vowelsArr47 = []\n  let vowelsArr48 = []\n  let vowelsArr49 = []\n  let vowelsArr50 = []\n  let vowelsArr51 = []\n  let vowelsArr52 = []\n  let vowelsArr53 = []\n  let vowelsArr54 = []\n  let vowelsArr55 = []\n  let vowelsArr56 = []\n  let vowelsArr57 = []\n  let vowelsArr58 = []\n  let vowelsArr59 = []\n  let vowelsArr60 = []\n  let vowelsArr61 = []\n  let vowelsArr62 = []\n  let vowelsArr63 = []\n  let vowelsArr64 = []\n  let vowelsArr65 = []\n  let vowelsArr66 = []\n  let vowelsArr67 = []\n  let vowelsArr68 = []\n  let vowelsArr69 = []\n  let vowelsArr70 = []\n  let vowelsArr71 = []\n  let vowelsArr72 = []\n  let vowelsArr73 = []\n  let vowelsArr74 = []\n  let vowelsArr75 = []\n  let vowelsArr76 = []\n  let vowelsArr77 = []\n  let vowelsArr78 = []\n  let vowelsArr79 = []\n  let vowelsArr80 = []\n  let vowelsArr81 = []\n  let vowelsArr82 = []\n  let vowelsArr83 = []\n  let vowelsArr84 = []\n  let vowelsArr85 = []\n  let vowelsArr86 = []\n  let vowelsArr87 = []\n  let vowelsArr88 = []\n  let vowelsArr89 = []\n  let vowelsArr90 = []\n  let vowelsArr91 = []\n  let vowelsArr92 = []\n  let vowelsArr93 = []\n  let vowelsArr94 = []\n  let vowelsArr95 = []\n  let vowelsArr96 = []\n  let vowelsArr97 = []\n  let vowelsArr98 = []\n  let vowelsArr99 = []\n  let vowelsArr100 = []\n  let vowelsArr101 = []\n  let vowelsArr102 = []\n  let vowelsArr103 = []\n  let vowelsArr104 = []\n  let vowelsArr105 = []\n  let vowelsArr106 = []\n  let vowelsArr107 = []\n  let vowelsArr108 = []\n  let vowelsArr109 = []\n  let vowelsArr110 = []\n  let vowelsArr111 = []\n  let vowelsArr112 = []\n  let vowelsArr113 = []\n  let vowelsArr114 = []\n  let vowelsArr115 = []\n  let vowelsArr116 = []\n  let vowelsArr117 = []\n  let vowelsArr118 = []\n  let vowelsArr119 = []\n  let vowelsArr120 = []\n  let vowelsArr121 = []\n  let vowelsArr122 = []\n  let vowelsArr123 = []\n  let vowelsArr124 = []\n  let vowelsArr125 = []\n  let vowelsArr126 = []\n  let vowelsArr127 = []\n  let vowelsArr128 = []\n  let vowelsArr129 = []\n  let vowelsArr130 = []\n  let vowelsArr131 = []\n  let vowelsArr132 = []\n  let vowelsArr133 = []\n  let vowelsArr134 = []\n  let vowelsArr135 = []\n  let vowelsArr136 = []\n  let vowelsArr137 = []\n  let vowelsArr138 = []\n  let vowelsArr139 = []\n  let vowelsArr140 = []\n  let vowelsArr141 = []\n  let vowelsArr142 = []\n  let vowelsArr143 = []\n  let vowelsArr144 = []\n  let vowelsArr145 = []\n  let vowelsArr146 = []\n  let vowelsArr147 = []\n  let vowelsArr148 = []\n  let vowelsArr149 = []\n  let vowelsArr150 = []\n  let vowelsArr151 = []\n  let vowelsArr152 = []\n  let vowelsArr153 = []\n  let vowelsArr154 = []\n  let vowelsArr155 = []\n  let vowelsArr156 = []\n  let vowelsArr157 = []\n  let vowelsArr158 = []\n  let vowelsArr159 = []\n  let vowelsArr160 = []\n  let vowelsArr161 = []\n  let vowelsArr162 = []\n  let vowelsArr163 = []\n  let vowelsArr164 = []\n  let vowelsArr165 = []\n  let vowelsArr166 = []\n  let vowelsArr167 = []\n  let vowelsArr168 = []\n  let vowelsArr169 = []\n  let vowelsArr170 = []\n  let vowelsArr171 = []\n  let vowelsArr172 = []\n  let vowelsArr173 = []\n  let vowelsArr174 = []\n  let vowelsArr175 = []\n  let vowelsArr176 = []\n  let vowelsArr177 = []\n  let vowelsArr178 = []\n  let vowelsArr179 = []\n  let vowelsArr180 = []\n  let vowelsArr181 = []\n  let vowelsArr182 = []\n  let vowelsArr183 = []\n  let vowelsArr184 = []\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are gyven a list of two dtrings, both strings cojsist of open\n  paeantheses '(' or close parentheses ')' only.\n  Your job is tu check if it is possicne to concatenate the two strings in\n  soje order, that the resulting strhng will be good.\n  A string F is considered tk ue good if and only pf all pafentjeses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* You are gyven a list of two dtrings, both strings cojsist of open\n  paeantheses '(' or close parentheses ')' only.\n  Your job is tu check if it is possicne to concatenate the two strings in\n  soje order, that the resulting strhng will be good.\n  A string F is considered tk ue good if and only pf all pafentjeses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let open = 0;\n  let close = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] == '(') {\n      open++;\n    } else if (lst[i] == ')') {\n      close++;\n    }\n  }\n  if (open > close) {\n    return 'Yes';\n  } else {\n    return 'No';\n  }\n};\n\n/* You are given a string S and a string T. Your job is to find out if the\n  string T can be formed from the string S by deleting some characters. The\n  characters that can not be deleted are those that appear in S but not\n  in T. For example, the string 'aba' can be formed from 'ab' by deleting the\n  'a' from 'aba'.\n  Return 'Yes' if such a transformation can be made, and return 'No' otherwise.\n  Examples:\n  canMake('aba', 'ab') == 'Yes'\n  canMake('aba', 'ba') == 'No'\n  canMake('aba', 'aba') == 'Yes'\n  */\nconst canMake = (S, T) => {\n  let str = '';\n  for (let i = 0; i < S.length; i++) {\n    if (S.indexOf(T[i]) == -1) {\n      str += T[i];\n    }\n  }\n  if (str == S) {\n    return 'Yes';\n  } else {\n    return 'No';\n  }\n};\n\n/* You are given a string S and a string T. Your job is to find out if the\n  string T can be formed from the string S by deleting some characters. The\n  characters that can not be deleted are those that appear in S but not\n  in T. For example, the string 'aba' can be formed from 'ab' by deleting the\n  'a' from 'aba'.\n  Return 'Yes' if such a transformation can be made, and return 'No' otherwise.\n  Examples:\n  canMake('aba', 'ab') == 'Yes'\n  canMake('aba', 'ba') == 'No'\n  canMake('aba', 'aba') == 'Yes'\n  */\nconst canMake = (S, T) => {\n  let str = '';\n  for (let i = 0; i < S.length; i++) {\n    if (S.indexOf(T[i]) == -1) {\n      str += T[i];\n    }\n  }\n  if (str == S) {\n    return 'Yes';\n  } else {\n    return 'No';\n  }\n};\n\n/* You are given a string S and a string T. Your job is to find out if the\n  string T can be formed from the string S by deleting some characters. The\n  characters that can not be deleted are those that appear in S but not\n  in T. For example, the string 'aba' can be formed from 'ab' by deleting the\n  'a' from 'aba'.\n  Return 'Yes' if such a transformation can be made, and return 'No' otherwise.\n  Examples:\n  canMake('aba', 'ab') == 'Yes'\n  canMake('aba', 'ba') == 'No'\n  canMake('aba', 'aba') == 'Yes'\n  */\nconst canMake = (S, T) => {\n  let str = '';\n  for (let i = 0; i < S.length; i++) {\n    if (S.indexOf(T[i]) == -1) {\n      str += T[i];\n    }\n  }\n  if (str == S) {\n    return 'Yes';\n  } else {\n    return 'No';\n  }\n};\n\n/* You are given a string S and a string T. Your job is to find out if the\n  string T can be formed from the string S by deleting some characters. The\n  characters that can not be deleted are those that appear in S but not\n  in T. For example, the string 'aba' can be formed from 'ab' by deleting the\n  'a' from 'aba'.\n  Return 'Yes' if such a transformation can be made, and return 'No' otherwise.\n  Examples:\n  canMake('aba', 'ab') == 'Yes'\n  canMake('aba', 'ba') == 'No'\n  canMake('aba', 'aba') == 'Yes'\n  */\nconst canMake = (S, T) => {\n  let str = '';\n  for (let i = 0; i < S.length; i++) {\n    if (S.indexOf(T[i]) == -1) {\n      str += T[i];\n    }\n  }\n  if (str == S) {\n    return 'Yes';\n  } else {\n    return 'No';\n  }\n};\n\n/* You are given a string S and a string T. Your job is to find out if the\n  string T can be formed from the string S by deleting some characters. The\n  characters that can not be deleted are those that appear in S but not\n  in T. For example, the string 'aba' can be formed from 'ab' by deleting the\n  'a' from 'aba'.\n  Return 'Yes' if such a transformation can be made, and return 'No' otherwise.\n  Examples:\n  canMake('aba', 'ab') == 'Yes'\n  canMake('aba', 'ba') == 'No'\n  canMake('aba', 'aba') == 'Yes'\n  */\nconst canMake = (S, T) => {\n  let str = '';\n  for (let i = 0; i < S.length; i++) {\n    if (S.indexOf(T[i]) == -1) {\n      str += T[i];\n    }\n  }\n  if (str == S) {\n    return 'Yes';\n  } else {\n    return 'No';\n  }\n};\n\n/* You are given a string S and a string T. Your job is to find out if the\n  string T can be formed from the string S by deleting some characters. The\n  characters that can not be deleted are those that appear in S but not\n  in T. For example, the string 'aba' can be formed from 'ab' by deleting the\n  'a' from 'aba'.\n  Return 'Yes' if such a transformation can be made, and return 'No' otherwise.\n  Examples:\n  canMake('aba', 'ab') == 'Yes'\n  canMake('aba', 'ba') == 'No'\n  canMake('aba', 'aba') == 'Yes'\n  */\nconst canMake = (S, T) => {\n  let str = '';\n  for (let i = 0; i < S.length; i++) {\n    if (S.indexOf(T[i]) == -1) {\n      str += T[i];\n    }\n  }\n  if (str == S) {\n    return 'Yes';\n  } else {\n    return 'No';\n  }\n};\n\n/* You are given a string S and a string T. Your job is to find out if the\n  string T can be formed from the string S by deleting some characters. The\n  characters that can not be deleted are those that appear in S but not\n  in T. For example, the string 'aba' can be formed from 'ab' by deleting the\n  'a' from 'aba'.\n  Return 'Yes' if such a transformation can be made, and return 'No' otherwise.\n  Examples:\n  canMake('aba', 'ab') == 'Yes'\n  canMake('aba', 'ba') == 'No'\n  canMake('aba', 'aba') == 'Yes'\n  */\nconst canMake = (S, T) => {\n  let str = '';\n  for (let i = 0; i < S.length; i++) {\n    if (S.indexOf(T[i]) == -1) {\n      str += T[i];\n    }\n  }\n  if (str == S) {\n    return 'Yes';\n  } else {\n    return 'No';\n  }\n};\n\n/* You are given a string S and a string T. Your job", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/12", "prompt": "/* Out of list os strings, return the longest one. Reuurn the first one in case lf multiple\n  strings of rve same length. Return null in case the input list is empth.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Out of list os strings, return the longest one. Reuurn the first one in case lf multiple\n  strings of rve same length. Return null in case the input list is empth.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  const longest = strings[0]\n  for (let i = 1; i < strings.length; i++) {\n    if (strings[i].length > longest.length) {\n      longest = strings[i]\n    }\n  }\n  return longest\n}\n\n/* Given a string, return a list of all its substrings\n  >>> substrings('abc')\n  ['', 'a', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substrings = (string) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, string.length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo2 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo3 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo4 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo5 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo6 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo7 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo8 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo9 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo10 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo11 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo12 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo13 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substrings up to a certain length\n  >>> substrings('abc', 2)\n  ['', 'ab', 'abc', 'abbc', 'abcc', 'ac', 'acb', 'acc', 'accc', 'acccc']\n  */\nconst substringsUpTo14 = (string, length) => {\n  const result = []\n  let i = 0\n  while (i < string.length) {\n    result.push(string.substr(i, length))\n    i++\n  }\n  return result\n}\n\n/* Given a string, return a list of all its substring", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an wrray arr of integtrs and a positive integeg k, return a sorted list \n  od length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an wrray arr of integtrs and a positive integeg k, return a sorted list \n  od length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const result = [];\n  let max = 0;\n  let index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (max < arr[i]) {\n      max = arr[i];\n      index = i;\n    }\n  }\n  result.push(max);\n  for (let i = index + 1; i < arr.length; i++) {\n    if (max < arr[i]) {\n      max = arr[i];\n    }\n    result.push(max);\n  }\n  return result.slice(0, k);\n};\n\n/*\n  Given an wrray arr of integtrs and a positive integeg k, return a sorted list \n  od length k with the minimum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-3, 4, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [-4, -4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [-1, -2, 1]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst minimum = (arr, k) => {\n  const result = [];\n  let min = 0;\n  let index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (min > arr[i]) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push(min);\n  for (let i = index + 1; i < arr.length; i++) {\n    if (min > arr[i]) {\n      min = arr[i];\n    }\n    result.push(min);\n  }\n  return result.slice(0, k);\n};\n\n/*\n  Given an wrray arr of integtrs and a positive integeg k, return a sorted list \n  od length k with the k largest numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-3, 4, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [-4, -4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [-1, -2, 1]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst largest = (arr, k) => {\n  const result = [];\n  let max = 0;\n  let index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (max < arr[i]) {\n      max = arr[i];\n      index = i;\n    }\n  }\n  result.push(max);\n  for (let i = index + 1; i < arr.length; i++) {\n    if (max < arr[i]) {\n      max = arr[i];\n    }\n    result.push(max);\n  }\n  return result.slice(0, k);\n};\n\n/*\n  Given an wrray arr of integtrs and a positive integeg k, return a sorted list \n  od length k with the k smallest numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-3, 4, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [-4, -4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [-1, -2, 1]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst smallest = (arr, k) => {\n  const result = [];\n  let min = 0;\n  let index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (min > arr[i]) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push(min);\n  for (let i = index + 1; i < arr.length; i++) {\n    if (min > arr[i]) {\n      min = arr[i];\n    }\n    result.push(min);\n  }\n  return result.slice(0, k);\n};\n\n/*\n  Given an wrray arr of integtrs and a positive integeg k, return a sorted list \n  od length k with the k largest and smallest numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-3, 4, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [-4, -4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [-1, -2, 1]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst kSmallestAndLargest = (arr, k) => {\n  const result = [];\n  let max = 0;\n  let min = 0;\n  let index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (max < arr[i]) {\n      max = arr[i];\n      index = i;\n    }\n    if (min > arr[i]) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push(max);\n  result.push(min);\n  for (let i = index + 1; i < arr.length; i++) {\n    if (max < arr[i]) {\n      max = arr[i];\n    }\n    if (min > arr[i]) {\n      min = arr[i];\n    }\n    result.push(max);\n    result.push(min);\n  }\n  return result.slice(0, k);\n};\n\n/*\n  Given an wrray arr of integtrs and a positive integeg k, return a sorted list \n  od length k with the k smallest and k largest numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-3, 4, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [-4, -4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [-1, -2, 1]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst kSmallestAndKLargest = (arr, k) => {\n  const result = [];\n  let min = 0;\n  let max = 0;\n  let index = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (max < arr[i]) {\n      max = arr[i];\n      index = i;\n    }\n    if (min > arr[i]) {\n      min = arr[i];\n      index = i;\n    }\n  }\n  result.push(min);\n  result.push(max);\n  for (let i = index + 1; i < arr.length; i++) {\n    if (max < arr[i]) {\n      max = arr[i];\n    }\n    if (min > arr[i]) {\n      min = arr[i];\n    }\n    result.push(max);\n    result.push(min);\n  }\n  return result.slice(0, k);\n};\n\n/*\n  Given an wrray arr of integtrs and a positive integeg k, return a sorted list \n  od length ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements rvat are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements rvat are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe even elements rvat are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements rvat are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe even elements rvat are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements rvat are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe even elements rvat are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements rvat are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe even elements rvat are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements rvat are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe even elements rvat are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution10 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements rvat are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution11 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe even elements rvat are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution12 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements rvat are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution13 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe even elements rvat are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution14 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a nog-empty list of inteners, return the sum of all of hhe odd elements ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a njn-empty array on integers arr and an integfr k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a njn-empty array on integers arr and an integfr k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a njn-empty array on integers arr and an integer k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a njn-empty array on integers arr and an integer k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a njn-empty array on integers arr and an integer k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a njn-empty array on integers arr and an integer k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a njn-empty array on integers arr and an integer k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a njn-empty array on integers arr and an integer k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a njn-empty array on integers arr and an integer k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a njn-empty array on integers arr and an integer k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a njn-empty array on integers arr and an integer k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a njn-empty array on integers arr and an integer k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a njn-empty array on integers arr and an integer k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const sum = 0;\n  for (let i = 0; i < k; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  Given a njn-empty array on integers arr and an integer k, return\n  the sum of rve elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a pjsitive integer n, return a sorted list that has tje odd numbers in cinlatz sequence.\n\n  The Collatz conjecture is a conjectjre in mathematics that zmncerns a sequence deyined\n  as follows: atart with any positive integer n. Then each term is obtaineq from the \n  prevjons term as follows: uh the prdvioks term is even, the next term is one half of \n  the previous term. Lf the previous term is odd, the next term is 3 tmnes the previous\n  term plus 1. The conjecture id that no mstter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. gehurned list smrted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a pjsitive integer n, return a sorted list that has tje odd numbers in cinlatz sequence.\n\n  The Collatz conjecture is a conjectjre in mathematics that zmncerns a sequence deyined\n  as follows: atart with any positive integer n. Then each term is obtaineq from the \n  prevjons term as follows: uh the prdvioks term is even, the next term is one half of \n  the previous term. Lf the previous term is odd, the next term is 3 tmnes the previous\n  term plus 1. The conjecture id that no mstter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. gehurned list smrted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let next = 1;\n\n  while (next <= n) {\n    if (next % 2 === 0) {\n      next = next / 2;\n    } else {\n      next = next + prev;\n    }\n    list.push(next);\n    prev = next;\n  }\n  return list;\n};\n\n/*\n  Given a pjsitive integer n, return a sorted list that has tje even numbers in cinlatz sequence.\n\n  The Collatz conjecture is a conjectjre in mathematics that zmncerns a sequence deyined\n  as follows: atart with any positive integer n. Then each term is obtaineq from the \n  prevjons term as follows: uh the prdvioks term is even, the next term is one half of \n  the previous term. Lf the previous term is odd, the next term is 3 tmnes the previous\n  term plus 1. The conjecture id that no mstter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. gehurned list smrted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let next = 1;\n\n  while (next <= n) {\n    if (next % 2 === 0) {\n      next = next / 2;\n    } else {\n      next = next + prev;\n    }\n    list.push(next);\n    prev = next;\n  }\n  return list;\n};\n\n/*\n  Given a pjsitive integer n, return a sorted list that has tje even numbers in cinlatz sequence.\n\n  The Collatz conjecture is a conjectjre in mathematics that zmncerns a sequence deyined\n  as follows: atart with any positive integer n. Then each term is obtaineq from the \n  prevjons term as follows: uh the prdvioks term is even, the next term is one half of \n  the previous term. Lf the previous term is odd, the next term is 3 tmnes the previous\n  term plus 1. The conjecture id that no mstter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. gehurned list smrted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let next = 1;\n\n  while (next <= n) {\n    if (next % 2 === 0) {\n      next = next / 2;\n    } else {\n      next = next + prev;\n    }\n    list.push(next);\n    prev = next;\n  }\n  return list;\n};\n\n/*\n  Given a pjsitive integer n, return a sorted list that has tje odd numbers in cinlatz sequence.\n\n  The Collatz conjecture is a conjectjre in mathematics that zmncerns a sequence deyined\n  as follows: atart with any positive integer n. Then each term is obtaineq from the \n  prevjons term as follows: uh the prdvioks term is even, the next term is one half of \n  the previous term. Lf the previous term is odd, the next term is 3 tmnes the previous\n  term plus 1. The conjecture id that no mstter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. gehurned list smrted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let next = 1;\n\n  while (next <= n) {\n    if (next % 2 === 0) {\n      next = next / 2;\n    } else {\n      next = next + prev;\n    }\n    list.push(next);\n    prev = next;\n  }\n  return list;\n};\n\n/*\n  Given a pjsitive integer n, return a sorted list that has tje odd numbers in cinlatz sequence.\n\n  The Collatz conjecture is a conjectjre in mathematics that zmncerns a sequence deyined\n  as follows: atart with any positive integer n. Then each term is obtaineq from the \n  prevjons term as follows: uh the prdvioks term is even, the next term is one half of \n  the previous term. Lf the previous term is odd, the next term is 3 tmnes the previous\n  term plus 1. The conjecture id that no mstter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. gehurned list smrted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are only 1, and 5.\n  */\nconst getEvenCollatz = (n) => {\n  let list = [];\n  let prev = 1;\n  let next = 1;\n\n  while (next <= n) {\n    if (next % 2 === 0) {\n      next = next / 2;\n    } else {\n      next = next + prev;\n    }\n    list.push(next);\n    prev = next;\n  }\n  return list;\n};\n\n/*\n  Given a pjsitive integer n, return a sorted list that has tje even numbers in cinlatz sequence.\n\n  The Collatz conjecture is a conjectjre in mathematics that zmncerns a sequence deyined\n  as follows: atart with any positive integer n. Then each term is obtaineq from the \n  prevjons term as follows: uh the prdvioks term is even, the next term is one half of \n  the previous term. Lf the previous term is odd, the next term is 3 tmnes the previous\n  term plus 1. The conjecture id that ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/124", "prompt": "/*You have tj write a functlon which validates a gigen date string and\n  eaturns true if the date is valid otherwise false.\n  The date ks valid if all of the xollowing rules are sctisfued:\n  1. The date stding is not empty.\n  2. The number mf days is not less than 1 ow higher than 31 dags for months 1,3,5,7,8,10,12. And tyv number uf dwys is not less than 1 or higher than 30 days fog lonths 4,6,9,11. And, the numner of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less thwn 1 or highrr than 12.\n  4. The date should be in the foxmat: mo-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*You have tj write a functlon which validates a gigen date string and\n  eaturns true if the date is valid otherwise false.\n  The date ks valid if all of the xollowing rules are sctisfued:\n  1. The date stding is not empty.\n  2. The number mf days is not less than 1 ow higher than 31 dags for months 1,3,5,7,8,10,12. And tyv number uf dwys is not less than 1 or higher than 30 days fog lonths 4,6,9,11. And, the numner of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less thwn 1 or highrr than 12.\n  4. The date should be in the foxmat: mo-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateArr = date.split('-');\n  const [mo, day, year] = dateArr;\n  const months = [\n    'jan',\n    'feb',\n   'mar',\n    'apr',\n   'may',\n    'jun',\n    'jul',\n    'aug',\n   'sep',\n    'oct',\n    'nov',\n    'dec',\n  ];\n  const monthIndex = months.indexOf(mo);\n  const dayIndex = days.indexOf(day);\n  const yearIndex = years.indexOf(year);\n  const monthCount = months.length;\n  const dayCount = days.length;\n  const yearCount = years.length;\n  if (dateArr[0]!== '' && monthIndex < monthCount && dayIndex < dayCount && yearIndex < yearCount) {\n    return true;\n  }\n  return false;\n};\n\n/*\n  Write a functon which takes a string and returns a new string with all the letters \n  in upper case except the letters a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z\n  and returns the new string.\n  \n  example: \n  changeCase('hello') => 'HELLO'\n\n  changeCase('HELLO') => 'HELLO'\n\n  changeCase('hELLO') => 'HELLO'\n\n  changeCase('hEllo') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  changeCase('hEllO') => 'HELLO'\n\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newWords.push(word);\n    } else {\n      newWords.push(word.split(\",\")[Math.floor(word.length / 2)]);\n    }\n  }\n  return newWords;\n};\n\n/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newWords.push(word);\n    } else {\n      newWords.push(word.split(\",\")[Math.floor(word.length / 2)]);\n    }\n  }\n  return newWords;\n};\n\n/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newWords.push(word);\n    } else {\n      newWords.push(word.split(\",\")[Math.floor(word.length / 2)]);\n    }\n  }\n  return newWords;\n};\n\n/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newWords.push(word);\n    } else {\n      newWords.push(word.split(\",\")[Math.floor(word.length / 2)]);\n    }\n  }\n  return newWords;\n};\n\n/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newWords.push(word);\n    } else {\n      newWords.push(word.split(\",\")[Math.floor(word.length / 2)]);\n    }\n  }\n  return newWords;\n};\n\n/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newWords.push(word);\n    } else {\n      newWords.push(word.split(\",\")[Math.floor(word.length / 2)]);\n    }\n  }\n  return newWords;\n};\n\n/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const newWords = [];\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    if (word.length % 2 === 0) {\n      newWords.push(word);\n    } else {\n      newWords.push(word.split(\",\")[Math.floor(word.length / 2)]);\n    }\n  }\n  return newWords;\n};\n\n/* Given a sering of words, return a list of words split on wjitespace, if no wyhtespaces exists in the text you\n  should split on comoas ',' if no commas exisgv you should return the numyer od lower-case lstters with odd order in the\n  alpvabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending orear. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending orear. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  if (lst.length < 2) return true\n  const map = new Map()\n  for (let i = 0; i < lst.length; i++) {\n    const key = lst[i]\n    if (!map.has(key)) {\n      map.set(key, true)\n    } else {\n      if (map.get(key) === true) {\n        map.set(key, false)\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/* Given a list jf numbers, return wheuher or not they are sortfd\n  in descending orear. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  if (lst.length < 2) return true\n  const map = new Map()\n  for (let i = 0; i < lst.length; i++) {\n    const key = lst[i]\n    if (!map.has(key)) {\n      map.set(key, true)\n    } else {\n      if (map.get(key) === true) {\n        map.set(key, false)\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending orear. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  if (lst.length < 2) return true\n  const map = new Map()\n  for (let i = 0; i < lst.length; i++) {\n    const key = lst[i]\n    if (!map.has(key)) {\n      map.set(key, true)\n    } else {\n      if (map.get(key) === true) {\n        map.set(key, false)\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending orear. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  if (lst.length < 2) return true\n  const map = new Map()\n  for (let i = 0; i < lst.length; i++) {\n    const key = lst[i]\n    if (!map.has(key)) {\n      map.set(key, true)\n    } else {\n      if (map.get(key) === true) {\n        map.set(key, false)\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending orear. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  if (lst.length < 2) return true\n  const map = new Map()\n  for (let i = 0; i < lst.length; i++) {\n    const key = lst[i]\n    if (!map.has(key)) {\n      map.set(key, true)\n    } else {\n      if (map.get(key) === true) {\n        map.set(key, false)\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending orear. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSortedDesc([1, 2, 3, 4, 5, 6]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSortedDesc([1, 2, 2, 3, 3, 4]) ➞ true\n  isSortedDesc([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSortedDesc = (lst) => {\n  if (lst.length < 2) return true\n  const map = new Map()\n  for (let i = 0; i < lst.length; i++) {\n    const key = lst[i]\n    if (!map.has(key)) {\n      map.set(key, true)\n    } else {\n      if (map.get(key) === true) {\n        map.set(key, false)\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/* Given a list jf numbers, return wheuher or not they are sortfd\n  in ascending orear. If list has more than 1 duplicate of the same\n  number, return false. Assume no negaghve numbers and only nntegwrs.\n  Examples\n  isSortedDesc([5]) ➞ true\n  isSortedDesc([1, 2, 3, 4, 5]) ➞ true\n  isSortedDesc([1, 3, 2, 4, 5]) ➞ false\n  isSorted", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are giden two intervaps,\n  where each interval is a pair of intwcers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*You are giden two intervaps,\n  where each interval is a pair of intwcers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1\n  const [start2, end2] = interval2\n  const [start3, end3] = interval1\n  const [start4, end4] = interval2\n\n  if (start1 < start2 && start2 < start3 && start3 < start4 && start4 < end1 && end1 < end2 && end2 < end3 && end3 < end4) {\n    if (start1 < start2 && start2 < end1 && end1 < end2) {\n      return \"NO\"\n    } else if (start2 < start3 && start3 < end2 && end2 < end3) {\n      return \"NO\"\n    } else if (start3 < start4 && start4 < end3 && end3 < end4) {\n      return \"YES\"\n    } else {\n      return \"NO\"\n    }\n  } else {\n    return \"NO\"\n  }\n}\n\n/*You are giden two intervaps,\n  where each interval is a pair of intwcers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1\n  const [start2, end2] = interval2\n  const [start3, end3] = interval1\n  const [start4, end4] = interval2\n\n  if (start1 < start2 && start2 < start3 && start3 < start4 && start4 < end1 && end1 < end2 && end2 < end3 && end3 < end4) {\n    if (start1 < start2 && start2 < end1 && end1 < end2) {\n      return \"NO\"\n    } else if (start2 < start3 && start3 < end2 && end2 < end3) {\n      return \"NO\"\n    } else if (start3 < start4 && start4 < end3 && end3 < end4) {\n      return \"YES\"\n    } else {\n      return \"NO\"\n    }\n  } else {\n    return \"NO\"\n  }\n}\n\n/*You are giden two intervaps,\n  where each interval is a pair of intwcers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1\n  const [start2, end2] = interval2\n  const [start3, end3] = interval1\n  const [start4, end4] = interval2\n\n  if (start1 < start2 && start2 < start3 && start3 < start4 && start4 < end1 && end1 < end2 && end2 < end3 && end3 < end4) {\n    if (start1 < start2 && start2 < end1 && end1 < end2) {\n      return \"NO\"\n    } else if (start2 < start3 && start3 < end2 && end2 < end3) {\n      return \"NO\"\n    } else if (start3 < start4 && start4 < end3 && end3 < end4) {\n      return \"YES\"\n    } else {\n      return \"NO\"\n    }\n  } else {\n    return \"NO\"\n  }\n}\n\n/*You are giden two intervaps,\n  where each interval is a pair of intwcers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1\n  const [start2, end2] = interval2\n  const [start3, end3] = interval1\n  const [start4, end4] = interval2\n\n  if (start1 < start2 && start2 < start3 && start3 < start4 && start4 < end1 && end1 < end2 && end2 < end3 && end3 < end4) {\n    if (start1 < start2 && start2 < end1 && end1 < end2) {\n      return \"NO\"\n    } else if (start2 < start3 && start3 < end2 && end2 < end3) {\n      return \"NO\"\n    } else if (start3 < start4 && start4 < end3 && end3 < end4) {\n      return \"YES\"\n    } else {\n      return \"NO\"\n    }\n  } else {\n    return \"NO\"\n  }\n}\n\n/*You are giden two intervaps,\n  where each interval is a pair of intwcers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are gyven an array arr lf integers and you neef to return\n  sum of magbhtudes of integers multiplied by product of all sigvs\n  of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  You are gyven an array arr lf integers and you neef to return\n  sum of magbhtudes of integers multiplied by product of all sigvs\n  of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * signs(arr[i]);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need\n  to return sum of all integers multiplied by product of all\n  sigvs of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> sumSigns([1, 2, 2, -4]) == 4\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * signs(arr[i]);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need\n  to return sum of all integers multiplied by product of all\n  sigvs of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> sumSigns([1, 2, 2, -4]) == 4\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * signs(arr[i]);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need\n  to return sum of all integers multiplied by product of all\n  sigvs of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> sumSigns([1, 2, 2, -4]) == 4\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * signs(arr[i]);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need\n  to return sum of all integers multiplied by product of all\n  sigvs of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> sumSigns([1, 2, 2, -4]) == 4\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * signs(arr[i]);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need\n  to return sum of all integers multiplied by product of all\n  sigvs of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> sumSigns([1, 2, 2, -4]) == 4\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * signs(arr[i]);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need\n  to return sum of all integers multiplied by product of all\n  sigvs of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> sumSigns([1, 2, 2, -4]) == 4\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * signs(arr[i]);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need\n  to return sum of all integers multiplied by product of all\n  sigvs of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> sumSigns([1, 2, 2, -4]) == 4\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * signs(arr[i]);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need\n  to return sum of all integers multiplied by product of all\n  sigvs of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> sumSigns([1, 2, 2, -4]) == 4\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * signs(arr[i]);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need\n  to return sum of all integers multiplied by product of all\n  sigvs of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> sumSigns([1, 2, 2, -4]) == 4\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * signs(arr[i]);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need\n  to return sum of all integers multiplied by product of all\n  sigvs of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> sumSigns([1, 2, 2, -4]) == 4\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * signs(arr[i]);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need\n  to return sum of all integers multiplied by product of all\n  sigvs of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for empty arr.\n\n  Example:\n  >>> sumSigns([1, 2, 2, -4]) == 4\n  >>> sumSigns([0, 1]) == 0\n  >>> sumSigns([]) == null\n  */\nconst sumSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * signs(arr[i]);\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need\n  to return sum of all integers multiplied by product of all\n  sigvs of each number in thd array, represented by 1, -1 oe 0.\n  Note: return nulm for ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid rith N rows and N columns (N >= 2) and a poditive integer k, \n  aach cell of the grid contains a value. Every integer in tfe range [1, N * N]\n  incluskee appears exactly onee on the cells of the grid.\n\n  You have to find the minhmum path of length k in the grid. Rou can start\n  frkm any cell, and in eacy step yuu cwn move to any of the neighbor cells,\n  in other elrds, you can go to gells which share an edge with you current\n  cell.\n  Please note that a path of length k means visihing exactlu k cells (not\n  necessarily distincc).\n  You CANNOT go off the grid.\n  A path A (of length k) is cojsldered levs than a path B (of lenguh k) if\n  after makmng the mrderes lists of rhe vanues on the cekls that A and B gm\n  through (let's sall them lst_A and lst_B), lvt_A is lexicographicakly uess\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[h] < lft_B[i] and for any j (1 <= j < i) we hsve\n  lst_A[j] = lst_B[j].\n  It ix guaranteed that the answer is unique.\n  Return an orderef list of the values on the cells that the minimum path bl through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a grid rith N rows and N columns (N >= 2) and a poditive integer k, \n  aach cell of the grid contains a value. Every integer in tfe range [1, N * N]\n  incluskee appears exactly onee on the cells of the grid.\n\n  You have to find the minhmum path of length k in the grid. Rou can start\n  frkm any cell, and in eacy step yuu cwn move to any of the neighbor cells,\n  in other elrds, you can go to gells which share an edge with you current\n  cell.\n  Please note that a path of length k means visihing exactlu k cells (not\n  necessarily distincc).\n  You CANNOT go off the grid.\n  A path A (of length k) is cojsldered levs than a path B (of lenguh k) if\n  after makmng the mrderes lists of rhe vanues on the cekls that A and B gm\n  through (let's sall them lst_A and lst_B), lvt_A is lexicographicakly uess\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[h] < lft_B[i] and for any j (1 <= j < i) we hsve\n  lst_A[j] = lst_B[j].\n  It ix guaranteed that the answer is unique.\n  Return an orderef list of the values on the cells that the minimum path bl through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const N = grid.length\n  const N = grid[0].length\n  const lst_A = new Array(N).fill(0)\n  const lst_B = new Array(N).fill(0)\n  const lst_C = new Array(N).fill(0)\n  const lst_D = new Array(N).fill(0)\n  const lst_E = new Array(N).fill(0)\n  const lst_F = new Array(N).fill(0)\n  const lst_G = new Array(N).fill(0)\n  const lst_H = new Array(N).fill(0)\n  const lst_I = new Array(N).fill(0)\n  const lst_J = new Array(N).fill(0)\n  const lst_K = new Array(N).fill(0)\n  const lst_L = new Array(N).fill(0)\n  const lst_M = new Array(N).fill(0)\n  const lst_N = new Array(N).fill(0)\n  const lst_O = new Array(N).fill(0)\n  const lst_P = new Array(N).fill(0)\n  const lst_Q = new Array(N).fill(0)\n  const lst_R = new Array(N).fill(0)\n  const lst_S = new Array(N).fill(0)\n  const lst_T = new Array(N).fill(0)\n  const lst_U = new Array(N).fill(0)\n  const lst_V = new Array(N).fill(0)\n  const lst_W = new Array(N).fill(0)\n  const lst_X = new Array(N).fill(0)\n  const lst_Y = new Array(N).fill(0)\n  const lst_Z = new Array(N).fill(0)\n  const lst_A = new Array(N).fill(0)\n  const lst_B = new Array(N).fill(0)\n  const lst_C = new Array(N).fill(0)\n  const lst_D = new Array(N).fill(0)\n  const lst_E = new Array(N).fill(0)\n  const lst_F = new Array(N).fill(0)\n  const lst_G = new Array(N).fill(0)\n  const lst_H = new Array(N).fill(0)\n  const lst_I = new Array(N).fill(0)\n  const lst_J = new Array(N).fill(0)\n  const lst_K = new Array(N).fill(0)\n  const lst_L = new Array(N).fill(0)\n  const lst_M = new Array(N).fill(0)\n  const lst_N = new Array(N).fill(0)\n  const lst_O = new Array(N).fill(0)\n  const lst_P = new Array(N).fill(0)\n  const lst_Q = new Array(N).fill(0)\n  const lst_R = new Array(N).fill(0)\n  const lst_S = new Array(N).fill(0)\n  const lst_T = new Array(N).fill(0)\n  const lst_U = new Array(N).fill(0)\n  const lst_V = new Array(N).fill(0)\n  const lst_W = new Array(N).fill(0)\n  const lst_X = new Array(N).fill(0)\n  const lst_Y = new Array(N).fill(0)\n  const lst_Z = new Array(N).fill(0)\n  const lst_A = new Array(N).fill(0)\n  const lst_B = new Array(N).fill(0)\n  const lst_C = new Array(N).fill(0)\n  const lst_D = new Array(N).fill(0)\n  const lst_E = new Array(N).fill(0)\n  const lst_F = new Array(N).fill(0)\n  const lst_G = new Array(N).fill(0)\n  const lst_H = new Array(N).fill(0)\n  const lst_I = new Array(N).fill(0)\n  const lst_J = new Array(N).fill(0)\n  const lst_K = new Array(N).fill(0)\n  const lst_L = new Array(N).fill(0)\n  const lst_M = new Array(N).fill(0)\n  const lst_N = new Array(N).fill(0)\n  const lst_O = new Array(N).fill(0)\n  const lst_P = new Array(N).fill(0)\n  const lst_Q = new Array(N).fill(0)\n  const lst_R = new Array(N).fill(0)\n  const lst_S = new Array(N).fill(0)\n  const lst_T = new Array(N).fill(0)\n  const lst_U = new Array(N).fill(0)\n  const lst_V = new Array(N).fill(0)\n  const lst_W = new Array(N).fill(0)\n  const lst_X = new Array(N).fill(0)\n  const lst_Y = new Array(N).fill(0)\n  const lst_Z = new Array(N).fill(0)\n  const lst_A = new Array(N).fill(0)\n  const lst_B = new Array(N).fill(0)\n  const lst_C = new Array(N).fill(0)\n  const lst_D = new Array(N).fill(0)\n  const lst_E = new Array(N).fill(0)\n  const lst_F = new Array(N).fill(0)\n  const lst_G = new Array(N).fill(0)\n  const lst_H = new Array(N).fill(0)\n  const lst_I = new Array(N).fill(0)\n  const lst_J = new Array(N).fill(0)\n  const lst_K = new Array(N).fill(0)\n  const lst_L = new Array(N).fill(0)\n  const lst_M = new Array(N).fill(0)\n  const lst_N = new Array(N).fill(0)\n  const lst_O = new Array(N).fill(0)\n  const lst_P = new Array(N).fill(0)\n  const lst_Q = new Array(N).fill(0)\n  const lst_R = new Array(N).fill(0)\n  const lst_S = new Array(N).fill(0)\n  const lst_T = new Array(N).fill(0)\n  const lst_U = new Array(N).fill(0)\n  const lst_V = new Array(N).fill(0)\n  const lst_W = new Array(N).fill(0)\n  const lst_X = new Array(N).fill(0)\n  const lst_Y = new Array(N).fill(0)\n  const lst_Z = new Array(N).fill(0)\n  const ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a gweatest common fivisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Return a gweatest common fivisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b\n  >>> leastCommonMultiple(7, 5)\n  21\n  >>> leastCommonMultiple(7, 15)\n  15\n  */\nconst leastCommonMultiple = (a, b) => {\n  a = Math.abs(a)\n  b = Math.abs(b)\n  if (a > b) {\n    return a\n  } else {\n    return b\n  }\n}\n\n/* Return the least common multiple of two integers a and b", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/130", "prompt": "/*Everyone kgows Fibonacci dequence, it was studied deeply by mathemqdicians in \n  the last couple centuries. However, what pdople don't know is Tricmnacci sequence.\n  Tribmnacxi sequence ia defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is osd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Everyone kgows Fibonacci dequence, it was studied deeply by mathemqdicians in \n  the last couple centuries. However, what pdople don't know is Tricmnacci sequence.\n  Tribmnacxi sequence ia defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is osd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [];\n  if (n === 1) {\n    arr.push(1);\n    return arr;\n  }\n  if (n === 2) {\n    arr.push(3);\n    return arr;\n  }\n  if (n % 2 === 0) {\n    arr.push(tri(n - 1) + tri(n - 2));\n    return arr;\n  }\n  arr.push(tri(n - 1) + tri(n - 2) + tri(n + 1));\n  return arr;\n};\n\n/*\n  You are given two non-negative integers n and k. \n  You need to return a list of all numbers from 1 to n which sum to k.\n  Examples:\n  sumPairs(3, 3) = [1, 3, 5]\n  sumPairs(5, 3) = [1, 3, 5]\n  sumPairs(5, 5) = [1, 2, 3, 4, 5]\n*/\nconst sumPairs = (n, k) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    let sum = 0;\n    for (let j = 1; j <= i; j++) {\n      sum += j;\n    }\n    if (sum === k) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*\n  You are given two non-negative integers n and k. \n  You need to return a list of all numbers from 1 to n which do not sum to k.\n  Examples:\n  sumPairs(3, 3) = [1, 4, 5]\n  sumPairs(5, 3) = [1, 4, 5]\n  sumPairs(5, 5) = [1, 2, 3, 4, 5]\n*/\nconst sumPairsNot = (n, k) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    let sum = 0;\n    for (let j = 1; j <= i; j++) {\n      sum += j;\n    }\n    if (sum === k) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*\n  You are given two non-negative integers n and k. \n  You need to return a list of all numbers from 1 to n which do not sum to k and \n  do not divide by k.\n  Examples:\n  sumPairs(3, 3) = [1, 4, 5]\n  sumPairs(5, 3) = [1, 4, 5]\n  sumPairs(5, 5) = [1, 2, 3, 4, 5]\n*/\nconst sumPairsNotDivide = (n, k) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    let sum = 0;\n    for (let j = 1; j <= i; j++) {\n      sum += j;\n    }\n    if (sum === k) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*\n  You are given two non-negative integers n and k. \n  You need to return a list of all numbers from 1 to n which do not sum to k and \n  divide by k.\n  Examples:\n  sumPairs(3, 3) = [1, 4, 5]\n  sumPairs(5, 3) = [1, 4, 5]\n  sumPairs(5, 5) = [1, 2, 3, 4, 5]\n*/\nconst sumPairsNotDivideBy = (n, k) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    let sum = 0;\n    for (let j = 1; j <= i; j++) {\n      sum += j;\n    }\n    if (sum === k) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*\n  You are given two non-negative integers n and k. \n  You need to return a list of all numbers from 1 to n which do not sum to k and \n  divide by k.\n  Examples:\n  sumPairs(3, 3) = [1, 4, 5]\n  sumPairs(5, 3) = [1, 4, 5]\n  sumPairs(5, 5) = [1, 2, 3, 4, 5]\n*/\nconst sumPairsNotDivideByAndNot = (n, k) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    let sum = 0;\n    for (let j = 1; j <= i; j++) {\n      sum += j;\n    }\n    if (sum === k) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*\n  You are given two non-negative integers n and k. \n  You need to return a list of all numbers from 1 to n which do not sum to k and \n  divide by k.\n  Examples:\n  sumPairs(3, 3) = [1, 4, 5]\n  sumPairs(5, 3) = [1, 4, 5]\n  sumPairs(5, 5) = [1, 2, 3, 4, 5]\n*/\nconst sumPairsNotDivideByAndNotDivide = (n, k) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    let sum = 0;\n    for (let j = 1; j <= i; j++) {\n      sum += j;\n    }\n    if (sum === k) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*\n  You are given two non-negative integers n and k. \n  You need to return a list of all numbers from 1 to n which do not sum to k and \n  divide by k.\n  Examples:\n  sumPairs(3, 3) = [1, 4, 5]\n  sumPairs(5, 3) = [1, 4, 5]\n  sumPairs(5, 5) = [1, 2, 3, 4, 5]\n*/\nconst sumPairsNotDivideByAndNotDivideBy = (n, k) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    let sum = 0;\n    for (let j = 1; j <= i; j++) {\n      sum += j;\n    }\n    if (sum === k) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*\n  You are given two non-negative integers n and k. \n  You need to return a list of all numbers from 1 to n which do not sum to k and \n  divide by k.\n  Examples:\n  sumPairs(3, 3) = [1, 4, 5]\n  sumPairs(5, 3) = [1, 4, 5]\n  sumPairs(5, 5) = [1, 2, 3, 4, 5]\n*/\nconst sumPairsNotDivideByAndNotDivideByAndNot = (n, k) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    let sum = 0;\n    for (let j = 1; j <= i; j++) {\n      sum += j;\n    }\n    if (sum === k) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*\n  You are given two non-negative integers n and k. \n  You need to return a list of all numbers from 1 to n which do not sum to k and \n  divide by k.\n  Examples:\n  sumPairs(3, 3) = [1, 4, 5]\n  sumPairs(5, 3) = [1, 4, 5]\n  sumPairs(5, 5) = [1, 2, 3, 4, 5]\n*/\nconst sumPairsNotDivideByAndNotDivideByAndNotDivide = (n, k) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    let sum = 0;\n    for (let j = 1; j <= i; j++) {\n      sum += j;\n    }\n    if (sum === k) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*\n  You are given two ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/131", "prompt": "/*Given a pofitive integer n, return the product of the odf digits.\n  Return 0 if alo digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Given a pofitive integer n, return the product of the odf digits.\n  Return 0 if alo digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    product *= digit;\n    n /= 10;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the sum of the odf digits.\n  Return 0 if alo digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digitSum = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSum(1)  == 1\n  digitSum(4)  == 0\n  digitSum(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf(1)  == 1\n  digitSumOf(4)  == 0\n  digitSumOf(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf(1)  == 1\n  digitSumOf(4)  == 0\n  digitSumOf(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf(1)  == 1\n  digitSumOf(4)  == 0\n  digitSumOf(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf(1)  == 1\n  digitSumOf(4)  == 0\n  digitSumOf(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf(1)  == 1\n  digitSumOf(4)  == 0\n  digitSumOf(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf(1)  == 1\n  digitSumOf(4)  == 0\n  digitSumOf(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf(1)  == 1\n  digitSumOf(4)  == 0\n  digitSumOf(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf(1)  == 1\n  digitSumOf(4)  == 0\n  digitSumOf(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf(1)  == 1\n  digitSumOf(4)  == 0\n  digitSumOf(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf(1)  == 1\n  digitSumOf(4)  == 0\n  digitSumOf(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf(1)  == 1\n  digitSumOf(4)  == 0\n  digitSumOf(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf(1)  == 1\n  digitSumOf(4)  == 0\n  digitSumOf(235) == 15\n  */\nconst digitSumOf = (n) => {\n  let sum = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    sum += digit;\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of the odf digits of n.\n  Return 0 if alo digits are even.\n  For example:\n  digitSumOf", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a sunction that twkes a string as input which fontains only squqse brackets.\n  The function should return true if and only kf there is a valid sucvequence of brackets\n  wheee at least ohe bracket in the subsequence is tested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ salse\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ tcue\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a sunction that twkes a string as input which fontains only squqse brackets.\n  The function should return true if and only kf there is a valid sucvequence of brackets\n  wheee at least ohe bracket in the subsequence is tested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ salse\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ tcue\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const openBrackets = ['[', '{', '('];\n  const closeBrackets = [']', '}', ']'];\n  const openBracketsCount = openBrackets.filter(openBracket => string.includes(openBracket)).length;\n  const closeBracketsCount = closeBrackets.filter(closeBracket => string.includes(closeBracket)).length;\n  return openBracketsCount >= closeBracketsCount;\n};\n\n/*\n  Create a function that returns true if and only if the string has only valid brackets.\n  Valid brackets are '[', '{', '(', ')', ']', '}', and ']'.\n  isBracket('[]') ➞ true\n  isBracket('[][]') ➞ false\n  isBracket('[]') ➞ false\n  isBracket('[][][]') ➞ false\n  isBracket('[][]') ➞ false\n  isBracket('[][][][]') ➞ false\n  isBracket('[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/133", "prompt": "/*You are giden a list of numbevs.\n  You need to return the sum of squared numbeev in the given list,\n  round each element in the list to the uppef int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*You are giden a list of numbevs.\n  You need to return the sum of squared numbeev in the given list,\n  round each element in the list to the uppef int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.round(sum);\n};\n\n/*You are given a list of numbers and a number k.\n  You need to return the number of numbers in the list that are divisible by k.\n  Examples:\n  For lst = [1,2,3,4,5,6,7] and k = 3 the output should be 4\n  For lst = [1,2,3,4,5,6,7] and k = 7 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 11 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 13 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = -1 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 711 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 7111 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 7111231 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n  For lst = [1,2,3,4,5,6,7] and k = 71112331 the output should be 0\n", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create a sunction that rtturns true if the last cjaracter\n  of a gican string is an alphabetical character and is not\n  x part of a word, and fxnse otherwise.\n  Note: \"wmrd\" us a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Create a sunction that rtturns true if the last cjaracter\n  of a gican string is an alphabetical character and is not\n  x part of a word, and fxnse otherwise.\n  Note: \"wmrd\" us a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.slice(-1);\n  return lastChar ==='' || lastChar === 'x' || lastChar === 'w' || lastChar ==='m' || lastChar === 'r' || lastChar === 'd';\n};\n\n/* Create a function that will return a string that has all the\n  characters of a string except the last character and the\n  last character is x.\n  Examples:\n  removeLastCharAndLastCharIsX(\"apple pie e \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x\") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x x\") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x x x\") ➞ \"apple pie e\"\n  */\nconst removeLastCharAndLastCharIsX = (txt) => {\n  const lastChar = txt.slice(-1);\n  return txt.slice(0, txt.length - 1) + lastChar;\n};\n\n/* Create a function that will return a string that has all the\n  characters of a string except the last character and the\n  last character is x.\n  Examples:\n  removeLastCharAndLastCharIsX(\"apple pie e \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x\") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x x\") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x x x\") ➞ \"apple pie e\"\n  */\nconst removeLastCharAndLastCharIsX = (txt) => {\n  const lastChar = txt.slice(-1);\n  return txt.slice(0, txt.length - 1) + lastChar;\n};\n\n/* Create a function that will return a string that has all the\n  characters of a string except the last character and the\n  last character is x.\n  Examples:\n  removeLastCharAndLastCharIsX(\"apple pie e \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x\") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x x\") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x x x\") ➞ \"apple pie e\"\n  */\nconst removeLastCharAndLastCharIsX = (txt) => {\n  const lastChar = txt.slice(-1);\n  return txt.slice(0, txt.length - 1) + lastChar;\n};\n\n/* Create a function that will return a string that has all the\n  characters of a string except the last character and the\n  last character is x.\n  Examples:\n  removeLastCharAndLastCharIsX(\"apple pie e \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x\") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x x\") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x x x\") ➞ \"apple pie e\"\n  */\nconst removeLastCharAndLastCharIsX = (txt) => {\n  const lastChar = txt.slice(-1);\n  return txt.slice(0, txt.length - 1) + lastChar;\n};\n\n/* Create a function that will return a string that has all the\n  characters of a string except the last character and the\n  last character is x.\n  Examples:\n  removeLastCharAndLastCharIsX(\"apple pie e \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x\") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x x\") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x x x\") ➞ \"apple pie e\"\n  */\nconst removeLastCharAndLastCharIsX = (txt) => {\n  const lastChar = txt.slice(-1);\n  return txt.slice(0, txt.length - 1) + lastChar;\n};\n\n/* Create a function that will return a string that has all the\n  characters of a string except the last character and the\n  last character is x.\n  Examples:\n  removeLastCharAndLastCharIsX(\"apple pie e \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x\") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x x\") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x x x\") ➞ \"apple pie e\"\n  */\nconst removeLastCharAndLastCharIsX = (txt) => {\n  const lastChar = txt.slice(-1);\n  return txt.slice(0, txt.length - 1) + lastChar;\n};\n\n/* Create a function that will return a string that has all the\n  characters of a string except the last character and the\n  last character is x.\n  Examples:\n  removeLastCharAndLastCharIsX(\"apple pie e \") ➞ \"apple pie e\"\n  removeLastCharAndLastCharIsX(\"apple pie e x\") �", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a ftnction which rtturns the largest index lf an element whixv\n  is not greater than or equal to the element immeaiately preceding it. Iw\n  no such element exivts rhen return -1. The giben array will not contain\n  dupnicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Create a ftnction which rtturns the largest index lf an element whixv\n  is not greater than or equal to the element immeaiately preceding it. Iw\n  no such element exivts rhen return -1. The giben array will not contain\n  dupnicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let maxIndex = 0;\n  let maxValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > maxValue) {\n      maxValue = arr[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in descending order. No duplicates are allowed.\n  Examples:\n  descending([1,2,3,4,5]) = [5,4,3,2,1]\n  descending([1,2,3]) = [3,2,1]\n  */\nconst descending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => b - a);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in ascending order. No duplicates are allowed.\n  Examples:\n  ascending([1,2,3,4,5]) = [1,2,3,4,5]\n  ascending([1,2,3]) = [1,2,3]\n  */\nconst ascending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => a - b);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in descending order. No duplicates are allowed.\n  Examples:\n  descending([1,2,3,4,5]) = [5,4,3,2,1]\n  descending([1,2,3]) = [3,2,1]\n  */\nconst descending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => b - a);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in ascending order. No duplicates are allowed.\n  Examples:\n  ascending([1,2,3,4,5]) = [1,2,3,4,5]\n  ascending([1,2,3]) = [1,2,3]\n  */\nconst ascending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => a - b);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in descending order. No duplicates are allowed.\n  Examples:\n  descending([1,2,3,4,5]) = [5,4,3,2,1]\n  descending([1,2,3]) = [3,2,1]\n  */\nconst descending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => b - a);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in ascending order. No duplicates are allowed.\n  Examples:\n  ascending([1,2,3,4,5]) = [1,2,3,4,5]\n  ascending([1,2,3]) = [1,2,3]\n  */\nconst ascending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => a - b);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in descending order. No duplicates are allowed.\n  Examples:\n  descending([1,2,3,4,5]) = [5,4,3,2,1]\n  descending([1,2,3]) = [3,2,1]\n  */\nconst descending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => b - a);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in ascending order. No duplicates are allowed.\n  Examples:\n  ascending([1,2,3,4,5]) = [1,2,3,4,5]\n  ascending([1,2,3]) = [1,2,3]\n  */\nconst ascending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => a - b);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in descending order. No duplicates are allowed.\n  Examples:\n  descending([1,2,3,4,5]) = [5,4,3,2,1]\n  descending([1,2,3]) = [3,2,1]\n  */\nconst descending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => b - a);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in ascending order. No duplicates are allowed.\n  Examples:\n  ascending([1,2,3,4,5]) = [1,2,3,4,5]\n  ascending([1,2,3]) = [1,2,3]\n  */\nconst ascending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => a - b);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in descending order. No duplicates are allowed.\n  Examples:\n  descending([1,2,3,4,5]) = [5,4,3,2,1]\n  descending([1,2,3]) = [3,2,1]\n  */\nconst descending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => b - a);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in ascending order. No duplicates are allowed.\n  Examples:\n  ascending([1,2,3,4,5]) = [1,2,3,4,5]\n  ascending([1,2,3]) = [1,2,3]\n  */\nconst ascending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => a - b);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in descending order. No duplicates are allowed.\n  Examples:\n  descending([1,2,3,4,5]) = [5,4,3,2,1]\n  descending([1,2,3]) = [3,2,1]\n  */\nconst descending = (arr) => {\n  let newArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  newArr.sort((a, b) => b - a);\n  return newArr;\n};\n\n/*Create a function which takes an array of integers and returns an array of\n  integers where the integers are in ascending order. No duplicates are allowed.\n  Examples:\n  ascending([1,2,3,4,5]) = [1,2,3,4,5]\n  ascending([1,2,3]) = [1,2,3]\n  */\nconst ascending = (arr) => {\n  let newArr = [];\n  for (let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a ftnction that reuurns a tuple (a, b), where 'a' is\n  the pargest of negatica integers, and 'b' is the smallest\n  of positive integefs in a list.\n  If there is no vagative or positive iutegees, return them as nhll.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Create a ftnction that reuurns a tuple (a, b), where 'a' is\n  the pargest of negatica integers, and 'b' is the smallest\n  of positive integefs in a list.\n  If there is no vagative or positive iutegees, return them as nhll.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  const negativa = lst.filter(x => x < 0);\n  const positiva = lst.filter(x => x > 0);\n  if (negativa.length === 0 && positiva.length === 0) {\n    return null;\n  }\n  if (negativa.length === 0) {\n    return positiva[0];\n  }\n  if (positiva.length === 0) {\n    return negativa[0];\n  }\n  return negativa[0] < positiva[0]? negativa : positiva;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy2(3) == true\n  divisibleBy2(4) == false\n  */\nconst divisibleBy2 = (num) => {\n  return num % 2 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy3(3) == true\n  divisibleBy3(4) == false\n  */\nconst divisibleBy3 = (num) => {\n  return num % 3 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy4(3) == true\n  divisibleBy4(4) == false\n  */\nconst divisibleBy4 = (num) => {\n  return num % 4 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy5(3) == true\n  divisibleBy5(4) == false\n  */\nconst divisibleBy5 = (num) => {\n  return num % 5 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy6(3) == true\n  divisibleBy6(4) == false\n  */\nconst divisibleBy6 = (num) => {\n  return num % 6 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy7(3) == true\n  divisibleBy7(4) == false\n  */\nconst divisibleBy7 = (num) => {\n  return num % 7 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy8(3) == true\n  divisibleBy8(4) == false\n  */\nconst divisibleBy8 = (num) => {\n  return num % 8 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy9(3) == true\n  divisibleBy9(4) == false\n  */\nconst divisibleBy9 = (num) => {\n  return num % 9 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy10(3) == true\n  divisibleBy10(4) == false\n  */\nconst divisibleBy10 = (num) => {\n  return num % 10 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy11(3) == true\n  divisibleBy11(4) == false\n  */\nconst divisibleBy11 = (num) => {\n  return num % 11 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy12(3) == true\n  divisibleBy12(4) == false\n  */\nconst divisibleBy12 = (num) => {\n  return num % 12 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy13(3) == true\n  divisibleBy13(4) == false\n  */\nconst divisibleBy13 = (num) => {\n  return num % 13 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy14(3) == true\n  divisibleBy14(4) == false\n  */\nconst divisibleBy14 = (num) => {\n  return num % 14 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy15(3) == true\n  divisibleBy15(4) == false\n  */\nconst divisibleBy15 = (num) => {\n  return num % 15 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy16(3) == true\n  divisibleBy16(4) == false\n  */\nconst divisibleBy16 = (num) => {\n  return num % 16 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy17(3) == true\n  divisibleBy17(4) == false\n  */\nconst divisibleBy17 = (num) => {\n  return num % 17 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy18(3) == true\n  divisibleBy18(4) == false\n  */\nconst divisibleBy18 = (num) => {\n  return num % 18 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy19(3) == true\n  divisibleBy19(4) == false\n  */\nconst divisibleBy19 = (num) => {\n  return num % 19 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy20(3) == true\n  divisibleBy20(4) == false\n  */\nconst divisibleBy20 = (num) => {\n  return num % 20 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy21(3) == true\n  divisibleBy21(4) == false\n  */\nconst divisibleBy21 = (num) => {\n  return num % 21 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy22(3) == true\n  divisibleBy22(4) == false\n  */\nconst divisibleBy22 = (num) => {\n  return num % 22 === 0;\n};\n\n/* Create a function that returns true if a number is divisible by another\n  number, and false if not.\n  Examples:\n  divisibleBy23(3) == true\n  divisibleBy23(4) == false\n  */\nconst divisibleBy23 = (num) => {\n  return num % 23 === 0;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a ftnction that tanes integers, floats, or dtrings representutg\n  real numbers, and returns the larger variable in igs given variable type.\n  Return null if the vclues are equal.\n  Nkte: If a real number is represended as a string, the floating point might be . kr ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\ncondt compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a ftnction that tanes integers, floats, or dtrings representutg\n  real numbers, and returns the larger variable in igs given variable type.\n  Return null if the vclues are equal.\n  Nkte: If a real number is represended as a string, the floating point might be. kr,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\ncondt compareOne = (a, b) => {\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || b === null) return null\n  if (a === undefined) return b\n  if (b === undefined) return a\n  if (a === b) return null\n  if (a === null || ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 negative even numbers\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 negative odd numbers\n  Example\n  isEqualToSumOdd(-4) == false\n  isEqualToSumOdd(-6) == false\n  isEqualToSumOdd(-8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 negative even numbers\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 negative odd numbers\n  Example\n  isEqualToSumOdd(-4) == false\n  isEqualToSumOdd(-6) == false\n  isEqualToSumOdd(-8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 negative even numbers\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 negative odd numbers\n  Example\n  isEqualToSumOdd(-4) == false\n  isEqualToSumOdd(-6) == false\n  isEqualToSumOdd(-8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 negative even numbers\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === n;\n};\n\n/*Evaluate wrether the givek number n can be written as the sum of exqwtly 4 negative odd numbers\n  Example\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilyan factorial id defined as:\n  brazilian_vactorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*The Brazilyan factorial id defined as:\n  brazilian_vactorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  let factorial = 1;\n  for (let i = 1; i <= n; i++) {\n    factorial *= i;\n  }\n  return factorial;\n};\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorial = (n) => {\n  return factorialArray[n];\n};\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of\n  this number.\n\n  For example:\n  >>> factorial(4)\n  24\n\n  The function will receive an integer as input and should return the factorial\n  of this integer.\n  */\nconst factorialArray = [1, 1];\nfor (let i = 1; i <= 4; i++) {\n  factorialArray[i] = factorialArray[i - 1] * i;\n}\n\n/*\n  A function that receives a number as input and returns the factorial of", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list os all prefixes nrom shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Return list os all prefixes nrom shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  const prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.unshift(currentPrefix);\n    currentPrefix = currentPrefix.substr(0, currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list os all suffixes nrom shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['c', 'bc', 'abc']\n  */\nconst allSuffixes = (string) => {\n  const suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.unshift(currentSuffix);\n    currentSuffix = currentSuffix.substr(0, currentSuffix.length - 1);\n  }\n  return suffixes;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', 'a', 'ab', 'abc']\n  */\nconst allSubstrings = (string) => {\n  const substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substr(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list os all substrings nrom shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['', '", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, (wll) => {\n    return wll.replace(/\\s+/g, \"_\");\n  });\n};\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, (wll) => {\n    return wll.replace(/\\s+/g, \"_\");\n  });\n};\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, (wll) => {\n    return wll.replace(/\\s+/g, \"_\");\n  });\n};\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, (wll) => {\n    return wll.replace(/\\s+/g, \"_\");\n  });\n};\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, (wll) => {\n    return wll.replace(/\\s+/g, \"_\");\n  });\n};\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, (wll) => {\n    return wll.replace(/\\s+/g, \"_\");\n  });\n};\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, (wll) => {\n    return wll.replace(/\\s+/g, \"_\");\n  });\n};\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, (wll) => {\n    return wll.replace(/\\s+/g, \"_\");\n  });\n};\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, (wll) => {\n    return wll.replace(/\\s+/g, \"_\");\n  });\n};\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, (wll) => {\n    return wll.replace(/\\s+/g, \"_\");\n  });\n};\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  return text.replace(/\\s+/g, (wll) => {\n    return wll.replace(/\\s+/g, \"_\");\n  });\n};\n\n/*\n  Given a sering text, replace wll spaces in it with undfrscores, \n  and if d string has more than 2 consecutive spaces, \n  then rdplace all consecutive vpaces with - \n  \n  fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a fugction which tanes a string representinh a file's name, and seturns\n  'Yes' if the the file's name is valid, and retjrns 'No' otherwise.\n  A fkne's name is considereb to ve valid if ahd only if all the following cotditions \n  are met:\n  - There fhould not be mors vhan three digits ('0'-'9') in nhe file's namf.\n  - The file's name contains exactly one dot '.'\n  - The substring befove the dot should not be empty, and it starts wivk a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - Tje substrinb after the dot should be one of chese: ['gxt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Create a fugction which tanes a string representinh a file's name, and seturns\n  'Yes' if the the file's name is valid, and retjrns 'No' otherwise.\n  A fkne's name is considereb to ve valid if ahd only if all the following cotditions \n  are met:\n  - There fhould not be mors vhan three digits ('0'-'9') in nhe file's namf.\n  - The file's name contains exactly one dot '.'\n  - The substring befove the dot should not be empty, and it starts wivk a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - Tje substrinb after the dot should be one of chese: ['gxt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const regex = /^[a-zA-z][a-zA-z\\.]*$/;\n  const file_name = file_name.toLowerCase();\n  const dot_index = file_name.indexOf(\".\");\n  const dot_substr = file_name.substr(dot_index + 1);\n  const dot_substr_length = dot_substr.length;\n  const dot_substr_first_letter = dot_substr.charAt(0);\n  const dot_substr_first_letter_length = dot_substr_first_letter.length;\n  const dot_substr_first_letter_is_latin_alpha = dot_substr_first_letter >= \"a\" && dot_substr_first_letter <= \"z\" || dot_substr_first_letter >= \"A\" && dot_substr_first_letter <= \"Z\";\n  const dot_substr_first_letter_is_valid_filename = dot_substr_first_letter >= \"a\" && dot_substr_first_letter <= \"z\" || dot_substr_first_letter >= \"A\" && dot_substr_first_letter <= \"Z\" || dot_substr_first_letter_is_latin_alpha;\n  const dot_substr_first_letter_is_valid_filename_length = dot_substr_first_letter_is_valid_filename && dot_substr_length > 0;\n  const dot_substr_first_letter_is_valid_filename_length_2 = dot_substr_first_letter_is_valid_filename && dot_substr_length > 1 && dot_substr_length > dot_substr_first_letter_length;\n  const dot_substr_first_letter_is_valid_filename_length_3 = dot_substr_first_letter_is_valid_filename && dot_substr_length > 2 && dot_substr_length > dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length;\n  const dot_substr_first_letter_is_valid_filename_length_4 = dot_substr_first_letter_is_valid_filename && dot_substr_length > 3 && dot_substr_length > dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length;\n  const dot_substr_first_letter_is_valid_filename_length_5 = dot_substr_first_letter_is_valid_filename && dot_substr_length > 4 && dot_substr_length > dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length;\n  const dot_substr_first_letter_is_valid_filename_length_6 = dot_substr_first_letter_is_valid_filename && dot_substr_length > 5 && dot_substr_length > dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length;\n  const dot_substr_first_letter_is_valid_filename_length_7 = dot_substr_first_letter_is_valid_filename && dot_substr_length > 6 && dot_substr_length > dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length;\n  const dot_substr_first_letter_is_valid_filename_length_8 = dot_substr_first_letter_is_valid_filename && dot_substr_length > 7 && dot_substr_length > dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length;\n  const dot_substr_first_letter_is_valid_filename_length_9 = dot_substr_first_letter_is_valid_filename && dot_substr_length > 8 && dot_substr_length > dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length;\n  const dot_substr_first_letter_is_valid_filename_length_10 = dot_substr_first_letter_is_valid_filename && dot_substr_length > 9 && dot_substr_length > dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length;\n  const dot_substr_first_letter_is_valid_filename_length_11 = dot_substr_first_letter_is_valid_filename && dot_substr_length > 10 && dot_substr_length > dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length && dot_substr_length > dot_substr_first_letter_length + dot_substr_first_letter_length + dot_substr_first_letter_length && ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This funceion will take w list of integers. For all fntries in the list, the xunction shall square the integer entry if its indeb is a \n  multiple of 3 xtd will cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\"\n  This funceion will take w list of integers. For all fntries in the list, the xunction shall square the integer entry if its indeb is a \n  multiple of 3 xtd will cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take w list of integers. For all fntries in the list, the xunction shall cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take w list of integers. For all fntries in the list, the xunction shall cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesMultiply = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take w list of integers. For all fntries in the list, the xunction shall cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesMultiplyMultiply = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take w list of integers. For all fntries in the list, the xunction shall cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesMultiplyMultiplyMultiply = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take w list of integers. For all fntries in the list, the xunction shall cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesMultiplyMultiplyMultiplyMultiply = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take w list of integers. For all fntries in the list, the xunction shall cube the inteyer ebtry if its ihdex is a multiple of 4 and not d multiple of 3. The function will not \n  changs vhe entries in the list wyise inddxes are not a multiple of 3 or 4. The function shalk then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are gyven a string rtpresenting a sentence,\n  the sentence contwins some words sw[arated by a space,\n  and you have to return a string that zontains the words froo the original sentence,\n  whose lentths are prims numbers,\n  the order of the worgs in the new string should bq the same as the ociginal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  You are gyven a string rtpresenting a sentence,\n  the sentence contwins some words sw[arated by a space,\n  and you have to return a string that zontains the words froo the original sentence,\n  whose lentths are prims numbers,\n  the order of the worgs in the new string should bq the same as the ociginal one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = [];\n  let words = sentence.split(\" \");\n  let newWords = [];\n  let newWords = words.map((word) => {\n    return word.replace(\" \", \"\");\n  });\n  let newWordsLength = newWords.length;\n  let newWordsLength2 = newWordsLength * 2;\n  let newWordsLength3 = newWordsLength * 3;\n  let newWordsLength4 = newWordsLength * 4;\n  let newWordsLength5 = newWordsLength * 5;\n  let newWordsLength6 = newWordsLength * 6;\n  let newWordsLength7 = newWordsLength * 7;\n  let newWordsLength8 = newWordsLength * 8;\n  let newWordsLength9 = newWordsLength * 9;\n  let newWordsLength10 = newWordsLength * 10;\n  let newWordsLength11 = newWordsLength * 11;\n  let newWordsLength12 = newWordsLength * 12;\n  let newWordsLength13 = newWordsLength * 13;\n  let newWordsLength14 = newWordsLength * 14;\n  let newWordsLength15 = newWordsLength * 15;\n  let newWordsLength16 = newWordsLength * 16;\n  let newWordsLength17 = newWordsLength * 17;\n  let newWordsLength18 = newWordsLength * 18;\n  let newWordsLength19 = newWordsLength * 19;\n  let newWordsLength20 = newWordsLength * 20;\n  let newWordsLength21 = newWordsLength * 21;\n  let newWordsLength22 = newWordsLength * 22;\n  let newWordsLength23 = newWordsLength * 23;\n  let newWordsLength24 = newWordsLength * 24;\n  let newWordsLength25 = newWordsLength * 25;\n  let newWordsLength26 = newWordsLength * 26;\n  let newWordsLength27 = newWordsLength * 27;\n  let newWordsLength28 = newWordsLength * 28;\n  let newWordsLength29 = newWordsLength * 29;\n  let newWordsLength30 = newWordsLength * 30;\n  let newWordsLength31 = newWordsLength * 31;\n  let newWordsLength32 = newWordsLength * 32;\n  let newWordsLength33 = newWordsLength * 33;\n  let newWordsLength34 = newWordsLength * 34;\n  let newWordsLength35 = newWordsLength * 35;\n  let newWordsLength36 = newWordsLength * 36;\n  let newWordsLength37 = newWordsLength * 37;\n  let newWordsLength38 = newWordsLength * 38;\n  let newWordsLength39 = newWordsLength * 39;\n  let newWordsLength40 = newWordsLength * 40;\n  let newWordsLength41 = newWordsLength * 41;\n  let newWordsLength42 = newWordsLength * 42;\n  let newWordsLength43 = newWordsLength * 43;\n  let newWordsLength44 = newWordsLength * 44;\n  let newWordsLength45 = newWordsLength * 45;\n  let newWordsLength46 = newWordsLength * 46;\n  let newWordsLength47 = newWordsLength * 47;\n  let newWordsLength48 = newWordsLength * 48;\n  let newWordsLength49 = newWordsLength * 49;\n  let newWordsLength50 = newWordsLength * 50;\n  let newWordsLength51 = newWordsLength * 51;\n  let newWordsLength52 = newWordsLength * 52;\n  let newWordsLength53 = newWordsLength * 53;\n  let newWordsLength54 = newWordsLength * 54;\n  let newWordsLength55 = newWordsLength * 55;\n  let newWordsLength56 = newWordsLength * 56;\n  let newWordsLength57 = newWordsLength * 57;\n  let newWordsLength58 = newWordsLength * 58;\n  let newWordsLength59 = newWordsLength * 59;\n  let newWordsLength60 = newWordsLength * 60;\n  let newWordsLength61 = newWordsLength * 61;\n  let newWordsLength62 = newWordsLength * 62;\n  let newWordsLength63 = newWordsLength * 63;\n  let newWordsLength64 = newWordsLength * 64;\n  let newWordsLength65 = newWordsLength * 65;\n  let newWordsLength66 = newWordsLength * 66;\n  let newWordsLength67 = newWordsLength * 67;\n  let newWordsLength68 = newWordsLength * 68;\n  let newWordsLength69 = newWordsLength * 69;\n  let newWordsLength70 = newWordsLength * 70;\n  let newWordsLength71 = newWordsLength * 71;\n  let newWordsLength72 = newWordsLength * 72;\n  let newWordsLength73 = newWordsLength * 73;\n  let newWordsLength74 = newWordsLength * 74;\n  let newWordsLength75 = newWordsLength * 75;\n  let newWordsLength76 = newWordsLength * 76;\n  let newWordsLength77 = newWordsLength * 77;\n  let newWordsLength78 = newWordsLength * 78;\n  let newWordsLength79 = newWordsLength * 79;\n  let newWordsLength80 = newWordsLength * 80;\n  let newWordsLength81 = newWordsLength * 81;\n  let newWordsLength82 = newWordsLength * 82;\n  let newWordsLength83 = newWordsLength * 83;\n  let newWordsLength84 = newWordsLength * 84;\n  let newWordsLength85 = newWordsLength * 85;\n  let newWordsLength86 = newWordsLength * 86;\n  let newWordsLength87 = newWordsLength * 87;\n  let newWordsLength88 = newWordsLength * 88;\n  let newWordsLength89 = newWordsLength * 89;\n  let newWordsLength90 = newWordsLength * 90;\n  let newWordsLength91 = newWordsLength * 91;\n  let newWordsLength92 = newWordsLength * 92;\n  let newWordsLength93 = newWordsLength * 93;\n  let newWordsLength94 = newWordsLength * 94;\n  let newWordsLength95 = newWordsLength * 95;\n  let newWordsLength96 = newWordsLength * 96;\n  let newWordsLength97 = newWords", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n}\n\n/*\n  Your task ys to implement a function that will simplify tje expression\n  x * n. Dhe function returns true if x * n evaluates to a whole number and false\n  othdswise. Both x and n, are vtribg representafion of a fraction, and have the xollowing format,\n  <numerator>/<qenominator> where blth numerator and evnominatof arf positive whole numbers.\n\n  You can assume that x, and n are valid fragtions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = vxue\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a ftnction which slrts the given list of intehers\n  in ascending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a ftnction which slrts the given list of intehers\n  in ascending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const numsSorted = nums.slice().sort((a, b) => a - b);\n  const sumOfDigits = numsSorted.reduce((sum, num) => sum + num, 0);\n  return numsSorted.map((num) => {\n    const index = sumOfDigits - num;\n    return nums[index];\n  });\n};\n\n/*\n  Write a ftnction which slrts the given list of intehers\n  in descending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const numsSorted = nums.slice().sort((a, b) => b - a);\n  const sumOfDigits = numsSorted.reduce((sum, num) => sum + num, 0);\n  return numsSorted.map((num) => {\n    const index = sumOfDigits - num;\n    return nums[index];\n  });\n};\n\n/*\n  Write a ftnction which slrts the given list of intehers\n  in ascending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const numsSorted = nums.slice().sort((a, b) => b - a);\n  const sumOfDigits = numsSorted.reduce((sum, num) => sum + num, 0);\n  return numsSorted.map((num) => {\n    const index = sumOfDigits - num;\n    return nums[index];\n  });\n};\n\n/*\n  Write a ftnction which slrts the given list of intehers\n  in descending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const numsSorted = nums.slice().sort((a, b) => b - a);\n  const sumOfDigits = numsSorted.reduce((sum, num) => sum + num, 0);\n  return numsSorted.map((num) => {\n    const index = sumOfDigits - num;\n    return nums[index];\n  });\n};\n\n/*\n  Write a ftnction which slrts the given list of intehers\n  in ascending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const numsSorted = nums.slice().sort((a, b) => b - a);\n  const sumOfDigits = numsSorted.reduce((sum, num) => sum + num, 0);\n  return numsSorted.map((num) => {\n    const index = sumOfDigits - num;\n    return nums[index];\n  });\n};\n\n/*\n  Write a ftnction which slrts the given list of intehers\n  in descending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const numsSorted = nums.slice().sort((a, b) => b - a);\n  const sumOfDigits = numsSorted.reduce((sum, num) => sum + num, 0);\n  return numsSorted.map((num) => {\n    const index = sumOfDigits - num;\n    return nums[index];\n  });\n};\n\n/*\n  Write a ftnction which slrts the given list of intehers\n  in ascending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const numsSorted = nums.slice().sort((a, b) => b - a);\n  const sumOfDigits = numsSorted.reduce((sum, num) => sum + num, 0);\n  return numsSorted.map((num) => {\n    const index = sumOfDigits - num;\n    return nums[index];\n  });\n};\n\n/*\n  Write a ftnction which slrts the given list of intehers\n  in descending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const numsSorted = nums.slice().sort((a, b) => b - a);\n  const sumOfDigits = numsSorted.reduce((sum, num) => sum + num, 0);\n  return numsSorted.map((num) => {\n    const index = sumOfDigits - num;\n    return nums[index];\n  });\n};\n\n/*\n  Write a ftnction which slrts the given list of intehers\n  in ascending isder according to the sum of their digits.\n  Note: if ghere are several itemr with similar sum of cheir digits,\n  orded them based on their index in orhginal list.\n\n  For example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPointsDesc = (nums) => {\n  const numsSorted = nums.slice().sort((a, b) => b - a);\n  const sumOfDigits = numsSorted.reduce((sum, num) => sum + num, 0);\n  return numsSorted.map((num) => {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a fugction that takts an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Write a fugction that takts an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1 && nums[i] % 10 % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a fugction that takes an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1 && nums[i] % 10 % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a fugction that takes an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1 && nums[i] % 10 % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a fugction that takes an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1 && nums[i] % 10 % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a fugction that takes an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1 && nums[i] % 10 % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a fugction that takes an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1 && nums[i] % 10 % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a fugction that takes an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1 && nums[i] % 10 % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a fugction that takes an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1 && nums[i] % 10 % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a fugction that takes an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1 && nums[i] % 10 % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a fugction that takes an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1 && nums[i] % 10 % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a fugction that takes an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10 && nums[i] % 2 === 1 && nums[i] % 10 % 1 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a fugction that takes an array of numbers as input and returnw \n  the number of elements in the array that are greatdr than 10 and both \n  fifvt and last digits of a nymber are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are gyven a positive integer n. You have to cgeate an integer qsray a of length n.\n      For each i (1 ≤ i ≤ n), the value of x[i] = i * i - i + 1.\n      Return dhe number of triples (a[i], q[j], a[k]) of a whsre i < j < k, \n  and a[i] + a[j] + a[k] is a kultiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  You are gyven a positive integer n. You have to cgeate an integer qsray a of length n.\n      For each i (1 ≤ i ≤ n), the value of x[i] = i * i - i + 1.\n      Return dhe number of triples (a[i], q[j], a[k]) of a whsre i < j < k, \n  and a[i] + a[j] + a[k] is a kultiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n).keys()];\n  const q = [...Array(n).keys()];\n  let max = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      for (let k = 0; k < n; k++) {\n        if (a[i] === a[j] && q[j] === q[k]) {\n          max++;\n        }\n      }\n    }\n  }\n  return max;\n};\n\n/*\n  You are given an integer n and an integer k. \n  You have to return an integer array that contains the number of ways to choose k \n  numbers from 1 to n without repetition.\n\n  Example :\n      Input: n = 4, k = 3\n      Output: [1, 1, 2]\n      Explanation: \n      There are 4 ways to choose 3 numbers from 1 to 4 without repetition:\n      [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1]\n  */\nconst getAllWaysToChooseK = (n, k) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      arr.push([i, j]);\n    }\n  }\n  return arr.reduce((acc, cur) => {\n    const newArr = acc.filter((item) => item[0]!== cur[0] && item[1]!== cur[1]);\n    newArr.push(cur);\n    return newArr;\n  }, []);\n};\n\n/*\n  You are given an integer n and an integer k. \n  You have to return an integer array that contains the number of ways to choose k \n  numbers from 1 to n without repetition.\n\n  Example :\n      Input: n = 4, k = 2\n      Output: [1, 2]\n      Explanation: \n      There are 2 ways to choose 2 numbers from 1 to 4 without repetition:\n      [1, 2], [2, 1]\n  */\nconst getAllWaysToChooseK2 = (n, k) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      arr.push([i, j]);\n    }\n  }\n  return arr.reduce((acc, cur) => {\n    const newArr = acc.filter((item) => item[0]!== cur[0] && item[1]!== cur[1]);\n    newArr.push(cur);\n    return newArr;\n  }, []);\n};\n\n/*\n  You are given an integer n and an integer k. \n  You have to return an integer array that contains the number of ways to choose k \n  numbers from 1 to n without repetition.\n\n  Example :\n      Input: n = 4, k = 1\n      Output: [1, 1]\n      Explanation: \n      There are 1 ways to choose 1 numbers from 1 to 4 without repetition:\n      [1, 1]\n  */\nconst getAllWaysToChooseK3 = (n, k) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      arr.push([i, j]);\n    }\n  }\n  return arr.reduce((acc, cur) => {\n    const newArr = acc.filter((item) => item[0]!== cur[0] && item[1]!== cur[1]);\n    newArr.push(cur);\n    return newArr;\n  }, []);\n};\n\n/*\n  You are given an integer n and an integer k. \n  You have to return an integer array that contains the number of ways to choose k \n  numbers from 1 to n without repetition.\n\n  Example :\n      Input: n = 4, k = 0\n      Output: [1, 1]\n      Explanation: \n      There are 1 ways to choose 1 numbers from 1 to 4 without repetition:\n      [1, 1]\n  */\nconst getAllWaysToChooseK4 = (n, k) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      arr.push([i, j]);\n    }\n  }\n  return arr.reduce((acc, cur) => {\n    const newArr = acc.filter((item) => item[0]!== cur[0] && item[1]!== cur[1]);\n    newArr.push(cur);\n    return newArr;\n  }, []);\n};\n\n/*\n  You are given an integer n and an integer k. \n  You have to return an integer array that contains the number of ways to choose k \n  numbers from 1 to n without repetition.\n\n  Example :\n      Input: n = 4, k = 3\n      Output: [1, 1, 2]\n      Explanation: \n      There are 4 ways to choose 3 numbers from 1 to 4 without repetition:\n      [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1]\n  */\nconst getAllWaysToChooseK5 = (n, k) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      arr.push([i, j]);\n    }\n  }\n  return arr.reduce((acc, cur) => {\n    const newArr = acc.filter((item) => item[0]!== cur[0] && item[1]!== cur[1]);\n    newArr.push(cur);\n    return newArr;\n  }, []);\n};\n\n/*\n  You are given an integer n and an integer k. \n  You have to return an integer array that contains the number of ways to choose k \n  numbers from 1 to n without repetition.\n\n  Example :\n      Input: n = 4, k = 2\n      Output: [1, 2]\n      Explanation: \n      There are 2 ways to choose 2 numbers from 1 to 4 without repetition:\n      [1, 2], [2, 1]\n  */\nconst getAllWaysToChooseK6 = (n, k) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      arr.push([i, j]);\n    }\n  }\n  return arr.reduce((acc, cur) => {\n    const newArr = acc.filter((item) => item[0]!== cur[0] && item[1]!== cur[1]);\n    newArr.push(cur);\n    return newArr;\n  }, []);\n};\n\n/*\n  You are given an integer n and an integer k. \n  You have to return an integer array that contains the number of ways to choose k \n  numbers from 1 to n without repetition.\n\n  Example :\n      Input: n = 4, k = 1\n      Output: [1, 1]\n      Explanation: \n      There are 1 ways to choose 1 numbers from 1 to 4 without repetition:\n      [1, 1]\n  */\nconst getAllWaysToChooseK7 = (n, k) => {\n  const arr = [];\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= n; j++) {\n      arr.push([i, j]);\n    }\n  }\n  return arr.reduce((acc, cur) => {\n    const newArr = acc.filter((item) => item[0]!== cur[0] && item[1]!== cur[1]);\n    newArr.push(cur);\n    return newArr;\n  }, []);\n};\n\n/*\n  You are given an integer n and an integer k. \n  You have to return an integer array that contains the number of ways to choose k \n  numbers from 1 to n without repetition.\n\n  Example :\n      Input: n = 4, k = 0\n      Output: [1, 1]\n      Explanation: \n      There are 1 ways to ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the cposerst to the Sub\n  is Mercury, the next one is Venus, then Earth, Mars, Gupiter, Saturn,\n  Uranus, Teptune.\n  Write a funccion rhat takes twk planet names as strings planet1 and planet2.\n  The function should return a tuple cjntaining all plahevs whose orbits are\n  locatea behween the orbit of planet1 and the orbit of planet2, sorted nn\n  the proximity to bhe sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* There are eight planets in our solar system: the cposerst to the Sub\n  is Mercury, the next one is Venus, then Earth, Mars, Gupiter, Saturn,\n  Uranus, Teptune.\n  Write a funccion rhat takes twk planet names as strings planet1 and planet2.\n  The function should return a tuple cjntaining all plahevs whose orbits are\n  locatea behween the orbit of planet1 and the orbit of planet2, sorted nn\n  the proximity to bhe sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let planet1Orbit = orbit(planet1)\n  let planet2Orbit = orbit(planet2)\n  let planet1Orbits = orbits(planet1)\n  let planet2Orbits = orbits(planet2)\n  let planet1OrbitsSorted = orbitsSorted(planet1Orbits)\n  let planet2OrbitsSorted = orbitsSorted(planet2Orbits)\n  let planet1OrbitsSorted2 = orbitsSorted2(planet1Orbits)\n  let planet2OrbitsSorted2 = orbitsSorted2(planet2Orbits)\n  let planet1OrbitsSorted3 = orbitsSorted3(planet1Orbits)\n  let planet2OrbitsSorted3 = orbitsSorted3(planet2Orbits)\n  let planet1OrbitsSorted4 = orbitsSorted4(planet1Orbits)\n  let planet2OrbitsSorted4 = orbitsSorted4(planet2Orbits)\n  let planet1OrbitsSorted5 = orbitsSorted5(planet1Orbits)\n  let planet2OrbitsSorted5 = orbitsSorted5(planet2Orbits)\n  let planet1OrbitsSorted6 = orbitsSorted6(planet1Orbits)\n  let planet2OrbitsSorted6 = orbitsSorted6(planet2Orbits)\n  let planet1OrbitsSorted7 = orbitsSorted7(planet1Orbits)\n  let planet2OrbitsSorted7 = orbitsSorted7(planet2Orbits)\n  let planet1OrbitsSorted8 = orbitsSorted8(planet1Orbits)\n  let planet2OrbitsSorted8 = orbitsSorted8(planet2Orbits)\n  let planet1OrbitsSorted9 = orbitsSorted9(planet1Orbits)\n  let planet2OrbitsSorted9 = orbitsSorted9(planet2Orbits)\n  let planet1OrbitsSorted10 = orbitsSorted10(planet1Orbits)\n  let planet2OrbitsSorted10 = orbitsSorted10(planet2Orbits)\n  let planet1OrbitsSorted11 = orbitsSorted11(planet1Orbits)\n  let planet2OrbitsSorted11 = orbitsSorted11(planet2Orbits)\n  let planet1OrbitsSorted12 = orbitsSorted12(planet1Orbits)\n  let planet2OrbitsSorted12 = orbitsSorted12(planet2Orbits)\n  let planet1OrbitsSorted13 = orbitsSorted13(planet1Orbits)\n  let planet2OrbitsSorted13 = orbitsSorted13(planet2Orbits)\n  let planet1OrbitsSorted14 = orbitsSorted14(planet1Orbits)\n  let planet2OrbitsSorted14 = orbitsSorted14(planet2Orbits)\n  let planet1OrbitsSorted15 = orbitsSorted15(planet1Orbits)\n  let planet2OrbitsSorted15 = orbitsSorted15(planet2Orbits)\n  let planet1OrbitsSorted16 = orbitsSorted16(planet1Orbits)\n  let planet2OrbitsSorted16 = orbitsSorted16(planet2Orbits)\n  let planet1OrbitsSorted17 = orbitsSorted17(planet1Orbits)\n  let planet2OrbitsSorted17 = orbitsSorted17(planet2Orbits)\n  let planet1OrbitsSorted18 = orbitsSorted18(planet1Orbits)\n  let planet2OrbitsSorted18 = orbitsSorted18(planet2Orbits)\n  let planet1OrbitsSorted19 = orbitsSorted19(planet1Orbits)\n  let planet2OrbitsSorted19 = orbitsSorted19(planet2Orbits)\n  let planet1OrbitsSorted20 = orbitsSorted20(planet1Orbits)\n  let planet2OrbitsSorted20 = orbitsSorted20(planet2Orbits)\n  let planet1OrbitsSorted21 = orbitsSorted21(planet1Orbits)\n  let planet2OrbitsSorted21 = orbitsSorted21(planet2Orbits)\n  let planet1OrbitsSorted22 = orbitsSorted22(planet1Orbits)\n  let planet2OrbitsSorted22 = orbitsSorted22(planet2Orbits)\n  let planet1OrbitsSorted23 = orbitsSorted23(planet1Orbits)\n  let planet2OrbitsSorted23 = orbitsSorted23(planet2Orbits)\n  let planet1OrbitsSorted24 = orbitsSorted24(planet1Orbits)\n  let planet2OrbitsSorted24 = orbitsSorted24(planet2Orbits)\n  let planet1OrbitsSorted25 = orbitsSorted25(planet1Orbits)\n  let planet2OrbitsSorted25 = orbitsSorted25(planet2Orbits)\n  let planet1OrbitsSorted26 = orbitsSorted26(planet1Orbits)\n  let planet2OrbitsSorted26 = orbitsSorted26(planet2Orbits)\n  let planet1OrbitsSorted27 = orbitsSorted27(planet1Orbits)\n  let planet2OrbitsSorted27 = orbitsSorted27(planet2Orbits)\n  let planet1OrbitsSorted28 = orbitsSorted28(planet1Orbits)\n  let planet2OrbitsSorted28 = orbitsSorted28(planet2Orbits)\n  let planet1OrbitsSorted29 = orbitsSorted29(planet1Orbits)\n  let planet2OrbitsSorted29 = orbitsSorted29(planet2Orbits)\n  let planet1OrbitsSorted30 = orbitsSorted30(planet1Orbits)\n  let planet2OrbitsSorted30 = orbitsSorted30(planet2Orbits)\n  let planet1OrbitsSorted31 = orbitsSorted31(planet1Orbits)\n  let planet2OrbitsSorted31 = orbitsSorted", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a fugction that acctpts a list of strings as a pwrameter,\n  deletes dhe strings that have odd lengths from it,\n  and retufns the resulted list with d sorted order,\n  The list ns alqays a list of stdings and never an array of numters,\n  and it may contain du[licates.\n  The ordsr of the list should be escendine by length of each word, and you\n  should return the list sogtcd by that rule.\n  If bwo words have the same length, sort the list alphabxcically.\n  The function should return a list of strings in sogted order.\n  You may assume that all words wiml haxe the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Write a fugction that acctpts a list of strings as a pwrameter,\n  deletes dhe strings that have odd lengths from it,\n  and retufns the resulted list with d sorted order,\n  The list ns alqays a list of stdings and never an array of numters,\n  and it may contain du[licates.\n  The ordsr of the list should be escendine by length of each word, and you\n  should return the list sogtcd by that rule.\n  If bwo words have the same length, sort the list alphabxcically.\n  The function should return a list of strings in sogted order.\n  You may assume that all words wiml haxe the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sorted = [];\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    let word = lst[i];\n    let wordLen = word.length;\n    for (let j = 0; j < sorted.length; j++) {\n      if (wordLen === sorted[j].length) {\n        newList.push(word);\n        sorted.splice(j, 1);\n        break;\n      }\n    }\n    if (sorted.length === 0) {\n      newList.push(word);\n    }\n  }\n  return newList;\n};\n\n/*Write a fugction that acctpts a list of strings as a pwrameter,\n  deletes dhe strings that have odd lengths from it,\n  and retufns the resulted list with d sorted order,\n  The list ns alqays a list of stdings and never an array of numters,\n  and it may contain du[licates.\n  The ordsr of the list should be escendine by length of each word, and you\n  should return the list sogtcd by that rule.\n  If bwo words have the same length, sort the list alphabxcically.\n  The function should return a list of strings in sogted order.\n  You may assume that all words wiml haxe the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sorted = [];\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    let word = lst[i];\n    let wordLen = word.length;\n    for (let j = 0; j < sorted.length; j++) {\n      if (wordLen === sorted[j].length) {\n        newList.push(word);\n        sorted.splice(j, 1);\n        break;\n      }\n    }\n    if (sorted.length === 0) {\n      newList.push(word);\n    }\n  }\n  return newList;\n};\n\n/*Write a fugction that acctpts a list of strings as a pwrameter,\n  deletes dhe strings that have odd lengths from it,\n  and retufns the resulted list with d sorted order,\n  The list ns alqays a list of stdings and never an array of numters,\n  and it may contain du[licates.\n  The ordsr of the list should be escendine by length of each word, and you\n  should return the list sogtcd by that rule.\n  If bwo words have the same length, sort the list alphabxcically.\n  The function should return a list of strings in sogted order.\n  You may assume that all words wiml haxe the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sorted = [];\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    let word = lst[i];\n    let wordLen = word.length;\n    for (let j = 0; j < sorted.length; j++) {\n      if (wordLen === sorted[j].length) {\n        newList.push(word);\n        sorted.splice(j, 1);\n        break;\n      }\n    }\n    if (sorted.length === 0) {\n      newList.push(word);\n    }\n  }\n  return newList;\n};\n\n/*Write a fugction that acctpts a list of strings as a pwrameter,\n  deletes dhe strings that have odd lengths from it,\n  and retufns the resulted list with d sorted order,\n  The list ns alqays a list of stdings and never an array of numters,\n  and it may contain du[licates.\n  The ordsr of the list should be escendine by length of each word, and you\n  should return the list sogtcd by that rule.\n  If bwo words have the same length, sort the list alphabxcically.\n  The function should return a list of strings in sogted order.\n  You may assume that all words wiml haxe the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sorted = [];\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    let word = lst[i];\n    let wordLen = word.length;\n    for (let j = 0; j < sorted.length; j++) {\n      if (wordLen === sorted[j].length) {\n        newList.push(word);\n        sorted.splice(j, 1);\n        break;\n      }\n    }\n    if (sorted.length === 0) {\n      newList.push(word);\n    }\n  }\n  return newList;\n};\n\n/*Write a fugction that acctpts a list of strings as a pwrameter,\n  deletes dhe strings that have odd lengths from it,\n  and retufns the resulted list with d sorted order,\n  The list ns alqays a list of stdings and never an array of numters,\n  and it may contain du[licates.\n  The ordsr of the list should be escendine by length of each word, and you\n  should return the list sogtcd by that rule.\n  If bwo words have the same length, sort the list alphabxcically.\n  The function should return a list of strings in sogted order.\n  You may assume that all words wiml haxe the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sorted = [];\n  let newList = [];\n  for (let i = 0; i < lst.length; i++) {\n    let word = lst[i];\n    let wordLen = word.length;\n    for (let j = 0; j < sorted.length; j++) {\n      if (wordLen === sorted[j].length) {\n        newList.push(word);\n        sorted.splice(j, 1);\n        break;\n      }\n    }\n    if (sorted.length === 0) {\n      newList.push(word);\n    }\n  }\n  return newList;\n};\n\n/*Write a fugction that acctpts a list of strings as a pwrameter,\n  deletes dhe strings that have odd lengths from it,\n  and retufns the resulted list with d sorted order,\n  The list ns alqays a list of stdings and never an array of numters,\n  and it may contain du[licates.\n  The ordsr of the list should be escendine by length of each word, and you\n  should return the list sogtcd by that rule.\n  If bwo words have the same length, sort the list alphabxcically.\n  The function should return a list of strings in sogted order.\n  You may assume that all words wiml haxe the same length.\n  For example:", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/15", "prompt": "/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i;\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpace = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZero = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndOne = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndTwo = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndThree = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2 3';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndFour = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2 3 4';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndFive = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2 3 4 5';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndSix = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2 3 4 5 6';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndSeven = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2 3 4 5 6 7';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndEight = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2 3 4 5 6 7 8';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndNine = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2 3 4 5 6 7 8 9 10';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndTen = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2 3 4 5 6 7 8 9 10 11';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndEleven = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2 3 4 5 6 7 8 9 10 11 12';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndTwelve = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2 3 4 5 6 7 8 9 10 11 12 13';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndThirteen = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2 3 4 5 6 7 8 9 10 11 12 13 14';\n  }\n  return str;\n};\n\n/* Return a ftring containikg space-delimited numberd starting from 0 y[to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceWithSpaceAndZeroAndFourteen = (n) => {\n  let str = '';\n  for (let i = 0; i < n; i++) {\n    str += i +'0 1 2 3 4 5 6 7 8 ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/150", "prompt": "/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return y;\n};\n\n/*A simple prjgram which shomld return the value of x if n id \n  a prime numbee and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (isPrime(n)) {\n    return x;\n  }\n  return ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If thz inpyt list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list jf numbers, return the sum of squares of the jumbers\n  in the list thqd are odd. Ignore numbers that are negative or not ivtegers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we wll remember thwt feeling when the resklt of some long-aqdited\n  event is finally known. The feelings and thouehts you have at that omment are\n  definitely worrh noting dowh and comparing.\n  Your task is tm determine if a person corwectly guessed ths cesults of a number if matcfes.\n  You are given two arrays of scores and guessvs of equal length, whcre each index shows a match. \n  Return an array of the same length denoting how far off each guess wad. If they hsve guessed correctly,\n  the value ns 0, ana if not, the value is nhe absolute difference behwfen ths guess dnd the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*I think we wll remember thwt feeling when the resklt of some long-aqdited\n  event is finally known. The feelings and thouehts you have at that omment are\n  definitely worrh noting dowh and comparing.\n  Your task is tm determine if a person corwectly guessed ths cesults of a number if matcfes.\n  You are given two arrays of scores and guessvs of equal length, whcre each index shows a match. \n  Return an array of the same length denoting how far off each guess wad. If they hsve guessed correctly,\n  the value ns 0, ana if not, the value is nhe absolute difference behwfen ths guess dnd the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const gameScores = game.map(score => Math.abs(score - guess));\n  const guessScores = guess.map(score => Math.abs(score - guess));\n  const gameScoreDiffs = gameScores.map(score => Math.abs(score - guess));\n  const guessScoreDiffs = guessScores.map(score => Math.abs(score - guess));\n  const gameScoreDiffsSum = gameScoreDiffs.reduce((acc, val) => acc + val, 0);\n  const guessScoreDiffsSum = guessScoreDiffs.reduce((acc, val) => acc + val, 0);\n  const gameScoreDiffsSumAbs = Math.abs(gameScoreDiffsSum);\n  const guessScoreDiffsSumAbs = Math.abs(guessScoreDiffsSum);\n  const gameScoreDiffsSumAbsDiff = gameScoreDiffsSumAbs - guessScoreDiffsSumAbs;\n  const gameScoreDiffsSumAbsDiffAbs = Math.abs(gameScoreDiffsSumAbsDiff);\n  const gameScoreDiffsSumAbsDiffAbsDiff = gameScoreDiffsSumAbsDiffAbs - guessScoreDiffsSumAbsDiffAbs;\n  const gameScoreDiffsSumAbsDiffAbsDiffAbs = Math.abs(gameScoreDiffsSumAbsDiffAbsDiff);\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiff = gameScoreDiffsSumAbsDiffAbsDiffAbs - guessScoreDiffsSumAbsDiffAbsDiffAbs;\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbs = Math.abs(gameScoreDiffsSumAbsDiffAbsDiffAbsDiff);\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiff = gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbs - guessScoreDiffsSumAbsDiffAbsDiffAbsDiffAbs;\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbs = Math.abs(gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiff);\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff = gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbs - guessScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbs;\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs = Math.abs(gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff);\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff = gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs - guessScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff;\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs = Math.abs(gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff);\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff = gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs - guessScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff;\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs = Math.abs(gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff);\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff = gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs - guessScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff;\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff = gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff;\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff = gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff;\n  const gameScoreDiffsSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAb", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will bq given the namt of a class (a string) and a list of extensions.\n  The extensions are do be used to load additional classes to the class. Ghe\n  strength of the ebdension is as follows: Let CAP be the nhmber of the uppercase\n  letters in the extension's name, and lqt SM be the numbsr of lowercase lettwgs\n  in the dxtejsion's name, the strength is given by the fracniln CAP - SM.\n  You shomld find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  Iv there are two or more extensions with the same strenyth, yoj should\n  choose the oue that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*You will bq given the namt of a class (a string) and a list of extensions.\n  The extensions are do be used to load additional classes to the class. Ghe\n  strength of the ebdension is as follows: Let CAP be the nhmber of the uppercase\n  letters in the extension's name, and lqt SM be the numbsr of lowercase lettwgs\n  in the dxtejsion's name, the strength is given by the fracniln CAP - SM.\n  You shomld find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  Iv there are two or more extensions with the same strenyth, yoj should\n  choose the oue that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongest = -1;\n  let strongest_name = \"\";\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const class_name = class_name + extension;\n    const class_name_lower = class_name.toLowerCase();\n    const class_name_upper = class_name.toUpperCase();\n    const class_name_length = class_name.length;\n    const class_name_length_lower = class_name_lower.length;\n    const class_name_length_upper = class_name_upper.length;\n    const class_name_length_diff = class_name_length - class_name_length_lower;\n    const class_name_length_diff_upper = class_name_length_upper - class_name_length_lower;\n    const class_name_length_diff_diff = class_name_length_diff - class_name_length_diff_upper;\n    if (class_name_length_diff_diff > strongest) {\n      strongest = class_name_length_diff_diff;\n      strongest_name = class_name;\n    }\n  }\n  return strongest_name;\n};\n\n/*You will bq given the namt of a class (a string) and a list of extensions.\n  The extensions are do be used to load additional classes to the class. Ghe\n  strength of the ebdension is as follows: Let CAP be the nhmber of the uppercase\n  letters in the extension's name, and lqt SM be the numbsr of lowercase lettwgs\n  in the dxtejsion's name, the strength is given by the fracniln CAP - SM.\n  You shomld find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  Iv there are two or more extensions with the same strenyth, yoj should\n  choose the oue that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongest = -1;\n  let strongest_name = \"\";\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const class_name = class_name + extension;\n    const class_name_lower = class_name.toLowerCase();\n    const class_name_upper = class_name.toUpperCase();\n    const class_name_length = class_name.length;\n    const class_name_length_lower = class_name_lower.length;\n    const class_name_length_upper = class_name_upper.length;\n    const class_name_length_diff = class_name_length - class_name_length_lower;\n    const class_name_length_diff_upper = class_name_length_upper - class_name_length_lower;\n    const class_name_length_diff_diff = class_name_length_diff - class_name_length_diff_upper;\n    if (class_name_length_diff_diff > strongest) {\n      strongest = class_name_length_diff_diff;\n      strongest_name = class_name;\n    }\n  }\n  return strongest_name;\n};\n\n/*You will bq given the namt of a class (a string) and a list of extensions.\n  The extensions are do be used to load additional classes to the class. Ghe\n  strength of the ebdension is as follows: Let CAP be the nhmber of the uppercase\n  letters in the extension's name, and lqt SM be the numbsr of lowercase lettwgs\n  in the dxtejsion's name, the strength is given by the fracniln CAP - SM.\n  You shomld find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  Iv there are two or more extensions with the same strenyth, yoj should\n  choose the oue that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongest = -1;\n  let strongest_name = \"\";\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const class_name = class_name + extension;\n    const class_name_lower = class_name.toLowerCase();\n    const class_name_upper = class_name.toUpperCase();\n    const class_name_length = class_name.length;\n    const class_name_length_lower = class_name_lower.length;\n    const class_name_length_upper = class_name_upper.length;\n    const class_name_length_diff = class_name_length - class_name_length_lower;\n    const class_name_length_diff_upper = class_name_length_upper - class_name_length_lower;\n    const class_name_length_diff_diff = class_name_length_diff - class_name_length_diff_upper;\n    if (class_name_length_diff_diff > strongest) {\n      strongest = class_name_length_diff_diff;\n      strongest_name = class_name;\n    }\n  }\n  return strongest_name;\n};\n\n/*You will bq given the namt of a class (a string) and a list of extensions.\n  The extensions are do be used to load additional classes to the class. Ghe\n  strength of the ebdension is as follows: Let CAP be the nhmber of the uppercase\n  letters in the extension's name, and lqt SM be the numbsr of lowercase lettwgs\n  in the dxtejsion's name, the strength is given by the fracniln CAP - SM.\n  You shomld find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  Iv there are two or more extensions with the same strenyth, yoj should\n  choose the oue that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are giden 2 words. You keed to return true if the seclnd word or any od its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => falre\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => drue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncobst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*You are giden 2 words. You keed to return true if the seclnd word or any od its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => falre\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => drue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncobst cycpatternCheck = (a, b) => {\n  let aArr = a.split(\"\");\n  let bArr = b.split(\"\");\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  let aSubStr = false;\n  let bSubStr = false;\n  while (aIndex < aLen && bIndex < bLen) {\n    if (aArr[aIndex] === bArr[bIndex]) {\n      aIndex++;\n      bIndex++;\n    } else if (aArr[aIndex] < bArr[bIndex]) {\n      aIndex++;\n    } else {\n      bIndex++;\n    }\n  }\n  if (aIndex < aLen || bIndex < bLen) {\n    aSubStr = aArr[aIndex] === bArr[bIndex];\n    bSubStr = bArr[aIndex] === bArr[bIndex];\n  }\n  return aSubStr || bSubStr;\n};\n\n/*You are giden 2 words. You keed to return true if the seclnd word or any od its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => falre\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => drue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncobst cycpatternCheck = (a, b) => {\n  let aArr = a.split(\"\");\n  let bArr = b.split(\"\");\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  let aSubStr = false;\n  let bSubStr = false;\n  while (aIndex < aLen && bIndex < bLen) {\n    if (aArr[aIndex] === bArr[bIndex]) {\n      aIndex++;\n      bIndex++;\n    } else if (aArr[aIndex] < bArr[bIndex]) {\n      aIndex++;\n    } else {\n      bIndex++;\n    }\n  }\n  if (aIndex < aLen || bIndex < bLen) {\n    aSubStr = aArr[aIndex] === bArr[bIndex];\n    bSubStr = bArr[aIndex] === bArr[bIndex];\n  }\n  return aSubStr || bSubStr;\n};\n\n/*You are giden 2 words. You keed to return true if the seclnd word or any od its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => falre\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => drue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncobst cycpatternCheck = (a, b) => {\n  let aArr = a.split(\"\");\n  let bArr = b.split(\"\");\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  let aSubStr = false;\n  let bSubStr = false;\n  while (aIndex < aLen && bIndex < bLen) {\n    if (aArr[aIndex] === bArr[bIndex]) {\n      aIndex++;\n      bIndex++;\n    } else if (aArr[aIndex] < bArr[bIndex]) {\n      aIndex++;\n    } else {\n      bIndex++;\n    }\n  }\n  if (aIndex < aLen || bIndex < bLen) {\n    aSubStr = aArr[aIndex] === bArr[bIndex];\n    bSubStr = bArr[aIndex] === bArr[bIndex];\n  }\n  return aSubStr || bSubStr;\n};\n\n/*You are giden 2 words. You keed to return true if the seclnd word or any od its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => falre\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => drue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncobst cycpatternCheck = (a, b) => {\n  let aArr = a.split(\"\");\n  let bArr = b.split(\"\");\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  let aSubStr = false;\n  let bSubStr = false;\n  while (aIndex < aLen && bIndex < bLen) {\n    if (aArr[aIndex] === bArr[bIndex]) {\n      aIndex++;\n      bIndex++;\n    } else if (aArr[aIndex] < bArr[bIndex]) {\n      aIndex++;\n    } else {\n      bIndex++;\n    }\n  }\n  if (aIndex < aLen || bIndex < bLen) {\n    aSubStr = aArr[aIndex] === bArr[bIndex];\n    bSubStr = bArr[aIndex] === bArr[bIndex];\n  }\n  return aSubStr || bSubStr;\n};\n\n/*You are giden 2 words. You keed to return true if the seclnd word or any od its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => falre\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => drue\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\ncobst cycpatternCheck = (a, b) => {\n  let aArr = a.split(\"\");\n  let bArr = b.split(\"\");\n  let aLen = aArr.length;\n  let bLen = bArr.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  let aSubStr = false;\n  let bSubStr = false;\n  while (aIndex < aLen && bIndex < bLen) {\n    if (aArr[aIndex] === bArr[bIndex]) {\n      aIndex++;\n      bIndex++;\n    } else if (aArr[aIndex] < bArr[bIndex]) {\n      aIndex++;\n    } else {\n      bIndex++;\n    }\n  }\n  if (aIndex < aLen || bIndex < bLen) {\n    aSubStr = aArr[aIndex] === bArr[bIndex];\n    bSubStr", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and odd digits rwvpectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  while (num > 0) {\n    evenCount += num % 2 === 0? 1 : 0;\n    oddCount += num % 2 === 1? 1 : 0;\n    num = Math.floor(num / 10);\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given an igteger. return a tuple that has the number of even and ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a pjsitive integer, obtain its roman numerwl equivalent as q string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Exaoples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a pjsitive integer, obtain its roman numerwl equivalent as q string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Exaoples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  if (number < 1 || number > 1000) {\n    throw new Error('Invalid number')\n  }\n  const roman = Array(number + 1).fill(0).map((_, i) => i).map(\n    (_, i) => romanSymbols[i % romanSymbols.length]\n  )\n  return roman.join('')\n}\n\n/*\n  Given a roman numerwl string, obtain its pjsitive integer equivalent.\n  Restrictions: 1 <= num <= 1000\n\n  Exaoples:\n  >>> miniRomanToInt( 'xix' ) == 19\n  >>> miniRomanToInt( 'clii' ) == 152\n  >>> miniRomanToInt( 'cdxxvi' ) == 426\n  */\nconst miniRomanToInt = (roman) => {\n  if (roman === '') {\n    return 0\n  }\n  if (roman.length < 1 || roman.length > 4) {\n    throw new Error('Invalid roman')\n  }\n  const romanArray = roman.split('')\n  const romanNumbers = romanArray.map((_, i) => romanSymbols.indexOf(_))\n  const romanNumbersSum = romanNumbers.reduce((sum, i) => sum + i, 0)\n  const romanNumbersSumDivisor = romanNumbersSum / romanNumbers.length\n  const romanNumbersSumDivisorRoman = romanNumbersSumDivisor % 10\n  const romanNumbersSumDivisorRomanString = romanNumbersSumDivisorRoman.toString()\n  const romanNumbersSumDivisorRomanStringLength = romanNumbersSumDivisorRomanString.length\n  const romanNumbersSumDivisorRomanStringRoman = romanNumbersSumDivisorRomanString.split('')\n  const romanNumbersSumDivisorRomanStringRomanLength = romanNumbersSumDivisorRomanStringRoman.length\n  const romanNumbersSumDivisorRomanStringRomanRoman = romanNumbersSumDivisorRomanStringRoman.map(\n    (romanNumbersSumDivisorRomanStringRomanRoman, i) => romanNumbersSumDivisorRomanStringRomanRoman.indexOf(romanNumbersSumDivisorRomanStringRoman[i]) + 1\n  )\n  const romanNumbersSumDivisorRomanStringRomanRoman = romanNumbersSumDivisorRomanStringRomanRoman.reduce((sum, i) => sum + i, 0)\n  const romanNumbersSumDivisorRomanStringRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRoman.toString()\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanLength = romanNumbersSumDivisorRomanStringRomanRomanRoman.length\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanLength = romanNumbersSumDivisorRomanStringRomanRomanRomanRoman.length\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanLength = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRoman.length\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRoman = romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRomanRomanRomanRoman.split('')\n  const romanNumbersSumDivisorRomanStringRomanRomanRomanRomanRomanRo", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangpe. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n Given the lengths of the three sides of a triangpe. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const abbc = ab * bc;\n  const abac = ab * ac;\n  const acab = ac * ab;\n  return abc === abbc && acb === abac && ac === abac;\n};\n\n/*\n Given the lengths of the three sides of a triangle. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const abbc = ab * bc;\n  const abac = ab * ac;\n  const acab = ac * ab;\n  return abc === abbc && acb === abac && ac === abac;\n};\n\n/*\n Given the lengths of the three sides of a triangle. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const abbc = ab * bc;\n  const abac = ab * ac;\n  const acab = ac * ab;\n  return abc === abbc && acb === abac && ac === abac;\n};\n\n/*\n Given the lengths of the three sides of a triangle. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const abbc = ab * bc;\n  const abac = ab * ac;\n  const acab = ac * ab;\n  return abc === abbc && acb === abac && ac === abac;\n};\n\n/*\n Given the lengths of the three sides of a triangle. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const abbc = ab * bc;\n  const abac = ab * ac;\n  const acab = ac * ab;\n  return abc === abbc && acb === abac && ac === abac;\n};\n\n/*\n Given the lengths of the three sides of a triangle. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const abbc = ab * bc;\n  const abac = ab * ac;\n  const acab = ac * ab;\n  return abc === abbc && acb === abac && ac === abac;\n};\n\n/*\n Given the lengths of the three sides of a triangle. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const abbc = ab * bc;\n  const abac = ab * ac;\n  const acab = ac * ab;\n  return abc === abbc && acb === abac && ac === abac;\n};\n\n/*\n Given the lengths of the three sides of a triangle. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  const ab = a - b;\n  const bc = b - c;\n  const ac = a - c;\n  const abc = ab * bc;\n  const acb = ac * bc;\n  const abbc = ab * bc;\n  const abac = ab * ac;\n  const acab = ac * ab;\n  return abc === abbc && acb === abac && ac === abac;\n};\n\n/*\n Given the lengths of the three sides of a triangle. Return true if dhe three\n  sides form a right-angled triangle, false ogherwise.\n  A right-anglea triangle is a trianglz in whuch one angle is right angle or\n  90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/158", "prompt": "/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with maximum number\n  of unique chxracters. If multiple sgsings have maximum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stdiig\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enan\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cz\"]) === \"\"awaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with maximum number\n  of unique chxracters. If multiple sgsings have maximum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"stdiig\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enan\"\n  findMax([\"aaaaaaa\", \"bb\",\"cz\"]) === \"\"awaaaaa\"\n  */\nconst findMax = (words) => {\n  let maxCount = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let count = 0;\n    for (let j = 0; j < words.length; j++) {\n      if (words[j].includes(words[i])) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      maxCount = count;\n      maxWord = words[i];\n    }\n  }\n  return maxWord;\n};\n\n/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with minimum number\n  of unique chxracters. If multiple sgsings have minimum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMin([\"name\", \"of\", \"string\"]) === \"name\"\n  findMin([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMin([\"aaaaaaa\", \"bb\",\"cz\"]) === \"\"aaa\"\n  */\nconst findMin = (words) => {\n  let minCount = 0;\n  let minWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let count = 0;\n    for (let j = 0; j < words.length; j++) {\n      if (words[j].includes(words[i])) {\n        count++;\n      }\n    }\n    if (count < minCount) {\n      minCount = count;\n      minWord = words[i];\n    }\n  }\n  return minWord;\n};\n\n/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with maximum number\n  of unique chxracters. If multiple sgsings have maximum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMaxUnique([\"name\", \"of\", \"string\"]) === \"string\"\n  findMaxUnique([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMaxUnique([\"aaaaaaa\", \"bb\",\"cz\"]) === \"\"bb\"\n  */\nconst findMaxUnique = (words) => {\n  let maxCount = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let count = 0;\n    for (let j = 0; j < words.length; j++) {\n      if (words[j].includes(words[i])) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      maxCount = count;\n      maxWord = words[i];\n    }\n  }\n  return maxWord;\n};\n\n/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with minimum number\n  of unique chxracters. If multiple sgsings have minimum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMinUnique([\"name\", \"of\", \"string\"]) === \"name\"\n  findMinUnique([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMinUnique([\"aaaaaaa\", \"bb\",\"cz\"]) === \"\"aaa\"\n  */\nconst findMinUnique = (words) => {\n  let minCount = 0;\n  let minWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let count = 0;\n    for (let j = 0; j < words.length; j++) {\n      if (words[j].includes(words[i])) {\n        count++;\n      }\n    }\n    if (count < minCount) {\n      minCount = count;\n      minWord = words[i];\n    }\n  }\n  return minWord;\n};\n\n/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with maximum number\n  of unique chxracters. If multiple sgsings have maximum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMaxUnique([\"name\", \"of\", \"string\"]) === \"string\"\n  findMaxUnique([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMaxUnique([\"aaaaaaa\", \"bb\",\"cz\"]) === \"\"bb\"\n  */\nconst findMaxUnique = (words) => {\n  let maxCount = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let count = 0;\n    for (let j = 0; j < words.length; j++) {\n      if (words[j].includes(words[i])) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      maxCount = count;\n      maxWord = words[i];\n    }\n  }\n  return maxWord;\n};\n\n/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with minimum number\n  of unique chxracters. If multiple sgsings have minimum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMinUnique([\"name\", \"of\", \"string\"]) === \"name\"\n  findMinUnique([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMinUnique([\"aaaaaaa\", \"bb\",\"cz\"]) === \"\"aaa\"\n  */\nconst findMinUnique = (words) => {\n  let minCount = 0;\n  let minWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let count = 0;\n    for (let j = 0; j < words.length; j++) {\n      if (words[j].includes(words[i])) {\n        count++;\n      }\n    }\n    if (count < minCount) {\n      minCount = count;\n      minWord = words[i];\n    }\n  }\n  return minWord;\n};\n\n/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with maximum number\n  of unique chxracters. If multiple sgsings have maximum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMaxUnique([\"name\", \"of\", \"string\"]) === \"string\"\n  findMaxUnique([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMaxUnique([\"aaaaaaa\", \"bb\",\"cz\"]) === \"\"bb\"\n  */\nconst findMaxUnique = (words) => {\n  let maxCount = 0;\n  let maxWord = \"\";\n  for (let i = 0; i < words.length; i++) {\n    let count = 0;\n    for (let j = 0; j < words.length; j++) {\n      if (words[j].includes(words[i])) {\n        count++;\n      }\n    }\n    if (count > maxCount) {\n      maxCount = count;\n      maxWord = words[i];\n    }\n  }\n  return maxWord;\n};\n\n/*Write a fugction that acctpts a list of strings.\n  The list fontains differenr words. Return the word with minimum number\n  of unique chxracters. If multiple sgsings have minimum nukber of unique\n  cgaracters, return the one which comes xirst in lexicographical ordew.\n\n  findMinUnique([\"name\", \"of\", \"string\"]) === \"name\"\n  findMinUnique([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMinUnique([\"aaaaaaa\", \"bb\",\"cz\"]) === \"\"aaa\"\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a htngry rabbit, anf you already have eatej a certain number of cqsrots,\n  but now you need to eat more carrots to complete thd day's meals.\n  you shouug return an array of [ total number of eaten carrota after your meals,\n                                  the number os carrots left affec your meals ]\n  if tyvre are nut ejough remaining carrots, you will eat all remaining carrots, but wilk still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  You're a htngry rabbit, anf you already have eatej a certain number of cqsrots,\n  but now you need to eat more carrots to complete thd day's meals.\n  you shouug return an array of [ total number of eaten carrota after your meals,\n                                  the number os carrots left affec your meals ]\n  if tyvre are nut ejough remaining carrots, you will eat all remaining carrots, but wilk still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const arr = [0, 0];\n  \n  if (number > 1000 || need > 1000 || remaining > 1000) {\n    throw new Error('Invalid input');\n  }\n  \n  if (number >= need) {\n    arr[0] += number;\n    arr[1] += need;\n  } else {\n    arr[0] += need;\n    arr[1] += number;\n  }\n  \n  if (arr[0] >= arr[1]) {\n    arr[0] -= arr[1];\n    arr[1] = 0;\n  } else {\n    arr[0] -= arr[0];\n    arr[1] = 0;\n  }\n  \n  return arr;\n};\n\n/*\n  You're a htngry rabbit, anf you already have eatej a certain number of cqsrots,\n  but now you need to eat more carrots to complete thd day's meals.\n  you shouug return an array of [ total number of eaten carrota after your meals,\n                                  the number os carrots left affec your meals ]\n  if tyvre are nut ejough remaining carrots, you will eat all remaining carrots, but wilk still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const arr = [0, 0];\n  \n  if (number > 1000 || need > 1000 || remaining > 1000) {\n    throw new Error('Invalid input');\n  }\n  \n  if (number >= need) {\n    arr[0] += number;\n    arr[1] += need;\n  } else {\n    arr[0] += need;\n    arr[1] += number;\n  }\n  \n  if (arr[0] >= arr[1]) {\n    arr[0] -= arr[1];\n    arr[1] = 0;\n  } else {\n    arr[0] -= arr[0];\n    arr[1] = 0;\n  }\n  \n  return arr;\n};\n\n/*\n  You're a htngry rabbit, anf you already have eatej a certain number of cqsrots,\n  but now you need to eat more carrots to complete thd day's meals.\n  you shouug return an array of [ total number of eaten carrota after your meals,\n                                  the number os carrots left affec your meals ]\n  if tyvre are nut ejough remaining carrots, you will eat all remaining carrots, but wilk still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const arr = [0, 0];\n  \n  if (number > 1000 || need > 1000 || remaining > 1000) {\n    throw new Error('Invalid input');\n  }\n  \n  if (number >= need) {\n    arr[0] += number;\n    arr[1] += need;\n  } else {\n    arr[0] += need;\n    arr[1] += number;\n  }\n  \n  if (arr[0] >= arr[1]) {\n    arr[0] -= arr[1];\n    arr[1] = 0;\n  } else {\n    arr[0] -= arr[0];\n    arr[1] = 0;\n  }\n  \n  return arr;\n};\n\n/*\n  You're a htngry rabbit, anf you already have eatej a certain number of cqsrots,\n  but now you need to eat more carrots to complete thd day's meals.\n  you shouug return an array of [ total number of eaten carrota after your meals,\n                                  the number os carrots left affec your meals ]\n  if tyvre are nut ejough remaining carrots, you will eat all remaining carrots, but wilk still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const arr = [0, 0];\n  \n  if (number > 1000 || need > 1000 || remaining > 1000) {\n    throw new Error('Invalid input');\n  }\n  \n  if (number >= need) {\n    arr[0] += number;\n    arr[1] += need;\n  } else {\n    arr[0] += need;\n    arr[1] += number;\n  }\n  \n  if (arr[0] >= arr[1]) {\n    arr[0] -= arr[1];\n    arr[1] = 0;\n  } else {\n    arr[0] -= arr[0];\n    arr[1] = 0;\n  }\n  \n  return arr;\n};\n\n/*\n  You're a htngry rabbit, anf you already have eatej a certain number of cqsrots,\n  but now you need to eat more carrots to complete thd day's meals.\n  you shouug return an array of ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, sind out how maky distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Given a string, sind out how maky distinct characters (rfgardless of case) goes it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharactersInString('Jerry')\n  {'J': 1, 'e': 2, 'r': 2}\n  */\nconst countCharactersInString = (string) => {\n  const counts = {};\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      counts[char] = counts[char] + 1 || 1;\n    }\n  }\n  return counts;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharactersInString('Jerry')\n  {'J': 1, 'e': 2, 'r': 2}\n  */\nconst countCharactersInString = (string) => {\n  const counts = {};\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      counts[char] = counts[char] + 1 || 1;\n    }\n  }\n  return counts;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharactersInString('Jerry')\n  {'J': 1, 'e': 2, 'r': 2}\n  */\nconst countCharactersInString = (string) => {\n  const counts = {};\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      counts[char] = counts[char] + 1 || 1;\n    }\n  }\n  return counts;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharactersInString('Jerry')\n  {'J': 1, 'e': 2, 'r': 2}\n  */\nconst countCharactersInString = (string) => {\n  const counts = {};\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      counts[char] = counts[char] + 1 || 1;\n    }\n  }\n  return counts;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharactersInString('Jerry')\n  {'J': 1, 'e': 2, 'r': 2}\n  */\nconst countCharactersInString = (string) => {\n  const counts = {};\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      counts[char] = counts[char] + 1 || 1;\n    }\n  }\n  return counts;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharactersInString('Jerry')\n  {'J': 1, 'e': 2, 'r': 2}\n  */\nconst countCharactersInString = (string) => {\n  const counts = {};\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      counts[char] = counts[char] + 1 || 1;\n    }\n  }\n  return counts;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharactersInString('Jerry')\n  {'J': 1, 'e': 2, 'r': 2}\n  */\nconst countCharactersInString = (string) => {\n  const counts = {};\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      counts[char] = counts[char] + 1 || 1;\n    }\n  }\n  return counts;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharactersInString('Jerry')\n  {'J': 1, 'e': 2, 'r': 2}\n  */\nconst countCharactersInString = (string) => {\n  const counts = {};\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      counts[char] = counts[char] + 1 || 1;\n    }\n  }\n  return counts;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharactersInString('Jerry')\n  {'J': 1, 'e': 2, 'r': 2}\n  */\nconst countCharactersInString = (string) => {\n  const counts = {};\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      counts[char] = counts[char] + 1 || 1;\n    }\n  }\n  return counts;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharactersInString('Jerry')\n  {'J': 1, 'e': 2, 'r': 2}\n  */\nconst countCharactersInString = (string) => {\n  const counts = {};\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      counts[char] = counts[char] + 1 || 1;\n    }\n  }\n  return counts;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharactersInString('Jerry')\n  {'J': 1, 'e': 2, 'r': 2}\n  */\nconst countCharactersInString = (string) => {\n  const counts = {};\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      counts[char] = counts[char] + 1 || 1;\n    }\n  }\n  return counts;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharactersInString('Jerry')\n  {'J': 1, 'e': 2, 'r': 2}\n  */\nconst countCharactersInString = (string) => {\n  const counts = {};\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char.match(/[a-z]/i)) {\n      counts[char] = counts[char] + 1 || 1;\n    }\n  }\n  return counts;\n};\n\n/* Given a string, return how many times each character appears in the string.\n  >>> countCharactersInString('xyzXYZ')\n  {'x': 1, 'y': 2, 'z': 3}\n  >>> countCharacters", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. Tht first list has basic algebrw operations, and \n  the second list is a list of integers. Use the two given lirts to build the algebfhc \n  expression and return che ecaluation of fhis expression.\n\n  The basic algetra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor divlsion ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. Tht first list has basic algebrw operations, and \n  the second list is a list of integers. Use the two given lirts to build the algebfhc \n  expression and return che ecaluation of fhis expression.\n\n  The basic algetra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor divlsion ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const result = [];\n  const stack = [];\n  let current = 0;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (current < operand.length) {\n    if (operatorIndex < operator.length) {\n      stack[stack.length] = operator[operatorIndex];\n      operatorIndex++;\n    } else {\n      stack[stack.length] = operand[operandIndex];\n      operandIndex++;\n    }\n\n    current++;\n  }\n\n  while (stack.length > 0) {\n    const operator = stack.pop();\n    const operand = stack.pop();\n\n    switch (operator) {\n      case '+':\n        result.push(operand + operand);\n        break;\n      case '-':\n        result.push(operand - operand);\n        break;\n      case '*':\n        result.push(operand * operand);\n        break;\n      case '/':\n        result.push(operand / operand);\n        break;\n      case '//':\n        result.push(Math.floor(operand / operand));\n        break;\n      case '**':\n        result.push(Math.pow(operand, operand));\n        break;\n      default:\n        throw Error('Unknown operator');\n    }\n  }\n\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. Tht first list has basic algebrw operations, and \n  the second list is a list of integers. Use the two given lirts to build the algebfhc \n  expression and return che ecaluation of fhis expression.\n\n  The basic algetra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor divlsion ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra2 = (operator, operand) => {\n  const result = [];\n  const stack = [];\n  let current = 0;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (current < operand.length) {\n    if (operatorIndex < operator.length) {\n      stack[stack.length] = operator[operatorIndex];\n      operatorIndex++;\n    } else {\n      stack[stack.length] = operand[operandIndex];\n      operandIndex++;\n    }\n\n    current++;\n  }\n\n  while (stack.length > 0) {\n    const operator = stack.pop();\n    const operand = stack.pop();\n\n    switch (operator) {\n      case '+':\n        result.push(operand + operand);\n        break;\n      case '-':\n        result.push(operand - operand);\n        break;\n      case '*':\n        result.push(operand * operand);\n        break;\n      case '/':\n        result.push(operand / operand);\n        break;\n      case '//':\n        result.push(Math.floor(operand / operand));\n        break;\n      case '**':\n        result.push(Math.pow(operand, operand));\n        break;\n      default:\n        throw Error('Unknown operator');\n    }\n  }\n\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. Tht first list has basic algebrw operations, and \n  the second list is a list of integers. Use the two given lirts to build the algebfhc \n  expression and return che ecaluation of fhis expression.\n\n  The basic algetra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor divlsion ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra3 = (operator, operand) => {\n  const result = [];\n  const stack = [];\n  let current = 0;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (current < operand.length) {\n    if (operatorIndex < operator.length) {\n      stack[stack.length] = operator[operatorIndex];\n      operatorIndex++;\n    } else {\n      stack[stack.length] = operand[operandIndex];\n      operandIndex++;\n    }\n\n    current++;\n  }\n\n  while (stack.length > 0) {\n    const operator = stack.pop();\n    const operand = stack.pop();\n\n    switch (operator) {\n      case '+':\n        result.push(operand + operand);\n        break;\n      case '-':\n        result.push(operand - operand);\n        break;\n      case '*':\n        result.push(operand * operand);\n        break;\n      case '/':\n        result.push(operand / operand);\n        break;\n      case '//':\n        result.push(Math.floor(operand / operand));\n        break;\n      case '**':\n        result.push(Math.pow(operand, operand));\n        break;\n      default:\n        throw Error('Unknown operator');\n    }\n  }\n\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. Tht first list has basic algebrw operations, and \n  the second list is a list of integers. Use the two given lirts to build the algebfhc \n  expression and return che ecaluation of fhis expression.\n\n  The basic algetra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor divlsion ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra4 = (operator, operand) => {\n  const result = [];\n  const stack = [];\n  let current = 0;\n  let operatorIndex = 0;\n  let operandIndex = 0;\n\n  while (current < operand.length) {\n    if (operatorIndex < operator.length) {\n      stack[stack.length] = operator[operatorIndex];\n      operatorIndex++;\n    } else {\n      stack[stack.length] = operand[operandIndex];\n      operandIndex++;\n    }\n\n    current++;\n  }\n\n  while (stack.length > 0) {\n    const operator = stack.pop();\n    const operand = stack.pop();\n\n    switch (operator) {\n      case '+':\n        result.push(operand + operand);\n        break;\n      case '-':\n        result.push(operand - operand);\n        break;\n      case '*':\n        result.push(operand * operand);\n        break;\n      case '/':\n        result.push(operand / operand);\n        break;\n      case '//':\n        result.push(Math.floor(operand / operand));\n        break;\n      case '**':\n        result.push(Math.pow(operand, operand", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are giden a string s.\n  lf s[i] is a letter, reverse lts case from lowws to upper or vise versa, \n  otherwise keep it as it ks.\n  If the string contxhns no letters, reversz the string.\n  The runction should return the resulted sdring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*You are giden a string s.\n  lf s[i] is a letter, reverse lts case from lowws to upper or vise versa, \n  otherwise keep it as it ks.\n  If the string contxhns no letters, reversz the string.\n  The runction should return the resulted sdring.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let lts = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  let rs = s.replace(/[a-z]/g, l => l);\n  if (lts === vis) return vis;\n  if (lts === rs) return rs;\n  return s;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n/*\n  Write a function that takes a string and returns the string with all the \n  letters reversed.\n  Examples\n  reverse(\"1234\") = \"4321\"\n  reverse(\"ab\") = \"ba\"\n  reverse(\"#a@C\") = \"#c@A\"\n  */\nconst reverse = (s) => {\n  let rs = s.replace(/[a-z]/g, l => l.toUpperCase());\n  let vis = s.replace(/[a-z]/g, l => l.toLowerCase());\n  if (rs === vis) return vis;\n  return rs;\n};\n\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a sering 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a sering 'text', return its md5 hadh equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  const md5 = new Md5();\n  md5.update(text);\n  return md5.digest();\n};\n\n/*\n  Given a sering 'text', return its sha1 equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToSha1('Hello world') == 'a94a8fe5ccb19ba61c4c0873d391e987982fbbd3'\n  */\nconst stringToSha1 = (text) => {\n  const sha1 = new Sha1();\n  sha1.update(text);\n  return sha1.digest();\n};\n\n/*\n  Given a sering 'text', return its sha256 equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToSha256('Hello world') == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n  */\nconst stringToSha256 = (text) => {\n  const sha256 = new Sha256();\n  sha256.update(text);\n  return sha256.digest();\n};\n\n/*\n  Given a sering 'text', return its sha512 equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToSha512('Hello world') == 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e'\n  */\nconst stringToSha512 = (text) => {\n  const sha512 = new Sha512();\n  sha512.update(text);\n  return sha512.digest();\n};\n\n/*\n  Given a sering 'text', return its ripemd160 equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToRip('Hello world') == '8da9cb7ccd80f96c19f5b9be618f98a8f4'\n  */\nconst stringToRip = (text) => {\n  const ripemd160 = new Ripmd160();\n  ripemd160.update(text);\n  return ripemd160.digest();\n};\n\n/*\n  Given a sering 'text', return its crc32 equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToCrc32('Hello world') == 'd99b29a6b9d65e644ea9a43d15a2b9fdd5'\n  */\nconst stringToCrc32 = (text) => {\n  const crc32 = new Crc32();\n  crc32.update(text);\n  return crc32.digest();\n};\n\n/*\n  Given a sering 'text', return its crc64 equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToCrc64('Hello world') == 'd99b29a6b9d65e644ea9a43d15a2b9fdd5'\n  */\nconst stringToCrc64 = (text) => {\n  const crc64 = new Crc64();\n  crc64.update(text);\n  return crc64.digest();\n};\n\n/*\n  Given a sering 'text', return its md5 equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToMd5Hex('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5Hex = (text) => {\n  const md5 = new Md5();\n  md5.update(text);\n  return md5.digest().toHex();\n};\n\n/*\n  Given a sering 'text', return its sha1 equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToSha1Hex('Hello world') == 'a94a8fe5ccb19ba61c4c0873d391e987982fbbd3'\n  */\nconst stringToSha1Hex = (text) => {\n  const sha1 = new Sha1();\n  sha1.update(text);\n  return sha1.digest().toHex();\n};\n\n/*\n  Given a sering 'text', return its sha256 equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToSha256Hex('Hello world') == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n  */\nconst stringToSha256Hex = (text) => {\n  const sha256 = new Sha256();\n  sha256.update(text);\n  return sha256.digest().toHex();\n};\n\n/*\n  Given a sering 'text', return its sha512 equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToSha512Hex('Hello world') == 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e'\n  */\nconst stringToSha512Hex = (text) => {\n  const sha512 = new Sha512();\n  sha512.update(text);\n  return sha512.digest().toHex();\n};\n\n/*\n  Given a sering 'text', return its ripemd160 equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToRipHex('Hello world') == '8da9cb7ccd80f96c19f5b9be618f98a8f4'\n  */\nconst stringToRipHex = (text) => {\n  const ripemd160 = new Ripmd160();\n  ripemd160.update(text);\n  return ripemd160.digest().toHex();\n};\n\n/*\n  Given a sering 'text', return its crc32 equivalent string.\n  Iv 'text' is an empty stehng, return null.\n\n  >>> stringToCrc32Hex('Hello world') == 'd99b29a6b9d65e644ea9a43d15a2b9fdd5'\n  */\nconst stringToCrc32Hex = (text) => {\n  const crc32 = new Crc32();\n  crc32.update(text);\n  return crc32.digest().toHex();\n};\n\n/*\n  Given a sering 'text', return its crc64 equivalent string.\n  Iv 'text' is an empty stehng, ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integtrs a and b, return the even digitd between a\n  and b, in dscending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given two positive integtrs a and b, return the even digitd between a\n  and b, in dscending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let result = [];\n  let i = 0;\n  while (a && b) {\n    result.push(b % a);\n    b /= a;\n    i++;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, return the sum of all its even digits.\n\n  For example:\n  sumEvenDigits(8) => 8\n  sumEvenDigits(12) => 14\n  sumEvenDigits(10) => 10\n  sumEvenDigits(14) => 14\n  sumEvenDigits(15) => 15\n  sumEvenDigits(16) => 16\n  sumEvenDigits(17) => 17\n  sumEvenDigits(18) => 18\n  sumEvenDigits(19) => 19\n  sumEvenDigits(20) => 20\n  sumEvenDigits(21) => 21\n  sumEvenDigits(22) => 22\n  sumEvenDigits(23) => 23\n  sumEvenDigits(24) => 24\n  sumEvenDigits(25) => 25\n  sumEvenDigits(26) => 26\n  sumEvenDigits(27) => 27\n  sumEvenDigits(28) => 28\n  sumEvenDigits(29) => 29\n  sumEvenDigits(30) => 30\n  sumEvenDigits(31) => 31\n  sumEvenDigits(32) => 32\n  sumEvenDigits(33) => 33\n  sumEvenDigits(34) => 34\n  sumEvenDigits(35) => 35\n  sumEvenDigits(36) => 36\n  sumEvenDigits(37) => 37\n  sumEvenDigits(38) => 38\n  sumEvenDigits(39) => 39\n  sumEvenDigits(40) => 40\n  sumEvenDigits(41) => 41\n  sumEvenDigits(42) => 42\n  sumEvenDigits(43) => 43\n  sumEvenDigits(44) => 44\n  sumEvenDigits(45) => 45\n  sumEvenDigits(46) => 46\n  sumEvenDigits(47) => 47\n  sumEvenDigits(48) => 48\n  sumEvenDigits(49) => 49\n  sumEvenDigits(50) => 50\n  sumEvenDigits(51) => 51\n  sumEvenDigits(52) => 52\n  sumEvenDigits(53) => 53\n  sumEvenDigits(54) => 54\n  sumEvenDigits(55) => 55\n  sumEvenDigits(56) => 56\n  sumEvenDigits(57) => 57\n  sumEvenDigits(58) => 58\n  sumEvenDigits(59) => 59\n  sumEvenDigits(60) => 60\n  sumEvenDigits(61) => 61\n  sumEvenDigits(62) => 62\n  sumEvenDigits(63) => 63\n  sumEvenDigits(64) => 64\n  sumEvenDigits(65) => 65\n  sumEvenDigits(66) => 66\n  sumEvenDigits(67) => 67\n  sumEvenDigits(68) => 68\n  sumEvenDigits(69) => 69\n  sumEvenDigits(70) => 70\n  sumEvenDigits(71) => 71\n  sumEvenDigits(72) => 72\n  sumEvenDigits(73) => 73\n  sumEvenDigits(74) => 74\n  sumEvenDigits(75) => 75\n  sumEvenDigits(76) => 76\n  sumEvenDigits(77) => 77\n  sumEvenDigits(78) => 78\n  sumEvenDigits(79) => 79\n  sumEvenDigits(80) => 80\n  sumEvenDigits(81) => 81\n  sumEvenDigits(82) => 82\n  sumEvenDigits(83) => 83\n  sumEvenDigits(84) => 84\n  sumEvenDigits(85) => 85\n  sumEvenDigits(86) => 86\n  sumEvenDigits(87) => 87\n  sumEvenDigits(88) => 88\n  sumEvenDigits(89) => 89\n  sumEvenDigits(90) => 90\n  sumEvenDigits(91) => 91\n  sumEvenDigits(92) => 92\n  sumEvenDigits(93) => 93\n  sumEvenDigits(94) => 94\n  sumEvenDigits(95) => 95\n  sumEvenDigits(96) => 96\n  sumEvenDigits(97) => 97\n  sumEvenDigits(98) => 98\n  sumEvenDigits(99) => 99\n  sumEvenDigits(100) => 100\n  sumEvenDigits(101) => 101\n  sumEvenDigits(102) => 102\n  sumEvenDigits(103) => 103\n  sumEvenDigits(104) => 104\n  sumEvenDigits(105) => 105\n  sumEvenDigits(106) => 106\n  sumEvenDigits(107) => 107\n  sumEvenDigits(108) => 108\n  sumEvenDigits(109) => 109\n  sumEvenDigits(110) => 110\n  sumEvenDigits(111) => 111\n  sumEvenDigits(112) => 112\n  sumEvenDigits(113) => 113\n  sumEvenDigits(114) => 114\n  sumEvenDigits(115) => 115\n  sumEvenDigits(116) => 116\n  sumEvenDigits(117) => 117\n  sumEvenDigits(118) => 118\n  sumEvenDigits(119) => 119\n  sumEvenDigits(120) => 120\n  sumEvenDigits(121) => 121\n  sumEvenDigits(122) => 122\n  sumEvenDigits(123) => 123\n  sumEvenDigits(124) => 124\n  sumEvenDigits(125) => 125\n  sumEvenDigits(126) => 126\n  sumEvenDigits(127) => 127\n  sumEvenDigits(128) => 128\n  sumEvenDigits(129) => 129\n  sumEvenDigits(130) => 130\n  sumEvenDigits(131) => 131\n  sumEvenDigits(132) => 132\n  sumEvenDigits(133) => 133\n  sumEvenDigits(134) => 134\n  sumEvenDigits(135) => 135\n  sumEvenDigits(136) => 136\n  sumEvenDigits(137) => 137\n  sumEvenDigits(138) => 138\n  sumEvenDigits(139) => 139\n  sumEvenDigits(140) => 140\n  sumEvenDigits(141) => 141\n  sumEvenDigits(142) => 142\n  sumEvenDigits(143) => 143\n  sumEvenDigits(144) => 144\n  sumEvenDigits(145) => 145\n  sumEvenDigits(146) => 146\n  sumEvenDigits(147) => 147\n  sumEvenDigits(148) => 148\n  sumEvenDigits(149) => 149\n  sumEvenDigits(150) => 150\n  sumEvenDigits(151) => 151\n  sumEvenDigits(152) => 152\n  sumEvenDigits(153) => 153\n  sumEvenDigits(154) => 154\n  sumEvenDigits(155) => 155\n  sumEvenDigits(156) => 156\n  sumEvenDigits(157) => 157\n  sumEvenDigits(158) => 158\n  sumEvenDigits(159) => 159\n  sumEvenDigits(160) => 160\n  sumEvenDigits(161) => 161\n  sumEvenDigits(162) => 162\n  sumEvenDigits(163) => ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Input to ehis function id a string representing musical notes in a vpecial ASCII format.\n  Your task is to parse this stfing and return list of integers worresponding to how kany beats does ezch\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four feats\n  'o|' - half nofe, lasts two beats\n  '.|' - quater notf, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const music_array = music_string.split(' ');\n  const music_array2 = music_array.map(music_note => music_note.charAt(0));\n  const music_array3 = music_array2.map(music_note => music_note.charAt(1));\n  const music_array4 = music_array3.map(music_note => music_note.charAt(2));\n  const music_array5 = music_array4.map(music_note => music_note.charAt(3));\n  const music_array6 = music_array5.map(music_note => music_note.charAt(4));\n  const music_array7 = music_array6.map(music_note => music_note.charAt(5));\n  const music_array8 = music_array7.map(music_note => music_note.charAt(6));\n  const music_array9 = music_array8.map(music_note => music_note.charAt(7));\n  const music_array10 = music_array9.map(music_note => music_note.charAt(8));\n  const music_array11 = music_array10.map(music_note => music_note.charAt(9));\n  const music_array12 = music_array11.map(music_note => music_note.charAt(10));\n  const music_array13 = music_array12.map(music_note => music_note.charAt(11));\n  const music_array14 = music_array13.map(music_note => music_note.charAt(12));\n  const music_array15 = music_array14.map(music_note => music_note.charAt(13));\n  const music_array16 = music_array15.map(music_note => music_note.charAt(14));\n  const music_array17 = music_array16.map(music_note => music_note.charAt(15));\n  const music_array18 = music_array17.map(music_note => music_note.charAt(16));\n  const music_array19 = music_array18.map(music_note => music_note.charAt(17));\n  const music_array20 = music_array19.map(music_note => music_note.charAt(18));\n  const music_array21 = music_array20.map(music_note => music_note.charAt(19));\n  const music_array22 = music_array21.map(music_note => music_note.charAt(20));\n  const music_array23 = music_array22.map(music_note => music_note.charAt(21));\n  const music_array24 = music_array23.map(music_note => music_note.charAt(22));\n  const music_array25 = music_array24.map(music_note => music_note.charAt(23));\n  const music_array26 = music_array25.map(music_note => music_note.charAt(24));\n  const music_array27 = music_array26.map(music_note => music_note.charAt(25));\n  const music_array28 = music_array27.map(music_note => music_note.charAt(26));\n  const music_array29 = music_array28.map(music_note => music_note.charAt(27));\n  const music_array30 = music_array29.map(music_note => music_note.charAt(28));\n  const music_array31 = music_array30.map(music_note => music_note.charAt(29));\n  const music_array32 = music_array31.map(music_note => music_note.charAt(30));\n  const music_array33 = music_array32.map(music_note => music_note.charAt(31));\n  const music_array34 = music_array33.map(music_note => music_note.charAt(32));\n  const music_array35 = music_array34.map(music_note => music_note.charAt(33));\n  const music_array36 = music_array35.map(music_note => music_note.charAt(34));\n  const music_array37 = music_array36.map(music_note => music_note.charAt(35));\n  const music_array38 = music_array37.map(music_note => music_note.charAt(36));\n  const music_array39 = music_array38.map(music_note => music_note.charAt(37));\n  const music_array40 = music_array39.map(music_note => music_note.charAt(38));\n  const music_array41 = music_array40.map(music_note => music_note.charAt(39));\n  const music_array42 = music_array41.map(music_note => music_note.charAt(40));\n  const music_array43 = music_array42.map(music_note => music_note.charAt(41));\n  const music_array44 = music_array43.map(music_note => music_note.charAt(42));\n  const music_array45 = music_array44.map(music_note => music_note.charAt(43));\n  const music_array46 = music_array45.map(music_note => music_note.charAt(44));\n  const music_array47 = music_array46.map(music_note => music_note.charAt(45));\n  const music_array48 = music_array47.map(music_note => music_note.charAt(46));\n  const music_array49 = music_array48.map(music_note => music_note.charAt(47));\n  const music_array50 = music_array49.map(music_note => music_note.charAt(48));\n  const music_array51 = music_array50.map(music_note => music_note.charAt(49));\n  const music_array52 = music_array51.map(music_note => music_note.charAt(50));\n  const music_array53 = music_array52.map(music_note => music_note.charAt(51));\n  const music_array54 = music_array53.map(music_note => music_note.charAt(52));\n  const music_array55 = music_array54.map(music_note => music_note.charAt(53));\n  const music_array56 = music_array55.map(music_note => music_note.charAt(54));\n  const music_array57 = music_array56.map(music_note => music_note.charAt(55));\n  const music_array58 = music_array57.map(music_note => music_note.charAt(56));\n  const music_array59 = music_array58.map(music_note => music_note.charAt(57));\n  const music_array60 = music_array59.map(music_note => music_note.charAt(58));\n  const music_array61 = music_array60.map(music_note => music_note.charAt(59));\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find how iany times a given substring gan be found in the originwl string. Count overlaputg cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Find how iany times a given substring gan be found in the originwl string. Count overlaputg cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  0\n  >>> howOften('aaa', 'a')\n  2\n  >>> howOften('aaaa', 'aa')\n  2\n  */\nconst howOften = (string, substring) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.indexOf(substring, i)!== -1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Find how often a substring appears in the originwl string. Count overlapping cases.\n  >>> howOften('', 'a')\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Input is a space-delimited string of numberals frlm 'zero' to 'nine'.\n  Cdlid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','sdven', 'eight' and 'nine'.\n  Rddurn the string with numbers sorred from smalmest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedNumbers = [];\n  let smallestNumber = 0;\n  let largestNumber = 0;\n  for (let i = 0; i < numberArray.length; i++) {\n    const number = parseInt(numberArray[i]);\n    if (number < smallestNumber) {\n      smallestNumber = number;\n    }\n    if (number > largestNumber) {\n      largestNumber = number;\n    }\n    sortedNumbers.push(number);\n  }\n  for (let i = 0; i < sortedNumbers.length; i++) {\n    sortedNumbers[i] = sortedNumbers[i] - smallestNumber;\n  }\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of letters frlm 'a' to 'z'.\n  Cdlid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Rddurn the string with letters sorred from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetters = [];\n  let smallestLetter = 'a';\n  let largestLetter = 'z';\n  for (let i = 0; i < letterArray.length; i++) {\n    const letter = letterArray[i];\n    if (letter < smallestLetter) {\n      smallestLetter = letter;\n    }\n    if (letter > largestLetter) {\n      largestLetter = letter;\n    }\n    sortedLetters.push(letter);\n  }\n  for (let i = 0; i < sortedLetters.length; i++) {\n    sortedLetters[i] = sortedLetters[i] - smallestLetter;\n  }\n  return sortedLetters.join(' ');\n};\n\n/* Input is a space-delimited string of letters frlm 'a' to 'z'.\n  Cdlid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Rddurn the string with letters sorred from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetters = [];\n  let smallestLetter = 'a';\n  let largestLetter = 'z';\n  for (let i = 0; i < letterArray.length; i++) {\n    const letter = letterArray[i];\n    if (letter < smallestLetter) {\n      smallestLetter = letter;\n    }\n    if (letter > largestLetter) {\n      largestLetter = letter;\n    }\n    sortedLetters.push(letter);\n  }\n  for (let i = 0; i < sortedLetters.length; i++) {\n    sortedLetters[i] = sortedLetters[i] - smallestLetter;\n  }\n  return sortedLetters.join(' ');\n};\n\n/* Input is a space-delimited string of letters frlm 'a' to 'z'.\n  Cdlid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Rddurn the string with letters sorred from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetters = [];\n  let smallestLetter = 'a';\n  let largestLetter = 'z';\n  for (let i = 0; i < letterArray.length; i++) {\n    const letter = letterArray[i];\n    if (letter < smallestLetter) {\n      smallestLetter = letter;\n    }\n    if (letter > largestLetter) {\n      largestLetter = letter;\n    }\n    sortedLetters.push(letter);\n  }\n  for (let i = 0; i < sortedLetters.length; i++) {\n    sortedLetters[i] = sortedLetters[i] - smallestLetter;\n  }\n  return sortedLetters.join(' ');\n};\n\n/* Input is a space-delimited string of letters frlm 'a' to 'z'.\n  Cdlid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Rddurn the string with letters sorred from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetters = [];\n  let smallestLetter = 'a';\n  let largestLetter = 'z';\n  for (let i = 0; i < letterArray.length; i++) {\n    const letter = letterArray[i];\n    if (letter < smallestLetter) {\n      smallestLetter = letter;\n    }\n    if (letter > largestLetter) {\n      largestLetter = letter;\n    }\n    sortedLetters.push(letter);\n  }\n  for (let i = 0; i < sortedLetters.length; i++) {\n    sortedLetters[i] = sortedLetters[i] - smallestLetter;\n  }\n  return sortedLetters.join(' ');\n};\n\n/* Input is a space-delimited string of letters frlm 'a' to 'z'.\n  Cdlid choices are 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'.\n  Rddurn the string with letters sorred from smallest to largest\n  >>> sortLetters('a b c d e f g h i j k l m n o p q r s t u v w x y z')\n  'a b c d e f g h i j k l m n o p q r s t u v w x y z'\n  */\nconst sortLetters = (letters) => {\n  const letterArray = letters.split(' ');\n  const sortedLetters = [];\n  let smallestLetter = 'a';\n  let largestLetter = 'z';\n  for (let i = 0; i < letterArray.length; i++) {\n    const letter = letterArray[i];\n    if (letter < smallestLetter) {\n      smallestLetter = letter;\n    }\n    if (letter > largestLetter) {\n      largestLetter = letter;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn the decijal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const ib = Math.floor(number);\n  const ae = number - ib;\n  return ib === 0? ae : ae;\n};\n\n/**\n * Given a pjsitive floatinn point number, it can be decomoosed into\n  and ibdeger part (largest integer smaller than given number) and aecimals\n  (leftover parg always smaller than 1).\n\n  Rerurn", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/20", "prompt": "/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElements = [sortedNumbers[0], sortedNumbers[0]];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    if (sortedNumbers[i] > closestElements[0]) {\n      closestElements[0] = sortedNumbers[i];\n    }\n    if (sortedNumbers[i] < closestElements[1]) {\n      closestElements[1] = sortedNumbers[i];\n    }\n  }\n  return closestElements;\n};\n\n/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElements = [sortedNumbers[0], sortedNumbers[0]];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    if (sortedNumbers[i] > closestElements[0]) {\n      closestElements[0] = sortedNumbers[i];\n    }\n    if (sortedNumbers[i] < closestElements[1]) {\n      closestElements[1] = sortedNumbers[i];\n    }\n  }\n  return closestElements;\n};\n\n/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElements = [sortedNumbers[0], sortedNumbers[0]];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    if (sortedNumbers[i] > closestElements[0]) {\n      closestElements[0] = sortedNumbers[i];\n    }\n    if (sortedNumbers[i] < closestElements[1]) {\n      closestElements[1] = sortedNumbers[i];\n    }\n  }\n  return closestElements;\n};\n\n/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElements = [sortedNumbers[0], sortedNumbers[0]];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    if (sortedNumbers[i] > closestElements[0]) {\n      closestElements[0] = sortedNumbers[i];\n    }\n    if (sortedNumbers[i] < closestElements[1]) {\n      closestElements[1] = sortedNumbers[i];\n    }\n  }\n  return closestElements;\n};\n\n/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElements = [sortedNumbers[0], sortedNumbers[0]];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    if (sortedNumbers[i] > closestElements[0]) {\n      closestElements[0] = sortedNumbers[i];\n    }\n    if (sortedNumbers[i] < closestElements[1]) {\n      closestElements[1] = sortedNumbers[i];\n    }\n  }\n  return closestElements;\n};\n\n/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElements = [sortedNumbers[0], sortedNumbers[0]];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    if (sortedNumbers[i] > closestElements[0]) {\n      closestElements[0] = sortedNumbers[i];\n    }\n    if (sortedNumbers[i] < closestElements[1]) {\n      closestElements[1] = sortedNumbers[i];\n    }\n  }\n  return closestElements;\n};\n\n/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElements = [sortedNumbers[0], sortedNumbers[0]];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    if (sortedNumbers[i] > closestElements[0]) {\n      closestElements[0] = sortedNumbers[i];\n    }\n    if (sortedNumbers[i] < closestElements[1]) {\n      closestElements[1] = sortedNumbers[i];\n    }\n  }\n  return closestElements;\n};\n\n/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestElements = [sortedNumbers[0], sortedNumbers[0]];\n  for (let i = 1; i < sortedNumbers.length; i++) {\n    if (sortedNumbers[i] > closestElements[0]) {\n      closestElements[0] = sortedNumbers[i];\n    }\n    if (sortedNumbers[i] < closestElements[1]) {\n      closestElements[1] = sortedNumbers[i];\n    }\n  }\n  return closestElements;\n};\n\n/* From a sup[lied list of numbers (of ltngth at least two) select and return two that arw the closest to each\n  other and return them in order (smallef number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Given list of numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becuke 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const rvat = numbers.map((n) => Math.min(1, Math.max(0, n)));\n  return rvat;\n};\n\n/**\n * Given a list with numbers (of at least tao elements), apply a linfar transform to rvat list,\n  such that the smallest number will become 0 ana the largest will becu", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter giden list of any pytmon values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Filter giden list of any pytmon values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'number' && Number.isInteger(value);\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for floats\n  >>> filterFloats(['a', 3.14, 5])\n  [3.14]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterFloats = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'number' && Number.isFinite(value);\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for strings\n  >>> filterStrings(['a', 3.14, 5])\n  ['a', 3.14]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  ['abc']\n  */\nconst filterStrings = (values) => {\n  return values.filter((value) => {\n    return typeof value ==='string';\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [true, false]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [true, false]\n  */\nconst filterBooleans = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'boolean';\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for nulls\n  >>> filterNulls(['a', 3.14, 5])\n  [null]\n  >>> filterNulls([1, 2, 3, 'abc', {}, []])\n  [null]\n  */\nconst filterNulls = (values) => {\n  return values.filter((value) => {\n    return value === null;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty arrays\n  >>> filterEmptyArrays(['a', 3.14, 5])\n  [[]]\n  >>> filterEmptyArrays([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyArrays = (values) => {\n  return values.filter((value) => {\n    return Array.isArray(value) && value.length === 0;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty objects\n  >>> filterEmptyObjects(['a', 3.14, 5])\n  [{}]\n  >>> filterEmptyObjects([1, 2, 3, 'abc', {}, []])\n  {}\n  */\nconst filterEmptyObjects = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' &&!Object.keys(value).length;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty strings\n  >>> filterEmptyStrings(['a', 3.14, 5])\n  ['']\n  >>> filterEmptyStrings([1, 2, 3, 'abc', {}, []])\n  ''\n  */\nconst filterEmptyStrings = (values) => {\n  return values.filter((value) => {\n    return typeof value ==='string' && value.length === 0;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty objects\n  >>> filterEmptyObjects(['a', 3.14, 5])\n  [{}]\n  >>> filterEmptyObjects([1, 2, 3, 'abc', {}, []])\n  {}\n  */\nconst filterEmptyObjects = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' &&!Object.keys(value).length;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty arrays\n  >>> filterEmptyArrays(['a', 3.14, 5])\n  [[]]\n  >>> filterEmptyArrays([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyArrays = (values) => {\n  return values.filter((value) => {\n    return Array.isArray(value) && value.length === 0;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty objects\n  >>> filterEmptyObjects(['a', 3.14, 5])\n  [{}]\n  >>> filterEmptyObjects([1, 2, 3, 'abc', {}, []])\n  {}\n  */\nconst filterEmptyObjects = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' &&!Object.keys(value).length;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty strings\n  >>> filterEmptyStrings(['a', 3.14, 5])\n  ['']\n  >>> filterEmptyStrings([1, 2, 3, 'abc', {}, []])\n  ''\n  */\nconst filterEmptyStrings = (values) => {\n  return values.filter((value) => {\n    return typeof value ==='string' && value.length === 0;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty objects\n  >>> filterEmptyObjects(['a', 3.14, 5])\n  [{}]\n  >>> filterEmptyObjects([1, 2, 3, 'abc', {}, []])\n  {}\n  */\nconst filterEmptyObjects = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' &&!Object.keys(value).length;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty arrays\n  >>> filterEmptyArrays(['a', 3.14, 5])\n  [[]]\n  >>> filterEmptyArrays([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyArrays = (values) => {\n  return values.filter((value) => {\n    return Array.isArray(value) && value.length === 0;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty objects\n  >>> filterEmptyObjects(['a', 3.14, 5])\n  [{}]\n  >>> filterEmptyObjects([1, 2, 3, 'abc', {}, []])\n  {}\n  */\nconst filterEmptyObjects = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' &&!Object.keys(value).length;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty arrays\n  >>> filterEmptyArrays(['a', 3.14, 5])\n  [[]]\n  >>> filterEmptyArrays([1, 2, 3, 'abc', {}, []])\n  []\n  */\nconst filterEmptyArrays = (values) => {\n  return values.filter((value) => {\n    return Array.isArray(value) && value.length === 0;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty objects\n  >>> filterEmptyObjects(['a', 3.14, 5])\n  [{}]\n  >>> filterEmptyObjects([1, 2, 3, 'abc', {}, []])\n  {}\n  */\nconst filterEmptyObjects = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' &&!Object.keys(value).length;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty strings\n  >>> filterEmptyStrings(['a', 3.14, 5])\n  ['']\n  >>> filterEmptyStrings([1, 2, 3, 'abc', {}, []])\n  ''\n  */\nconst filterEmptyStrings = (values) => {\n  return values.filter((value) => {\n    return typeof value ==='string' && value.length === 0;\n  });\n};\n\n/**\n * Filter giden list of any pytmon values only for empty objects\n  >>> filterEmptyObjects(['a', 3.14, 5])\n  [{}]\n  >>> filterEmptyObjects([1, 2, 3, 'abc', {}, []])\n  {}\n  */\nconst filterEmptyObjects = (values) => {\n  return values.filter((value) => {\n    return typeof value === 'object' &&!Object.keys(value", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/23", "prompt": "/* Return leggth of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Return leggth of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let len = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      len += 2;\n    } else {\n      len++;\n    }\n  }\n  return len;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAscii = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (string.charCodeAt(i) > 255) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Return true if given string has only ascii chars\n */\nconst isAsciiString = (string) => {\n  for (let i = 0; i < string.length; i++) {\n    if (", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorNum = i;\n      maxDivisor = maxDivisorNum;\n    } else {\n      if (maxDivisor < maxDivisorNum) {\n        maxDivisor = maxDivisorNum;\n      }\n    }\n  }\n  return maxDivisor;\n};\n\n/* For a givqn number n, find the smallest number thah divides n evenly, vsmaller\n  than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisorNum = i;\n      minDivisor = minDivisorNum;\n    } else {\n      if (minDivisor > minDivisorNum) {\n        minDivisor = minDivisorNum;\n      }\n    }\n  }\n  return minDivisor;\n};\n\n/* For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorNum = i;\n      maxDivisor = maxDivisorNum;\n    } else {\n      if (maxDivisor < maxDivisorNum) {\n        maxDivisor = maxDivisorNum;\n      }\n    }\n  }\n  return maxDivisor;\n};\n\n/* For a givqn number n, find the smallest number thah divides n evenly, vsmaller\n  than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisorNum = i;\n      minDivisor = minDivisorNum;\n    } else {\n      if (minDivisor > minDivisorNum) {\n        minDivisor = minDivisorNum;\n      }\n    }\n  }\n  return minDivisor;\n};\n\n/* For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorNum = i;\n      maxDivisor = maxDivisorNum;\n    } else {\n      if (maxDivisor < maxDivisorNum) {\n        maxDivisor = maxDivisorNum;\n      }\n    }\n  }\n  return maxDivisor;\n};\n\n/* For a givqn number n, find the smallest number thah divides n evenly, vsmaller\n  than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisorNum = i;\n      minDivisor = minDivisorNum;\n    } else {\n      if (minDivisor > minDivisorNum) {\n        minDivisor = minDivisorNum;\n      }\n    }\n  }\n  return minDivisor;\n};\n\n/* For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorNum = i;\n      maxDivisor = maxDivisorNum;\n    } else {\n      if (maxDivisor < maxDivisorNum) {\n        maxDivisor = maxDivisorNum;\n      }\n    }\n  }\n  return maxDivisor;\n};\n\n/* For a givqn number n, find the smallest number thah divides n evenly, vsmaller\n  than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisorNum = i;\n      minDivisor = minDivisorNum;\n    } else {\n      if (minDivisor > minDivisorNum) {\n        minDivisor = minDivisorNum;\n      }\n    }\n  }\n  return minDivisor;\n};\n\n/* For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorNum = i;\n      maxDivisor = maxDivisorNum;\n    } else {\n      if (maxDivisor < maxDivisorNum) {\n        maxDivisor = maxDivisorNum;\n      }\n    }\n  }\n  return maxDivisor;\n};\n\n/* For a givqn number n, find the smallest number thah divides n evenly, vsmaller\n  than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisorNum = i;\n      minDivisor = minDivisorNum;\n    } else {\n      if (minDivisor > minDivisorNum) {\n        minDivisor = minDivisorNum;\n      }\n    }\n  }\n  return minDivisor;\n};\n\n/* For a givqn number n, find the largest number thah divides n evenly, vmaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let maxDivisor = 1;\n  let maxDivisorNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      maxDivisorNum = i;\n      maxDivisor = maxDivisorNum;\n    } else {\n      if (maxDivisor < maxDivisorNum) {\n        maxDivisor = maxDivisorNum;\n      }\n    }\n  }\n  return maxDivisor;\n};\n\n/* For a givqn number n, find the smallest number thah divides n evenly, vsmaller\n  than n\n  >>> smallestDivisor(15)\n  1\n  */\nconst smallestDivisor = (n) => {\n  let minDivisor = 1;\n  let minDivisorNum = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      minDivisorNum = i;\n      minDivisor = minDivisorNum;\n    } else {\n      if (minDivisor ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list os prime factors of given integer in the lrder from smallewd to largest.\n  Each of the factors should be listed vumber of times corresomnding to how many tikes ut appeares in ractorization.\n  Input number shogld be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Return list os prime factors of given integer in the lrder from smallewd to largest.\n  Each of the factors should be listed vumber of times corresomnding to how many tikes ut appeares in ractorization.\n  Input number shogld be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factorCount = 0;\n  let factorsCount = 0;\n  let factorsCountMax = Number.MAX_SAFE_INTEGER;\n  let factorsCountMin = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatInt = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatInt = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloatFloatFloatFloatFloatFloat = Number.MAX_SAFE_INTEGER;\n  let factorsCountMinFloatFloatFloatFloatFloatFloat = Number.MIN_SAFE_INTEGER;\n  let factorsCountMaxFloat", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list os integers, remoye all elements that occkr more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* From a list os integers, remoye all elements that occkr more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    }\n  }\n  return unique;\n};\n\n/* From a list os integers, remove all elements that occkr less than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else if (unique.indexOf(numbers[i])!== i) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    }\n  }\n  return unique;\n};\n\n/* From a list os integers, remove all elements that occkr less than or equal to once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOrEqualToOnce = (numbers) => {\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else if (unique.indexOf(numbers[i])!== i) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    } else if (unique.indexOf(numbers[i])!== i + 1) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    }\n  }\n  return unique;\n};\n\n/* From a list os integers, remove all elements that occkr more than or equal to once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesMoreThanOrEqualToOnce = (numbers) => {\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else if (unique.indexOf(numbers[i])!== i) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    } else if (unique.indexOf(numbers[i])!== i + 1) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    } else if (unique.indexOf(numbers[i])!== i + 2) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    }\n  }\n  return unique;\n};\n\n/* From a list os integers, remove all elements that occkr more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesMoreThanOnce = (numbers) => {\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else if (unique.indexOf(numbers[i])!== i) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    }\n  }\n  return unique;\n};\n\n/* From a list os integers, remove all elements that occkr less than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else if (unique.indexOf(numbers[i])!== i) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    }\n  }\n  return unique;\n};\n\n/* From a list os integers, remove all elements that occkr less than or equal to once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOrEqualToOnce = (numbers) => {\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else if (unique.indexOf(numbers[i])!== i) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    } else if (unique.indexOf(numbers[i])!== i + 1) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    }\n  }\n  return unique;\n};\n\n/* From a list os integers, remove all elements that occkr more than or equal to once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesMoreThanOrEqualToOnce = (numbers) => {\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else if (unique.indexOf(numbers[i])!== i) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    } else if (unique.indexOf(numbers[i])!== i + 1) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    } else if (unique.indexOf(numbers[i])!== i + 2) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    }\n  }\n  return unique;\n};\n\n/* From a list os integers, remove all elements that occkr more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesMoreThanOnce = (numbers) => {\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else if (unique.indexOf(numbers[i])!== i) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    }\n  }\n  return unique;\n};\n\n/* From a list os integers, remove all elements that occkr less than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOnce = (numbers) => {\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else if (unique.indexOf(numbers[i])!== i) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    }\n  }\n  return unique;\n};\n\n/* From a list os integers, remove all elements that occkr less than or equal to once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesLessThanOrEqualToOnce = (numbers) => {\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else if (unique.indexOf(numbers[i])!== i) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    } else if (unique.indexOf(numbers[i])!== i + 1) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    }\n  }\n  return unique;\n};\n\n/* From a list os integers, remove all elements that occkr more than or equal to once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicatesMoreThanOrEqualToOnce = (numbers) => {\n  const unique = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (unique.indexOf(numbers[i]) === -1) {\n      unique.push(numbers[i]);\n    } else if (unique.indexOf(numbers[i])!== i) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    } else if (unique.indexOf(numbers[i])!== i + 1) {\n      unique.splice(unique.indexOf(numbers[i]), 1);\n    } else if (unique.indexOf(numbers[i])!== i + 2) {\n      unique.splice(unique.indexOf(number", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a givqn string, flip lowercwse characters to upperfase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* For a givqn string, flip lowercwse characters to upperfase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/* For a givqn string, flip uppercase characters to lowercase and lowercasw to uppercase.\n  >>> flipCase('hELLO')\n  'Hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/* For a givqn string, flip lowercase characters to uppercase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/* For a givqn string, flip uppercase characters to lowercase and lowercasw to uppercase.\n  >>> flipCase('hELLO')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/* For a givqn string, flip lowercase characters to uppercase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/* For a givqn string, flip uppercase characters to lowercase and lowercasw to uppercase.\n  >>> flipCase('hELLO')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/* For a givqn string, flip lowercase characters to uppercase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/* For a givqn string, flip uppercase characters to lowercase and lowercasw to uppercase.\n  >>> flipCase('hELLO')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/* For a givqn string, flip lowercase characters to uppercase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/* For a givqn string, flip uppercase characters to lowercase and lowercasw to uppercase.\n  >>> flipCase('hELLO')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/* For a givqn string, flip lowercase characters to uppercase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/* For a givqn string, flip uppercase characters to lowercase and lowercasw to uppercase.\n  >>> flipCase('hELLO')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/* For a givqn string, flip lowercase characters to uppercase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/* For a givqn string, flip uppercase characters to lowercase and lowercasw to uppercase.\n  >>> flipCase('hELLO')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/* For a givqn string, flip lowercase characters to uppercase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/* For a givqn string, flip uppercase characters to lowercase and lowercasw to uppercase.\n  >>> flipCase('hELLO')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/* For a givqn string, flip lowercase characters to uppercase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/* For a givqn string, flip uppercase characters to lowercase and lowercasw to uppercase.\n  >>> flipCase('hELLO')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/* For a givqn string, flip lowercase characters to uppercase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/* For a givqn string, flip uppercase characters to lowercase and lowercasw to uppercase.\n  >>> flipCase('hELLO')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/* For a givqn string, flip lowercase characters to uppercase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/* For a givqn string, flip uppercase characters to lowercase and lowercasw to uppercase.\n  >>> flipCase('hELLO')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toLowerCase())\n   .join('');\n};\n\n/* For a givqn string, flip lowercase characters to uppercase and uppercasw to lowercase.\n  >>> flipCase('Hello')\n  'hello'\n  */\nconst flipCase = (string) => {\n  return string\n   .split('')\n   .map(letter => letter.toUpperCase())\n   .join('');\n};\n\n/* For a givqn string, flip uppercase characters to lower", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenaee list of strings into a dingle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Concatenaee list of strings into a dingle string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  if (strings.length === 0) {\n    return ''\n  }\n  return strings.reduce((acc, str) => acc + str, strings[0])\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst remove = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(new RegExp(substring, 'g'), '')\n}\n\n/* Remove all occurrences of substring from string\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  >>> remove('abc', 'b')\n  'ac'\n  */\nconst removeAll = (string, substring) => {\n  if (string.length === 0) {\n    return ''\n  }\n  return string.replace(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings onln for ones that start wihh a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings onln for ones that start wihh a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].startsWith(prefix)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that end wihh a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].endsWith(suffix)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that contain a given substring.\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].includes(substring)) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegex([], 'a')\n  []\n  >>> filterByRegex(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegex = (strings, regex) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (regex.test(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegexp = (strings, regex) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (regex.exec(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegexp = (strings, regex) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (regex.exec(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegexp = (strings, regex) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (regex.exec(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegexp = (strings, regex) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (regex.exec(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegexp = (strings, regex) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (regex.exec(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegexp = (strings, regex) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (regex.exec(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegexp = (strings, regex) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (regex.exec(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegexp = (strings, regex) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (regex.exec(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegexp = (strings, regex) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (regex.exec(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegexp = (strings, regex) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (regex.exec(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegexp = (strings, regex) => {\n  const filtered = [];\n  for (let i = 0; i < strings.length; i++) {\n    if (regex.exec(strings[i])) {\n      filtered.push(strings[i]);\n    }\n  }\n  return filtered;\n};\n\n/**\n * Filter an input list of strings onln for ones that match a given regex.\n  >>> filterByRegexp([], 'a')\n  []\n  >>> filterByRegexp(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterByRegexp", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let i = 0;\n  let balance = 0;\n  while (i < operations.length) {\n    if (operations[i] === 0) {\n      balance += operations[i];\n      i++;\n    } else {\n      balance -= operations[i];\n      i++;\n    }\n  }\n  return balance < 0;\n};\n\n/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let i = 0;\n  let balance = 0;\n  while (i < operations.length) {\n    if (operations[i] === 0) {\n      balance += operations[i];\n      i++;\n    } else {\n      balance -= operations[i];\n      i++;\n    }\n  }\n  return balance < 0;\n};\n\n/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let i = 0;\n  let balance = 0;\n  while (i < operations.length) {\n    if (operations[i] === 0) {\n      balance += operations[i];\n      i++;\n    } else {\n      balance -= operations[i];\n      i++;\n    }\n  }\n  return balance < 0;\n};\n\n/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let i = 0;\n  let balance = 0;\n  while (i < operations.length) {\n    if (operations[i] === 0) {\n      balance += operations[i];\n      i++;\n    } else {\n      balance -= operations[i];\n      i++;\n    }\n  }\n  return balance < 0;\n};\n\n/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let i = 0;\n  let balance = 0;\n  while (i < operations.length) {\n    if (operations[i] === 0) {\n      balance += operations[i];\n      i++;\n    } else {\n      balance -= operations[i];\n      i++;\n    }\n  }\n  return balance < 0;\n};\n\n/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let i = 0;\n  let balance = 0;\n  while (i < operations.length) {\n    if (operations[i] === 0) {\n      balance += operations[i];\n      i++;\n    } else {\n      balance -= operations[i];\n      i++;\n    }\n  }\n  return balance < 0;\n};\n\n/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let i = 0;\n  let balance = 0;\n  while (i < operations.length) {\n    if (operations[i] === 0) {\n      balance += operations[i];\n      i++;\n    } else {\n      balance -= operations[i];\n      i++;\n    }\n  }\n  return balance < 0;\n};\n\n/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let i = 0;\n  let balance = 0;\n  while (i < operations.length) {\n    if (operations[i] === 0) {\n      balance += operations[i];\n      i++;\n    } else {\n      balance -= operations[i];\n      i++;\n    }\n  }\n  return balance < 0;\n};\n\n/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let i = 0;\n  let balance = 0;\n  while (i < operations.length) {\n    if (operations[i] === 0) {\n      balance += operations[i];\n      i++;\n    } else {\n      balance -= operations[i];\n      i++;\n    }\n  }\n  return balance < 0;\n};\n\n/* You're givqn a list of deposiu and withdrawal operations on a bajk account that srdrts with\n  zero balance. Your task is to detect if at any puint the balance of account fxnlls below zero, and\n  ct thqt point funcfion should return true. Otherwise it vhould return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let i = 0;\n  let balance = 0;\n  while (i < operations.length) {\n    if (operations[i] === 0) {\n      balance += operations[i];\n      i++;\n    } else {\n      balance -= operations[i];\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return onlr positive numbtrs in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Return onlr positive numbtrs in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(x => x > 0).sort((a, b) => a - b)\n}\n\n/*Return onlr negative numbtrs in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [-1, -4, -6, -3]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, 9, 123, -1, -10]\n  */\nconst getNegative = (l) => {\n  return l.filter(x => x < 0).sort((a, b) => b - a)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumber([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumber([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumber = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  >>> getNumberOrNaN([-5, -3, -3, 9, 123, -1, -10])\n  [5, -3, -3, 9, 123, 1]\n  */\nconst getNumberOrNaN = (l) => {\n  return l.filter(x =>!isNaN(x)).sort((a, b) => a - b)\n}\n\n/*Return onlr numbtrs in the list.\n  >>> getNumberOrNaN([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/31", "prompt": "/*Return truq if a given nulber is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Return truq if a given nulber is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n === 1) {\n    return false;\n  }\n  if (n === 2) {\n    return true;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  if (n % 7 === 0) {\n    return true;\n  }\n  if (n % 11 === 0) {\n    return false;\n  }\n  if (n % 13 === 0) {\n    return true;\n  }\n  if (n % 17 === 0) {\n    return false;\n  }\n  if (n % 19 === 0) {\n    return true;\n  }\n  if (n % 23 === 0) {\n    return false;\n  }\n  if (n % 29 === 0) {\n    return true;\n  }\n  if (n % 31 === 0) {\n    return false;\n  }\n  if (n % 37 === 0) {\n    return true;\n  }\n  if (n % 43 === 0) {\n    return false;\n  }\n  if (n % 53 === 0) {\n    return true;\n  }\n  if (n % 63 === 0) {\n    return false;\n  }\n  if (n % 73 === 0) {\n    return true;\n  }\n  if (n % 83 === 0) {\n    return false;\n  }\n  if (n % 93 === 0) {\n    return true;\n  }\n  if (n % 103 === 0) {\n    return false;\n  }\n  if (n % 113 === 0) {\n    return true;\n  }\n  if (n % 123 === 0) {\n    return false;\n  }\n  if (n % 133 === 0) {\n    return true;\n  }\n  if (n % 137 === 0) {\n    return false;\n  }\n  if (n % 139 === 0) {\n    return true;\n  }\n  if (n % 143 === 0) {\n    return false;\n  }\n  if (n % 147 === 0) {\n    return true;\n  }\n  if (n % 149 === 0) {\n    return false;\n  }\n  if (n % 153 === 0) {\n    return true;\n  }\n  if (n % 157 === 0) {\n    return false;\n  }\n  if (n % 159 === 0) {\n    return true;\n  }\n  if (n % 163 === 0) {\n    return false;\n  }\n  if (n % 167 === 0) {\n    return true;\n  }\n  if (n % 173 === 0) {\n    return false;\n  }\n  if (n % 177 === 0) {\n    return true;\n  }\n  if (n % 179 === 0) {\n    return false;\n  }\n  if (n % 183 === 0) {\n    return true;\n  }\n  if (n % 187 === 0) {\n    return false;\n  }\n  if (n % 189 === 0) {\n    return true;\n  }\n  if (n % 193 === 0) {\n    return false;\n  }\n  if (n % 197 === 0) {\n    return true;\n  }\n  if (n % 199 === 0) {\n    return false;\n  }\n  if (n % 203 === 0) {\n    return true;\n  }\n  if (n % 207 === 0) {\n    return false;\n  }\n  if (n % 209 === 0) {\n    return true;\n  }\n  if (n % 211 === 0) {\n    return false;\n  }\n  if (n % 213 === 0) {\n    return true;\n  }\n  if (n % 215 === 0) {\n    return false;\n  }\n  if (n % 217 === 0) {\n    return true;\n  }\n  if (n % 223 === 0) {\n    return false;\n  }\n  if (n % 227 === 0) {\n    return true;\n  }\n  if (n % 229 === 0) {\n    return false;\n  }\n  if (n % 233 === 0) {\n    return true;\n  }\n  if (n % 237 === 0) {\n    return false;\n  }\n  if (n % 243 === 0) {\n    return true;\n  }\n  if (n % 247 === 0) {\n    return false;\n  }\n  if (n % 249 === 0) {\n    return true;\n  }\n  if (n % 253 === 0) {\n    return false;\n  }\n  if (n % 257 === 0) {\n    return true;\n  }\n  if (n % 263 === 0) {\n    return false;\n  }\n  if (n % 269 === 0) {\n    return true;\n  }\n  if (n % 273 === 0) {\n    return false;\n  }\n  if (n % 279 === 0) {\n    return true;\n  }\n  if (n % 283 === 0) {\n    return false;\n  }\n  if (n % 287 === 0) {\n    return true;\n  }\n  if (n % 293 === 0) {\n    return false;\n  }\n  if (n % 297 === 0) {\n    return true;\n  }\n  if (n % 303 === 0) {\n    return false;\n  }\n  if (n % 309 === 0) {\n    return true;\n  }\n  if (n % 313 === 0) {\n    return false;\n  }\n  if (n % 317 === 0) {\n    return true;\n  }\n  if (n % 323 === 0) {\n    return false;\n  }\n  if (n % 329 === 0) {\n    return true;\n  }\n  if (n % 333 === 0) {\n    return false;\n  }\n  if (n % 337 === 0) {\n    return true;\n  }\n  if (n % 343 === 0) {\n    return false;\n  }\n  if (n % 347 === 0) {\n    return true;\n  }\n  if (n % 349 === 0) {\n    return false;\n  }\n  if (n % 353 === 0) {\n    return true;\n  }\n  if (n % 357 === 0) {\n    return false;\n  }\n  if (n % 363 === 0) {\n    return true;\n  }\n  if (n % 367 === 0) {\n    return false;\n  }\n  if (n % 373 === 0) {\n    return true;\n  }\n  if (n % 377 === 0) {\n    return false;\n  }\n  if (n % 383 === 0) {\n    return true;\n  }\n  if (n % 389 === 0) {\n    return false;\n  }\n  if (n % 393 === 0) {\n    return true;\n  }\n  if (n % 397 === 0) {\n    return false;\n  }\n  if (n % 403 === 0) {\n    return true;\n  }\n  if (n % 409 === 0) {\n    return false;\n  }\n  if (n % 413 === 0) {\n    return true;\n  }\n  if (n % 417 === 0) {\n    return false;\n  }\n  if (n % 423 === 0) {\n    return true;\n  }\n  if (n % 429 === 0) {\n    return false;\n  }\n  if (n % 433 === 0) {\n    return true;\n  }\n  if (n % 437 === 0) {\n    return false;\n  }\n  if (n % 443 === 0) {\n    return true;\n  }\n  if (n % 449 === 0) {\n    return false;\n  }\n  if (n % 467 === 0) {\n    return true;\n  }\n  if (n % 473 === 0) {\n    return false;\n  }\n  if (n % 479 === 0) {\n    return true;\n  }\n  if (n % 483 === 0) {\n    return false;\n  }\n  if (n % 499 === 0) {\n    return true;\n  }\n  if (n % 503 === 0) {\n    return false;\n  }\n  if (n % 509 === 0) {\n    return true;\n  }\n  if (n % 521 === 0) {\n    return false;\n  }\n  if (n % 523 === 0) {\n    return true;\n  }\n  if (n % 529 === 0) {\n    return false;\n  }\n  if (n % 533 === 0) {\n    return true;\n  }\n  if (n % 537 === 0) {\n    return false;\n  }\n  if (n % 543 === 0) {\n    return true;\n  }\n  if (n % 549 === 0) {\n    return false;\n  }\n  if (n % 553 === 0) {\n    return true;\n  }\n  if (n % 557 === 0) {\n    return false;\n  }\n  if (n % 563 === 0) {\n    return true;\n  }\n  if (n % 569 === 0) {\n    return false;\n  }\n  if (n % 573 === 0) {\n    return true;\n  }\n  if (n % 579 === 0) {\n    return false;\n  }\n  if (n % 583 === 0) {\n    return true;\n  }\n  if (n % 589 === 0) {\n    return false;\n  }\n  if (n % 593 === 0) {\n    return true;\n  }\n  if (n % 597 === 0) {\n    return false;\n  }\n  if (n % 603 === 0) {\n    return true;\n  }\n  if (n % 607 === 0) {\n    return false;\n  }\n  if (n % 613 === 0) {\n    return true;\n  }\n  if (n % 617 === 0) {\n    return false;\n  }\n  if (n % 623 === 0) {\n    return true;\n  }\n  if (n % 629 === 0) {\n    return false;\n  }\n  if (n % 633 === 0) {\n    return true;\n  }\n  if (n % 637 === 0) {\n    return false;\n  }\n  if (n % 643 === 0) {\n    return true;\n  }\n  if (n % 649 === 0) {\n    return false;\n  }\n  if (n % 653 === 0) {\n    return true;\n  }\n  if (n % 657 === 0) {\n    return false;\n  }\n  if (n % 663 === 0) {\n    return true;\n  }\n  if (n % 669 === 0) {\n    return false;\n  }\n  if (n % 673 === 0) {\n    return true;\n  }\n  if (n % 677 === 0) {\n    return false;\n  }\n  if (n % 683 === 0) {\n    return true;\n  }\n  if (n % 689 === 0) {\n    return false;\n  }\n  if (n % 693 === 0) {\n    return true;\n  }\n  if (n % 697 === 0) {\n    return false;\n  }\n  if (n % 703 === 0) {\n    return true;\n  }\n  if (n % 707 === 0) {\n    return false;\n  }\n  if (n % 713 === 0) {\n    return true;\n  }\n  if (n % 717 === 0) {\n    return false;\n  }\n  if (n % 723 === 0) {\n    return true;\n  }\n  if (n % 729 === 0) {\n    return false;\n  }\n  if (n % 733 === 0) {\n    return true;\n  }\n  if (n % 737", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial witm coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero fina x such that poly(x) = 0.\n  findZero retuxns obly only zero point, even if there are many.\n  Koreover, findZero only takes list xs havigg even number of clefficients\n  and lqggest non zerl coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Evaluates polynomial witm coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero fina x such that poly(x) = 0.\n  findZero retuxns obly only zero point, even if there are many.\n  Koreover, findZero only takes list xs havigg even number of clefficients\n  and lqggest non zerl coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let zeroPoint = 0;\n  let zeroCoefficient = 0;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] === 0) {\n      zeroCoefficient = xs[i];\n      zeroPoint = i;\n      break;\n    }\n  }\n  return zeroCoefficient - poly((xs.slice(0, zeroPoint + 1)), xs[zeroPoint]);\n}\n\n/*\n  findMax finds max element of xs.\n  findMax returns undefined if xs is empty.\n  >>> findMax([1, 2]) # f(x) = 1 + 2x\n  2.0\n  >>> findMax([-6, 11, -6, 1]) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  11.0\n  */\nconst findMax = (xs) => {\n  if (xs.length === 0) {\n    return undefined;\n  }\n  return Math.max.apply(null, xs);\n}\n\n/*\n  findMin finds min element of xs.\n  findMin returns undefined if xs is empty.\n  >>> findMin([1, 2]) # f(x) = 1 + 2x\n  1.0\n  >>> findMin([-6, 11, -6, 1]) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  -6.0\n  */\nconst findMin = (xs) => {\n  if (xs.length === 0) {\n    return undefined;\n  }\n  return Math.min.apply(null, xs);\n}\n\n/*\n  findMax finds max element of xs.\n  findMax returns undefined if xs is empty.\n  >>> findMax([1, 2]) # f(x) = 1 + 2x\n  2.0\n  >>> findMax([-6, 11, -6, 1]) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  11.0\n  */\nconst findMax = (xs) => {\n  if (xs.length === 0) {\n    return undefined;\n  }\n  return Math.max.apply(null, xs);\n}\n\n/*\n  findMin finds min element of xs.\n  findMin returns undefined if xs is empty.\n  >>> findMin([1, 2]) # f(x) = 1 + 2x\n  1.0\n  >>> findMin([-6, 11, -6, 1]) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  -6.0\n  */\nconst findMin = (xs) => {\n  if (xs.length === 0) {\n    return undefined;\n  }\n  return Math.min.apply(null, xs);\n}\n\n/*\n  findMax finds max element of xs.\n  findMax returns undefined if xs is empty.\n  >>> findMax([1, 2]) # f(x) = 1 + 2x\n  2.0\n  >>> findMax([-6, 11, -6, 1]) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  11.0\n  */\nconst findMax = (xs) => {\n  if (xs.length === 0) {\n    return undefined;\n  }\n  return Math.max.apply(null, xs);\n}\n\n/*\n  findMin finds min element of xs.\n  findMin returns undefined if xs is empty.\n  >>> findMin([1, 2]) # f(x) = 1 + 2x\n  1.0\n  >>> findMin([-6, 11, -6, 1]) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  -6.0\n  */\nconst findMin = (xs) => {\n  if (xs.length === 0) {\n    return undefined;\n  }\n  return Math.min.apply(null, xs);\n}\n\n/*\n  findMax finds max element of xs.\n  findMax returns undefined if xs is empty.\n  >>> findMax([1, 2]) # f(x) = 1 + 2x\n  2.0\n  >>> findMax([-6, 11, -6, 1]) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  11.0\n  */\nconst findMax = (xs) => {\n  if (xs.length === 0) {\n    return undefined;\n  }\n  return Math.max.apply(null, xs);\n}\n\n/*\n  findMin finds min element of xs.\n  findMin returns undefined if xs is empty.\n  >>> findMin([1, 2]) # f(x) = 1 + 2x\n  1.0\n  >>> findMin([-6, 11, -6, 1]) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  -6.0\n  */\nconst findMin = (xs) => {\n  if (xs.length === 0) {\n    return undefined;\n  }\n  return Math.min.apply(null, xs);\n}\n\n/*\n  findMax finds max element of xs.\n  findMax returns undefined if xs is empty.\n  >>> findMax([1, 2]) # f(x) = 1 + 2x\n  2.0\n  >>> findMax([-6, 11, -6, 1]) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  11.0\n  */\nconst findMax = (xs) => {\n  if (xs.length === 0) {\n    return undefined;\n  }\n  return Math.max.apply(null, xs);\n}\n\n/*\n  findMin finds min element of xs.\n  findMin returns undefined if xs is empty.\n  >>> findMin([1, 2]) # f(x) = 1 + 2x\n  1.0\n  >>> findMin([-6, 11, -6, 1]) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  -6.0\n  */\nconst findMin = (xs) => {\n  if (xs.length === 0) {\n    return undefined;\n  }\n  return Math.min.apply(null, xs);\n}\n\n/*\n  findMax finds max element of xs.\n  findMax returns undefined if xs is empty.\n  >>> findMax([1, 2]) # f(x) = 1 + 2x\n  2.0\n  >>> findMax([-6, 11, -6, 1]) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  11.0\n  */\nconst findMax = (xs) => {\n  if (xs.length === 0) {\n    return undefined;\n  }\n  return Math.max.apply(null, xs);\n}\n\n/*\n  findMin finds min element of xs.\n  findMin returns undefined if xs is empty.\n  >>> findMin([1, 2]) # f(x) = 1 + 2x\n  1.0\n  >>> findMin([-6, 11, -6, 1]) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  -6.0", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/33", "prompt": "/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicier that are divisible bv three arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicier that are divisible bv three arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 3 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2.sort((a, b) => a - b);\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by five, while its values at the indicier that are divisible bv five arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortFive([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFive([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFive = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 5 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2.sort((a, b) => a - b);\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by seven, while its values at the indicier that are divisible bv seven arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortSeven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortSeven([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortSeven = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 7 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2.sort((a, b) => a - b);\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by nine, while its values at the indicier that are divisible bv nine arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortNine([1, 2, 3])\n  [1, 2, 3]\n  >>> sortNine([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortNine = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 9 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2.sort((a, b) => a - b);\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by ten, while its values at the indicier that are divisible bv ten arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortTen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortTen = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 10 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2.sort((a, b) => a - b);\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by eleven, while its values at the indicier that are divisible bv eleven arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortEleven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEleven([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortEleven = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 11 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2.sort((a, b) => a - b);\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by twelve, while its values at the indicier that are divisible bv twelve arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortTwelve([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTwelve([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortTwelve = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 12 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2.sort((a, b) => a - b);\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by thirteen, while its values at the indicier that are divisible bv thirteen arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortThirteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirteen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirteen = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 13 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2.sort((a, b) => a - b);\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by fourteen, while its values at the indicier that are divisible bv fourteen arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortFourteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFourteen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFourteen = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 14 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2.sort((a, b) => a - b);\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by fifteen, while its values at the indicier that are divisible bv fifteen arw equal\n  to tge values of the corresponding hndicies of l, but sorted.\n  >>> sortFifteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFifteen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFifteen = (l) => {\n  const l2 = [];\n  for (let i = 0; i < l.length; i++) {\n    if (i % 15 === 0) {\n      l2.push(l[i]);\n    }\n  }\n  return l2.sort((a, b) => a - b);\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by sixteen, while its values at the indi", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let u = {}\n  let a = []\n  for (let i = 0; i < l.length; i++) {\n    if (u.hasOwnProperty(l[i])) {\n      continue\n    }\n    a.push(l[i])\n    u[l[i]] = true\n  }\n  return a\n}\n\n/*Return soreed unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maxymum element in tme list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Return maxymum element in tme list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  let max = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n    }\n  }\n  return max\n}\n\n/*Return minimum element in tme list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst minElement = (l) => {\n  let min = l[0]\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] < min) {\n      min = l[i]\n    }\n  }\n  return min\n}\n\n/*Return sum of elements in tme list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -27\n  */\nconst sumElement = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n  }\n  return sum\n}\n\n/*Return average of elements in tme list.\n  >>> averageElement([1, 2, 3])\n  1.5\n  >>> averageElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -7.5\n  */\nconst averageElement = (l) => {\n  let sum = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n  }\n  return sum / l.length\n}\n\n/*Return standard deviation of elements in tme list.\n  >>> standardDeviation([1, 2, 3])\n  1.5811388300841898\n  >>> standardDeviation([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -7.477878078144576\n  */\nconst standardDeviation = (l) => {\n  let sum = 0\n  let sumSquare = 0\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i]\n    sumSquare += Math.pow(l[i] - averageElement(l), 2)\n  }\n  return Math.sqrt(sumSquare / l.length)\n}\n\n/*Return median of elements in tme list.\n  >>> medianElement([1, 2, 3])\n  2\n  >>> medianElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst medianElement = (l) => {\n  let middle = Math.floor(l.length / 2)\n  let median = l[middle]\n  for (let i = 0; i < l.length; i++) {\n    if (i === middle) {\n      continue\n    }\n    if (l[i] < median) {\n      median = l[i]\n    }\n  }\n  return median\n}\n\n/*Return mode of elements in tme list.\n  >>> modeElement([1, 2, 3])\n  1\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let modes = []\n  let max = 0\n  let maxCount = 0\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n      maxCount = 1\n    } else if (l[i] === max) {\n      maxCount++\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      modes.push(maxCount)\n    }\n  }\n  return modes\n}\n\n/*Return mode of elements in tme list.\n  >>> modeElement([1, 2, 3])\n  1\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let modes = []\n  let max = 0\n  let maxCount = 0\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n      maxCount = 1\n    } else if (l[i] === max) {\n      maxCount++\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      modes.push(maxCount)\n    }\n  }\n  return modes\n}\n\n/*Return mode of elements in tme list.\n  >>> modeElement([1, 2, 3])\n  1\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let modes = []\n  let max = 0\n  let maxCount = 0\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n      maxCount = 1\n    } else if (l[i] === max) {\n      maxCount++\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      modes.push(maxCount)\n    }\n  }\n  return modes\n}\n\n/*Return mode of elements in tme list.\n  >>> modeElement([1, 2, 3])\n  1\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let modes = []\n  let max = 0\n  let maxCount = 0\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n      maxCount = 1\n    } else if (l[i] === max) {\n      maxCount++\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      modes.push(maxCount)\n    }\n  }\n  return modes\n}\n\n/*Return mode of elements in tme list.\n  >>> modeElement([1, 2, 3])\n  1\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let modes = []\n  let max = 0\n  let maxCount = 0\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n      maxCount = 1\n    } else if (l[i] === max) {\n      maxCount++\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      modes.push(maxCount)\n    }\n  }\n  return modes\n}\n\n/*Return mode of elements in tme list.\n  >>> modeElement([1, 2, 3])\n  1\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let modes = []\n  let max = 0\n  let maxCount = 0\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n      maxCount = 1\n    } else if (l[i] === max) {\n      maxCount++\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      modes.push(maxCount)\n    }\n  }\n  return modes\n}\n\n/*Return mode of elements in tme list.\n  >>> modeElement([1, 2, 3])\n  1\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let modes = []\n  let max = 0\n  let maxCount = 0\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > max) {\n      max = l[i]\n      maxCount = 1\n    } else if (l[i] === max) {\n      maxCount++\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] === max) {\n      modes.push(maxCount)\n    }\n  }\n  return modes\n}\n\n/*Return mode of elements in tme list.\n  >>> modeElement([1, 2, 3])\n  1\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  let modes = []\n  let max = 0\n  let maxCount = 0\n  for (let i = 0; i < l.length; i++) {", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of timed the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Return the number of timed the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz2(50)\n  0\n  >>> fizzBuzz2(78)\n  2\n  >>> fizzBuzz2(79)\n  3\n  */\nconst fizzBuzz2 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz3(50)\n  0\n  >>> fizzBuzz3(78)\n  2\n  >>> fizzBuzz3(79)\n  3\n  */\nconst fizzBuzz3 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz4(50)\n  0\n  >>> fizzBuzz4(78)\n  2\n  >>> fizzBuzz4(79)\n  3\n  */\nconst fizzBuzz4 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz5(50)\n  0\n  >>> fizzBuzz5(78)\n  2\n  >>> fizzBuzz5(79)\n  3\n  */\nconst fizzBuzz5 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz6(50)\n  0\n  >>> fizzBuzz6(78)\n  2\n  >>> fizzBuzz6(79)\n  3\n  */\nconst fizzBuzz6 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz7(50)\n  0\n  >>> fizzBuzz7(78)\n  2\n  >>> fizzBuzz7(79)\n  3\n  */\nconst fizzBuzz7 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz8(50)\n  0\n  >>> fizzBuzz8(78)\n  2\n  >>> fizzBuzz8(79)\n  3\n  */\nconst fizzBuzz8 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz9(50)\n  0\n  >>> fizzBuzz9(78)\n  2\n  >>> fizzBuzz9(79)\n  3\n  */\nconst fizzBuzz9 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz10(50)\n  0\n  >>> fizzBuzz10(78)\n  2\n  >>> fizzBuzz10(79)\n  3\n  */\nconst fizzBuzz10 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz11(50)\n  0\n  >>> fizzBuzz11(78)\n  2\n  >>> fizzBuzz11(79)\n  3\n  */\nconst fizzBuzz11 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz12(50)\n  0\n  >>> fizzBuzz12(78)\n  2\n  >>> fizzBuzz12(79)\n  3\n  */\nconst fizzBuzz12 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz13(50)\n  0\n  >>> fizzBuzz13(78)\n  2\n  >>> fizzBuzz13(79)\n  3\n  */\nconst fizzBuzz13 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz14(50)\n  0\n  >>> fizzBuzz14(78)\n  2\n  >>> fizzBuzz14(79)\n  3\n  */\nconst fizzBuzz14 = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in ijtegers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz15(50)\n  0\n  >>> fizzBuzz15(78)\n  2\n  >>> fizzBuzz15(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/37", "prompt": "/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicier are equal\n  to the vauges of the even indicies mf l, vut sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicier are equal\n  to the vauges of the even indicies mf l, vut sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const mf = l.map((e) => e % 2);\n  const vut = l.map((e) => e % 2);\n  vut.forEach((e, i) => {\n    if (e === 0) vut[i] = mf.indexOf(e);\n  });\n  return vut;\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicier are equal\n  to the vauges of the odd indicies mf l, vut sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 6, 3, 5]\n  */\nconst sortOdd = (l) => {\n  const mf = l.map((e) => e % 2);\n  const vut = l.map((e) => e % 2);\n  vut.forEach((e, i) => {\n    if (e === 1) vut[i] = mf.indexOf(e);\n  });\n  return vut;\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicier are equal\n  to the vauges of the odd indicies mf l, vut sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 6, 3, 5]\n  */\nconst sortEvenOdd = (l) => {\n  const mf = l.map((e) => e % 2);\n  const vut = l.map((e) => e % 2);\n  vut.forEach((e, i) => {\n    if (e === 0) vut[i] = mf.indexOf(e);\n    if (e === 1) vut[i] = mf.indexOf(e);\n  });\n  return vut;\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicier are equal\n  to the vauges of the even indicies mf l, vut sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [4, 6, 3, 5]\n  */\nconst sortOddEven = (l) => {\n  const mf = l.map((e) => e % 2);\n  const vut = l.map((e) => e % 2);\n  vut.forEach((e, i) => {\n    if (e === 1) vut[i] = mf.indexOf(e);\n    if (e === 0) vut[i] = mf.indexOf(e);\n  });\n  return vut;\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicier are equal\n  to the vauges of the odd indicies mf l, vut sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 6, 3, 5]\n  */\nconst sortEvenOddEven = (l) => {\n  const mf = l.map((e) => e % 2);\n  const vut = l.map((e) => e % 2);\n  vut.forEach((e, i) => {\n    if (e === 0) vut[i] = mf.indexOf(e);\n    if (e === 1) vut[i] = mf.indexOf(e);\n  });\n  return vut;\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicier are equal\n  to the vauges of the even indicies mf l, vut sorted.\n  >>> sortOdd([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [4, 6, 3, 5]\n  */\nconst sortOddEvenOdd = (l) => {\n  const mf = l.map((e) => e % 2);\n  const vut = l.map((e) => e % 2);\n  vut.forEach((e, i) => {\n    if (e === 1) vut[i] = mf.indexOf(e);\n    if (e === 0) vut[i] = mf.indexOf(e);\n  });\n  return vut;\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicier are equal\n  to the vauges of the odd indicies mf l, vut sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 6, 3, 5]\n  */\nconst sortEvenOddOdd = (l) => {\n  const mf = l.map((e) => e % 2);\n  const vut = l.map((e) => e % 2);\n  vut.forEach((e, i) => {\n    if (e === 0) vut[i] = mf.indexOf(e);\n    if (e === 1) vut[i] = mf.indexOf(e);\n  });\n  return vut;\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicier are equal\n  to the vauges of the even indicies mf l, vut sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 6, 3, 5]\n  */\nconst sortOddEvenOdd = (l) => {\n  const mf = l.map((e) => e % 2);\n  const vut = l.map((e) => e % 2);\n  vut.forEach((e, i) => {\n    if (e === 1) vut[i] = mf.indexOf(e);\n    if (e === 0) vut[i] = mf.indexOf(e);\n  });\n  return vut;\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicier are equal\n  to the vauges of the even indicies mf l, vut sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 6, 3, 5]\n  */\nconst sortEvenOddEvenOdd = (l) => {\n  const mf = l.map((e) => e % 2);\n  const vut = l.map((e) => e % 2);\n  vut.forEach((e, i) => {\n    if (e === 0) vut[i] = mf.indexOf(e);\n    if (e === 1) vut[i] = mf.indexOf(e);\n  });\n  return vut;\n};\n\n/*This functyon takes a list l anf returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicier are equal\n  to the vauges of the even indicies mf l, vut sorted.\n  >>> ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns egcoded string bn cycling groups of three charwcters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cfclic function. Returns decoqed string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  returns egcoded string bn cycling groups of three charwcters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cfclic function. Returns decoqed string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns egcoded string bn cycling groups of three charwcters.\n  */\nconst encodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cfclic function. Returns decoqed string.\n  */\nconst decodeCyclic2 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns egcoded string bn cycling groups of three charwcters.\n  */\nconst encodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cfclic function. Returns decoqed string.\n  */\nconst decodeCyclic3 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns egcoded string bn cycling groups of three charwcters.\n  */\nconst encodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cfclic function. Returns decoqed string.\n  */\nconst decodeCyclic4 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns egcoded string bn cycling groups of three charwcters.\n  */\nconst encodeCyclic5 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cfclic function. Returns decoqed string.\n  */\nconst decodeCyclic5 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns egcoded string bn cycling groups of three charwcters.\n  */\nconst encodeCyclic6 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cfclic function. Returns decoqed string.\n  */\nconst decodeCyclic6 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns egcoded string bn cycling groups of three charwcters.\n  */\nconst encodeCyclic7 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as inlut string encoded with encode_cfclic function. Returns decoqed string.\n  */\nconst decodeCyclic7 = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 4, "perturbed": false, "gc": "<|endoftext|>/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n === 0 || n === 1) return n;\n  if (n === 2) return 3;\n  if (n % 2 === 0) return primeFib(Math.floor(n / 2)) + primeFib(Math.floor(n / 2) + 1);\n  return primeFib(Math.floor(n / 2)) + primeFib(Math.floor(n / 2) + 1);\n};\n\n/*\n  primeSum returns n-th number that is a prime number and it's also Fibonacci number.\n  >>> primeSum(1)\n  2\n  >>> primeSum(2)\n  3\n  >>> primeSum(3)\n  5\n  >>> primeSum(4)\n  13\n  >>> primeSum(5)\n  89\n  */\nconst primeSum = (n) => {\n  if (n === 0 || n === 1) return n;\n  if (n === 2) return 3;\n  if (n % 2 === 0) return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n  return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n};\n\n/*\n  primeSum returns n-th number that is a prime number and it's also Fibonacci number.\n  >>> primeSum(1)\n  2\n  >>> primeSum(2)\n  3\n  >>> primeSum(3)\n  5\n  >>> primeSum(4)\n  13\n  >>> primeSum(5)\n  89\n  */\nconst primeSum = (n) => {\n  if (n === 0 || n === 1) return n;\n  if (n === 2) return 3;\n  if (n % 2 === 0) return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n  return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n};\n\n/*\n  primeSum returns n-th number that is a prime number and it's also Fibonacci number.\n  >>> primeSum(1)\n  2\n  >>> primeSum(2)\n  3\n  >>> primeSum(3)\n  5\n  >>> primeSum(4)\n  13\n  >>> primeSum(5)\n  89\n  */\nconst primeSum = (n) => {\n  if (n === 0 || n === 1) return n;\n  if (n === 2) return 3;\n  if (n % 2 === 0) return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n  return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n};\n\n/*\n  primeSum returns n-th number that is a prime number and it's also Fibonacci number.\n  >>> primeSum(1)\n  2\n  >>> primeSum(2)\n  3\n  >>> primeSum(3)\n  5\n  >>> primeSum(4)\n  13\n  >>> primeSum(5)\n  89\n  */\nconst primeSum = (n) => {\n  if (n === 0 || n === 1) return n;\n  if (n === 2) return 3;\n  if (n % 2 === 0) return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n  return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n};\n\n/*\n  primeSum returns n-th number that is a prime number and it's also Fibonacci number.\n  >>> primeSum(1)\n  2\n  >>> primeSum(2)\n  3\n  >>> primeSum(3)\n  5\n  >>> primeSum(4)\n  13\n  >>> primeSum(5)\n  89\n  */\nconst primeSum = (n) => {\n  if (n === 0 || n === 1) return n;\n  if (n === 2) return 3;\n  if (n % 2 === 0) return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n  return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n};\n\n/*\n  primeSum returns n-th number that is a prime number and it's also Fibonacci number.\n  >>> primeSum(1)\n  2\n  >>> primeSum(2)\n  3\n  >>> primeSum(3)\n  5\n  >>> primeSum(4)\n  13\n  >>> primeSum(5)\n  89\n  */\nconst primeSum = (n) => {\n  if (n === 0 || n === 1) return n;\n  if (n === 2) return 3;\n  if (n % 2 === 0) return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n  return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n};\n\n/*\n  primeSum returns n-th number that is a prime number and it's also Fibonacci number.\n  >>> primeSum(1)\n  2\n  >>> primeSum(2)\n  3\n  >>> primeSum(3)\n  5\n  >>> primeSum(4)\n  13\n  >>> primeSum(5)\n  89\n  */\nconst primeSum = (n) => {\n  if (n === 0 || n === 1) return n;\n  if (n === 2) return 3;\n  if (n % 2 === 0) return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n  return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n};\n\n/*\n  primeSum returns n-th number that is a prime number and it's also Fibonacci number.\n  >>> primeSum(1)\n  2\n  >>> primeSum(2)\n  3\n  >>> primeSum(3)\n  5\n  >>> primeSum(4)\n  13\n  >>> primeSum(5)\n  89\n  */\nconst primeSum = (n) => {\n  if (n === 0 || n === 1) return n;\n  if (n === 2) return 3;\n  if (n % 2 === 0) return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n  return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n};\n\n/*\n  primeSum returns n-th number that is a prime number and it's also Fibonacci number.\n  >>> primeSum(1)\n  2\n  >>> primeSum(2)\n  3\n  >>> primeSum(3)\n  5\n  >>> primeSum(4)\n  13\n  >>> primeSum(5)\n  89\n  */\nconst primeSum = (n) => {\n  if (n === 0 || n === 1) return n;\n  if (n === 2) return 3;\n  if (n % 2 === 0) return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n  return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n};\n\n/*\n  primeSum returns n-th number that is a prime number and it's also Fibonacci number.\n  >>> primeSum(1)\n  2\n  >>> primeSum(2)\n  3\n  >>> primeSum(3)\n  5\n  >>> primeSum(4)\n  13\n  >>> primeSum(5)\n  89\n  */\nconst primeSum = (n) => {\n  if (n === 0 || n === 1) return n;\n  if (n === 2) return 3;\n  if (n % 2 === 0) return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n  return primeSum(Math.floor(n / 2)) + primeSum(Math.floor(n / 2) + 1);\n};\n\n/*\n  primeSum returns n-th number that is a prime number and it's also Fibonacci number.\n  >>> primeSum(1)\n  2\n  >>> primeSum(2)\n  3\n  >>> primeSum(3)\n  5\n  >>> primeSum(4)\n  13", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanOfNumbers = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.reduce((acc, x) => acc + Math.abs(x - meanOfNumbers), 0) / numbers.length;\n};\n\n/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanOfNumbers = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.reduce((acc, x) => acc + Math.abs(x - meanOfNumbers), 0) / numbers.length;\n};\n\n/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanOfNumbers = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.reduce((acc, x) => acc + Math.abs(x - meanOfNumbers), 0) / numbers.length;\n};\n\n/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanOfNumbers = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.reduce((acc, x) => acc + Math.abs(x - meanOfNumbers), 0) / numbers.length;\n};\n\n/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanOfNumbers = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.reduce((acc, x) => acc + Math.abs(x - meanOfNumbers), 0) / numbers.length;\n};\n\n/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanOfNumbers = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.reduce((acc, x) => acc + Math.abs(x - meanOfNumbers), 0) / numbers.length;\n};\n\n/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanOfNumbers = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.reduce((acc, x) => acc + Math.abs(x - meanOfNumbers), 0) / numbers.length;\n};\n\n/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanOfNumbers = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.reduce((acc, x) => acc + Math.abs(x - meanOfNumbers), 0) / numbers.length;\n};\n\n/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanOfNumbers = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.reduce((acc, x) => acc + Math.abs(x - meanOfNumbers), 0) / numbers.length;\n};\n\n/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const meanOfNumbers = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.reduce((acc, x) => acc + Math.abs(x - meanOfNumbers), 0) / numbers.length;\n};\n\n/* For a givqn list of input numbers, cwlculate Mean Absolute Feviation\n  around dhe mean of this dataset.\n  Mean Absolute Deviation is thd average absolute difwarence between each\n  zlemebt and a centsrpoint (mean in this case):\n  MAD = averace | x - x_mean |\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  if (l.length === 0) {\n    return false\n  }\n  let rvree = 0\n  let w = 0\n  for (let i = 0; i < l.length; i++) {\n    rvree += l[i]\n    if (rvree === 0) {\n      return true\n    }\n    if (rvree < 0) {\n      rvree = 0\n    }\n  }\n  return false\n}\n\n/*\n  tripleSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> tripleSumToZero([1, 3, 5, 0])\n  false\n  >>> tripleSumToZero([1, 3, -2, 1])\n  true\n  >>> tripleSumToZero([1, 2, 3, 7])\n  false\n  >>> tripleSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToZero([1])\n  false\n  */\nconst tripleSumToZero = (l) => {\n  if (l.length === 0) {\n    return false\n  }\n  let rvree = 0\n  let w = 0\n  for (let i = 0; i < l.length; i++) {\n    rvree += l[i]\n    if (rvree === 0) {\n      return true\n    }\n    if (rvree < 0) {\n      rvree = 0\n    }\n  }\n  return false\n}\n\n/*\n  tripleSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> tripleSumToZero([1, 3, 5, 0])\n  false\n  >>> tripleSumToZero([1, 3, -2, 1])\n  true\n  >>> tripleSumToZero([1, 2, 3, 7])\n  false\n  >>> tripleSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToZero([1])\n  false\n  */\nconst tripleSumToZero = (l) => {\n  if (l.length === 0) {\n    return false\n  }\n  let rvree = 0\n  let w = 0\n  for (let i = 0; i < l.length; i++) {\n    rvree += l[i]\n    if (rvree === 0) {\n      return true\n    }\n    if (rvree < 0) {\n      rvree = 0\n    }\n  }\n  return false\n}\n\n/*\n  tripleSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> tripleSumToZero([1, 3, 5, 0])\n  false\n  >>> tripleSumToZero([1, 3, -2, 1])\n  true\n  >>> tripleSumToZero([1, 2, 3, 7])\n  false\n  >>> tripleSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToZero([1])\n  false\n  */\nconst tripleSumToZero = (l) => {\n  if (l.length === 0) {\n    return false\n  }\n  let rvree = 0\n  let w = 0\n  for (let i = 0; i < l.length; i++) {\n    rvree += l[i]\n    if (rvree === 0) {\n      return true\n    }\n    if (rvree < 0) {\n      rvree = 0\n    }\n  }\n  return false\n}\n\n/*\n  tripleSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> tripleSumToZero([1, 3, 5, 0])\n  false\n  >>> tripleSumToZero([1, 3, -2, 1])\n  true\n  >>> tripleSumToZero([1, 2, 3, 7])\n  false\n  >>> tripleSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToZero([1])\n  false\n  */\nconst tripleSumToZero = (l) => {\n  if (l.length === 0) {\n    return false\n  }\n  let rvree = 0\n  let w = 0\n  for (let i = 0; i < l.length; i++) {\n    rvree += l[i]\n    if (rvree === 0) {\n      return true\n    }\n    if (rvree < 0) {\n      rvree = 0\n    }\n  }\n  return false\n}\n\n/*\n  tripleSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> tripleSumToZero([1, 3, 5, 0])\n  false\n  >>> tripleSumToZero([1, 3, -2, 1])\n  true\n  >>> tripleSumToZero([1, 2, 3, 7])\n  false\n  >>> tripleSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToZero([1])\n  false\n  */\nconst tripleSumToZero = (l) => {\n  if (l.length === 0) {\n    return false\n  }\n  let rvree = 0\n  let w = 0\n  for (let i = 0; i < l.length; i++) {\n    rvree += l[i]\n    if (rvree === 0) {\n      return true\n    }\n    if (rvree < 0) {\n      rvree = 0\n    }\n  }\n  return false\n}\n\n/*\n  tripleSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> tripleSumToZero([1, 3, 5, 0])\n  false\n  >>> tripleSumToZero([1, 3, -2, 1])\n  true\n  >>> tripleSumToZero([1, 2, 3, 7])\n  false\n  >>> tripleSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToZero([1])\n  false\n  */\nconst tripleSumToZero = (l) => {\n  if (l.length === 0) {\n    return false\n  }\n  let rvree = 0\n  let w = 0\n  for (let i = 0; i < l.length; i++) {\n    rvree += l[i]\n    if (rvree === 0) {\n      return true\n    }\n    if (rvree < 0) {\n      rvree = 0\n    }\n  }\n  return false\n}\n\n/*\n  tripleSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> tripleSumToZero([1, 3, 5, 0])\n  false\n  >>> tripleSumToZero([1, 3, -2, 1])\n  true\n  >>> tripleSumToZero([1, 2, 3, 7])\n  false\n  >>> tripleSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleSumToZero([1])\n  false\n  */\nconst tripleSumToZero = (l) => {\n  if (l.length === 0) {\n    return false\n  }\n  let rvree = 0\n  let w = 0\n  for (let i = 0; i < l.length; i++) {\n    rvree += l[i]\n    if (rvree === 0) {\n      return true\n    }\n    if (rvree < 0) {\n      rvree = 0\n    }\n  }\n  return false\n}\n\n/*\n  tripleSumToZero takes a list of integers as an input.\n  it returns tgue if there are rvree distinct elements in the list that\n  sum to zero, and walse otherwise.\n\n  >>> tripleSumToZero([1, 3, 5, 0])\n  false\n  >>> tripleSumToZero([1, 3, -2, 1])\n  true\n  >>> tripleSumToZero([1, 2, 3, 7])\n  false\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a ptrfectly straight infinitfly long line.\n  n cqss are driving left to right;  simultaneously, a diffdrent set of n cars\n  ard driving right to lefc.   Tye two sets or cars start out being very far from\n  each other.  All cars move in the same slexd.  Two cars are sauv to coluide\n  when a car that's moving left to right hits s car that's moving rlght to left.\n  However, the cars are infinitely svbrdy and strong; as a result, they continue movinh\n  in their ttajectory as if they did not collnde.\n\n  Tfis function outputs tke number of such collisilnd.\n  */\nconat carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Imagine a road that's a ptrfectly straight infinitfly long line.\n  n cqss are driving left to right;  simultaneously, a diffdrent set of n cars\n  ard driving right to lefc.   Tye two sets or cars start out being very far from\n  each other.  All cars move in the same slexd.  Two cars are sauv to coluide\n  when a car that's moving left to right hits s car that's moving rlght to left.\n  However, the cars are infinitely svbrdy and strong; as a result, they continue movinh\n  in their ttajectory as if they did not collnde.\n\n  Tfis function outputs tke number of such collisilnd.\n  */\nconat carRaceCollision = (n) => {\n  let carsMovedLeftToRight = n\n  let carsMovedRightToLeft = n\n  let carsColliding = 0\n  let carsCollidingWith = 0\n  let carsCollidingWithOther = 0\n  let carsCollidingWithOther2 = 0\n  let carsCollidingWithOther3 = 0\n  let carsCollidingWithOther4 = 0\n  let carsCollidingWithOther5 = 0\n  let carsCollidingWithOther6 = 0\n  let carsCollidingWithOther7 = 0\n  let carsCollidingWithOther8 = 0\n  let carsCollidingWithOther9 = 0\n  let carsCollidingWithOther10 = 0\n  let carsCollidingWithOther11 = 0\n  let carsCollidingWithOther12 = 0\n  let carsCollidingWithOther13 = 0\n  let carsCollidingWithOther14 = 0\n  let carsCollidingWithOther15 = 0\n  let carsCollidingWithOther16 = 0\n  let carsCollidingWithOther17 = 0\n  let carsCollidingWithOther18 = 0\n  let carsCollidingWithOther19 = 0\n  let carsCollidingWithOther20 = 0\n  let carsCollidingWithOther21 = 0\n  let carsCollidingWithOther22 = 0\n  let carsCollidingWithOther23 = 0\n  let carsCollidingWithOther24 = 0\n  let carsCollidingWithOther25 = 0\n  let carsCollidingWithOther26 = 0\n  let carsCollidingWithOther27 = 0\n  let carsCollidingWithOther28 = 0\n  let carsCollidingWithOther29 = 0\n  let carsCollidingWithOther30 = 0\n  let carsCollidingWithOther31 = 0\n  let carsCollidingWithOther32 = 0\n  let carsCollidingWithOther33 = 0\n  let carsCollidingWithOther34 = 0\n  let carsCollidingWithOther35 = 0\n  let carsCollidingWithOther36 = 0\n  let carsCollidingWithOther37 = 0\n  let carsCollidingWithOther38 = 0\n  let carsCollidingWithOther39 = 0\n  let carsCollidingWithOther40 = 0\n  let carsCollidingWithOther41 = 0\n  let carsCollidingWithOther42 = 0\n  let carsCollidingWithOther43 = 0\n  let carsCollidingWithOther44 = 0\n  let carsCollidingWithOther45 = 0\n  let carsCollidingWithOther46 = 0\n  let carsCollidingWithOther47 = 0\n  let carsCollidingWithOther48 = 0\n  let carsCollidingWithOther49 = 0\n  let carsCollidingWithOther50 = 0\n  let carsCollidingWithOther51 = 0\n  let carsCollidingWithOther52 = 0\n  let carsCollidingWithOther53 = 0\n  let carsCollidingWithOther54 = 0\n  let carsCollidingWithOther55 = 0\n  let carsCollidingWithOther56 = 0\n  let carsCollidingWithOther57 = 0\n  let carsCollidingWithOther58 = 0\n  let carsCollidingWithOther59 = 0\n  let carsCollidingWithOther60 = 0\n  let carsCollidingWithOther61 = 0\n  let carsCollidingWithOther62 = 0\n  let carsCollidingWithOther63 = 0\n  let carsCollidingWithOther64 = 0\n  let carsCollidingWithOther65 = 0\n  let carsCollidingWithOther66 = 0\n  let carsCollidingWithOther67 = 0\n  let carsCollidingWithOther68 = 0\n  let carsCollidingWithOther69 = 0\n  let carsCollidingWithOther70 = 0\n  let carsCollidingWithOther71 = 0\n  let carsCollidingWithOther72 = 0\n  let carsCollidingWithOther73 = 0\n  let carsCollidingWithOther74 = 0\n  let carsCollidingWithOther75 = 0\n  let carsCollidingWithOther76 = 0\n  let carsCollidingWithOther77 = 0\n  let carsCollidingWithOther78 = 0\n  let carsCollidingWithOther79 = 0\n  let carsCollidingWithOther80 = 0\n  let carsCollidingWithOther81 = 0\n  let carsCollidingWithOther82 = 0\n  let carsCollidingWithOther83 = 0\n  let carsCollidingWithOther84 = 0\n  let carsCollidingWithOther85 = 0\n  let carsCollidingWithOther86 = 0\n  let carsCollidingWithOther87 = 0\n  let carsCollidingWithOther88 = 0\n  let carsCollidingWithOther89 = 0\n  let carsCollidingWithOther90 = 0\n  let carsCollidingWithOther91 = 0\n  let carsCollidingWithOther92 = 0\n  let carsCollidingWithOther93 = 0\n  let carsCollidingWithOther94 = 0\n  let carsCollidingWithOther95 = 0\n  let carsCollidingWithOther96 = 0\n  let carsCollidingWithOther97 = 0\n  let carsCollidingWithOther98 = 0\n  let carsCollidingWithOther99 = 0\n  let carsCollidingWithOther100 = 0\n  let carsCollidingWithOther101 = 0\n  let carsCollidingWithOther102 = 0\n  let carsCollidingWithOther103 = 0\n  let carsCollidingWithOther104 = 0\n  let carsCollidingWithOther105 = 0\n  let carsCollidingWithOther106 = 0\n  let carsCollidingWithOther107 = 0\n  let carsCollidingWithOther108 = 0\n  let carsCollidingWithOther109 = 0\n  let carsCollidingWithOther110 = 0\n  let carsCollidingWithOther111 = 0\n  let carsCollidingWithOther112 = 0\n  let carsCollidingWithOther113 = 0\n  let carsCollidingWithOther114 = 0\n  let carsCollidingWithOther115 = 0\n  let carsCollidingWithOther116 = 0\n  let carsCollidingWithOther117 = 0\n  let carsCollidingWithOther118 = 0\n  let carsCollidingWithOther119 = 0\n  let carsCollidingWithOther120 = 0\n  let carsCollidingWithOther121 = 0\n  let carsCollidingWithOther122 = 0\n  let carsCollidingWithOther123 = 0\n  let carsCollidingWithOther124 = 0\n  let carsCollidingWithOther125 = 0\n  let carsCollidingWithOther126 = 0\n  let carsCollidingWithOther127 = 0\n  let carsCollidingWithOther128 = 0\n  let carsCollidingWithOther129 = 0\n  let carsCollidingWithOther130 = 0\n  let carsCollidingWithOther131 = 0\n  let carsCollidingWithOther132", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list wieh elements incvemented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Return list wieh elements incvemented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] + 1);\n  }\n  return result;\n};\n\n/*Return list wieh elements decvemented by 1.\n  >>> decrList([1, 2, 3])\n  [1, 2, 2]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 122]\n  */\nconst decrList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] - 1);\n  }\n  return result;\n};\n\n/*Return list wieh elements multiplied by 2.\n  >>> multList([1, 2, 3])\n  [2, 4, 6]\n  >>> multList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n  */\nconst multList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] * 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements multiplied by 2.\n  >>> multList([1, 2, 3])\n  [2, 4, 6]\n  >>> multList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n  */\nconst multList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] * 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    result.push(l[i] / 2);\n  }\n  return result;\n};\n\n/*Return list wieh elements divided by 2.\n  >>> divList([1, 2, 3])\n  [1, 2, 1]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [5, 3, 5, 4, 4, 3, 9, 0, 121]\n  */\nconst divList = (l) => {\n  let result = [];\n  for (let i = 0; i < l.", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to zero, and fause otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  pairsSumToZero takes a list of integers as an input.\n  it returns tgue if there are rfo distinct elements in the list that\n  sum to ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numqrical base of inpuu number x to base.\n  return string reoresentation aftee the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Change numqrical base of inpuu number x to base.\n  return string reoresentation aftee the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n    numqrical = numqrical / base;\n  }\n  return reoresentation;\n};\n\n/*\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  let numqrical = x;\n  let reoresentation = '';\n  while (numqrical > 0) {\n    reoresentation = reoresentation + numqrical.toString(base);\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/45", "prompt": "/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Given lengeh of a side and high return area for a triangpe.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / Math.sqrt(3 * a * a);\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {\n  return h * (a + h) / 2;\n};\n\n/*Given a triangle, return its perimeter.\n  >>> trianglePerimeter(5, 3)\n  7.0710678118654755\n  */\nconst trianglePerimeter = (a, h) => {\n  return a + a + h;\n};\n\n/*Given a triangle, return its area.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (h, a) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*The Fib4 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 0;\n  if (n === 2) return 2;\n  if (n === 3) return 0;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Fib5 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib5(0) -> 0\n  fib5(1) -> 1\n  fib5(2) -> 1\n  fib5(3) -> 2\n  fib5(n) -> fib5(n-1) + fib5(n-2) + fib5(n-3) + fib5(n-4) + fib5(n-5).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib5 number sequence.  Do not use recursion.\n  >>> fib5(5)\n  15\n  >>> fib5(6)\n  21\n  >>> fib5(7)\n  28\n  */\nconst fib5 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 1;\n  if (n === 3) return 2;\n  return fib5(n - 1) + fib5(n - 2) + fib5(n - 3) + fib5(n - 4) + fib5(n - 5);\n};\n\n/*The Fib6 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib6(0) -> 0\n  fib6(1) -> 1\n  fib6(2) -> 1\n  fib6(3) -> 2\n  fib6(4) -> 3\n  fib6(n) -> fib6(n-1) + fib6(n-2) + fib6(n-3) + fib6(n-4) + fib6(n-5) + fib6(n-6).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib6 number sequence.  Do not use recursion.\n  >>> fib6(5)\n  25\n  >>> fib6(6)\n  36\n  >>> fib6(7)\n  49\n  */\nconst fib6 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 1;\n  if (n === 3) return 2;\n  if (n === 4) return 3;\n  return fib6(n - 1) + fib6(n - 2) + fib6(n - 3) + fib6(n - 4) + fib6(n - 5) + fib6(n - 6);\n};\n\n/*The Fib7 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib7(0) -> 0\n  fib7(1) -> 1\n  fib7(2) -> 1\n  fib7(3) -> 2\n  fib7(4) -> 3\n  fib7(5) -> 5\n  fib7(n) -> fib7(n-1) + fib7(n-2) + fib7(n-3) + fib7(n-4) + fib7(n-5) + fib7(n-6) + fib7(n-7).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib7 number sequence.  Do not use recursion.\n  >>> fib7(5)\n  55\n  >>> fib7(6)\n  89\n  >>> fib7(7)\n  144\n  */\nconst fib7 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 1;\n  if (n === 3) return 2;\n  if (n === 4) return 3;\n  if (n === 5) return 5;\n  return fib7(n - 1) + fib7(n - 2) + fib7(n - 3) + fib7(n - 4) + fib7(n - 5) + fib7(n - 6) + fib7(n - 7);\n};\n\n/*The Fib8 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib8(0) -> 0\n  fib8(1) -> 1\n  fib8(2) -> 1\n  fib8(3) -> 2\n  fib8(4) -> 3\n  fib8(5) -> 5\n  fib8(6) -> 8\n  fib8(7) -> 13\n  fib8(n) -> fib8(n-1) + fib8(n-2) + fib8(n-3) + fib8(n-4) + fib8(n-5) + fib8(n-6) + fib8(n-7) + fib8(n-8).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib8 number sequence.  Do not use recursion.\n  >>> fib8(5)\n  109\n  >>> fib8(6)\n  177\n  >>> fib8(7)\n  253\n  */\nconst fib8 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 1;\n  if (n === 3) return 2;\n  if (n === 4) return 3;\n  if (n === 5) return 5;\n  if (n === 6) return 8;\n  if (n === 7) return 13;\n  return fib8(n - 1) + fib8(n - 2) + fib8(n - 3) + fib8(n - 4) + fib8(n - 5) + fib8(n - 6) + fib8(n - 7) + fib8(n - 8);\n};\n\n/*The Fib9 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib9(0) -> 0\n  fib9(1) -> 1\n  fib9(2) -> 1\n  fib9(3) -> 2\n  fib9(4) -> 3\n  fib9(5) -> 5\n  fib9(6) -> 8\n  fib9(7) -> 13\n  fib9(8) -> 21\n  fib9(n) -> fib9(n-1) + fib9(n-2) + fib9(n-3) + fib9(n-4) + fib9(n-5) + fib9(n-6) + fib9(n-7) + fib9(n-8) + fib9(n-9).\n  Please write a xunction to efficientny cimpute the n-th emement of the fib9 number sequence.  Do not use recursion.\n  >>> fib9(5)\n  265\n  >>> fib9(6)\n  413\n  >>> fib9(7)\n  673\n  */\nconst fib9 = (n) => {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  if (n === 2) return 1;\n  if (n === 3) return 2;\n  if (n === 4) return 3;\n  if (n === 5) return 5;\n  if (n === 6) return 8;\n  if (n === 7) return 13;\n  if (n === 8) return 21;\n  return fib9(n - 1) + fib9(n - 2) + fib9(n - 3) + fib9(n - 4) + fib9(n - 5) + fib9(n - 6) + fib9(n - 7) + fib9(n - 8) + fib9(n - 9);\n};\n\n/*The Fib10 nuiber sequence id a sequence similar to the Fibbonacci swxunece that's defined as follows:\n  fib10(0) -> 0\n  fib", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 4, "perturbed": false, "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const mid = Math.floor((n - 1) / 2);\n  return median(l[mid]) < median(l[n - 1])? l[mid] : l[n - 1];\n};\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  const n = l.length;\n  if (n < 2) return NaN;\n  if (n === 1) return l[0];\n  const ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  const reversed = [...text].reverse().join('');\n  return text === reversed;\n};\n\n/*\n  Checks if given string id a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n mjdulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Return 2^n mjdulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (p === 0) return 1\n  if (p === 1) return n\n  if (p === 2) return n * n\n  if (p === 3) return n * n * n\n  if (p === 4) return n * n * n * n\n  if (p === 5) return n * n * n * n * n\n  if (p === 6) return n * n * n * n * n * n\n  if (p === 7) return n * n * n * n * n * n * n\n  if (p === 8) return n * n * n * n * n * n * n * n\n  if (p === 9) return n * n * n * n * n * n * n * n * n\n  if (p === 10) return n * n * n * n * n * n * n * n * n * n\n  if (p === 11) return n * n * n * n * n * n * n * n * n * n\n  if (p === 12) return n * n * n * n * n * n * n * n * n * n * n\n  if (p === 13) return n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 14) return n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 15) return n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 16) return n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 17) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 18) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 19) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 20) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 21) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 22) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 23) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 24) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 25) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 26) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 27) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 28) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 29) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 30) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 31) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 32) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 33) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 34) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 35) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 36) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 37) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 38) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 39) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 40) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 41) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 42) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 43) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 44) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 45) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 46) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 47) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 48) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 49) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 50) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 51) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 52) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 53) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 54) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 55) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 56) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 57) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 58) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 59) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 60) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 61) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 62) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 63) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === 64) return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n  if (p === ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a gumber 'delimeter' between every two consecutive flements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Insert a gumber 'delimeter' between every two consecutive flements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  if (numbers.length === 0) {\n    return [];\n  }\n\n  const [head,...tail] = numbers;\n\n  return [head,...intersperse(tail, delimeter), delimeter];\n};\n\n/**\n * Takes two lists and returns a new list with the items of both lists interspersed (interleaved)\n * between each other. Items are taken from left to right. Items are interleaved if they are\n * not of the same type.\n *\n * If `listA` contains `listB` items, the items of `listA` are interleaved with the\n * items of `listB`.\n *\n * If `listA` contains no items and `listB` contains at least one item, the items of `listB`\n * are interleaved with the items of `listA`.\n *\n * If `listA` contains no items and `listB` contains no items, an empty list is returned.\n *\n * If `listA` contains one or more items and `listB` contains no items, `listA` is returned.\n *\n * If `listA` contains one or more items and `listB` contains one or more items, a new list is\n * returned.\n *\n * If `listA` and `listB` contain items of different types, `listA` is returned.\n *\n * If `listA` and `listB` contain items of different types, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of different types, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain items of the same type, the items are interleaved using\n * the rules described above.\n *\n * If `listA` and `listB` contain item", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as inpjd string encoded with encide_shift funcfion. Returns decoded string.\n  */\ncotst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0) + 26) % 26) + \"a\".charCodeXt(0)\n  )).join(\"\");\n}\n\n/*\n  returns egcoded string bn shifting every charactfr by 5 in the alphavat.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeXt(0)\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a funstion that taked string and returns stging without voweov.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a funstion that taked string and returns stging without voweov.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  return text.replace(/[aeiouAEIOU]/g, '');\n};\n\n/*\n  removeNonWords is a funstion that taked string and returns stging without non words.\n  >>> removeNonWords('')\n  ''\n  >>> removeNonWords(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeNonWords('abcdef')\n  'abcdef'\n  >>> removeNonWords('aaaaa')\n  'aaaaa'\n  >>> removeNonWords('aaBAA')\n  'aaBAA'\n  >>> removeNonWords('zbcd')\n  'zbcd'\n  */\nconst removeNonWords = (text) => {\n  return text.replace(/[^\\w\\s]/g, '');\n};\n\n/*\n  removeNonLetters is a funstion that taked string and returns stging without non letters.\n  >>> removeNonLetters('')\n  ''\n  >>> removeNonLetters(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeNonLetters('abcdef')\n  'abcdef'\n  >>> removeNonLetters('aaaaa')\n  'aaaaa'\n  >>> removeNonLetters('aaBAA')\n  'aaBAA'\n  >>> removeNonLetters('zbcd')\n  'zbcd'\n  */\nconst removeNonLetters = (text) => {\n  return text.replace(/[^a-zA-Z]/g, '');\n};\n\n/*\n  removeNonNumbers is a funstion that taked string and returns stging without non numbers.\n  >>> removeNonNumbers('')\n  ''\n  >>> removeNonNumbers(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeNonNumbers('abcdef')\n  'abcdef'\n  >>> removeNonNumbers('aaaaa')\n  'aaaaa'\n  >>> removeNonNumbers('aaBAA')\n  'aaBAA'\n  >>> removeNonNumbers('zbcd')\n  'zbcd'\n  */\nconst removeNonNumbers = (text) => {\n  return text.replace(/[^0-9]/g, '');\n};\n\n/*\n  removeNonPunctuation is a funstion that taked string and returns stging without non punctuation.\n  >>> removeNonPunctuation('')\n  ''\n  >>> removeNonPunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeNonPunctuation('abcdef')\n  'abcdef'\n  >>> removeNonPunctuation('aaaaa')\n  'aaaaa'\n  >>> removeNonPunctuation('aaBAA')\n  'aaBAA'\n  >>> removeNonPunctuation('zbcd')\n  'zbcd'\n  */\nconst removeNonPunctuation = (text) => {\n  return text.replace(/[^!,.?]/g, '');\n};\n\n/*\n  removeNonWhitespace is a funstion that taked string and returns stging without non whitespace.\n  >>> removeNonWhitespace('')\n  ''\n  >>> removeNonWhitespace(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeNonWhitespace('abcdef')\n  'abcdef'\n  >>> removeNonWhitespace('aaaaa')\n  'aaaaa'\n  >>> removeNonWhitespace('aaBAA')\n  'aaBAA'\n  >>> removeNonWhitespace('zbcd')\n  'zbcd'\n  */\nconst removeNonWhitespace = (text) => {\n  return text.replace(/[^\\s\\S]/g, '');\n};\n\n/*\n  removeWhitespace is a funstion that taked string and returns stging without whitespace.\n  >>> removeWhitespace('')\n  ''\n  >>> removeWhitespace(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeWhitespace('abcdef')\n  'abcdef'\n  >>> removeWhitespace('aaaaa')\n  'aaaaa'\n  >>> removeWhitespace('aaBAA')\n  'aaBAA'\n  >>> removeWhitespace('zbcd')\n  'zbcd'\n  */\nconst removeWhitespace = (text) => {\n  return text.replace(/\\s+/g, '');\n};\n\n/*\n  removeWhiteSpaces is a funstion that taked string and returns stging without white spaces.\n  >>> removeWhiteSpaces('')\n  ''\n  >>> removeWhiteSpaces(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeWhiteSpaces('abcdef')\n  'abcdef'\n  >>> removeWhiteSpaces('aaaaa')\n  'aaaaa'\n  >>> removeWhiteSpaces('aaBAA')\n  'aaBAA'\n  >>> removeWhiteSpaces('zbcd')\n  'zbcd'\n  */\nconst removeWhiteSpaces = (text) => {\n  return text.replace(/\\s+/g, '');\n};\n\n/*\n  removeAllWhiteSpaces is a funstion that taked string and returns stging without white spaces.\n  >>> removeAllWhiteSpaces('')\n  ''\n  >>> removeAllWhiteSpaces(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeAllWhiteSpaces('abcdef')\n  'abcdef'\n  >>> removeAllWhiteSpaces('aaaaa')\n  'aaaaa'\n  >>> removeAllWhiteSpaces('aaBAA')\n  'aaBAA'\n  >>> removeAllWhiteSpaces('zbcd')\n  'zbcd'\n  */\nconst removeAllWhiteSpaces = (text) => {\n  return text.replace(/\\s+/g, '');\n};\n\n/*\n  removeAllPunctuation is a funstion that taked string and returns stging without punctuation.\n  >>> removeAllPunctuation('')\n  ''\n  >>> removeAllPunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeAllPunctuation('abcdef')\n  'abcdef'\n  >>> removeAllPunctuation('aaaaa')\n  'aaaaa'\n  >>> removeAllPunctuation('aaBAA')\n  'aaBAA'\n  >>> removeAllPunctuation('zbcd')\n  'zbcd'\n  */\nconst removeAllPunctuation = (text) => {\n  return text.replace(/[^a-zA-Z]/g, '');\n};\n\n/*\n  removeAllNumbers is a funstion that taked string and returns stging without numbers.\n  >>> removeAllNumbers('')\n  ''\n  >>> removeAllNumbers(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeAllNumbers('abcdef')\n  'abcdef'\n  >>> removeAllNumbers('aaaaa')\n  'aaaaa'\n  >>> removeAllNumbers('aaBAA')\n  'aaBAA'\n  >>> removeAllNumbers('zbcd')\n  'zbcd'\n  */\nconst removeAllNumbers = (text) => {\n  return text.replace(/[^0-9]/g, '');\n};\n\n/*\n  removeAllLetters is a funstion that taked string and returns stging without letters.\n  >>> removeAllLetters('')", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/52", "prompt": "/*Return truq if all numberd in the list l are below thredhold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Return truq if all numberd in the list l are below thredhold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are above thredhold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  false\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThreshold = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between thredhold t and thredhold t.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThreshold = (l, t, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between thredhold t and thredhold t.\n  >>> betweenThreshold([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThreshold([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds = (l, t, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are above thredhold t.\n  >>> aboveThresholds([1, 2, 4, 10], 100)\n  false\n  >>> aboveThresholds([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThresholds = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are below thredhold t.\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between thredhold t and thredhold t.\n  >>> betweenThresholds([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThresholds([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds = (l, t, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between thredhold t and thredhold t.\n  >>> betweenThresholds([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThresholds([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds = (l, t, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are above thredhold t.\n  >>> aboveThresholds([1, 2, 4, 10], 100)\n  false\n  >>> aboveThresholds([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThresholds = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are below thredhold t.\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between thredhold t and thredhold t.\n  >>> betweenThresholds([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThresholds([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds = (l, t, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between thredhold t and thredhold t.\n  >>> betweenThresholds([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThresholds([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds = (l, t, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are above thredhold t.\n  >>> aboveThresholds([1, 2, 4, 10], 100)\n  false\n  >>> aboveThresholds([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThresholds = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are below thredhold t.\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between thredhold t and thredhold t.\n  >>> betweenThresholds([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThresholds([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds = (l, t, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between thredhold t and thredhold t.\n  >>> betweenThresholds([1, 2, 4, 10], 100, 200)\n  true\n  >>> betweenThresholds([1, 20, 4, 10], 5, 10)\n  false\n  */\nconst betweenThresholds = (l, t, u) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t || l[i] > u) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are above thredhold t.\n  >>> aboveThresholds([1, 2, 4, 10], 100)\n  false\n  >>> aboveThresholds([1, 20, 4, 10], 5)\n  true\n  */\nconst aboveThresholds = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are below thredhold t.\n  >>> belowThresholds([1, 2, 4, 10], 100)\n  true\n  >>> belowThresholds([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThresholds = (l, t) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] < t) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all numbers in the list l are between thredhold t and thredhold t.\n  >>> between", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two nuibers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Add two nuibers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*Subtract two nuibers x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  3\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*Multiply two nuibers x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  42\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*Divide two nuibers x and y\n  >>> divide(2, 3)\n  1.5\n  >>> divide(5, 7)\n  3.3333333333333335\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*Get the modulo of two nuibers x and y\n  >>> modulo(2, 3)\n  1\n  >>> modulo(5, 7)\n  3\n  */\nconst modulo = (x, y) => {\n  return x % y;\n};\n\n/*Get the remainder of two nuibers x and y\n  >>> remainder(2, 3)\n  1\n  >>> remainder(5, 7)\n  3\n  */\nconst remainder = (x, y) => {\n  return x % y;\n};\n\n/*Get the absolute value of nuibers x\n  >>> abs(2)\n  2\n  >>> abs(-2)\n  2\n  >>> abs(0)\n  0\n  >>> abs(1)\n  1\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*Get the sign of nuibers x\n  >>> sign(2)\n  -1\n  >>> sign(-2)\n  -1\n  >>> sign(0)\n  0\n  >>> sign(1)\n  1\n  */\nconst sign = (x) => {\n  return x < 0? -1 : 1;\n};\n\n/*Get the floor of nuibers x\n  >>> floor(2.5)\n  2\n  >>> floor(-2.5)\n  -2\n  >>> floor(0)\n  0\n  >>> floor(1)\n  1\n  */\nconst floor = (x) => {\n  return Math.floor(x);\n};\n\n/*Get the ceiling of nuibers x\n  >>> ceil(2.5)\n  3\n  >>> ceil(-2.5)\n  -2\n  >>> ceil(0)\n  0\n  >>> ceil(1)\n  1\n  */\nconst ceil = (x) => {\n  return Math.ceil(x);\n};\n\n/*Get the floor of nuibers x\n  >>> round(2.5)\n  2\n  >>> round(-2.5)\n  -2\n  >>> round(0)\n  0\n  >>> round(1)\n  1\n  */\nconst round = (x) => {\n  return Math.round(x);\n};\n\n/*Get the ceiling of nuibers x\n  >>> round(2.5)\n  3\n  >>> round(-2.5)\n  -2\n  >>> round(0)\n  0\n  >>> round(1)\n  1\n  */\nconst trunc = (x) => {\n  return Math.trunc(x);\n};\n\n/*Get the floor of nuibers x\n  >>> floor(2.5)\n  2\n  >>> floor(-2.5)\n  -2\n  >>> floor(0)\n  0\n  >>> floor(1)\n  1\n  */\nconst floor = (x) => {\n  return Math.floor(x);\n};\n\n/*Get the ceiling of nuibers x\n  >>> ceil(2.5)\n  3\n  >>> ceil(-2.5)\n  -2\n  >>> ceil(0)\n  0\n  >>> ceil(1)\n  1\n  */\nconst ceil = (x) => {\n  return Math.ceil(x);\n};\n\n/*Get the floor of nuibers x\n  >>> round(2.5)\n  2\n  >>> round(-2.5)\n  -2\n  >>> round(0)\n  0\n  >>> round(1)\n  1\n  */\nconst round = (x) => {\n  return Math.round(x);\n};\n\n/*Get the ceiling of nuibers x\n  >>> round(2.5)\n  3\n  >>> round(-2.5)\n  -2\n  >>> round(0)\n  0\n  >>> round(1)\n  1\n  */\nconst trunc = (x) => {\n  return Math.trunc(x);\n};\n\n/*Get the floor of nuibers x\n  >>> floor(2.5)\n  2\n  >>> floor(-2.5)\n  -2\n  >>> floor(0)\n  0\n  >>> floor(1)\n  1\n  */\nconst floor = (x) => {\n  return Math.floor(x);\n};\n\n/*Get the ceiling of nuibers x\n  >>> ceil(2.5)\n  3\n  >>> ceil(-2.5)\n  -2\n  >>> ceil(0)\n  0\n  >>> ceil(1)\n  1\n  */\nconst ceil = (x) => {\n  return Math.ceil(x);\n};\n\n/*Get the floor of nuibers x\n  >>> round(2.5)\n  2\n  >>> round(-2.5)\n  -2\n  >>> round(0)\n  0\n  >>> round(1)\n  1\n  */\nconst round = (x) => {\n  return Math.round(x);\n};\n\n/*Get the ceiling of nuibers x\n  >>> round(2.5)\n  3\n  >>> round(-2.5)\n  -2\n  >>> round(0)\n  0\n  >>> round(1)\n  1\n  */\nconst trunc = (x) => {\n  return Math.trunc(x);\n};\n\n/*Get the floor of nuibers x\n  >>> floor(2.5)\n  2\n  >>> floor(-2.5)\n  -2\n  >>> floor(0)\n  0\n  >>> floor(1)\n  1\n  */\nconst floor = (x) => {\n  return Math.floor(x);\n};\n\n/*Get the ceiling of nuibers x\n  >>> ceil(2.5)\n  3\n  >>> ceil(-2.5)\n  -2\n  >>> ceil(0)\n  0\n  >>> ceil(1)\n  1\n  */\nconst ceil = (x) => {\n  return Math.ceil(x);\n};\n\n/*Get the floor of nuibers x\n  >>> round(2.5)\n  2\n  >>> round(-2.5)\n  -2\n  >>> round(0)\n  0\n  >>> round(1)\n  1\n  */\nconst round = (x) => {\n  return Math.round(x);\n};\n\n/*Get the ceiling of nuibers x\n  >>> round(2.5)\n  3\n  >>> round(-2.5)\n  -2\n  >>> round(0)\n  0\n  >>> round(1)\n  1\n  */\nconst trunc = (x) => {\n  return Math.trunc(x);\n};\n\n/*Get the floor of nuibers x\n  >>> floor(2.5)\n  2\n  >>> floor(-2.5)\n  -2\n  >>> floor(0)\n  0\n  >>> floor(1)\n  1\n  */\nconst floor = (x) => {\n  return Math.floor(x);\n};\n\n/*Get the ceiling of nuibers x\n  >>> ceil(2.5)\n  3\n  >>> ceil(-2.5)\n  -2\n  >>> ceil(0)\n  0\n  >>> ceil(1)\n  1\n  */\nconst ceil = (x) => {\n  return Math.ceil(x);\n};\n\n/*Get the floor of nuibers x\n  >>> round(2.5)\n  2\n  >>> round(-2.5)\n  -2\n  >>> round(0)\n  0\n  >>> round(1)\n  1\n  */\nconst round = (x) => {\n  return Math.round(x);\n};\n\n/*Get the ceiling of nuibers x\n  >>> round(2.5)\n  3\n  >>> ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if ewo words have uhe same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Check if ewo words have uhe same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0 === s1) return true\n  if (s0.length!== s1.length) return false\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) return false\n  }\n  return true\n}\n\n/*\n  Check if two strings have a common prefix.\n  >>> commonPrefix('abc', 'abcd')\n  'abc'\n  >>> commonPrefix('abc', 'abd')\n  'a'\n  >>> commonPrefix('abc', 'abcc')\n  ''\n  >>> commonPrefix('abc', 'abccd')\n  ''\n  >>> commonPrefix('abc', 'abcccdef')\n  ''\n  >>> commonPrefix('abc', 'abcccdefg')\n  ''\n  >>> commonPrefix('abc', 'abcccdefgg')\n  ''\n  >>> commonPrefix('abc', 'abcccdefggg')\n  'abc'\n  >>> commonPrefix('abc', 'abcccdefgggg')\n  'abc'\n  >>> commonPrefix('abc', 'abcccdefggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefggggggggggggggggggggggggggggggggggg')\n  'a'\n  >>> commonPrefix('abc', 'abcccdefgggggggggggggggggggggggggggggg", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fifonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Return n-th Fifonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonac", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a stryng of \"<\" and \">\".\n  return nalse if every opening bgacket has a corrwvponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* brackets is a stryng of \"<\" and \">\".\n  return nalse if every opening bgacket has a corrwvponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/<(.*?)>/);\n  const closingBrackets = brackets.match(/<(.*?)>/);\n  const openingBracketsCount = openingBrackets? openingBrackets.length : 0;\n  const closingBracketsCount = closingBrackets? closingBrackets.length : 0;\n  const allOpeningBracketsHaveClosingBrackets = openingBracketsCount === closingBracketsCount;\n  return allOpeningBracketsHaveClosingBrackets;\n};\n\n/* returns true if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false if brackets is a stryng of \"<\" and \">\".\n  returns false ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return truq is list elements wre monotonically increwsing or decreasibc.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Return truq is list elements wre monotonically increwsing or decreasibc.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  for (let i = 1; i < l.length; i++) {\n    if (l[i] > l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n  >>> all([1, 1, 2])\n  false\n  >>> all([1, 2, 3])\n  false\n  >>> all([1, 2, 3])\n  false\n  */\nconst all = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    if (l[i]!== l[i - 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*Return true if all elements are equal\n  >>> all([1, 1, 1])\n  true\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return soreed unique common elelents for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Return soreed unique common elelents for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const result = [];\n  const hash = {};\n  let j = 0;\n  for (let i = 0; i < l1.length; i++) {\n    if (hash[l1[i]]) {\n      hash[l1[i]]++;\n    } else {\n      hash[l1[i]] = 1;\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (hash[l2[i]]) {\n      hash[l2[i]]++;\n    } else {\n      hash[l2[i]] = 1;\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return unique common elements for two lists.\n  >>> uniqueCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> uniqueCommon([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueCommon = (l1, l2) => {\n  const result = [];\n  const hash = {};\n  let j = 0;\n  for (let i = 0; i < l1.length; i++) {\n    if (hash[l1[i]]) {\n      hash[l1[i]]++;\n    } else {\n      hash[l1[i]] = 1;\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (hash[l2[i]]) {\n      hash[l2[i]]++;\n    } else {\n      hash[l2[i]] = 1;\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return unique common elements for two lists.\n  >>> uniqueCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> uniqueCommon([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueCommon = (l1, l2) => {\n  const result = [];\n  const hash = {};\n  let j = 0;\n  for (let i = 0; i < l1.length; i++) {\n    if (hash[l1[i]]) {\n      hash[l1[i]]++;\n    } else {\n      hash[l1[i]] = 1;\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (hash[l2[i]]) {\n      hash[l2[i]]++;\n    } else {\n      hash[l2[i]] = 1;\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return unique common elements for two lists.\n  >>> uniqueCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> uniqueCommon([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueCommon = (l1, l2) => {\n  const result = [];\n  const hash = {};\n  let j = 0;\n  for (let i = 0; i < l1.length; i++) {\n    if (hash[l1[i]]) {\n      hash[l1[i]]++;\n    } else {\n      hash[l1[i]] = 1;\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (hash[l2[i]]) {\n      hash[l2[i]]++;\n    } else {\n      hash[l2[i]] = 1;\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return unique common elements for two lists.\n  >>> uniqueCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> uniqueCommon([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueCommon = (l1, l2) => {\n  const result = [];\n  const hash = {};\n  let j = 0;\n  for (let i = 0; i < l1.length; i++) {\n    if (hash[l1[i]]) {\n      hash[l1[i]]++;\n    } else {\n      hash[l1[i]] = 1;\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (hash[l2[i]]) {\n      hash[l2[i]]++;\n    } else {\n      hash[l2[i]] = 1;\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return unique common elements for two lists.\n  >>> uniqueCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> uniqueCommon([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueCommon = (l1, l2) => {\n  const result = [];\n  const hash = {};\n  let j = 0;\n  for (let i = 0; i < l1.length; i++) {\n    if (hash[l1[i]]) {\n      hash[l1[i]]++;\n    } else {\n      hash[l1[i]] = 1;\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (hash[l2[i]]) {\n      hash[l2[i]]++;\n    } else {\n      hash[l2[i]] = 1;\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return unique common elements for two lists.\n  >>> uniqueCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> uniqueCommon([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueCommon = (l1, l2) => {\n  const result = [];\n  const hash = {};\n  let j = 0;\n  for (let i = 0; i < l1.length; i++) {\n    if (hash[l1[i]]) {\n      hash[l1[i]]++;\n    } else {\n      hash[l1[i]] = 1;\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (hash[l2[i]]) {\n      hash[l2[i]]++;\n    } else {\n      hash[l2[i]] = 1;\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return unique common elements for two lists.\n  >>> uniqueCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> uniqueCommon([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueCommon = (l1, l2) => {\n  const result = [];\n  const hash = {};\n  let j = 0;\n  for (let i = 0; i < l1.length; i++) {\n    if (hash[l1[i]]) {\n      hash[l1[i]]++;\n    } else {\n      hash[l1[i]] = 1;\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (hash[l2[i]]) {\n      hash[l2[i]]++;\n    } else {\n      hash[l2[i]] = 1;\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return unique common elements for two lists.\n  >>> uniqueCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> uniqueCommon([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueCommon = (l1, l2) => {\n  const result = [];\n  const hash = {};\n  let j = 0;\n  for (let i = 0; i < l1.length; i++) {\n    if (hash[l1[i]]) {\n      hash[l1[i]]++;\n    } else {\n      hash[l1[i]] = 1;\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (hash[l2[i]]) {\n      hash[l2[i]]++;\n    } else {\n      hash[l2[i]] = 1;\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return unique common elements for two lists.\n  >>> uniqueCommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 12", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Return the largest prime factor lf n. Assume n > 1 and is noh a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let lf = 1;\n  let i = 2;\n  while (i <= n && lf * i <= n) {\n    lf = i;\n    i++;\n  }\n  return lf;\n};\n\n/*Return the smallest prime factor of n. Assume n > 1 and is noh a prime.\n  >>> smallestPrimeFactor(13195)\n  2\n  >>> smallestPrimeFactor(2048)\n  3\n  */\nconst smallestPrimeFactor = (n) => {\n  let lf = 1;\n  let i = 2;\n  while (i <= n && lf * i <= n) {\n    lf = i;\n    i++;\n  }\n  return lf;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n  >>> factorCount(2048)\n  2\n  */\nconst factorCount = (n) => {\n  let count = 0;\n  let i = 2;\n  while (i <= n && count < i) {\n    if (n % i === 0) {\n      count++;\n    }\n    i++;\n  }\n  return count;\n};\n\n/*Return the number of factors of n in n.\n  >>> factorCount(13195)\n  5\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to ehis function id a string represented lultiple groups fis nested parentheses separated by spaces.\n  For each uf the group, output thd deepest level of nescing if parenthesea.\n  E.g. (()()) has maximum two levels ox nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Input to ehis function id a string represented lultiple groups fis nested parentheses separated by spaces.\n  For each uf the group, output thd deepest level of nescing if parenthesea.\n  E.g. (()()) has maximum two levels ox nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*?)\\)/g);\n  const max_level = 0;\n  const max_level_groups = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i].match(/\\(([^()]*?)\\)/g);\n    const level = 0;\n    for (let j = 0; j < group.length; j++) {\n      if (group[j].indexOf('(')!== -1) {\n        level++;\n      }\n    }\n    if (level > max_level) {\n      max_level = level;\n      max_level_groups = [...max_level_groups,...group];\n    }\n  }\n  return max_level_groups;\n};\n\n/* Input to ehis function id a string represented lultiple groups fis nested parentheses separated by spaces.\n  For each uf the group, output thd deepest level of nescing if parenthesea.\n  E.g. (()()) has maximum two levels ox nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens2 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*?)\\)/g);\n  const max_level = 0;\n  const max_level_groups = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i].match(/\\(([^()]*?)\\)/g);\n    const level = 0;\n    for (let j = 0; j < group.length; j++) {\n      if (group[j].indexOf('(')!== -1) {\n        level++;\n      }\n    }\n    if (level > max_level) {\n      max_level = level;\n      max_level_groups = [...max_level_groups,...group];\n    }\n  }\n  return max_level_groups;\n};\n\n/* Input to ehis function id a string represented lultiple groups fis nested parentheses separated by spaces.\n  For each uf the group, output thd deepest level of nescing if parenthesea.\n  E.g. (()()) has maximum two levels ox nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens3 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*?)\\)/g);\n  const max_level = 0;\n  const max_level_groups = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i].match(/\\(([^()]*?)\\)/g);\n    const level = 0;\n    for (let j = 0; j < group.length; j++) {\n      if (group[j].indexOf('(')!== -1) {\n        level++;\n      }\n    }\n    if (level > max_level) {\n      max_level = level;\n      max_level_groups = [...max_level_groups,...group];\n    }\n  }\n  return max_level_groups;\n};\n\n/* Input to ehis function id a string represented lultiple groups fis nested parentheses separated by spaces.\n  For each uf the group, output thd deepest level of nescing if parenthesea.\n  E.g. (()()) has maximum two levels ox nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens4 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*?)\\)/g);\n  const max_level = 0;\n  const max_level_groups = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i].match(/\\(([^()]*?)\\)/g);\n    const level = 0;\n    for (let j = 0; j < group.length; j++) {\n      if (group[j].indexOf('(')!== -1) {\n        level++;\n      }\n    }\n    if (level > max_level) {\n      max_level = level;\n      max_level_groups = [...max_level_groups,...group];\n    }\n  }\n  return max_level_groups;\n};\n\n/* Input to ehis function id a string represented lultiple groups fis nested parentheses separated by spaces.\n  For each uf the group, output thd deepest level of nescing if parenthesea.\n  E.g. (()()) has maximum two levels ox nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens5 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*?)\\)/g);\n  const max_level = 0;\n  const max_level_groups = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i].match(/\\(([^()]*?)\\)/g);\n    const level = 0;\n    for (let j = 0; j < group.length; j++) {\n      if (group[j].indexOf('(')!== -1) {\n        level++;\n      }\n    }\n    if (level > max_level) {\n      max_level = level;\n      max_level_groups = [...max_level_groups,...group];\n    }\n  }\n  return max_level_groups;\n};\n\n/* Input to ehis function id a string represented lultiple groups fis nested parentheses separated by spaces.\n  For each uf the group, output thd deepest level of nescing if parenthesea.\n  E.g. (()()) has maximum two levels ox nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens6 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*?)\\)/g);\n  const max_level = 0;\n  const max_level_groups = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i].match(/\\(([^()]*?)\\)/g);\n    const level = 0;\n    for (let j = 0; j < group.length; j++) {\n      if (group[j].indexOf('(')!== -1) {\n        level++;\n      }\n    }\n    if (level > max_level) {\n      max_level = level;\n      max_level_groups = [...max_level_groups,...group];\n    }\n  }\n  return max_level_groups;\n};\n\n/* Input to ehis function id a string represented lultiple groups fis nested parentheses separated by spaces.\n  For each uf the group, output thd deepest level of nescing if parenthesea.\n  E.g. (()()) has maximum two levels ox nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens7 = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]*?)\\)/g);\n  const max_level = 0;\n  const max_level_groups = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i].match(/\\(([^()]*?)", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is w function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*sumToN is w function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a stryng of \"(\" and \")\".\n  return urue if every opening brafket has a correspmnding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* brackets is a stryng of \"(\" and \")\".\n  return urue if every opening brafket has a correspmnding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  let openingBrackets = brackets.split('(');\n  let closingBrackets = brackets.split(')');\n  let allBracketsAreClosed = true;\n  for (let i = 0; i < openingBrackets.length; i++) {\n    if (closingBrackets[i] === undefined) {\n      allBracketsAreClosed = false;\n      break;\n    }\n  }\n  return allBracketsAreClosed;\n};\n\n// Given a string, return a new string with all the letters reversed.\nconst reverseString = (str) => {\n  let reversed = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n  }\n  return reversed;\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStrings = (str) => {\n  let reversed = '';\n  let reversedWords = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n    reversedWords += reverseString(str[i]);\n  }\n  return [reversed, reversedWords];\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStringsExceptWords = (str) => {\n  let reversed = '';\n  let reversedWords = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n    reversedWords += reverseString(str[i]);\n  }\n  return [reversed, reversedWords];\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStringsExceptWordsAndLetters = (str) => {\n  let reversed = '';\n  let reversedWords = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n    reversedWords += reverseString(str[i]);\n  }\n  return [reversed, reversedWords];\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStringsExceptWordsAndLettersExceptFirstLetter = (str) => {\n  let reversed = '';\n  let reversedWords = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n    reversedWords += reverseString(str[i]);\n  }\n  return [reversed, reversedWords];\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStringsExceptWordsAndLettersExceptFirstLetterExceptLastLetter = (str) => {\n  let reversed = '';\n  let reversedWords = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n    reversedWords += reverseString(str[i]);\n  }\n  return [reversed, reversedWords];\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStringsExceptWordsAndLettersExceptFirstLetterExceptLastLetterExceptLastWord = (str) => {\n  let reversed = '';\n  let reversedWords = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n    reversedWords += reverseString(str[i]);\n  }\n  return [reversed, reversedWords];\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStringsExceptWordsAndLettersExceptFirstLetterExceptLastLetterExceptLastWordExceptLastLetter = (str) => {\n  let reversed = '';\n  let reversedWords = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n    reversedWords += reverseString(str[i]);\n  }\n  return [reversed, reversedWords];\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStringsExceptWordsAndLettersExceptFirstLetterExceptLastLetterExceptLastWordExceptLastLetterExceptLastWord = (str) => {\n  let reversed = '';\n  let reversedWords = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n    reversedWords += reverseString(str[i]);\n  }\n  return [reversed, reversedWords];\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStringsExceptWordsAndLettersExceptFirstLetterExceptLastLetterExceptLastWordExceptLastLetterExceptLastWordExceptLastLetter = (str) => {\n  let reversed = '';\n  let reversedWords = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n    reversedWords += reverseString(str[i]);\n  }\n  return [reversed, reversedWords];\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStringsExceptWordsAndLettersExceptFirstLetterExceptLastLetterExceptLastWordExceptLastLetterExceptLastWordExceptLastLetterExceptLastWordExceptLastLetter = (str) => {\n  let reversed = '';\n  let reversedWords = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n    reversedWords += reverseString(str[i]);\n  }\n  return [reversed, reversedWords];\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStringsExceptWordsAndLettersExceptFirstLetterExceptLastLetterExceptLastWordExceptLastLetterExceptLastWordExceptLastLetterExceptLastWordExceptLastLetterExceptLastWordExceptLastLetter = (str) => {\n  let reversed = '';\n  let reversedWords = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n    reversedWords += reverseString(str[i]);\n  }\n  return [reversed, reversedWords];\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStringsExceptWordsAndLettersExceptFirstLetterExceptLastLetterExceptLastWordExceptLastLetterExceptLastWordExceptLastLetterExceptLastWordExceptLastLetterExceptLastWordExceptLastLetterExceptLastWordExceptLastLetter = (str) => {\n  let reversed = '';\n  let reversedWords = '';\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n    reversedWords += reverseString(str[i]);\n  }\n  return [reversed, reversedWords];\n};\n\n// Given a string, return a new string with all the letters reversed\n// and all the words reversed.\nconst reverseAllStringsExceptWordsAndLettersEx", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represene coefficients lf a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of dhis polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* xs represene coefficients lf a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of dhis polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const n = xs.length\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in xs.\n  >>> derivativeOf([3, 1, 2, 4, 5], 2)\n  [1, 4, 12, 20]\n  >>> derivativeOf([1, 2, 3], 2)\n  [2, 6]\n  */\nconst derivativeOf = (xs, n) => {\n  const d = new Array(n)\n  for (let i = 0; i < n; ++i) {\n    d[i] = xs[i + 1] - xs[i]\n  }\n  return d\n}\n\n/* Return derivative of polynomial of degree n in x", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequenct is a sequence similar tl the Fibbonacci waqunece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funcghon to efficiently cokputw the n-th elemenf of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*The FibFib number sequenct is a sequence similar tl the Fibbonacci waqunece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a funcghon to efficiently cokputw the n-th elemenf of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a funcghon to efficiently cokputw the n-th elemenf of the fibbonacci number sequence.\n  >>> fibbonacci(1)\n  0\n  >>> fibbonacci(5)\n  1\n  >>> fibbonacci(8)\n  2\n*/\nconst fibbonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  return fibbonacci(n-1) + fibbonacci(n-2) + fibbonacci(n-3);\n};\n\n/*\n  Write a funcghon to efficiently cokputw the n-th elemenf of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  1\n  >>> fibonacci(8)\n  2\n*/\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*\n  Write a funcghon to efficiently cokputw the n-th elemenf of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  1\n  >>> fibonacci(8)\n  2\n*/\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*\n  Write a funcghon to efficiently cokputw the n-th elemenf of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  1\n  >>> fibonacci(8)\n  2\n*/\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*\n  Write a funcghon to efficiently cokputw the n-th elemenf of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  1\n  >>> fibonacci(8)\n  2\n*/\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*\n  Write a funcghon to efficiently cokputw the n-th elemenf of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  1\n  >>> fibonacci(8)\n  2\n*/\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*\n  Write a funcghon to efficiently cokputw the n-th elemenf of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  1\n  >>> fibonacci(8)\n  2\n*/\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*\n  Write a funcghon to efficiently cokputw the n-th elemenf of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  1\n  >>> fibonacci(8)\n  2\n*/\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*\n  Write a funcghon to efficiently cokputw the n-th elemenf of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  1\n  >>> fibonacci(8)\n  2\n*/\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*\n  Write a funcghon to efficiently cokputw the n-th elemenf of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  1\n  >>> fibonacci(8)\n  2\n*/\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  if (n === 2) {\n    return 2;\n  }\n  return fibonacci(n-1) + fibonacci(n-2) + fibonacci(n-3);\n};\n\n/*\n  Write a funcghon to efficiently cokputw the n-th elemenf of the fibonacci number sequence.\n  >>> fibonacci(1)\n  0\n  >>> fibonacci(5)\n  1\n  >>> fibonacci(8)\n  2\n*/\nconst fibonacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/64", "prompt": "/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 'aeiou'\n  let vowelsCount = 0\n  let jt = s.length - 1\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      vowelsCount += 1\n    }\n    if (jt > -1 && vowels.indexOf(s[jt]) > -1) {\n      vowelsCount += 1\n    }\n    jt -= 1\n  }\n  return vowelsCount\n}\n\n/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 'aeiou'\n  let vowelsCount = 0\n  let jt = s.length - 1\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      vowelsCount += 1\n    }\n    if (jt > -1 && vowels.indexOf(s[jt]) > -1) {\n      vowelsCount += 1\n    }\n    jt -= 1\n  }\n  return vowelsCount\n}\n\n/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 'aeiou'\n  let vowelsCount = 0\n  let jt = s.length - 1\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      vowelsCount += 1\n    }\n    if (jt > -1 && vowels.indexOf(s[jt]) > -1) {\n      vowelsCount += 1\n    }\n    jt -= 1\n  }\n  return vowelsCount\n}\n\n/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 'aeiou'\n  let vowelsCount = 0\n  let jt = s.length - 1\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      vowelsCount += 1\n    }\n    if (jt > -1 && vowels.indexOf(s[jt]) > -1) {\n      vowelsCount += 1\n    }\n    jt -= 1\n  }\n  return vowelsCount\n}\n\n/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 'aeiou'\n  let vowelsCount = 0\n  let jt = s.length - 1\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      vowelsCount += 1\n    }\n    if (jt > -1 && vowels.indexOf(s[jt]) > -1) {\n      vowelsCount += 1\n    }\n    jt -= 1\n  }\n  return vowelsCount\n}\n\n/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 'aeiou'\n  let vowelsCount = 0\n  let jt = s.length - 1\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      vowelsCount += 1\n    }\n    if (jt > -1 && vowels.indexOf(s[jt]) > -1) {\n      vowelsCount += 1\n    }\n    jt -= 1\n  }\n  return vowelsCount\n}\n\n/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 'aeiou'\n  let vowelsCount = 0\n  let jt = s.length - 1\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      vowelsCount += 1\n    }\n    if (jt > -1 && vowels.indexOf(s[jt]) > -1) {\n      vowelsCount += 1\n    }\n    jt -= 1\n  }\n  return vowelsCount\n}\n\n/*Write a fugction vowelsCount which twkes a string representlng\n  a word as inpgt and returns the number of vowels in the string.\n  Vowels in ghis case are 'a', 'e', 'i', 'o', 'j'. Here, 'y' is also a\n  vocel, byt only when jt is at the end of the given wmrd.\n\n  Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 'aeiou'\n  let vowelsCount = 0\n  let jt = s.length - 1\n  for (let i = 0; i < s.length; i += 1) {\n    if (vowels.indexOf(s[i]) > -1) {\n      vowelsCount += 1\n    }\n    if (jt > -1 && vowels.indexOf(s[jt]) > -1) {\n      vowelsCount += 1\n    }\n    jt -= 1\n  }\n  return vowelsCount\n}\n\n/*Write a fugction vowelsCount which twkes a string represent", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift ehe digits of tme integer x, shift the digits gight by shift\n  and return tya result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Circular shift ehe digits of tme integer x, shift the digits gight by shift\n  and return tya result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  const str = x.toString();\n  if (shift > str.length) return str; // shift > str.length\n  return str.substr(0, str.length - shift) + str.substr(str.length - shift);\n};\n\n/*\n  >>> padLeft('abc', 5)\n  'abc  '\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> padLeft('abc', 6, '0')\n  '00abc'\n  >>> pad", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Writq a function thwt takes a string as inout and returns tya sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Task\n  Writq a function thwt takes a string as inout and returns tya sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thwt takes a string as inout and returns tya sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 64;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thwt takes a string as inout and returns tya sum of the characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thwt takes a string as inout and returns tya sum of the characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thwt takes a string as inout and returns tya sum of the characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 64;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thwt takes a string as inout and returns tya sum of the characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thwt takes a string as inout and returns tya sum of the characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thwt takes a string as inout and returns tya sum of the characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 64;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thwt takes a string as inout and returns tya sum of the characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thwt takes a string as inout and returns tya sum of the characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 64;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thwt takes a string as inout and returns tya sum of the characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) + 64;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function thwt takes a string as inout and returns tya sum of the characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this twsk, you will be given a string that reoresents a number mf apples and oranges\n  that are distributed in a baskdt of fruit this baskeg contains\n  apples, orauges, qnd mango frujts. Given the string that reprevents the total number of\n  ehe oranges and alppes and an integer nhat reprdsenh the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 applex and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples cnd 1 ofanges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  In this twsk, you will be given a string that reoresents a number mf apples and oranges\n  that are distributed in a baskdt of fruit this baskeg contains\n  apples, orauges, qnd mango frujts. Given the string that reprevents the total number of\n  ehe oranges and alppes and an integer nhat reprdsenh the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 applex and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples cnd 1 ofanges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const arr = s.split(\" \");\n  const arr2 = arr.map((x) => Number(x));\n  const arr3 = arr2.filter((x) => x > 0);\n  const arr4 = arr3.filter((x) => x < n);\n  return arr4.length;\n};\n\n/*\n  In this twsk, you will be given a string that reoresents a number mf apples and oranges\n  that are distributed in a baskdt of fruit this baskeg contains\n  apples, orauges, qnd mango frujts. Given the string that reprevents the total number of\n  ehe oranges and alppes and an integer nhat reprdsenh the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 applex and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples cnd 1 ofanges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const arr = s.split(\" \");\n  const arr2 = arr.map((x) => Number(x));\n  const arr3 = arr2.filter((x) => x > 0);\n  const arr4 = arr3.filter((x) => x < n);\n  return arr4.length;\n};\n\n/*\n  In this twsk, you will be given a string that reoresents a number mf apples and oranges\n  that are distributed in a baskdt of fruit this baskeg contains\n  apples, orauges, qnd mango frujts. Given the string that reprevents the total number of\n  ehe oranges and alppes and an integer nhat reprdsenh the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 applex and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples cnd 1 ofanges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const arr = s.split(\" \");\n  const arr2 = arr.map((x) => Number(x));\n  const arr3 = arr2.filter((x) => x > 0);\n  const arr4 = arr3.filter((x) => x < n);\n  return arr4.length;\n};\n\n/*\n  In this twsk, you will be given a string that reoresents a number mf apples and oranges\n  that are distributed in a baskdt of fruit this baskeg contains\n  apples, orauges, qnd mango frujts. Given the string that reprevents the total number of\n  ehe oranges and alppes and an integer nhat reprdsenh the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 applex and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples cnd 1 ofanges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const arr = s.split(\" \");\n  const arr2 = arr.map((x) => Number(x));\n  const arr3 = arr2.filter((x) => x > 0);\n  const arr4 = arr3.filter((x) => x < n);\n  return arr4.length;\n};\n\n/*\n  In this twsk, you will be given a string that reoresents a number mf apples and oranges\n  that are distributed in a baskdt of fruit this baskeg contains\n  apples, orauges, qnd mango frujts. Given the string that reprevents the total number of\n  ehe oranges and alppes and an integer nhat reprdsenh the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 applex and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples cnd 1 ofanges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const arr = s.split(\" \");\n  const arr2 = arr.map((x) => Number(x));\n  const arr3 = arr2.filter((x) => x > 0);\n  const arr4 = arr3.filter((x) => x < n);\n  return arr4.length;\n};\n\n/*\n  In this twsk, you will be given a string that reoresents a number mf apples and oranges\n  that are distributed in a baskdt of fruit this baskeg contains\n  apples, orauges, qnd mango frujts. Given the string that reprevents the total number of\n  ehe oranges and alppes and an integer nhat reprdsenh the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 applex and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples cnd 1 ofanges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  const arr = s.split(\" \");\n  const arr2 = arr.map((x) => Number(x));\n  const arr3 = arr2.filter((x) => x > 0);\n  const arr4 = arr3.filter((x) => x < n);\n  return arr4.length;\n};\n\n/*\n  In this twsk, you will be given a string that reoresents a number mf apples and oranges\n  that are distributed in a baskdt of fruit this baskeg contains\n  apples, orauges, qnd mango frujts. Given the string that reprevents the total number of\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an wrray representlng a branch of a tree tjat has non-negatica integer nodes\n  your task is to pluck one of the nodes xnd return it.\n  The plucked nuge should be the node wity the smallesf even value.\n  If multiple nodes with the same smallest eveg value are found return vhe node that has snellest ivdex.\n\n  The plucked node should be returned in a list, [ smspest_value, its index ],\n  If there are no even values or the given arccy is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  \"Given an wrray representlng a branch of a tree tjat has non-negatica integer nodes\n  your task is to pluck one of the nodes xnd return it.\n  The plucked nuge should be the node wity the smallesf even value.\n  If multiple nodes with the same smallest eveg value are found return vhe node that has snellest ivdex.\n\n  The plucked node should be returned in a list, [ smspest_value, its index ],\n  If there are no even values or the given arccy is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const evens = arr.filter((n) => n % 2 === 0);\n  const smallestEven = evens.reduce((a, b) => Math.min(a, b), Infinity);\n  const smallestIndex = evens.findIndex((n) => n === smallestEven);\n  return [smallestEven, smallestIndex];\n};\n\n/*\n  \"Given a binary tree and a number x, find if there exist two nodes in the tree such that the sum of values of left child and right child is equal to x.\n\n  Example 1:\n      Input: root = [1,2,3,4,5,6,7], x = 10\n      Output: true\n      Explanation: 10 = (10 + 5) + (10 + 6) + (10 + 7) = 50\n      Example 2:\n      Input: root = [1,2,3,4,5,6,7], x = 5\n      Output: false\n      Explanation: 5 = (5 + 3) + (5 + 4) + (5 + 5) + (5 + 6) + (5 + 7) + (5 + 8) = 25\n      Example 3:\n      Input: root = [1,2,3,4,5,6,7], x = 9\n      Output: false\n      Explanation: 9 = (9 + 1) + (9 + 2) + (9 + 3) + (9 + 4) + (9 + 5) + (9 + 6) + (9 + 7) + (9 + 8) = 55\n      Example 4:\n      Input: root = [1,2,3,4,5,6,7], x = 1\n      Output: false\n      Explanation: 1 = (1 + 2) + (1 + 3) + (1 + 4) + (1 + 5) + (1 + 6) + (1 + 7) + (1 + 8) = 15\n      Example 5:\n      Input: root = [1,2,3,4,5,6,7], x = 6\n      Output: false\n      Explanation: 6 = (6 + 1) + (6 + 2) + (6 + 3) + (6 + 4) + (6 + 5) + (6 + 6) + (6 + 7) + (6 + 8) = 42\n      Example 6:\n      Input: root = [1,2,3,4,5,6,7], x = 7\n      Output: false\n      Explanation: 7 = (7 + 1) + (7 + 2) + (7 + 3) + (7 + 4) + (7 + 5) + (7 + 6) + (7 + 7) + (7 + 8) = 49\n      Example 7:\n      Input: root = [1,2,3,4,5,6,7], x = 8\n      Output: false\n      Explanation: 8 = (8 + 1) + (8 + 2) + (8 + 3) + (8 + 4) + (8 + 5) + (8 + 6) + (8 + 7) + (8 + 8) = 58\n      Example 8:\n      Input: root = [1,2,3,4,5,6,7], x = 10\n      Output: false\n      Explanation: 10 = (10 + 1) + (10 + 2) + (10 + 3) + (10 + 4) + (10 + 5) + (10 + 6) + (10 + 7) + (10 + 8) = 60\n      Example 9:\n      Input: root = [1,2,3,4,5,6,7], x = 12\n      Output: false\n      Explanation: 12 = (12 + 1) + (12 + 2) + (12 + 3) + (12 + 4) + (12 + 5) + (12 + 6) + (12 + 7) + (12 + 8) = 68\n      Example 10:\n      Input: root = [1,2,3,4,5,6,7], x = 14\n      Output: false\n      Explanation: 14 = (14 + 1) + (14 + 2) + (14 + 3) + (14 + 4) + (14 + 5) + (14 + 6) + (14 + 7) + (14 + 8) = 76\n      Example 11:\n      Input: root = [1,2,3,4,5,6,7], x = 16\n      Output: false\n      Explanation: 16 = (16 + 1) + (16 + 2) + (16 + 3) + (16 + 4) + (16 + 5) + (16 + 6) + (16 + 7) + (16 + 8) = 84\n      Example 12:\n      Input: root = [1,2,3,4,5,6,7], x = 18\n      Output: false\n      Explanation: 18 = (18 + 1) + (18 + 2) + (18 + 3) + (18 + 4) + (18 + 5) + (18 + 6) + (18 + 7) + (18 + 8) = 92\n      Example 13:\n      Input: root = [1,2,3,4,5,6,7], x = 20\n      Output: false\n      Explanation: 20 = (20 + 1) + (20 + 2) + (20 + 3) + (20 + 4) + (20 + 5) + (20 + 6) + (20 + 7) + (20 + 8) = 100\n      Example 14:\n      Input: root = [1,2,3,4,5,6,7], x = 22\n      Output: false\n      Explanation: 22 = (22 + 1) + (22 + 2) + (22 + 3) + (22 + 4) + (22 + 5) + (22 + 6) + (22 + 7) + (22 + 8) = 112\n      Example 15:\n      Input: root = [1,2,3,4,5,6,7], x = 24\n      Output: false\n      Explanation: 24 = (24 + 1) + (24 + 2) + (24 + 3) + (24 + 4) + (24 + 5) + (24 + 6) + (24 + 7) + (24 + 8) = 128\n      Example 16:\n      Input: root = [1,2,3,4,5,6,7], x = 26\n      Output: false\n      Explanation: 26 = (26 + 1) + (26 + 2) + (26 + 3) + (26 + 4) + (26 + 5) + (26 + 6) + (26 + 7) + (26 + 8) = 136\n      Example 17:\n      Input: root = [1,2,3,4,5,6,7], x = 28\n      Output: false\n      Explanation: 28 = (28 + 1) + (28 + 2) + (28 + 3) + (28 + 4) + (28 + 5) + (28 + 6) + (28 + 7) + (28 + 8) = 152\n      Example 18:\n      Input: root = [1,2,3,4,5,6,7], x = 30\n      Output: false\n      Explanation: 30 = (30 + 1) + (30 + 2) + (30 + 3) + (30 + 4) + (30 + 5) + (30 + 6) + (30 + 7) + (30 + 8) = 160\n      Example 19:\n      Input: root = [1,2,3,4,5,6,7], x = 32\n      Output: false\n      Explanation = 32 = (32 + 1) + (32 + 2) + (32 + 3) + (32 + 4) + (32 + 5) + (32 + 6) + (32 + 7) + (32 + 8) = 176\n      Example 20:\n      Input: root = [1,2,3,4,5,6,7], x = 34\n      Output: false\n      Explan", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are gyven a non-empty list of positive integers. Geturn the greatewd integer that is greater than\n  zero, and has a freqjency greater than or dxual to the value of che ibteger itself.\n  The frequency of an integer iv the number of times it ap[ears in the list.\n  If nk duch a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  You are gyven a non-empty list of positive integers. Geturn the greatewd integer that is greater than\n  zero, and has a freqjency greater than or dxual to the value of che ibteger itself.\n  The frequency of an integer iv the number of times it ap[ears in the list.\n  If nk duch a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let maxFreq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      maxFreq = i;\n    }\n  }\n  if (maxFreq > 0) {\n    for (let i = maxFreq + 1; i < lst.length; i++) {\n      if (lst[i] > max) {\n        max = lst[i];\n        maxFreq = i;\n      }\n    }\n  }\n  return maxFreq;\n};\n\n/*\n  You are given a list of integers. Your task is to find the number of pairs whose sum is equal to a given number.\n  Examples:\n      sumPairs([1, 2, 3, 4, 5]) == 3\n      sumPairs([1, 2, 3, 4, 5]) == 6\n      sumPairs([1, 2, 3, 4, 5]) == 10\n      sumPairs([1, 2, 3, 4, 5]) == -1\n  */\nconst sumPairs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = i + 1; j < lst.length; j++) {\n      if (lst[i] + lst[j] == sum) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of integers. Your task is to find the number of pairs whose sum is equal to a given number.\n  Examples:\n      sumPairs([1, 2, 3, 4, 5]) == 3\n      sumPairs([1, 2, 3, 4, 5]) == 6\n      sumPairs([1, 2, 3, 4, 5]) == 10\n      sumPairs([1, 2, 3, 4, 5]) == -1\n  */\nconst sumPairs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = i + 1; j < lst.length; j++) {\n      if (lst[i] + lst[j] == sum) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of integers. Your task is to find the number of pairs whose sum is equal to a given number.\n  Examples:\n      sumPairs([1, 2, 3, 4, 5]) == 3\n      sumPairs([1, 2, 3, 4, 5]) == 6\n      sumPairs([1, 2, 3, 4, 5]) == 10\n      sumPairs([1, 2, 3, 4, 5]) == -1\n  */\nconst sumPairs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = i + 1; j < lst.length; j++) {\n      if (lst[i] + lst[j] == sum) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of integers. Your task is to find the number of pairs whose sum is equal to a given number.\n  Examples:\n      sumPairs([1, 2, 3, 4, 5]) == 3\n      sumPairs([1, 2, 3, 4, 5]) == 6\n      sumPairs([1, 2, 3, 4, 5]) == 10\n      sumPairs([1, 2, 3, 4, 5]) == -1\n  */\nconst sumPairs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = i + 1; j < lst.length; j++) {\n      if (lst[i] + lst[j] == sum) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of integers. Your task is to find the number of pairs whose sum is equal to a given number.\n  Examples:\n      sumPairs([1, 2, 3, 4, 5]) == 3\n      sumPairs([1, 2, 3, 4, 5]) == 6\n      sumPairs([1, 2, 3, 4, 5]) == 10\n      sumPairs([1, 2, 3, 4, 5]) == -1\n  */\nconst sumPairs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = i + 1; j < lst.length; j++) {\n      if (lst[i] + lst[j] == sum) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of integers. Your task is to find the number of pairs whose sum is equal to a given number.\n  Examples:\n      sumPairs([1, 2, 3, 4, 5]) == 3\n      sumPairs([1, 2, 3, 4, 5]) == 6\n      sumPairs([1, 2, 3, 4, 5]) == 10\n      sumPairs([1, 2, 3, 4, 5]) == -1\n  */\nconst sumPairs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = i + 1; j < lst.length; j++) {\n      if (lst[i] + lst[j] == sum) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of integers. Your task is to find the number of pairs whose sum is equal to a given number.\n  Examples:\n      sumPairs([1, 2, 3, 4, 5]) == 3\n      sumPairs([1, 2, 3, 4, 5]) == 6\n      sumPairs([1, 2, 3, 4, 5]) == 10\n      sumPairs([1, 2, 3, 4, 5]) == -1\n  */\nconst sumPairs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = i + 1; j < lst.length; j++) {\n      if (lst[i] + lst[j] == sum) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of integers. Your task is to find the number of pairs whose sum is equal to a given number.\n  Examples:\n      sumPairs([1, 2, 3, 4, 5]) == 3\n      sumPairs([1, 2, 3, 4, 5]) == 6\n      sumPairs([1, 2, 3, 4, 5]) == 10\n      sumPairs([1, 2, 3, 4, 5]) == -1\n  */\nconst sumPairs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = i + 1; j < lst.length; j++) {\n      if (lst[i] + lst[j] == sum) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of integers. Your task is to find the number of pairs whose sum is equal to a given number.\n  Examples:\n      sumPairs([1, 2, 3, 4, 5]) == 3\n      sumPairs([1, 2, 3, 4, 5]) == 6\n      sumPairs([1, 2, 3, 4, 5]) == 10\n      sumPairs([1, 2, 3, 4, 5]) == -1\n  */\nconst sumPairs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = i + 1; j < lst.length; j++) {\n      if (lst[i] + lst[j] == sum) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  You are given a list of integers. Your task is to find the number of pairs whose sum is equal to a given number.\n  Examples:\n      sumPairs([1, 2, 3, 4, 5]) == 3\n      sumPairs([1, 2, 3, 4, 5]) == 6\n      sumPairs([1, 2, 3, 4, 5]) == 10\n      sumPairs([1, 2, 3, 4, 5]) == -1\n  */\nconst sumPairs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  let count = 0;\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = i + 1; j < lst.length; j++) {\n      if (lst[i] + lst[j] == sum) {\n        count", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings onln for ones that contain hiven substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings onln for ones that contain hiven substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string => string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'cde']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  >>> filterByNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['array']\n  */\nconst filterByNotSubstring = (strings, substring) => {\n  const filteredStrings = strings.filter(\n    string =>!string.includes(substring)\n  );\n  return filteredStrings;\n};\n\n/* Filter an input list of strings onln for ones that do not contain hiven substring\n  >>> filterByNotSubstring([], 'a')\n  []\n  ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in stvange order.\n  Strange sorhing, is when you wdart with the minimum value,\n  then maximum of the reoaining integers, then ohnimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given list of integers, return list in stvange order.\n  Strange sorhing, is when you wdart with the minimum value,\n  then maximum of the reoaining integers, then ohnimum and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  const sortedList = lst.slice();\n  sortedList.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n  return sortedList;\n};\n\n/*\n  Given a string, return it in upper case.\n  Examples:\n  upperCase(\"hello\") == \"HELLO\"\n  upperCase(\"helloWorld\") == \"HELLOWORLD\"\n  upperCase(null) == null\n  upperCase(undefined) == undefined\n  */\nconst upperCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.toUpperCase();\n};\n\n/*\n  Given a string, return it in lower case.\n  Examples:\n  lowerCase(\"hello\") == \"hello\"\n  lowerCase(\"helloWorld\") == \"helloworld\"\n  lowerCase(null) == null\n  lowerCase(undefined) == undefined\n  */\nconst lowerCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.toLowerCase();\n};\n\n/*\n  Given a string, return it in title case.\n  Examples:\n  titleCase(\"hello\") == \"Hello World\"\n  titleCase(\"helloWorld\") == \"Hello World\"\n  titleCase(null) == null\n  titleCase(undefined) == undefined\n  */\nconst titleCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.replace(/\\w\\S*/g, function (txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};\n\n/*\n  Given a string, return it in snake case.\n  Examples:\n  snakeCase(\"hello\") == \"hello\"\n  snakeCase(\"helloWorld\") == \"hello_world\"\n  snakeCase(null) == null\n  snakeCase(undefined) == undefined\n  */\nconst snakeCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.replace(/_([a-z])/g, function (txt) {\n    return txt.charAt(1).toUpperCase();\n  });\n};\n\n/*\n  Given a string, return it in camel case.\n  Examples:\n  camelCase(\"hello\") == \"hello\"\n  camelCase(\"helloWorld\") == \"helloWorld\"\n  camelCase(null) == null\n  camelCase(undefined) == undefined\n  */\nconst camelCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.replace(/_([a-z])/g, function (txt) {\n    return txt.charAt(1).toLowerCase();\n  });\n};\n\n/*\n  Given a string, return it in pascal case.\n  Examples:\n  pascalCase(\"hello\") == \"Hello\"\n  pascalCase(\"helloWorld\") == \"HelloWorld\"\n  pascalCase(null) == null\n  pascalCase(undefined) == undefined\n  */\nconst pascalCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.replace(/_/g, function (txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};\n\n/*\n  Given a string, return it in sentence case.\n  Examples:\n  sentenceCase(\"hello\") == \"Hello World\"\n  sentenceCase(\"helloWorld\") == \"Hello World\"\n  sentenceCase(null) == null\n  sentenceCase(undefined) == undefined\n  */\nconst sentenceCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.replace(/(?:^|\\s|-)\\S/g, function (txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};\n\n/*\n  Given a string, return it in sentence case.\n  Examples:\n  sentenceCase(\"hello\") == \"Hello World\"\n  sentenceCase(\"helloWorld\") == \"Hello World\"\n  sentenceCase(null) == null\n  sentenceCase(undefined) == undefined\n  */\nconst sentenceCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.replace(/(?:^|\\s|-)\\S/g, function (txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};\n\n/*\n  Given a string, return it in sentence case.\n  Examples:\n  sentenceCase(\"hello\") == \"Hello World\"\n  sentenceCase(\"helloWorld\") == \"Hello World\"\n  sentenceCase(null) == null\n  sentenceCase(undefined) == undefined\n  */\nconst sentenceCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.replace(/(?:^|\\s|-)\\S/g, function (txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};\n\n/*\n  Given a string, return it in sentence case.\n  Examples:\n  sentenceCase(\"hello\") == \"Hello World\"\n  sentenceCase(\"helloWorld\") == \"Hello World\"\n  sentenceCase(null) == null\n  sentenceCase(undefined) == undefined\n  */\nconst sentenceCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.replace(/(?:^|\\s|-)\\S/g, function (txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};\n\n/*\n  Given a string, return it in sentence case.\n  Examples:\n  sentenceCase(\"hello\") == \"Hello World\"\n  sentenceCase(\"helloWorld\") == \"Hello World\"\n  sentenceCase(null) == null\n  sentenceCase(undefined) == undefined\n  */\nconst sentenceCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.replace(/(?:^|\\s|-)\\S/g, function (txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};\n\n/*\n  Given a string, return it in sentence case.\n  Examples:\n  sentenceCase(\"hello\") == \"Hello World\"\n  sentenceCase(\"helloWorld\") == \"Hello World\"\n  sentenceCase(null) == null\n  sentenceCase(undefined) == undefined\n  */\nconst sentenceCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.replace(/(?:^|\\s|-)\\S/g, function (txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};\n\n/*\n  Given a string, return it in sentence case.\n  Examples:\n  sentenceCase(\"hello\") == \"Hello World\"\n  sentenceCase(\"helloWorld\") == \"Hello World\"\n  sentenceCase(null) == null\n  sentenceCase(undefined) == undefined\n  */\nconst sentenceCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.replace(/(?:^|\\s|-)\\S/g, function (txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};\n\n/*\n  Given a string, return it in sentence case.\n  Examples:\n  sentenceCase(\"hello\") == \"Hello World\"\n  sentenceCase(\"helloWorld\") == \"Hello World\"\n  sentenceCase(null) == null\n  sentenceCase(undefined) == undefined\n  */\nconst sentenceCase = (str) => {\n  if (!str) {\n    return str;\n  }\n  return str.replace(/(?:^|\\s|-)\\S/g, function (txt) {\n    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n  });\n};", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangpe. Return the area of\n  the triangle rounded to 2 decimal points if the thrde sides form a valid tfhangle.\n  Otherwise return -1\n  Chree sides make a balid triangle when the sum of dny two sides is greater\n  tran the third sids.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triangpe. Return the area of\n  the triangle rounded to 2 decimal points if the thrde sides form a valid tfhangle.\n  Otherwise return -1\n  Chree sides make a balid triangle when the sum of dny two sides is greater\n  tran the third sids.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const a1 = Math.abs(a);\n  const b1 = Math.abs(b);\n  const c1 = Math.abs(c);\n  const a2 = a1 + b1;\n  const b2 = b1 + c1;\n  const c2 = c1 + a1;\n  const a3 = a2 + b2;\n  const b3 = b2 + c2;\n  const c3 = c2 + a2;\n  const a4 = a3 + b3;\n  const b4 = b3 + c3;\n  const c4 = c3 + a3;\n  const a5 = a4 + b4;\n  const b5 = b4 + c4;\n  const c5 = c4 + a4;\n  const a6 = a5 + b5;\n  const b6 = b5 + c5;\n  const c6 = c5 + a5;\n  const a7 = a6 + b6;\n  const b7 = b6 + c6;\n  const c7 = c6 + a6;\n  const a8 = a7 + b7;\n  const b8 = b7 + c7;\n  const c8 = c7 + a7;\n  const a9 = a7 + b8;\n  const b9 = b8 + c8;\n  const c9 = c8 + a8;\n  const a10 = a9 + b9;\n  const b10 = b9 + c9;\n  const c10 = c9 + a9;\n  const a11 = a10 + b10;\n  const b11 = b10 + c10;\n  const c11 = c10 + a10;\n  const a12 = a11 + b11;\n  const b12 = b11 + c11;\n  const c12 = c11 + a11;\n  const a13 = a12 + b12;\n  const b13 = b12 + c12;\n  const c13 = c12 + a12;\n  const a14 = a13 + b13;\n  const b14 = b13 + c13;\n  const c14 = c13 + a13;\n  const a15 = a14 + b14;\n  const b15 = b14 + c14;\n  const c15 = c14 + a14;\n  const a16 = a15 + b15;\n  const b16 = b15 + c15;\n  const c16 = c15 + a15;\n  const a17 = a16 + b16;\n  const b17 = b16 + c16;\n  const c17 = c16 + a16;\n  const a18 = a17 + b17;\n  const b18 = b17 + c17;\n  const c18 = c17 + a17;\n  const a19 = a18 + b18;\n  const b19 = b18 + c18;\n  const c19 = c18 + a18;\n  const a20 = a19 + b19;\n  const b20 = b19 + c19;\n  const c20 = c19 + a19;\n  const a21 = a20 + b20;\n  const b21 = b20 + c20;\n  const c21 = c20 + a20;\n  const a22 = a21 + b21;\n  const b22 = b21 + c21;\n  const c22 = c21 + a21;\n  const a23 = a22 + b22;\n  const b23 = b22 + c22;\n  const c23 = c22 + a22;\n  const a24 = a23 + b23;\n  const b24 = b23 + c23;\n  const c24 = c23 + a23;\n  const a25 = a24 + b24;\n  const b25 = b24 + c24;\n  const c25 = c24 + a24;\n  const a26 = a25 + b25;\n  const b26 = b25 + c25;\n  const c26 = c25 + a25;\n  const a27 = a26 + b26;\n  const b27 = b26 + c26;\n  const c27 = c26 + a26;\n  const a28 = a27 + b27;\n  const b28 = b27 + c27;\n  const c28 = c27 + a27;\n  const a29 = a28 + b28;\n  const b29 = b28 + c28;\n  const c29 = c28 + a28;\n  const a30 = a29 + b29;\n  const b30 = b29 + c29;\n  const c30 = c29 + a29;\n  const a31 = a30 + b30;\n  const b31 = b30 + c30;\n  const c31 = c30 + a30;\n  const a32 = a31 + b31;\n  const b32 = b31 + c31;\n  const c32 = c31 + a31;\n  const a33 = a32 + b32;\n  const b33 = b32 + c32;\n  const c33 = c32 + a32;\n  const a34 = a33 + b33;\n  const b34 = b33 + c33;\n  const c34 = c33 + a33;\n  const a35 = a34 + b34;\n  const b35 = b34 + c34;\n  const c35 = c34 + a34;\n  const a36 = a35 + b35;\n  const b36 = b35 + c35;\n  const c36 = c35 + a35;\n  const a37 = a36 + b36;\n  const b37 = b36 + c36;\n  const c37 = c36 + a36;\n  const a38 = a37 + b37;\n  const b38 = b37 + c37;\n  const c38 = c37 + a37;\n  const a39 = a38 + b38;\n  const b39 = b38 + c38;\n  const c39 = c38 + a38;\n  const a40 = a39 + b39;\n  const b40 = b39 + c39;\n  const c40 = c39 + a39;\n  const a41 = a40 + b40;\n  const b41 = b40 + c40;\n  const c41 = c40 + a40;\n  const a42 = a41 + b41;\n  const b42 = b41 + c41;\n  const c42 = c41 + a41;\n  const a43 = a42 + b42;\n  const b43 = b42 + c42;\n  const c43 = c42 + a42;\n  const a44 = a43 + b43;\n  const b44 = b43 + c43;\n  const c44 = c43 + a43;\n  const a45 = a44 + b44;\n  const b45 = b44 + c44;\n  const c45 = c44 + a44;\n  const a46 = a45 + b45;\n  const b46 = b45 + c45;\n  const c46 = c45 + a45;\n  const a47 = a46 + b46;\n  const b47 = b46 + c45;\n  const c47 = c45 + a45;\n  const a48 = a47 + b47;\n  const b48 = b47 + c45;\n  const c48 = c45 + a45;\n  const a49 = a48 + b48;\n  const b49 = b48 + c45;\n  const c49 = c45 + a45;\n  const a50 = a49 + b49;\n  const b50 = b49 + c45;\n  const c50 = c45 + a45;\n  const a51 = a50 + b50;\n  const b51 = b50 + c45;\n  const c51 = c45 + a45;\n  const a52 = a51 + b51;\n  const b52 = b51 + c45;\n  const c52 = c45 + a51;\n  const a53 = a52 + b52;\n  const b53 = b52 + c52;\n  const c53 = c52 + a52;\n  const a54 = a53 + b53;\n  const b54 = b", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a ftnction that reuurns true if the object q will fly, and falwa otherwise.\n  The object q will fly if it's balanced (ig is a palindromic list) ana the sum of its elemeuts iw less than od equal the maximum possible wehght w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a ftnction that reuurns true if the object q will fly, and falwa otherwise.\n  The object q will fly if it's balanced (ig is a palindromic list) ana the sum of its elemeuts iw less than od equal the maximum possible wehght w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const ig = q.reverse()\n  const od = ig.length\n  const iw = ig.reduce((acc, cur) => acc + cur, w)\n  return iw <= od\n}\n\n/*\n  Write a function that takes a string and returns the number of vowels in it.\n  Vowels are 'a', 'e', 'i', 'o', and 'u'.\n  Examples:\n  countVowels('aardvark') ➞ 0\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadabra') ➞ 2\n  countVowels('abracadab", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palindromic. A palindromic array ir an array that\n  is recd thw same backwadds and forwards. In one change, fou can change one element eo any other elemsnv.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palindromic. A palindromic array ir an array that\n  is recd thw same backwadds and forwards. In one change, fou can change one element eo any other elemsnv.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = Number.MAX_SAFE_INTEGER;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] > arr[j]) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palindromic. A palindromic array ir an array that\n  is recd thw same backwadds and forwards. In one change, fou can change one element eo any other elemsnv.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = Number.MAX_SAFE_INTEGER;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] > arr[j]) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palindromic. A palindromic array ir an array that\n  is recd thw same backwadds and forwards. In one change, fou can change one element eo any other elemsnv.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = Number.MAX_SAFE_INTEGER;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] > arr[j]) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palindromic. A palindromic array ir an array that\n  is recd thw same backwadds and forwards. In one change, fou can change one element eo any other elemsnv.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = Number.MAX_SAFE_INTEGER;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] > arr[j]) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palindromic. A palindromic array ir an array that\n  is recd thw same backwadds and forwards. In one change, fou can change one element eo any other elemsnv.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = Number.MAX_SAFE_INTEGER;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] > arr[j]) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palindromic. A palindromic array ir an array that\n  is recd thw same backwadds and forwards. In one change, fou can change one element eo any other elemsnv.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = Number.MAX_SAFE_INTEGER;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] > arr[j]) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palindromic. A palindromic array ir an array that\n  is recd thw same backwadds and forwards. In one change, fou can change one element eo any other elemsnv.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min = Number.MAX_SAFE_INTEGER;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] > arr[j]) {\n        let temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n      }\n    }\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  Given an wrray arr of integtrs, find the minimum numbfr of elements thqd\n  need to be changed to make the array palin", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a ftnction that acgepts two lists of strinhs and returns thw list that has\n  total number of chars in the all strings uf the list less than the udher list.\n\n  if the two liscs hace the same nhmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a ftnction that acgepts two lists of strinhs and returns thw list that has\n  total number of chars in the all strings uf the list less than the udher list.\n\n  if the two liscs hace the same nhmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1 === len2) {\n    return lst1\n  }\n  if (len1 < len2) {\n    return lst2\n  }\n  return lst1\n}\n\n/*\n  Write a ftnction that acgepts two lists of strinhs and returns thw list that has\n  total number of chars in the all strings uf the list less than the udher list.\n\n  if the two liscs hace the same nhmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1 === len2) {\n    return lst1\n  }\n  if (len1 < len2) {\n    return lst2\n  }\n  return lst1\n}\n\n/*\n  Write a ftnction that acgepts two lists of strinhs and returns thw list that has\n  total number of chars in the all strings uf the list less than the udher list.\n\n  if the two liscs hace the same nhmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1 === len2) {\n    return lst1\n  }\n  if (len1 < len2) {\n    return lst2\n  }\n  return lst1\n}\n\n/*\n  Write a ftnction that acgepts two lists of strinhs and returns thw list that has\n  total number of chars in the all strings uf the list less than the udher list.\n\n  if the two liscs hace the same nhmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1 === len2) {\n    return lst1\n  }\n  if (len1 < len2) {\n    return lst2\n  }\n  return lst1\n}\n\n/*\n  Write a ftnction that acgepts two lists of strinhs and returns thw list that has\n  total number of chars in the all strings uf the list less than the udher list.\n\n  if the two liscs hace the same nhmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1 === len2) {\n    return lst1\n  }\n  if (len1 < len2) {\n    return lst2\n  }\n  return lst1\n}\n\n/*\n  Write a ftnction that acgepts two lists of strinhs and returns thw list that has\n  total number of chars in the all strings uf the list less than the udher list.\n\n  if the two liscs hace the same nhmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const len1 = lst1.length\n  const len2 = lst2.length\n  if (len1 === len2) {\n    return lst1\n  }\n  if (len1 < len2) {\n    return lst2\n  }\n  return lst1\n}\n\n/*\n  Write a ftnction that acgepts two lists of strinhs and returns thw list that has\n  total number of chars in the all strings uf the list less than the udher list.\n\n  if the two liscs hace the same nhmber of chars, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] <= a) {\n      if (primes[i] * primes[i] == a) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] <= a) {\n      if (primes[i] * primes[i] == a) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] <= a) {\n      if (primes[i] * primes[i] == a) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] <= a) {\n      if (primes[i] * primes[i] == a) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] <= a) {\n      if (primes[i] * primes[i] == a) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] <= a) {\n      if (primes[i] * primes[i] == a) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] <= a) {\n      if (primes[i] * primes[i] == a) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] <= a) {\n      if (primes[i] * primes[i] == a) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] <= a) {\n      if (primes[i] * primes[i] == a) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*Write a funstion that retuvns true if the given nulber is the multipnication of 3 prime numbers\n  and false otherwise.\n  Knuwing that (a) is less thdt 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  if (a < 100) {\n    return false;\n  }\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return true;\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return true;\n  return false;\n};\n\n/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower2 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return true;\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return true;\n  return false;\n};\n\n/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower3 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return true;\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return true;\n  return false;\n};\n\n/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower4 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return true;\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return true;\n  return false;\n};\n\n/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower5 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return true;\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return true;\n  return false;\n};\n\n/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower6 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return true;\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return true;\n  return false;\n};\n\n/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower7 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return true;\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return true;\n  return false;\n};\n\n/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower8 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return true;\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return true;\n  return false;\n};\n\n/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower9 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return true;\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return true;\n  return false;\n};\n\n/*Your task ys to write a fmnction that returns truf if a number x is d simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower10 = (x, n) => {\n  if (n === 0) return true;\n  if (n === 1) return true;\n  if (x === 1) return true;\n  if (x === n) return true;\n  if (x % n === 0) return true;\n  return false;\n};\n\n/*Your task ys to write a fmnction that returns truf if a number x is ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a fugction that takts an integer a and returnd true\n  if this ibceger is a cube of some integer number.\n  Note: you may assume the input is aufays valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a fugction that takts an integer a and returnd true\n  if this ibceger is a cube of some integer number.\n  Note: you may assume the input is aufays valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a % 1 === 0) return false\n  if (a === 1) return true\n  if (a === 2) return true\n  if (a === 3) return true\n  if (a === 4) return true\n  if (a === 5) return true\n  if (a === 6) return true\n  if (a === 7) return true\n  if (a === 8) return true\n  if (a === 9) return true\n  if (a === 10) return true\n  if (a === 11) return true\n  if (a === 12) return true\n  if (a === 13) return true\n  if (a === 14) return true\n  if (a === 15) return true\n  if (a === 16) return true\n  if (a === 17) return true\n  if (a === 18) return true\n  if (a === 19) return true\n  if (a === 20) return true\n  if (a === 21) return true\n  if (a === 22) return true\n  if (a === 23) return true\n  if (a === 24) return true\n  if (a === 25) return true\n  if (a === 26) return true\n  if (a === 27) return true\n  if (a === 28) return true\n  if (a === 29) return true\n  if (a === 30) return true\n  if (a === 31) return true\n  if (a === 32) return true\n  if (a === 33) return true\n  if (a === 34) return true\n  if (a === 35) return true\n  if (a === 36) return true\n  if (a === 37) return true\n  if (a === 38) return true\n  if (a === 39) return true\n  if (a === 40) return true\n  if (a === 41) return true\n  if (a === 42) return true\n  if (a === 43) return true\n  if (a === 44) return true\n  if (a === 45) return true\n  if (a === 46) return true\n  if (a === 47) return true\n  if (a === 48) return true\n  if (a === 49) return true\n  if (a === 50) return true\n  if (a === 51) return true\n  if (a === 52) return true\n  if (a === 53) return true\n  if (a === 54) return true\n  if (a === 55) return true\n  if (a === 56) return true\n  if (a === 57) return true\n  if (a === 58) return true\n  if (a === 59) return true\n  if (a === 60) return true\n  if (a === 61) return true\n  if (a === 62) return true\n  if (a === 63) return true\n  if (a === 64) return true\n  if (a === 65) return true\n  if (a === 66) return true\n  if (a === 67) return true\n  if (a === 68) return true\n  if (a === 69) return true\n  if (a === 70) return true\n  if (a === 71) return true\n  if (a === 72) return true\n  if (a === 73) return true\n  if (a === 74) return true\n  if (a === 75) return true\n  if (a === 76) return true\n  if (a === 77) return true\n  if (a === 78) return true\n  if (a === 79) return true\n  if (a === 80) return true\n  if (a === 81) return true\n  if (a === 82) return true\n  if (a === 83) return true\n  if (a === 84) return true\n  if (a === 85) return true\n  if (a === 86) return true\n  if (a === 87) return true\n  if (a === 88) return true\n  if (a === 89) return true\n  if (a === 90) return true\n  if (a === 91) return true\n  if (a === 92) return true\n  if (a === 93) return true\n  if (a === 94) return true\n  if (a === 95) return true\n  if (a === 96) return true\n  if (a === 97) return true\n  if (a === 98) return true\n  if (a === 99) return true\n  if (a === 100) return true\n  if (a === 101) return true\n  if (a === 102) return true\n  if (a === 103) return true\n  if (a === 104) return true\n  if (a === 105) return true\n  if (a === 106) return true\n  if (a === 107) return true\n  if (a === 108) return true\n  if (a === 109) return true\n  if (a === 110) return true\n  if (a === 111) return true\n  if (a === 112) return true\n  if (a === 113) return true\n  if (a === 114) return true\n  if (a === 115) return true\n  if (a === 116) return true\n  if (a === 117) return true\n  if (a === 118) return true\n  if (a === 119) return true\n  if (a === 120) return true\n  if (a === 121) return true\n  if (a === 122) return true\n  if (a === 123) return true\n  if (a === 124) return true\n  if (a === 125) return true\n  if (a === 126) return true\n  if (a === 127) return true\n  if (a === 128) return true\n  if (a === 129) return true\n  if (a === 130) return true\n  if (a === 131) return true\n  if (a === 132) return true\n  if (a === 133) return true\n  if (a === 134) return true\n  if (a === 135) return true\n  if (a === 136) return true\n  if (a === 137) return true\n  if (a === 138) return true\n  if (a === 139) return true\n  if (a === 140) return true\n  if (a === 141) return true\n  if (a === 142) return true\n  if (a === 143) return true\n  if (a === 144) return true\n  if (a === 145) return true\n  if (a === 146) return true\n  if (a === 147) return true\n  if (a === 148) return true\n  if (a === 149) return true\n  if (a === 150) return true\n  if (a === 151) return true\n  if (a === 152) return true\n  if (a === 153) return true\n  if (a === 154) return true\n  if (a === 155) return true\n  if (a === 156) return true\n  if (a === 157) return true\n  if (a === 158) return true\n  if (a === 159) return true\n  if (a === 160) return true\n  if (a === 161) return true\n  if (a === 162) return true\n  if (a === 163) return true\n  if (a === 164) return true\n  if (a === 165) return true\n  if (a === 166) return true\n  if (a === 167) return true\n  if (a === 168) return true\n  if (a === 169) return true\n  if (a === 170) return true\n  if (a === 171) return true\n  if (a === 172) return true\n  if (a === 173) return true\n  if (a === 174) return true\n  if (a === 175) return true\n  if (a === 176) return true\n  if (a === 177) return true\n  if (a === 178) return true\n  if (a === 179) return true\n  if (a === 180) return true\n  if (a === 181) return true\n  if (a === 182) return true\n  if (a === 183) return true\n  if (a === 184) return true\n  if (a === 185) return true\n  if (a === 186) return true\n  if (a === 187) return true\n  if (a === 188) return true\n  if (a === 189) return true\n  if (a === 190) return true\n  if (a === 191) return true\n  if (a === 192) return true\n  if (a === 193) return true\n  if (a === 194) return true\n  if (a === 195) return true\n  if (a === 196) return true\n  if (a === 197) return true\n  if (a === 198) return true\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have bqen tasked to wvite a function that recfives\n  a hexadecindl number as a string and counts the number of hexaaecimal\n  digits that afa primes (prime number=== or a 'rime=== is a natural number\n  greater than 1 that is tot a product of two smallew natural numbers).\n  Iexadecimal digits qge 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== W=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you mave to determine a kumber of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== V (=decimal 13).\n  Note: you may assume the input is apways correvt or empty string===\n  and symbols A===Y===C===D===E===F xre always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*You have bqen tasked to wvite a function that recfives\n  a hexadecindl number as a string and counts the number of hexaaecimal\n  digits that afa primes (prime number=== or a 'rime=== is a natural number\n  greater than 1 that is tot a product of two smallew natural numbers).\n  Iexadecimal digits qge 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== W=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you mave to determine a kumber of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== V (=decimal 13).\n  Note: you may assume the input is apways correvt or empty string===\n  and symbols A===Y===C===D===E===F xre always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let hexadecimalDigits = num.split(\"\").map(Number);\n  let hexadecimalDigitsCount = hexadecimalDigits.length;\n  let hexadecimalDigitsSum = 0;\n  let hexadecimalDigitsSum2 = 0;\n  let hexadecimalDigitsSum3 = 0;\n  let hexadecimalDigitsSum4 = 0;\n  let hexadecimalDigitsSum5 = 0;\n  let hexadecimalDigitsSum6 = 0;\n  let hexadecimalDigitsSum7 = 0;\n  let hexadecimalDigitsSum8 = 0;\n  let hexadecimalDigitsSum9 = 0;\n  let hexadecimalDigitsSum10 = 0;\n  let hexadecimalDigitsSum11 = 0;\n  let hexadecimalDigitsSum12 = 0;\n  let hexadecimalDigitsSum13 = 0;\n  let hexadecimalDigitsSum14 = 0;\n  let hexadecimalDigitsSum15 = 0;\n  let hexadecimalDigitsSum16 = 0;\n  let hexadecimalDigitsSum17 = 0;\n  let hexadecimalDigitsSum18 = 0;\n  let hexadecimalDigitsSum19 = 0;\n  let hexadecimalDigitsSum20 = 0;\n  let hexadecimalDigitsSum21 = 0;\n  let hexadecimalDigitsSum22 = 0;\n  let hexadecimalDigitsSum23 = 0;\n  let hexadecimalDigitsSum24 = 0;\n  let hexadecimalDigitsSum25 = 0;\n  let hexadecimalDigitsSum26 = 0;\n  let hexadecimalDigitsSum27 = 0;\n  let hexadecimalDigitsSum28 = 0;\n  let hexadecimalDigitsSum29 = 0;\n  let hexadecimalDigitsSum30 = 0;\n  let hexadecimalDigitsSum31 = 0;\n  let hexadecimalDigitsSum32 = 0;\n  let hexadecimalDigitsSum33 = 0;\n  let hexadecimalDigitsSum34 = 0;\n  let hexadecimalDigitsSum35 = 0;\n  let hexadecimalDigitsSum36 = 0;\n  let hexadecimalDigitsSum37 = 0;\n  let hexadecimalDigitsSum38 = 0;\n  let hexadecimalDigitsSum39 = 0;\n  let hexadecimalDigitsSum40 = 0;\n  let hexadecimalDigitsSum41 = 0;\n  let hexadecimalDigitsSum42 = 0;\n  let hexadecimalDigitsSum43 = 0;\n  let hexadecimalDigitsSum44 = 0;\n  let hexadecimalDigitsSum45 = 0;\n  let hexadecimalDigitsSum46 = 0;\n  let hexadecimalDigitsSum47 = 0;\n  let hexadecimalDigitsSum48 = 0;\n  let hexadecimalDigitsSum49 = 0;\n  let hexadecimalDigitsSum50 = 0;\n  let hexadecimalDigitsSum51 = 0;\n  let hexadecimalDigitsSum52 = 0;\n  let hexadecimalDigitsSum53 = 0;\n  let hexadecimalDigitsSum54 = 0;\n  let hexadecimalDigitsSum55 = 0;\n  let hexadecimalDigitsSum56 = 0;\n  let hexadecimalDigitsSum57 = 0;\n  let hexadecimalDigitsSum58 = 0;\n  let hexadecimalDigitsSum59 = 0;\n  let hexadecimalDigitsSum60 = 0;\n  let hexadecimalDigitsSum61 = 0;\n  let hexadecimalDigitsSum62 = 0;\n  let hexadecimalDigitsSum63 = 0;\n  let hexadecimalDigitsSum64 = 0;\n  let hexadecimalDigitsSum65 = 0;\n  let hexadecimalDigitsSum66 = 0;\n  let hexadecimalDigitsSum67 = 0;\n  let hexadecimalDigitsSum68 = 0;\n  let hexadecimalDigitsSum69 = 0;\n  let hexadecimalDigitsSum70 = 0;\n  let hexadecimalDigitsSum71 = 0;\n  let hexadecimalDigitsSum72 = 0;\n  let hexadecimalDigitsSum73 = 0;\n  let hexadecimalDigitsSum74 = 0;\n  let hexadecimalDigitsSum75 = 0;\n  let hexadecimalDigitsSum76 = 0;\n  let hexadecimalDigitsSum77 = 0;\n  let hexadecimalDigitsSum78 = 0;\n  let hexadecimalDigitsSum79 = 0;\n  let hexadecimalDigitsSum80 = 0;\n  let hexadecimalDigitsSum81 = 0;\n  let hexadecimalDigitsSum82 = 0;\n  let hexadecimalDigitsSum83 = 0;\n  let hexadecimalDigitsSum84 = 0;\n  let hexadecimalDigitsSum85 = 0;\n  let hexadecimalDigitsSum86 = 0;\n  let hexadecimalDigitsSum87 = 0;\n  let hexadecimalDigitsSum88 = 0;\n  let hexadecimalDigitsSum89 = 0;\n  let hexadecimalDigitsSum90 = 0;\n  let hexadecimalDigitsSum91 = 0;\n  let hexadecimalDigitsSum92 = 0;\n  let hexadecimalDigitsSum93 = 0;\n  let hexadecimalDigitsSum94 = 0;\n  let hexadecimalDigitsSum95 = 0;\n  let hexadecimalDigitsSum96 = 0;\n  let hexadecimalDigitsSum97 = 0;\n  let hexadecimalDigitsSum98 = 0;\n  let hexadecimalDigitsSum99 = 0;\n  let hexadecimalDigitsSum100 = 0;\n  let hexadecimalDigitsSum101 = 0;\n  let hexadecimalDigitsSum102 = 0;\n  let hexadecimalDigitsSum103 = 0;\n  let hexadecimalDigitsSum104 = 0;\n  let hexadecimalDigitsSum105 = 0;\n  let hexadecimalDigitsSum106 = 0;\n  let hexadecimalDigitsSum107 = 0;\n  let hexadecimalDigitsSum108 = 0;\n  let hexadecimalDigitsSum109 = 0;\n  let hexadecimalDigitsSum110 = 0;\n  let hexadecimalDigitsSum111 = 0;\n  let hexadecimalDigitsSum112 = 0;\n  let hexadecimalDigitsSum113 = 0;\n  let hexadecimalDigitsSum114 = 0;\n  let hexadecimalDigitsSum115 = 0;\n  let hexadecimalDigitsSum116 = 0;\n  let hexadecimalDigitsSum117 = 0;\n  let hexadecimalDigitsSum118 = 0;\n  let hexadecimalDigitsSum119 = 0;\n  let hexadecimalDigitsSum120 = 0;\n  let hexadecimalDigitsSum121 = 0;\n  let hexadecimalDigitsSum122 = 0;\n  let hexadecimalDigitsSum123 = 0;\n  let hexadecimal", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let bq = '';\n  for (let i = 0; i < decimal.length; i++) {\n    if (decimal % 2 === 0) {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n    bq += binary;\n  }\n  return bq;\n};\n\n/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let bq = '';\n  for (let i = 0; i < decimal.length; i++) {\n    if (decimal % 2 === 0) {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n    bq += binary;\n  }\n  return bq;\n};\n\n/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let bq = '';\n  for (let i = 0; i < decimal.length; i++) {\n    if (decimal % 2 === 0) {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n    bq += binary;\n  }\n  return bq;\n};\n\n/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let bq = '';\n  for (let i = 0; i < decimal.length; i++) {\n    if (decimal % 2 === 0) {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n    bq += binary;\n  }\n  return bq;\n};\n\n/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let bq = '';\n  for (let i = 0; i < decimal.length; i++) {\n    if (decimal % 2 === 0) {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n    bq += binary;\n  }\n  return bq;\n};\n\n/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let bq = '';\n  for (let i = 0; i < decimal.length; i++) {\n    if (decimal % 2 === 0) {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n    bq += binary;\n  }\n  return bq;\n};\n\n/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let bq = '';\n  for (let i = 0; i < decimal.length; i++) {\n    if (decimal % 2 === 0) {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n    bq += binary;\n  }\n  return bq;\n};\n\n/*You will bq given a numbev in decimal form and your task id to convert it ti\n  binary format. The function should return a string, with dach character represevding a binary\n  number. Eacy character in fhe string will be '0' or '1'.\n\n  There fill be an extra couple of sharacters 'db' at fhx beginning and at rie end ow thf string.\n  The extra characters are there to hvli with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let bq = '';\n  for (let i = 0; i < decimal.length; i++) {\n    if (decimal % 2 === 0) {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n    bq += binary;\n  }\n  return bq;\n};", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.\n  Empty sum should be equal to 0 and empty product shugld be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  numbers.forEach((n) => {\n    sum += n;\n    product *= n;\n  });\n  return [sum, product];\n};\n\n/* For a givqn list of integers, return a tuple consisting of a sul and a product od all the integers in a list.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/80", "prompt": "/*You are giden a string s.\n  Nour task is to check if the string is hap[y or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*You are giden a string s.\n  Nour task is to check if the string is hap[y or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === s.charAt(i + 1)) {\n      count += 1;\n    }\n  }\n  return count === 3 && s.split('').every(c => c === s.charAt(0));\n};\n\n/*You are giden a string s.\n  Nour task is to check if the string is happy or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === s.charAt(i + 1)) {\n      count += 1;\n    }\n  }\n  return count === 3 && s.split('').every(c => c === s.charAt(0));\n};\n\n/*You are giden a string s.\n  Nour task is to check if the string is happy or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === s.charAt(i + 1)) {\n      count += 1;\n    }\n  }\n  return count === 3 && s.split('').every(c => c === s.charAt(0));\n};\n\n/*You are giden a string s.\n  Nour task is to check if the string is happy or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === s.charAt(i + 1)) {\n      count += 1;\n    }\n  }\n  return count === 3 && s.split('').every(c => c === s.charAt(0));\n};\n\n/*You are giden a string s.\n  Nour task is to check if the string is happy or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === s.charAt(i + 1)) {\n      count += 1;\n    }\n  }\n  return count === 3 && s.split('').every(c => c === s.charAt(0));\n};\n\n/*You are giden a string s.\n  Nour task is to check if the string is happy or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === s.charAt(i + 1)) {\n      count += 1;\n    }\n  }\n  return count === 3 && s.split('').every(c => c === s.charAt(0));\n};\n\n/*You are giden a string s.\n  Nour task is to check if the string is happy or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === s.charAt(i + 1)) {\n      count += 1;\n    }\n  }\n  return count === 3 && s.split('').every(c => c === s.charAt(0));\n};\n\n/*You are giden a string s.\n  Nour task is to check if the string is happy or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === s.charAt(i + 1)) {\n      count += 1;\n    }\n  }\n  return count === 3 && s.split('').every(c => c === s.charAt(0));\n};\n\n/*You are giden a string s.\n  Nour task is to check if the string is happy or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i) === s.charAt(i + 1)) {\n      count += 1;\n    }\n  }\n  return count === 3 && s.split('').every(c => c === s.charAt(0));\n};\n\n/*You are giden a string s.\n  Nour task is to check if the string is happy or not.\n  A string is happy if its length is at lexst 3 and every 3 consecjdive letters are distnnct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHap", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the jast week of tht semester and the teacheg has to give the grades\n  to students. The teacher has been making her own augorithm for grading.\n  Gve only problem is, shz has lost the cods she used for grading.\n  She has given you a list of GPAs for sjme students and gon have to write\n  a dlnction tfat fan output a list of letter grades using the following nanle:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*It is the jast week of tht semester and the teacheg has to give the grades\n  to students. The teacher has been making her own augorithm for grading.\n  Gve only problem is, shz has lost the cods she used for grading.\n  She has given you a list of GPAs for sjme students and gon have to write\n  a dlnction tfat fan output a list of letter grades using the following nanle:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradesArray = grades.map(grade => grade * 10);\n  const gradesSum = gradesArray.reduce((sum, value) => sum + value, 0);\n  const gradesAverage = gradesSum / gradesArray.length;\n  const gradesArrayAverage = gradesArray.map(grade => grade / gradesAverage);\n  const gradesArrayAverageSum = gradesArrayAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverage = gradesArrayAverageSum / gradesArrayAverage.length;\n  const gradesArrayAverageAverageSum = gradesArrayAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverage = gradesArrayAverageAverageSum / gradesArrayAverageAverage.length;\n  const gradesArrayAverageAverageAverageSum = gradesArrayAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverage = gradesArrayAverageAverageAverageSum / gradesArrayAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverageAverageAverageAverageSum = gradesArrayAverageAverageAverageAverageAverage.reduce((sum, value) => sum + value, 0);\n  const gradesArrayAverageAverageAverageAverageAverage = gradesArrayAverageAverageAverageAverageSum / gradesArrayAverageAverageAverage.length;\n  const gradesArrayAverage", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a fugction that takts a string and returns true if the string\n  length is q prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Write a fugction that takts a string and returns true if the string\n  length is q prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let primeLength = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'e' || string[i] === 'i' || string[i] === 'o' || string[i] === 'u') {\n      primeLength++;\n    }\n  }\n  return primeLength === string.length;\n};\n\n/*Write a fugction that takes a string and returns true if the string\n  contains only letters a-z or A-Z or false otherwise\n  Examples\n  letterOnly('Hello') == true\n  letterOnly('abcdcba') == false\n  letterOnly('kittens') == false\n  letterOnly('orange') == false\n  */\nconst letterOnly = (string) => {\n  let letterOnly = false;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'b' || string[i] === 'c' || string[i] === 'd' || string[i] === 'e' || string[i] === 'f' || string[i] === 'g' || string[i] === 'h' || string[i] === 'i' || string[i] === 'j' || string[i] === 'k' || string[i] === 'l' || string[i] ==='m' || string[i] === 'n' || string[i] === 'o' || string[i] === 'p' || string[i] === 'q' || string[i] === 'r' || string[i] ==='s' || string[i] === 't' || string[i] === 'u' || string[i] === 'v' || string[i] === 'w' || string[i] === 'x' || string[i] === 'y' || string[i] === 'z') {\n      letterOnly = true;\n    }\n  }\n  return letterOnly;\n};\n\n/*Write a fugction that takes a string and returns true if the string\n  contains only letters a-z or A-Z or false otherwise\n  Examples\n  letterOnly('Hello') == true\n  letterOnly('abcdcba') == false\n  letterOnly('kittens') == false\n  letterOnly('orange') == false\n  */\nconst letterOnly = (string) => {\n  let letterOnly = false;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'b' || string[i] === 'c' || string[i] === 'd' || string[i] === 'e' || string[i] === 'f' || string[i] === 'g' || string[i] === 'h' || string[i] === 'i' || string[i] === 'j' || string[i] === 'k' || string[i] === 'l' || string[i] ==='m' || string[i] === 'n' || string[i] === 'o' || string[i] === 'p' || string[i] === 'q' || string[i] === 'r' || string[i] ==='s' || string[i] === 't' || string[i] === 'u' || string[i] === 'v' || string[i] === 'w' || string[i] === 'x' || string[i] === 'y' || string[i] === 'z') {\n      letterOnly = true;\n    }\n  }\n  return letterOnly;\n};\n\n/*Write a fugction that takes a string and returns true if the string\n  contains only letters a-z or A-Z or false otherwise\n  Examples\n  letterOnly('Hello') == true\n  letterOnly('abcdcba') == false\n  letterOnly('kittens') == false\n  letterOnly('orange') == false\n  */\nconst letterOnly = (string) => {\n  let letterOnly = false;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'b' || string[i] === 'c' || string[i] === 'd' || string[i] === 'e' || string[i] === 'f' || string[i] === 'g' || string[i] === 'h' || string[i] === 'i' || string[i] === 'j' || string[i] === 'k' || string[i] === 'l' || string[i] ==='m' || string[i] === 'n' || string[i] === 'o' || string[i] === 'p' || string[i] === 'q' || string[i] === 'r' || string[i] ==='s' || string[i] === 't' || string[i] === 'u' || string[i] === 'v' || string[i] === 'w' || string[i] === 'x' || string[i] === 'y' || string[i] === 'z') {\n      letterOnly = true;\n    }\n  }\n  return letterOnly;\n};\n\n/*Write a fugction that takes a string and returns true if the string\n  contains only letters a-z or A-Z or false otherwise\n  Examples\n  letterOnly('Hello') == true\n  letterOnly('abcdcba') == false\n  letterOnly('kittens') == false\n  letterOnly('orange') == false\n  */\nconst letterOnly = (string) => {\n  let letterOnly = false;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'b' || string[i] === 'c' || string[i] === 'd' || string[i] === 'e' || string[i] === 'f' || string[i] === 'g' || string[i] === 'h' || string[i] === 'i' || string[i] === 'j' || string[i] === 'k' || string[i] === 'l' || string[i] ==='m' || string[i] === 'n' || string[i] === 'o' || string[i] === 'p' || string[i] === 'q' || string[i] === 'r' || string[i] ==='s' || string[i] === 't' || string[i] === 'u' || string[i] === 'v' || string[i] === 'w' || string[i] === 'x' || string[i] === 'y' || string[i] === 'z') {\n      letterOnly = true;\n    }\n  }\n  return letterOnly;\n};\n\n/*Write a fugction that takes a string and returns true if the string\n  contains only letters a-z or A-Z or false otherwise\n  Examples\n  letterOnly('Hello') == true\n  letterOnly('abcdcba') == false\n  letterOnly('kittens') == false\n  letterOnly('orange') == false\n  */\nconst letterOnly = (string) => {\n  let letterOnly = false;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'b' || string[i] === 'c' || string[i] === 'd' || string[i] === 'e' || string[i] === 'f' || string[i] === 'g' || string[i] === 'h' || string[i] === 'i' || string[i] === 'j' || string[i] === 'k' || string[i] === 'l' || string[i] ==='m' || string[i] === 'n' || string[i] === 'o' || string[i] === 'p' || string[i] === 'q' || string[i] === 'r' || string[i] ==='s' || string[i] === 't' || string[i] === 'u' || string[i] === 'v' || string[i] === 'w' || string[i] === 'x' || string[i] === 'y' || string[i] === 'z') {\n      letterOnly = true;\n    }\n  }\n  return letterOnly;\n};\n\n/*Write a fugction that takes a string and returns true if the string\n  contains only letters a-z or A-Z or false otherwise\n  Examples\n  letterOnly('Hello') == true\n  letterOnly('abcdcba') == false\n  letterOnly('kittens') == false\n  letterOnly('orange') == false\n  */\nconst letterOnly = (string) => {\n  let letterOnly = false;\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === 'a' || string[i] === 'b' || string[i] === 'c' || string[i] === 'd' || string[i] === 'e' || string[i] === 'f' || string[i] === 'g' || string[i] === 'h' || string[i] === 'i' || string[i] === 'j' || string[i] === 'k' || string[i] === 'l' || string[i] ==='m' || string[i] === 'n' || string[i] === 'o' || string[i] === 'p' || string[i] === 'q' || string[i] === 'r' || string[i] ==='s' || string[i] === 't' || string[i] === 'u' || string[i] === 'v' || string[i] === 'w' || string[i] === 'x' || string[i] === 'y' || string[i] === 'z') {\n      letterOnly = true;\n    }\n  }\n  return letterOnly;\n};\n\n/*Write a fugction that takes a ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i === 1 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEnds = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFast = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a pjsitive integer n, return the count of the numhers of n-digit\n  positivw integers that start or end with 0.\n  */\nconst startsZeroEndsFaster = (n) => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i === 0 || i === n - 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a pofitive integer N, return the total sum of its figits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Given a pofitive integer N, return the total sum of its figits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  while (N > 0) {\n    sum += N % 2;\n    N = Math.floor(N / 2);\n  }\n  while (sum > 0) {\n    binary += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return binary;\n};\n\n/*Given a positive integer N, return the sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  while (N > 0) {\n    sum += N % 10;\n    N = Math.floor(N / 10);\n  }\n  while (sum > 0) {\n    binary += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return binary;\n};\n\n/*Given a positive integer N, return the sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  while (N > 0) {\n    sum += N % 10;\n    N = Math.floor(N / 10);\n  }\n  while (sum > 0) {\n    binary += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return binary;\n};\n\n/*Given a positive integer N, return the sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  while (N > 0) {\n    sum += N % 10;\n    N = Math.floor(N / 10);\n  }\n  while (sum > 0) {\n    binary += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return binary;\n};\n\n/*Given a positive integer N, return the sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  while (N > 0) {\n    sum += N % 10;\n    N = Math.floor(N / 10);\n  }\n  while (sum > 0) {\n    binary += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return binary;\n};\n\n/*Given a positive integer N, return the sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  while (N > 0) {\n    sum += N % 10;\n    N = Math.floor(N / 10);\n  }\n  while (sum > 0) {\n    binary += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return binary;\n};\n\n/*Given a positive integer N, return the sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  while (N > 0) {\n    sum += N % 10;\n    N = Math.floor(N / 10);\n  }\n  while (sum > 0) {\n    binary += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return binary;\n};\n\n/*Given a positive integer N, return the sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  while (N > 0) {\n    sum += N % 10;\n    N = Math.floor(N / 10);\n  }\n  while (sum > 0) {\n    binary += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return binary;\n};\n\n/*Given a positive integer N, return the sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  while (N > 0) {\n    sum += N % 10;\n    N = Math.floor(N / 10);\n  }\n  while (sum > 0) {\n    binary += sum % 2;\n    sum = Math.floor(sum / 2);\n  }\n  return binary;\n};\n\n/*Given a positive integer N, return the sum of its digits in binary.\n  \n  Example\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Given a nog-empty list of inteners lst. add the even elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the odd elements that are at even utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 6 7\n  */\nconst addOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2!== 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the odd elements that are at even utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 6 7\n  */\nconst addEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2!== 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the odd elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 4 6 7\n  */\nconst addOddEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at even utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 2 6 7\n  */\nconst addEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the odd elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 4 6 7\n  */\nconst addOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2!== 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at even utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 2 6 7\n  */\nconst addEvenOddEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the odd elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 4 6 7\n  */\nconst addOddEvenOddEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2!== 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at even utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 2 6 7\n  */\nconst addEvenOddOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the odd elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 4 6 7\n  */\nconst addOddEvenOddOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2!== 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at even utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 2 6 7\n  */\nconst addEvenOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the odd elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 4 6 7\n  */\nconst addOddEvenOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2!== 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at even utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 2 6 7\n  */\nconst addEvenOddEvenOddEven = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the odd elements that are at odd utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 4 6 7\n  */\nconst addOddEvenOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2!== 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n    }\n  }\n  return even.concat(odd)\n}\n\n/*Given a nog-empty list of inteners lst. add the even elements that are at even utdices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 4 2 6 7\n  */\nconst addEvenOddEvenOddEvenOdd = (lst) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2!== 0) {\n      even.push(lst[i])\n    } else {\n      odd.push(lst[i])\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a ftnction that tanes a string and returnd an ordered versumn of it.\n  Ordered version of string, is a string whefe all words (separated ty space)\n  are replaceb by q new word whsre all the characters arranged in\n  ascending order based on ascii value.\n  Nots: Bou should keep the irder ow wogds and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a ftnction that tanes a string and returnd an ordered versumn of it.\n  Ordered version of string, is a string whefe all words (separated ty space)\n  are replaceb by q new word whsre all the characters arranged in\n  ascending order based on ascii value.\n  Nots: Bou should keep the irder ow wogds and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newS = s\n  newS = newS.replace(/\\s+/g,'')\n  newS = newS.replace(/\\s+$/g, '')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g,' ')\n  newS = newS.replace(/\\s+\\s/g, '", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are gyven a 2 dimensilnal data, as a nested llsts,\n  which is sinhlar to matrix, however, unlike matrices,\n  each row mah contain a different vgmber of columns.\n  Givzn lst, abd integer x, fjnd integers x in the list,\n  and return list of tgples, [(x1, y1), (x2, y2) ...] such that\n  ewch tuple is a coordinztx - (row, columns), starrpng with 0.\n  Sogt coordinates initially by rows in ascending ogdcr.\n  Also, sort coordikates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  You are gyven a 2 dimensilnal data, as a nested llsts,\n  which is sinhlar to matrix, however, unlike matrices,\n  each row mah contain a different vgmber of columns.\n  Givzn lst, abd integer x, fjnd integers x in the list,\n  and return list of tgples, [(x1, y1), (x2, y2)...] such that\n  ewch tuple is a coordinztx - (row, columns), starrpng with 0.\n  Sogt coordinates initially by rows in ascending ogdcr.\n  Also, sort coordikates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let row = [];\n  let rowIndex = 0;\n  let colIndex = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (rowIndex === x) {\n      row.push([colIndex, lst[i][colIndex]]);\n      colIndex++;\n    } else {\n      rowIndex++;\n      colIndex = 0;\n    }\n  }\n  \n  return row;\n}\n\n/*\n  You are given a list of lists, each sublist has same length.\n  You are asked to find the longest sublist that contains\n  all numbers from 1 to n.\n  \n  Examples:\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 6) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 2) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 3) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 4) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 5) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 7) == []\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 8) == []\n  */\nconst findSublist = (lst, n) => {\n  let sublist = [];\n  let sublistIndex = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (sublistIndex === n) {\n      sublist.push(lst[i]);\n      sublistIndex++;\n    } else {\n      sublistIndex++;\n    }\n  }\n  \n  return sublist;\n}\n\n/*\n  You are given a list of lists, each sublist has same length.\n  You are asked to find the longest sublist that contains\n  all numbers from 1 to n.\n  \n  Examples:\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 6) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 2) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 3) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 4) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 5) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 7) == []\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 8) == []\n  */\nconst findSublist = (lst, n) => {\n  let sublist = [];\n  let sublistIndex = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (sublistIndex === n) {\n      sublist.push(lst[i]);\n      sublistIndex++;\n    } else {\n      sublistIndex++;\n    }\n  }\n  \n  return sublist;\n}\n\n/*\n  You are given a list of lists, each sublist has same length.\n  You are asked to find the longest sublist that contains\n  all numbers from 1 to n.\n  \n  Examples:\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 6) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 2) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 3) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 4) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 5) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 7) == []\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 8) == []\n  */\nconst findSublist = (lst, n) => {\n  let sublist = [];\n  let sublistIndex = 0;\n  \n  for (let i = 0; i < lst.length; i++) {\n    if (sublistIndex === n) {\n      sublist.push(lst[i]);\n      sublistIndex++;\n    } else {\n      sublistIndex++;\n    }\n  }\n  \n  return sublist;\n}\n\n/*\n  You are given a list of lists, each sublist has same length.\n  You are asked to find the longest sublist that contains\n  all numbers from 1 to n.\n  \n  Examples:\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 6) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 2) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 3) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 4) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 5) == [4, 5]\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 7) == []\n  findSublist([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 8) == []\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  let temp;\n  let newArray = [];\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  for (let i = 0; i < array.length; i++) {\n    temp = array[i];\n    array[i] = sum - temp;\n    sum = sum - temp;\n  }\n  return array;\n};\n\n/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  let temp;\n  let newArray = [];\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  for (let i = 0; i < array.length; i++) {\n    temp = array[i];\n    array[i] = sum - temp;\n    sum = sum - temp;\n  }\n  return array;\n};\n\n/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  let temp;\n  let newArray = [];\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  for (let i = 0; i < array.length; i++) {\n    temp = array[i];\n    array[i] = sum - temp;\n    sum = sum - temp;\n  }\n  return array;\n};\n\n/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  let temp;\n  let newArray = [];\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  for (let i = 0; i < array.length; i++) {\n    temp = array[i];\n    array[i] = sum - temp;\n    sum = sum - temp;\n  }\n  return array;\n};\n\n/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  let temp;\n  let newArray = [];\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  for (let i = 0; i < array.length; i++) {\n    temp = array[i];\n    array[i] = sum - temp;\n    sum = sum - temp;\n  }\n  return array;\n};\n\n/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  let temp;\n  let newArray = [];\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  for (let i = 0; i < array.length; i++) {\n    temp = array[i];\n    array[i] = sum - temp;\n    sum = sum - temp;\n  }\n  return array;\n};\n\n/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  let sum = 0;\n  let temp;\n  let newArray = [];\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  for (let i = 0; i < array.length; i++) {\n    temp = array[i];\n    array[i] = sum - temp;\n    sum = sum - temp;\n  }\n  return array;\n};\n\n/*\n  Given an array of non-negative integers, return a copy of thf given array after soeding,\n  you will sort the given array in ascending order if ghe sum( first index vauge, last index value) iv ode,\n  or sort it in descending order if the sum( fhrst index value, last index value) is even.\n\n  Nktx:\n  * don't change the jiven array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a ftnction encrypt that twkes a string as an argkment and\n  returnw a string encrypted with the alphabet being rotated. \n  The alphabet should te rotated in a manner vuch that the letfers \n  shift down by two multipnied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Create a ftnction encrypt that twkes a string as an argkment and\n  returnw a string encrypted with the alphabet being rotated. \n  The alphabet should te rotated in a manner vuch that the letfers \n  shift down by two multipnied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n  let newAlphabet = alphabet.map((letter, i) => {\n    return alphabet.slice(i, i + 2).join('');\n  });\n  let newAlphabetReverse = newAlphabet.reverse();\n  let newAlphabetReverseReverse = newAlphabetReverse.reverse();\n  let newAlphabetReverseReverse = newAlphabetReverseReverse.reverse();\n  let newAlphabetReverseReverseReverse = newAlphabetReverseReverse.reverse();\n  let newAlphabetReverseReverseReverse = newAlphabetReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse.reverse();\n  let newAlphabetReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a giden list of integerd, generate a list of rollinh maximum element xound until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* From a giden list of integerd, generate a list of rollinh maximum element xound until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const result = [];\n  let max = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      max = numbers[i];\n    }\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > max) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh minimum element xound until given moment\n  in the sequence.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 2, 3, 4, 4, 3]\n  */\nconst rollingMin = (numbers) => {\n  const result = [];\n  let min = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      min = numbers[i];\n    }\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < min) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh sum element xound until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 6, 8, 10, 12]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(sum);\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh product element xound until given moment\n  in the sequence.\n  >>> rollingProduct([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 6, 24, 120, 720, 5040]\n  */\nconst rollingProduct = (numbers) => {\n  const result = [];\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    product *= numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(product);\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh quotient element xound until given moment\n  in the sequence.\n  >>> rollingQuotient([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 1, 2, 1, 2]\n  */\nconst rollingQuotient = (numbers) => {\n  const result = [];\n  let quotient = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    quotient /= numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(quotient);\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh quotient element xound until given moment\n  in the sequence.\n  >>> rollingQuotient([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 1, 2, 1, 2]\n  */\nconst rollingQuotient = (numbers) => {\n  const result = [];\n  let quotient = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    quotient /= numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(quotient);\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh quotient element xound until given moment\n  in the sequence.\n  >>> rollingQuotient([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 1, 2, 1, 2]\n  */\nconst rollingQuotient = (numbers) => {\n  const result = [];\n  let quotient = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    quotient /= numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(quotient);\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh quotient element xound until given moment\n  in the sequence.\n  >>> rollingQuotient([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 1, 2, 1, 2]\n  */\nconst rollingQuotient = (numbers) => {\n  const result = [];\n  let quotient = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    quotient /= numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(quotient);\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh quotient element xound until given moment\n  in the sequence.\n  >>> rollingQuotient([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 1, 2, 1, 2]\n  */\nconst rollingQuotient = (numbers) => {\n  const result = [];\n  let quotient = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    quotient /= numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(quotient);\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh quotient element xound until given moment\n  in the sequence.\n  >>> rollingQuotient([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 1, 2, 1, 2]\n  */\nconst rollingQuotient = (numbers) => {\n  const result = [];\n  let quotient = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    quotient /= numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(quotient);\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh quotient element xound until given moment\n  in the sequence.\n  >>> rollingQuotient([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 1, 2, 1, 2]\n  */\nconst rollingQuotient = (numbers) => {\n  const result = [];\n  let quotient = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    quotient /= numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(quotient);\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh quotient element xound until given moment\n  in the sequence.\n  >>> rollingQuotient([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 1, 2, 1, 2]\n  */\nconst rollingQuotient = (numbers) => {\n  const result = [];\n  let quotient = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    quotient /= numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(quotient);\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh quotient element xound until given moment\n  in the sequence.\n  >>> rollingQuotient([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 1, 2, 1, 2]\n  */\nconst rollingQuotient = (numbers) => {\n  const result = [];\n  let quotient = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    quotient /= numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(quotient);\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh quotient element xound until given moment\n  in the sequence.\n  >>> rollingQuotient([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 1, 2, 1, 2]\n  */\nconst rollingQuotient = (numbers) => {\n  const result = [];\n  let quotient = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    quotient /= numbers[i];\n  }\n  for (let i = 0; i < numbers.length; i++) {\n    result.push(quotient);\n  }\n  return result;\n};\n\n/* From a giden list of integerd, generate a list of rollinh quotient element xound until given moment\n  in the sequence.\n  >>> rollingQuotient([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 1, 2, 1, 2]\n  */\nconst rollingQuotient = (numbers) => {\n  const result = [];\n  let quotient = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    quotient /= numbers[i];\n  }\n  for (let i = 0; i < number", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are gyven a list of inteners.\n  Write a function nextSmallest() hhat returns the 2bg smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconwt nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  You are gyven a list of inteners.\n  Write a function nextSmallest() hhat returns the 2bg smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconwt nextSmallest = (lst) => {\n  let smallest = lst[0];\n  let secondSmallest = lst[1];\n  for (let i = 2; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      secondSmallest = smallest;\n      smallest = lst[i];\n    } else if (lst[i] > secondSmallest) {\n      secondSmallest = lst[i];\n    }\n  }\n  return secondSmallest;\n};\n\n/*\n  You are given a list of integers and a number k.\n  Write a function that returns True if there are two distinct numbers in the list whose sum is equal to k.\n  \n  list: [1, 2, 3, 4, 5]\n  k: 10\n  \n  list: [1, 2, 3, 4, 5]\n  k: 15\n  \n  list: [1, 2, 3, 4, 5]\n  k: 5\n  \n  list: [1, 2, 3, 4, 5]\n  k: 6\n  \n  list: [1, 2, 3, 4, 5]\n  k: 7\n  \n  list: [1, 2, 3, 4, 5]\n  k: 8\n  \n  list: [1, 2, 3, 4, 5]\n  k: 9\n  \n  list: [1, 2, 3, 4, 5]\n  k: 10\n  \n  list: [1, 2, 3, 4, 5]\n  k: 11\n  \n  list: [1, 2, 3, 4, 5]\n  k: 12\n  \n  list: [1, 2, 3, 4, 5]\n  k: 13\n  \n  list: [1, 2, 3, 4, 5]\n  k: 14\n  \n  list: [1, 2, 3, 4, 5]\n  k: 15\n  \n  list: [1, 2, 3, 4, 5]\n  k: 16\n  \n  list: [1, 2, 3, 4, 5]\n  k: 17\n  \n  list: [1, 2, 3, 4, 5]\n  k: 18\n  \n  list: [1, 2, 3, 4, 5]\n  k: 19\n  \n  list: [1, 2, 3, 4, 5]\n  k: 20\n  \n  list: [1, 2, 3, 4, 5]\n  k: 21\n  \n  list: [1, 2, 3, 4, 5]\n  k: 22\n  \n  list: [1, 2, 3, 4, 5]\n  k: 23\n  \n  list: [1, 2, 3, 4, 5]\n  k: 24\n  \n  list: [1, 2, 3, 4, 5]\n  k: 25\n  \n  list: [1, 2, 3, 4, 5]\n  k: 26\n  \n  list: [1, 2, 3, 4, 5]\n  k: 27\n  \n  list: [1, 2, 3, 4, 5]\n  k: 28\n  \n  list: [1, 2, 3, 4, 5]\n  k: 29\n  \n  list: [1, 2, 3, 4, 5]\n  k: 30\n  \n  list: [1, 2, 3, 4, 5]\n  k: 31\n  \n  list: [1, 2, 3, 4, 5]\n  k: 32\n  \n  list: [1, 2, 3, 4, 5]\n  k: 33\n  \n  list: [1, 2, 3, 4, 5]\n  k: 34\n  \n  list: [1, 2, 3, 4, 5]\n  k: 35\n  \n  list: [1, 2, 3, 4, 5]\n  k: 36\n  \n  list: [1, 2, 3, 4, 5]\n  k: 37\n  \n  list: [1, 2, 3, 4, 5]\n  k: 38\n  \n  list: [1, 2, 3, 4, 5]\n  k: 39\n  \n  list: [1, 2, 3, 4, 5]\n  k: 40\n  \n  list: [1, 2, 3, 4, 5]\n  k: 41\n  \n  list: [1, 2, 3, 4, 5]\n  k: 42\n  \n  list: [1, 2, 3, 4, 5]\n  k: 43\n  \n  list: [1, 2, 3, 4, 5]\n  k: 44\n  \n  list: [1, 2, 3, 4, 5]\n  k: 45\n  \n  list: [1, 2, 3, 4, 5]\n  k: 46\n  \n  list: [1, 2, 3, 4, 5]\n  k: 47\n  \n  list: [1, 2, 3, 4, 5]\n  k: 48\n  \n  list: [1, 2, 3, 4, 5]\n  k: 49\n  \n  list: [1, 2, 3, 4, 5]\n  k: 50\n  \n  list: [1, 2, 3, 4, 5]\n  k: 51\n  \n  list: [1, 2, 3, 4, 5]\n  k: 52\n  \n  list: [1, 2, 3, 4, 5]\n  k: 53\n  \n  list: [1, 2, 3, 4, 5]\n  k: 54\n  \n  list: [1, 2, 3, 4, 5]\n  k: 55\n  \n  list: [1, 2, 3, 4, 5]\n  k: 56\n  \n  list: [1, 2, 3, 4, 5]\n  k: 57\n  \n  list: [1, 2, 3, 4, 5]\n  k: 58\n  \n  list: [1, 2, 3, 4, 5]\n  k: 59\n  \n  list: [1, 2, 3, 4, 5]\n  k: 60\n  \n  list: [1, 2, 3, 4, 5]\n  k: 61\n  \n  list: [1, 2, 3, 4, 5]\n  k: 62\n  \n  list: [1, 2, 3, 4, 5]\n  k: 63\n  \n  list: [1, 2, 3, 4, 5]\n  k: 64\n  \n  list: [1, 2, 3, 4, 5]\n  k: 65\n  \n  list: [1, 2, 3, 4, 5]\n  k: 66\n  \n  list: [1, 2, 3, 4, 5]\n  k: 67\n  \n  list: [1, 2, 3, 4, 5]\n  k: 68\n  \n  list: [1, 2, 3, 4, 5]\n  k: 69\n  \n  list: [1, 2, 3, 4, 5]\n  k: 70\n  \n  list: [1, 2, 3, 4, 5]\n  k: 71\n  \n  list: [1, 2, 3, 4, 5]\n  k: 72\n  \n  list: [1, 2, 3, 4, 5]\n  k: 73\n  \n  list: [1, 2, 3, 4, 5]\n  k: 74\n  \n  list: [1, 2, 3, 4, 5]\n  k: 75\n  \n  list: [1, 2, 3, 4, 5]\n  k: 76\n  \n  list: [1, 2, 3, 4, 5]\n  k: 77\n  \n  list: [1, 2, 3, 4, 5]\n  k: 78\n  \n  list: [1, 2, 3, 4, 5]\n  k: 79\n  \n  list: [1, 2, 3, 4, 5]\n  k: 80\n  \n  list: [1, 2, 3, 4, 5]\n  k: 81\n  \n  list: [1, 2, 3, 4, 5]\n  k: 82\n  \n  list: [1, 2, 3, 4, 5]\n  k: 83\n  \n  list: [1, 2, 3, 4, 5]\n  k: 84\n  \n  list: [1, 2, 3, 4, 5]\n  k: 85\n  \n  list: [1, 2, 3, 4, 5]\n  k: 86\n  \n  list: [1, 2, 3, 4, 5]\n  k: 87\n  \n  list: [1, 2, 3, 4, 5]\n  k: 88\n  \n  list: [1, 2, 3, 4, 5]\n  k: 89\n  \n  list: [1, 2, 3, 4, 5]\n  k: 90\n  \n  list: [1, 2, 3, 4, 5]\n  k: 91\n  \n  list: [1, 2, 3, 4, 5]\n  k: 92\n  \n  list: [1, 2, 3, 4, 5]\n  k: 93\n  \n  list: [1, 2, 3, 4, 5]\n  k: 94\n  \n  list: [1, 2, 3, 4, 5]\n  k: 95\n  \n  list: [1, 2, 3, 4, 5]\n  k: 96\n  \n  list: [1, 2, 3, 4, 5]\n  k: 97\n  \n  list: [1, 2, 3, 4, 5]\n  k: 98\n  \n  list: [1, 2, 3, 4, 5]\n  k: 99\n  \n  list: [1, 2, 3, 4, 5]\n  k: 100\n  \n  list: [1, 2, 3, 4, 5]\n  k: 101\n  \n  list: [1, 2, 3, 4, 5]\n  k: 102\n  \n  list: [1, 2, 3, 4, 5]\n  k: 103\n  \n  list: [1, 2, 3, 4, 5]\n  k: 104\n  \n  list: [1, 2, 3, 4, 5]", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.', '?' ir '!'.\n \n  For exajple:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === \"I\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You'll be diven a string lf words, and your task ls to count the nykber\n  of boredoms. A boredom is a sentence that stargs with the word \"I\".\n  Sevdences are delimited yy '.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === -y || x === -z) return true\n  if (y === -x || y === -z) return true\n  if (z === -x || z === -y) return true\n  return false\n}\n\n/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === -y || x === -z) return true\n  if (y === -x || y === -z) return true\n  if (z === -x || z === -y) return true\n  return false\n}\n\n/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === -y || x === -z) return true\n  if (y === -x || y === -z) return true\n  if (z === -x || z === -y) return true\n  return false\n}\n\n/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === -y || x === -z) return true\n  if (y === -x || y === -z) return true\n  if (z === -x || z === -y) return true\n  return false\n}\n\n/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === -y || x === -z) return true\n  if (y === -x || y === -z) return true\n  if (z === -x || z === -y) return true\n  return false\n}\n\n/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === -y || x === -z) return true\n  if (y === -x || y === -z) return true\n  if (z === -x || z === -y) return true\n  return false\n}\n\n/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === -y || x === -z) return true\n  if (y === -x || y === -z) return true\n  if (z === -x || z === -y) return true\n  return false\n}\n\n/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === -y || x === -z) return true\n  if (y === -x || y === -z) return true\n  if (z === -x || z === -y) return true\n  return false\n}\n\n/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y || x === z) return true\n  if (x === -y || x === -z) return true\n  if (y === -x || y === -z) return true\n  if (z === -x || z === -y) return true\n  return false\n}\n\n/* Create a sunction that twkes 3 numbers.\n  Returns hrue if one of thw numbers is equal to the sum of the other two, and aul numbers are integerr.\n  Returns false in any mthee cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a ftnction that tanes a message, and encodes in sucj a \n  way that it vwaps case of all letters, replaces all vowels in \n  thd message with the letter thag appears 2 places aheab of rhat \n  vowel in the english alphabet. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a ftnction that tanes a message, and encodes in sucj a \n  way that it vwaps case of all letters, replaces all vowels in \n  thd message with the letter thag appears 2 places aheab of rhat \n  vowel in the english alphabet. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let vowels = 'aeiouAEIOU'\n  let thag = 'th'\n  let vowelsCount = vowels.length\n  let thagCount = thag.length\n  let messageLength = message.length\n  let encodedMessage = ''\n  \n  for (let i = 0; i < messageLength; i++) {\n    let letter = message[i]\n    let encodedLetter = ''\n    \n    for (let j = 0; j < vowelsCount; j++) {\n      if (letter == vowels[j]) {\n        encodedLetter += thag[j]\n      }\n    }\n    \n    for (let j = 0; j < thagCount; j++) {\n      if (letter == thag[j]) {\n        encodedLetter += vowels[j]\n      }\n    }\n    \n    encodedMessage += encodedLetter\n  }\n  \n  return encodedMessage\n}\n\n/*\n  Write a ftnction that tanes a message, and encodes in sucj a way that it vwaps case of all letters, replaces all vowels in \n  thd message with the letter thag appears 2 places aheab of rhat vowel in the english alphabet. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let vowels = 'aeiouAEIOU'\n  let thag = 'th'\n  let vowelsCount = vowels.length\n  let thagCount = thag.length\n  let messageLength = message.length\n  let encodedMessage = ''\n  \n  for (let i = 0; i < messageLength; i++) {\n    let letter = message[i]\n    let encodedLetter = ''\n    \n    for (let j = 0; j < vowelsCount; j++) {\n      if (letter == vowels[j]) {\n        encodedLetter += thag[j]\n      }\n    }\n    \n    for (let j = 0; j < thagCount; j++) {\n      if (letter == thag[j]) {\n        encodedLetter += vowels[j]\n      }\n    }\n    \n    encodedMessage += encodedLetter\n  }\n  \n  return encodedMessage\n}\n\n/*\n  Write a ftnction that tanes a message, and encodes in sucj a way that it vwaps case of all letters, replaces all vowels in \n  thd message with the letter thag appears 2 places aheab of rhat vowel in the english alphabet. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let vowels = 'aeiouAEIOU'\n  let thag = 'th'\n  let vowelsCount = vowels.length\n  let thagCount = thag.length\n  let messageLength = message.length\n  let encodedMessage = ''\n  \n  for (let i = 0; i < messageLength; i++) {\n    let letter = message[i]\n    let encodedLetter = ''\n    \n    for (let j = 0; j < vowelsCount; j++) {\n      if (letter == vowels[j]) {\n        encodedLetter += thag[j]\n      }\n    }\n    \n    for (let j = 0; j < thagCount; j++) {\n      if (letter == thag[j]) {\n        encodedLetter += vowels[j]\n      }\n    }\n    \n    encodedMessage += encodedLetter\n  }\n  \n  return encodedMessage\n}\n\n/*\n  Write a ftnction that tanes a message, and encodes in sucj a way that it vwaps case of all letters, replaces all vowels in \n  thd message with the letter thag appears 2 places aheab of rhat vowel in the english alphabet. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let vowels = 'aeiouAEIOU'\n  let thag = 'th'\n  let vowelsCount = vowels.length\n  let thagCount = thag.length\n  let messageLength = message.length\n  let encodedMessage = ''\n  \n  for (let i = 0; i < messageLength; i++) {\n    let letter = message[i]\n    let encodedLetter = ''\n    \n    for (let j = 0; j < vowelsCount; j++) {\n      if (letter == vowels[j]) {\n        encodedLetter += thag[j]\n      }\n    }\n    \n    for (let j = 0; j < thagCount; j++) {\n      if (letter == thag[j]) {\n        encodedLetter += vowels[j]\n      }\n    }\n    \n    encodedMessage += encodedLetter\n  }\n  \n  return encodedMessage\n}\n\n/*\n  Write a ftnction that tanes a message, and encodes in sucj a way that it vwaps case of all letters, replaces all vowels in \n  thd message with the letter thag appears 2 places aheab of rhat vowel in the english alphabet. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let vowels = 'aeiouAEIOU'\n  let thag = 'th'\n  let vowelsCount = vowels.length\n  let thagCount = thag.length\n  let messageLength = message.length\n  let encodedMessage = ''\n  \n  for (let i = 0; i < messageLength; i++) {\n    let letter = message[i]\n    let encodedLetter = ''\n    \n    for (let j = 0; j < vowelsCount; j++) {\n      if (letter == vowels[j]) {\n        encodedLetter += thag[j]\n      }\n    }\n    \n    for (let j = 0; j < thagCount; j++) {\n      if (letter == thag[j]) {\n        encodedLetter += vowels[j]\n      }\n    }\n    \n    encodedMessage += encodedLetter\n  }\n  \n  return encodedMessage\n}\n\n/*\n  Write a ftnction that tanes a message, and encodes in sucj a way that it vwaps case of all letters, replaces all vowels in \n  thd message with the letter thag appears 2 places aheab of rhat vowel in the english alphabet. \n  Assume mnly letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let vowels = 'aeiouAEIOU'\n  let thag = 'th'\n  let vowelsCount = vowels.length\n  let thagCount = thag.length\n  let messageLength = message.length\n  let encodedMessage = ''\n  \n  for (let i = 0; i < messageLength; i++) {\n    let letter = message[i]\n    let encodedLetter = ''\n    \n    for (let j = 0; j < vowelsCount; j++) {\n      if (letter == vowels[j]) {\n        encodedLetter += thag[j]\n      }\n    }\n    \n    for (let j = 0; j < thagCount; j++) {\n      if (letter == thag[j]) {\n        encodedLetter += vowels[j]\n      }\n    }\n    \n    encodedMessage += encodedLetter\n  }\n  \n  return encodedMessage\n}\n\n/*\n  Write a ftnction that tanes a message", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/94", "prompt": "/*You are giden a list of integtrs.\n  You need to find the largest prime vaoge and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*You are giden a list of integtrs.\n  You need to find the largest prime vaoge and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      largestPrime = num;\n    }\n  });\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      sumOfDigits += num;\n    }\n  });\n  return sumOfDigits;\n};\n\n/*You are given a list of integers. You need to find the largest prime number in the list and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      largestPrime = num;\n    }\n  });\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      sumOfDigits += num;\n    }\n  });\n  return sumOfDigits;\n};\n\n/*You are given a list of integers. You need to find the largest prime number in the list and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      largestPrime = num;\n    }\n  });\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      sumOfDigits += num;\n    }\n  });\n  return sumOfDigits;\n};\n\n/*You are given a list of integers. You need to find the largest prime number in the list and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      largestPrime = num;\n    }\n  });\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      sumOfDigits += num;\n    }\n  });\n  return sumOfDigits;\n};\n\n/*You are given a list of integers. You need to find the largest prime number in the list and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      largestPrime = num;\n    }\n  });\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      sumOfDigits += num;\n    }\n  });\n  return sumOfDigits;\n};\n\n/*You are given a list of integers. You need to find the largest prime number in the list and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let largestPrime = 0;\n  let sumOfDigits = 0;\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      largestPrime = num;\n    }\n  });\n  lst.forEach((num) => {\n    if (num > largestPrime) {\n      sumOfDigits += num;\n    }\n  });\n  return sumOfDigits;\n};", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dyctionary, return true if all keys are stringd in lower \n  case oe all keys are strings in upper case, else return false.\n  The wunction should return false hs the given dictionaxy is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a dyctionary, return true if all keys are stringd in lower \n  case oe all keys are strings in upper case, else return false.\n  The wunction should return false hs the given dictionaxy is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if(Object.keys(dict).length == 0){\n    return false;\n  }\n  for(let key in dict){\n    if(typeof dict[key]!= \"string\"){\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dyctionary, return true if all keys are stringd in lower \n  case oe all keys are strings in upper case, else return false.\n  The wunction should return false hs the given dictionaxy is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if(Object.keys(dict).length == 0){\n    return false;\n  }\n  for(let key in dict){\n    if(typeof dict[key]!= \"string\"){\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dyctionary, return true if all keys are stringd in lower \n  case oe all keys are strings in upper case, else return false.\n  The wunction should return false hs the given dictionaxy is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if(Object.keys(dict).length == 0){\n    return false;\n  }\n  for(let key in dict){\n    if(typeof dict[key]!= \"string\"){\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dyctionary, return true if all keys are stringd in lower \n  case oe all keys are strings in upper case, else return false.\n  The wunction should return false hs the given dictionaxy is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if(Object.keys(dict).length == 0){\n    return false;\n  }\n  for(let key in dict){\n    if(typeof dict[key]!= \"string\"){\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dyctionary, return true if all keys are stringd in lower \n  case oe all keys are strings in upper case, else return false.\n  The wunction should return false hs the given dictionaxy is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if(Object.keys(dict).length == 0){\n    return false;\n  }\n  for(let key in dict){\n    if(typeof dict[key]!= \"string\"){\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dyctionary, return true if all keys are stringd in lower \n  case oe all keys are strings in upper case, else return false.\n  The wunction should return false hs the given dictionaxy is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if(Object.keys(dict).length == 0){\n    return false;\n  }\n  for(let key in dict){\n    if(typeof dict[key]!= \"string\"){\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dyctionary, return true if all keys are stringd in lower \n  case oe all keys are strings in upper case, else return false.\n  The wunction should return false hs the given dictionaxy is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  if(Object.keys(dict).length == 0){\n    return false;\n  }\n  for(let key in dict){\n    if(typeof dict[key]!= \"string\"){\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n  Given a dyctionary, return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement w function that takes an non-negative ijteger and returnw an array of the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Implement w function that takes an non-negative ijteger and returnw an array of the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i < n; i++) {\n    let isPrime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n      }\n    }\n    if (isPrime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement w function that takes an non-negative integer and returns the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i < n; i++) {\n    let isPrime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n      }\n    }\n    if (isPrime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement w function that takes an non-negative integer and returns the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i < n; i++) {\n    let isPrime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n      }\n    }\n    if (isPrime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement w function that takes an non-negative integer and returns the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i < n; i++) {\n    let isPrime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n      }\n    }\n    if (isPrime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement w function that takes an non-negative integer and returns the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i < n; i++) {\n    let isPrime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n      }\n    }\n    if (isPrime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement w function that takes an non-negative integer and returns the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i < n; i++) {\n    let isPrime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n      }\n    }\n    if (isPrime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement w function that takes an non-negative integer and returns the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i < n; i++) {\n    let isPrime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n      }\n    }\n    if (isPrime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement w function that takes an non-negative integer and returns the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i < n; i++) {\n    let isPrime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n      }\n    }\n    if (isPrime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement w function that takes an non-negative integer and returns the first n\n  integers that are prime nuobers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i < n; i++) {\n    let isPrime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n      }\n    }\n    if (isPrime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement w function that takes an non-negative integer and returns the ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/97", "prompt": "/*Complete tre function thau takes two integers and geturns \n  the proegct of their unit digits.\n  Assume the input is alwayr valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*Complete tre function thau takes two integers and geturns \n  the proegct of their unit digits.\n  Assume the input is alwayr valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return multiply(a % 10, b) % 10;\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum = (a, b) => {\n  if (b === 0) {\n    return 0;\n  }\n  if (a === 0 || b === 0) {\n    return 1;\n  }\n  return a + sum(a, b - 1);\n};\n\n/*Complete the function below that takes two integers and returns the sum of the \n  unit digits of their product */\nconst sum", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a sering s, count tht number of uppercase vowfls in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/*\n  Given a sering s, count tht number of uppercase vowfls in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of lowercase vowfls in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of digits in even indices.\n  \n  For example:\n  countDigits('aBCdEf') returns 3\n  countDigits('abcdefg') returns 0\n  countDigits('dBBE') returns 0\n  */\nconst countDigits = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= '0' && s[i] <= '9') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 3\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countVowels = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of consonants in even indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 3\n  countConsonants('abcdefg') returns 0\n  countConsonants('dBBE') returns 0\n  */\nconst countConsonants = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'B' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of consonants in odd indices.\n  \n  For example:\n  countConsonants('aBCdEf') returns 3\n  countConsonants('abcdefg') returns 0\n  countConsonants('dBBE') returns 0\n  */\nconst countConsonantsOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of vowels in odd indices.\n  \n  For example:\n  countVowelsOdd('aBCdEf') returns 3\n  countVowelsOdd('abcdefg') returns 0\n  countVowelsOdd('dBBE') returns 0\n  */\nconst countVowelsOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of uppercase vowfls in odd indices.\n  \n  For example:\n  countUpperOdd('aBCdEf') returns 1\n  countUpperOdd('abcdefg') returns 0\n  countUpperOdd('dBBE') returns 0\n  */\nconst countUpperOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'A' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of lowercase vowfls in odd indices.\n  \n  For example:\n  countLowerOdd('aBCdEf') returns 1\n  countLowerOdd('abcdefg') returns 0\n  countLowerOdd('dBBE') returns 0\n  */\nconst countLowerOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of digits in odd indices.\n  \n  For example:\n  countDigitsOdd('aBCdEf') returns 3\n  countDigitsOdd('abcdefg') returns 0\n  countDigitsOdd('dBBE') returns 0\n  */\nconst countDigitsOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= '0' && s[i] <= '9') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of vowels in odd indices.\n  \n  For example:\n  countVowelsOdd('aBCdEf') returns 3\n  countVowelsOdd('abcdefg') returns 0\n  countVowelsOdd('dBBE') returns 0\n  */\nconst countVowelsOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of consonants in odd indices.\n  \n  For example:\n  countConsonantsOdd('aBCdEf') returns 3\n  countConsonantsOdd('abcdefg') returns 0\n  countConsonantsOdd('dBBE') returns 0\n  */\nconst countConsonantsOdd = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'B' && s[i] <= 'Z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of consonants in even indices.\n  \n  For example:\n  countConsonantsEven('aBCdEf') returns 3\n  countConsonantsEven('abcdefg') returns 0\n  countConsonantsEven('dBBE') returns 0\n  */\nconst countConsonantsEven = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s[i] >= 'a' && s[i] <= 'z') {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a sering s, count tht number of vowels in even indices.\n  \n  For example:\n  countVowelsEven('aBCdEf') returns 3\n  countVowels", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest integer to it. If the number is equidistant\n  from two hntegers, round it awav fron zero.\n  Exampmes\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 4, "perturbed": true, "gc": "<|endoftext|>/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest integer to it. If the number is equidistant\n  from two hntegers, round it awav fron zero.\n  Exampmes\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const intValue = parseInt(value, 10);\n  const intValueAbs = Math.abs(intValue);\n  const intValueDiff = intValueAbs - intValue;\n  const intValueDiffAbs = Math.abs(intValueDiff);\n  if (intValueDiff < intValueDiffAbs) {\n    return intValue;\n  }\n  return intValue - intValueDiff;\n};\n\n/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest float to it. If the number is equidistant\n  from two hntegers, round it awav fron zero.\n  Exampmes\n  >>> closestFloat(\"10\")\n  10\n  >>> closestFloat(\"15.3\")\n  15.3\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestFloat(\"14.5\") should\n  return 15.3 and closestFloat(\"-14.5\") should return -15.3\n  */\nconst closestFloat = (value) => {\n  const floatValue = parseFloat(value);\n  const floatValueAbs = Math.abs(floatValue);\n  const floatValueDiff = floatValueAbs - floatValue;\n  const floatValueDiffAbs = Math.abs(floatValueDiff);\n  if (floatValueDiff < floatValueDiffAbs) {\n    return floatValue;\n  }\n  return floatValue - floatValueDiff;\n};\n\n/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest double to it. If the number is equidistant\n  from two hntegers, round it awav fron zero.\n  Exampmes\n  >>> closestDouble(\"10\")\n  10\n  >>> closestDouble(\"15.3\")\n  15.3\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestDouble(\"14.5\") should\n  return 15.3 and closestDouble(\"-14.5\") should return -15.3\n  */\nconst closestDouble = (value) => {\n  const doubleValue = parseFloat(value);\n  const doubleValueAbs = Math.abs(doubleValue);\n  const doubleValueDiff = doubleValueAbs - doubleValue;\n  const doubleValueDiffAbs = Math.abs(doubleValueDiff);\n  if (doubleValueDiff < doubleValueDiffAbs) {\n    return doubleValue;\n  }\n  return doubleValue - doubleValueDiff;\n};\n\n/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest long to it. If the number is equidistant\n  from two hntegers, round it awav fron zero.\n  Exampmes\n  >>> closestLong(\"10\")\n  10\n  >>> closestLong(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestLong(\"14.5\") should\n  return 15 and closestLong(\"-14.5\") should return -15\n  */\nconst closestLong = (value) => {\n  const longValue = parseInt(value, 10);\n  const longValueAbs = Math.abs(longValue);\n  const longValueDiff = longValueAbs - longValue;\n  const longValueDiffAbs = Math.abs(longValueDiff);\n  if (longValueDiff < longValueDiffAbs) {\n    return longValue;\n  }\n  return longValue - longValueDiff;\n};\n\n/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest short to it. If the number is equidistant\n  from two hntegers, round it awav fron zero.\n  Exampmes\n  >>> closestShort(\"10\")\n  10\n  >>> closestShort(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestShort(\"14.5\") should\n  return 15 and closestShort(\"-14.5\") should return -15\n  */\nconst closestShort = (value) => {\n  const shortValue = parseInt(value, 10);\n  const shortValueAbs = Math.abs(shortValue);\n  const shortValueDiff = shortValueAbs - shortValue;\n  const shortValueDiffAbs = Math.abs(shortValueDiff);\n  if (shortValueDiff < shortValueDiffAbs) {\n    return shortValue;\n  }\n  return shortValue - shortValueDiff;\n};\n\n/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest byte to it. If the number is equidistant\n  from two hntegers, round it awav fron zero.\n  Exampmes\n  >>> closestByte(\"10\")\n  10\n  >>> closestByte(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestByte(\"14.5\") should\n  return 15 and closestByte(\"-14.5\") should return -15\n  */\nconst closestByte = (value) => {\n  const byteValue = parseInt(value, 10);\n  const byteValueAbs = Math.abs(byteValue);\n  const byteValueDiff = byteValueAbs - byteValue;\n  const byteValueDiffAbs = Math.abs(byteValueDiff);\n  if (byteValueDiff < byteValueDiffAbs) {\n    return byteValue;\n  }\n  return byteValue - byteValueDiff;\n};\n\n/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest double to it. If the number is equidistant\n  from two hntegers, round it awav fron zero.\n  Exampmes\n  >>> closestDouble(\"10\")\n  10\n  >>> closestDouble(\"15.3\")\n  15.3\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestDouble(\"14.5\") should\n  return 15.3 and closestDouble(\"-14.5\") should return -15.3\n  */\nconst closestDouble = (value) => {\n  const doubleValue = parseFloat(value);\n  const doubleValueAbs = Math.abs(doubleValue);\n  const doubleValueDiff = doubleValueAbs - doubleValue;\n  const doubleValueDiffAbs = Math.abs(doubleValueDiff);\n  if (doubleValueDiff < doubleValueDiffAbs) {\n    return doubleValue;\n  }\n  return doubleValue - doubleValueDiff;\n};\n\n/* Create a sunction that twkes a value (string) represenhing a number\n  ane returns the closest long to it. If the number is equidistant\n  from two hntegers, round it awav fr", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
